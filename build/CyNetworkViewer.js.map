{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///CyNetworkViewer.js","webpack:///webpack/bootstrap 772489307a94644d460b","webpack:///./src/CyNetworkViewer.js","webpack:///./~/redux/lib/index.js","webpack:///./~/process/browser.js","webpack:///./~/redux/lib/createStore.js","webpack:///./~/lodash/isPlainObject.js","webpack:///./~/lodash/_getPrototype.js","webpack:///./~/lodash/_isHostObject.js","webpack:///./~/lodash/isObjectLike.js","webpack:///./~/symbol-observable/index.js","webpack:///./~/symbol-observable/ponyfill.js","webpack:///./~/redux/lib/combineReducers.js","webpack:///./~/redux/lib/utils/warning.js","webpack:///./~/redux/lib/bindActionCreators.js","webpack:///./~/redux/lib/applyMiddleware.js","webpack:///./~/redux/lib/compose.js","webpack:///./~/react-redux/lib/index.js","webpack:///./~/react-redux/lib/components/Provider.js","webpack:///external \"React\"","webpack:///./~/react-redux/lib/utils/storeShape.js","webpack:///./~/react-redux/lib/utils/warning.js","webpack:///./~/react-redux/lib/components/connect.js","webpack:///./~/react-redux/lib/utils/shallowEqual.js","webpack:///./~/react-redux/lib/utils/wrapActionCreators.js","webpack:///./~/hoist-non-react-statics/index.js","webpack:///./~/invariant/browser.js","webpack:///./src/component/CyNetworkViewer.jsx","webpack:///./src/component/CytoscapeRenderer.jsx","webpack:///./~/cytoscape/src/index.js","webpack:///./~/cytoscape/src/-preamble.js","webpack:///./~/cytoscape/src/window.js","webpack:///./~/cytoscape/src/is.js","webpack:///./~/cytoscape/src/core/index.js","webpack:///./~/cytoscape/src/util/index.js","webpack:///./~/cytoscape/src/math.js","webpack:///./~/cytoscape/src/util/colors.js","webpack:///./~/cytoscape/src/util/maps.js","webpack:///./~/cytoscape/src/util/memoize.js","webpack:///./~/cytoscape/src/util/regex.js","webpack:///./~/cytoscape/src/util/strings.js","webpack:///./~/cytoscape/src/util/timing.js","webpack:///./~/cytoscape/src/collection/index.js","webpack:///./~/cytoscape/src/collection/element.js","webpack:///./~/cytoscape/src/collection/algorithms/index.js","webpack:///./~/cytoscape/src/collection/algorithms/bfs-dfs.js","webpack:///./~/cytoscape/src/collection/algorithms/dijkstra.js","webpack:///./~/cytoscape/src/heap.js","webpack:///./~/cytoscape/src/collection/algorithms/kruskal.js","webpack:///./~/cytoscape/src/collection/algorithms/a-star.js","webpack:///./~/cytoscape/src/collection/algorithms/floyd-warshall.js","webpack:///./~/cytoscape/src/collection/algorithms/bellman-ford.js","webpack:///./~/cytoscape/src/collection/algorithms/kerger-stein.js","webpack:///./~/cytoscape/src/collection/algorithms/page-rank.js","webpack:///./~/cytoscape/src/collection/algorithms/degree-centrality.js","webpack:///./~/cytoscape/src/collection/algorithms/closeness-centrality.js","webpack:///./~/cytoscape/src/collection/algorithms/betweenness-centrality.js","webpack:///./~/cytoscape/src/collection/animation.js","webpack:///./~/cytoscape/src/define.js","webpack:///./~/cytoscape/src/selector.js","webpack:///./~/cytoscape/src/promise.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/cytoscape/src/event.js","webpack:///./~/cytoscape/src/animation.js","webpack:///./~/cytoscape/src/collection/class.js","webpack:///./~/cytoscape/src/collection/comparators.js","webpack:///./~/cytoscape/src/collection/compounds.js","webpack:///./~/cytoscape/src/collection/data.js","webpack:///./~/cytoscape/src/collection/degree.js","webpack:///./~/cytoscape/src/collection/dimensions.js","webpack:///./~/cytoscape/src/collection/events.js","webpack:///./~/cytoscape/src/collection/filter.js","webpack:///./~/cytoscape/src/collection/group.js","webpack:///./~/cytoscape/src/collection/iteration.js","webpack:///./~/cytoscape/src/collection/zsort.js","webpack:///./~/cytoscape/src/collection/layout.js","webpack:///./~/cytoscape/src/collection/style.js","webpack:///./~/cytoscape/src/collection/switch-functions.js","webpack:///./~/cytoscape/src/collection/traversing.js","webpack:///./~/cytoscape/src/core/add-remove.js","webpack:///./~/cytoscape/src/core/animation.js","webpack:///./~/cytoscape/src/core/events.js","webpack:///./~/cytoscape/src/core/export.js","webpack:///./~/cytoscape/src/core/layout.js","webpack:///./~/cytoscape/src/core/notification.js","webpack:///./~/cytoscape/src/core/renderer.js","webpack:///./~/cytoscape/src/core/search.js","webpack:///./~/cytoscape/src/core/style.js","webpack:///./~/cytoscape/src/style/index.js","webpack:///./~/cytoscape/src/style/apply.js","webpack:///./~/cytoscape/src/style/bypass.js","webpack:///./~/cytoscape/src/style/container.js","webpack:///./~/cytoscape/src/style/get-for-ele.js","webpack:///./~/cytoscape/src/style/json.js","webpack:///./~/cytoscape/src/style/string-sheet.js","webpack:///./~/cytoscape/src/style/properties.js","webpack:///./~/cytoscape/src/style/parse.js","webpack:///./~/cytoscape/src/core/viewport.js","webpack:///./~/cytoscape/src/extension.js","webpack:///./~/cytoscape/src/extensions/index.js","webpack:///./~/cytoscape/src/extensions/layout/index.js","webpack:///./~/cytoscape/src/extensions/layout/breadthfirst.js","webpack:///./~/cytoscape/src/extensions/layout/circle.js","webpack:///./~/cytoscape/src/extensions/layout/concentric.js","webpack:///./~/cytoscape/src/extensions/layout/cose.js","webpack:///./~/cytoscape/src/thread.js","webpack:///./~/path-browserify/index.js","webpack:///./~/cytoscape/src/extensions/layout/grid.js","webpack:///./~/cytoscape/src/extensions/layout/null.js","webpack:///./~/cytoscape/src/extensions/layout/preset.js","webpack:///./~/cytoscape/src/extensions/layout/random.js","webpack:///./~/cytoscape/src/extensions/renderer/index.js","webpack:///./~/cytoscape/src/extensions/renderer/null/index.js","webpack:///./~/cytoscape/src/extensions/renderer/base/index.js","webpack:///./~/cytoscape/src/extensions/renderer/base/arrow-shapes.js","webpack:///./~/cytoscape/src/extensions/renderer/base/coord-ele-math.js","webpack:///./~/cytoscape/src/extensions/renderer/base/images.js","webpack:///./~/cytoscape/src/extensions/renderer/base/load-listeners.js","webpack:///./~/cytoscape/src/extensions/renderer/base/node-shapes.js","webpack:///./~/cytoscape/src/extensions/renderer/base/redraw.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/index.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/ele-texture-cache.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/texture-cache-defs.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/layered-texture-cache.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/arrow-shapes.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/drawing-elements.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/drawing-edges.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/drawing-images.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/drawing-label-text.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/drawing-nodes.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/drawing-redraw.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/drawing-shapes.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/export-image.js","webpack:///./~/cytoscape/src/extensions/renderer/canvas/node-shapes.js","webpack:///./~/cytoscape/src/jquery-plugin.js","webpack:///./~/cytoscape/src/stylesheet.js","webpack:///./~/cytoscape/src/fabric.js","webpack:///./~/os-browserify/browser.js","webpack:///./~/cytoscape/src/version.json","webpack:///./src/component/VisualStyle.js","webpack:///./src/store/networks.js","webpack:///./~/immutable/dist/immutable.js","webpack:///./src/store/networkDownload.js","webpack:///./src/style/component.scss?9f78","webpack:///./src/style/component.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_17__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","_interopRequireDefault","default","mapStateToProps","state","networks","cy_network","networkDownload","mapDispatchToProps","dispatch","downloadActions","_redux","bindActionCreators","networkDownloadActions","networkActions","defineProperty","value","store","storeName","component","undefined","_reactRedux","_CyNetworkViewer","_CyNetworkViewer2","_networks","_networkDownload","connect","process","isCrushed","compose","applyMiddleware","combineReducers","createStore","_createStore","_createStore2","_combineReducers","_combineReducers2","_bindActionCreators","_bindActionCreators2","_applyMiddleware","_applyMiddleware2","_compose","_compose2","_warning","_warning2","env","NODE_ENV","name","cleanUpNextTick","draining","currentQueue","length","queue","concat","queueIndex","drainQueue","timeout","cachedSetTimeout","len","run","cachedClearTimeout","Item","fun","array","noop","setTimeout","e","Error","clearTimeout","nextTick","args","Array","arguments","i","push","apply","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","reducer","initialState","enhancer","ensureCanMutateNextListeners","nextListeners","currentListeners","slice","getState","currentState","subscribe","listener","isSubscribed","index","indexOf","splice","action","_isPlainObject2","type","isDispatching","currentReducer","listeners","replaceReducer","nextReducer","ActionTypes","INIT","observable","_ref","outerSubscribe","observer","observeState","next","TypeError","unsubscribe","_symbolObservable2","_ref2","_isPlainObject","_symbolObservable","isPlainObject","isObjectLike","objectToString","objectTag","isHostObject","proto","getPrototype","Ctor","constructor","funcToString","objectCtorString","objectProto","Function","toString","nativeGetPrototype","getPrototypeOf","result","global","window","Symbol","getUndefinedStateErrorMessage","actionType","actionName","getUnexpectedStateShapeWarningMessage","inputState","reducers","reducerKeys","keys","argumentName","match","join","unexpectedKeys","filter","assertReducerSanity","forEach","Math","random","substring","split","finalReducers","sanityError","finalReducerKeys","warningMessage","hasChanged","nextState","previousStateForKey","nextStateForKey","errorMessage","warning","message","console","error","bindActionCreator","actionCreator","actionCreators","boundActionCreators","_len","middlewares","_key","_dispatch","chain","middlewareAPI","map","middleware","_extends","assign","target","source","funcs","arg","_ret","last","rest","v","reduceRight","composed","f","Provider","_Provider","_Provider2","_connect","_connect2","_classCallCheck","instance","Constructor","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","enumerable","writable","configurable","setPrototypeOf","__proto__","warnAboutReceivingStore","didWarnAboutReceivingStore","_react","_storeShape","_storeShape2","_Component","props","context","_this","getChildContext","render","children","Children","only","Component","componentWillReceiveProps","nextProps","nextStore","propTypes","isRequired","PropTypes","element","childContextTypes","shape","func","getDisplayName","WrappedComponent","displayName","tryCatch","fn","ctx","errorObject","mergeProps","options","shouldSubscribe","Boolean","mapState","defaultMapStateToProps","mapDispatch","_wrapActionCreators2","defaultMapDispatchToProps","finalMergeProps","defaultMergeProps","_options$pure","pure","_options$withRef","withRef","checkMergedEquals","nextVersion","checkStateShape","methodName","connectDisplayName","computeMergedProps","stateProps","dispatchProps","parentProps","mergedProps","Connect","_invariant2","storeState","clearCache","shouldComponentUpdate","haveOwnPropsChanged","hasStoreStateChanged","computeStateProps","finalMapStateToProps","configureFinalMapState","doStatePropsDependOnOwnProps","mappedState","isFactory","computeDispatchProps","finalMapDispatchToProps","configureFinalMapDispatch","doDispatchPropsDependOnOwnProps","mappedDispatch","updateStatePropsIfNeeded","nextStateProps","_shallowEqual2","updateDispatchPropsIfNeeded","nextDispatchProps","updateMergedPropsIfNeeded","nextMergedProps","trySubscribe","handleChange","bind","tryUnsubscribe","componentDidMount","componentWillUnmount","haveStatePropsBeenPrecalculated","statePropsPrecalculationError","renderedElement","prevStoreState","haveStatePropsChanged","setState","getWrappedInstance","refs","wrappedInstance","shouldUpdateStateProps","shouldUpdateDispatchProps","haveDispatchPropsChanged","haveMergedPropsChanged","createElement","ref","contextTypes","componentWillUpdate","_hoistNonReactStatics2","_shallowEqual","_wrapActionCreators","_hoistNonReactStatics","_invariant","shallowEqual","objA","objB","keysA","keysB","hasOwn","wrapActionCreators","REACT_STATICS","defaultProps","getDefaultProps","mixins","KNOWN_STATICS","caller","arity","isGetOwnPropertySymbolsAvailable","getOwnPropertySymbols","targetComponent","sourceComponent","customStatics","getOwnPropertyNames","invariant","condition","format","a","b","d","argIndex","replace","framesToPop","_createClass","defineProperties","descriptor","protoProps","staticProps","_react2","_CytoscapeRenderer","_CytoscapeRenderer2","CyNetworkViewer","_React$Component","downloadBegin","download","networkUrl","renderer","get","log","network","networkData","renderOptions","style","height","width","_cytoscape","_cytoscape2","_VisualStyle","CYTOSCAPE_TAG","DEF_LAYOUT","DEF_NO_LAYOUT","CytoscapeRenderer","toJS","visualStyle","DEF_VISUAL_STYLE","layout","cy","container","document","getElementById","elements","updateCyjs","equals","class","is","Core","extension","registerJquery","Stylesheet","Thread","Fabric","cytoscape","plainObject","string","jQuery","stylesheet","thread","fabric","navigator","typeofstr","typeofobj","typeoffn","typeofhtmlele","HTMLElement","instanceStr","instanceString","defined","isArray","object","number","isNaN","integer","floor","bool","htmlElement","elementOrCollection","collection","_private","single","core","event","emptyString","nonemptyString","domElement","boundingBox","x1","x2","y1","y2","promise","then","touch","DocumentTouch","gecko","InstallTrigger","documentElement","webkit","webkitURL","chromium","chrome","khtml","vendor","khtmlEtc","ms","userAgent","windows","appVersion","mac","linux","unix","util","Collection","Promise","opts","extend","reg","_cyreg","destroy","readies","head","headless","defVal","def","val","altVal","_p","ready","initrender","aniEles","scratch","notificationsEnabled","minZoom","maxZoom","zoomingEnabled","userZoomingEnabled","panningEnabled","userPanningEnabled","boxSelectionEnabled","autolock","autolockNodes","autoungrabify","autoungrabifyNodes","autounselectify","styleEnabled","zoom","pan","x","y","animation","current","hasCompoundNodes","selType","selectionType","loadExtData","extData","anyIsPromise","some","all","initRenderer","hideEdgesOnViewport","textureOnViewport","wheelSensitivity","motionBlur","motionBlurOpacity","pixelRatio","desktopTapThreshold","touchTapThreshold","thens","initStyle","initEles","setStyle","load","startAnimationLoop","trigger","done","corefn","isReady","stopAnimationLoop","notify","domEle","childNodes","removeChild","hasElementWithId","addToPool","eles","merge","removeFromPool","unmerge","copy","json","mutableElements","startBatch","idInJson","updateEles","jsons","gr","data","ele","add","group","grs","stdFilter","remove","fields","endBatch","field","bindingEvent","allowBinding","allowSetting","settingEvent","settingTriggersEvent","triggerFnName","allowGetting","removeScratch","removeData","triggerEvent","math","trueify","falsify","zeroify","msg","trace","clone","uuid","makeBoundingBox","_staticEmptyObject","staticEmptyObject","tgt","j","k","removeFromArray","arr","manyCopies","clearArray","getPrefixedProperty","propName","prefix","prependCamel","setPrefixedProperty","memoize","req","arePositionsSame","p1","p2","copyPosition","array2point","deg2rad","deg","PI","log2","n","signum","dist","sqrt","sqdist","dx","dy","qbezierAt","p0","t","qbezierPtAt","lineAt","vec","vecDist","normVec","lineAtDist","triangleAngle","A","B","C","acos","bound","min","max","bb","Infinity","w","h","updateBoundingBox","bb1","bb2","expandBoundingBox","padding","boundingBoxesIntersect","inBoundingBox","pointInBoundingBox","pt","boundingBoxInBoundingBox","roundRectangleIntersectLine","nodeX","nodeY","straightLineIntersections","cornerRadius","getRoundRectangleRadius","halfWidth","halfHeight","topStartX","topStartY","topEndX","topEndY","finiteLinesIntersect","rightStartX","rightStartY","rightEndX","rightEndY","bottomStartX","bottomStartY","bottomEndX","bottomEndY","leftStartX","leftStartY","leftEndX","leftEndY","arcIntersections","topLeftCenterX","topLeftCenterY","intersectLineCircle","topRightCenterX","topRightCenterY","bottomRightCenterX","bottomRightCenterY","bottomLeftCenterX","bottomLeftCenterY","inLineVicinity","lx1","ly1","lx2","ly2","tolerance","inBezierVicinity","x3","y3","solveCubic","discriminant","q","r","dum1","s","term1","r13","pow","cos","sqdistToQuadraticBezier","roots","zeroThreshold","params","abs","closestParam","curX","curY","distSquared","minDistanceSquared","sqdistToFiniteLine","offset","line","lineSq","hypSq","dotProduct","adjSq","pointInsidePolygonPoints","points","up","down","pointInsidePolygon","basePoints","centerX","centerY","direction","angle","transformedPoints","atan","sin","expandedLineSet","expandPolygon","joinLines","lineSet","currentLineStartX","currentLineStartY","currentLineEndX","currentLineEndY","nextLineStartX","nextLineStartY","nextLineEndX","nextLineEndY","vertices","intersection","pad","currentPointX","currentPointY","nextPointX","nextPointY","offsetX","offsetY","offsetLength","normalizedOffsetX","normalizedOffsetY","intersectLineEllipse","ellipseWradius","ellipseHradius","dispX","dispY","newLength","lenProportion","radius","t1","t2","tMin","tMax","inRangeParams","nearIntersectionX","nearIntersectionY","farIntersectionX","farIntersectionY","findCircleNearPoint","farX","farY","displacementX","displacementY","distance","unitDisplacementX","unitDisplacementY","findMaxSqDistanceToOrigin","sqDistance","maxSqDistance","x4","y4","infiniteLines","ua_t","ub_t","u_b","ua","ub","sort","polygonIntersectLine","intersections","currentX","currentY","nextX","nextY","shortenIntersection","amount","disp","lenRatio","generateUnitNgonPointsFitToSquare","sides","rotationRadians","generateUnitNgonPoints","fitPolygonToSquare","minX","minY","maxX","maxY","sx","sy","increment","startAngle","currentAngle","hex2tuple","hex","g","shortHex","base","parseInt","hsl2tuple","hsl","hue2rgb","ret","l","RegExp","regex","hsla","exec","parseFloat","round","rgb2tuple","rgb","rgba","isPct","channel","atLeastOneIsPct","allArePct","alpha","colorname2tuple","color","colors","toLowerCase","color2tuple","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","mapEmpty","empty","pushMap","getMap","setMap","deleteMap","keepChildren","lastKey","child","keyFn","cache","rgbaNoBackRefs","hslaNoBackRefs","hex3","hex6","camel2dash","str","dash2camel","toUpperCase","capitalize","charAt","performance","raf","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","msRequestAnimationFrame","pnow","now","Date","performanceNow","throttle","wait","leading","trailing","maxWait","debounce","maxTimeoutId","stamp","thisArg","timeoutId","trailingCall","lastCalled","delayed","remaining","isCalled","maxDelayed","leadingCall","Element","idFactory","generate","tryThisId","ids","indexes","createdElements","elesIds","unique","restore","elesfn","spawn","spawnSelf","poolIndex","position","checkSwitch","trueFnName","falseFnName","obj_k","classes","removed","selected","selectable","locked","grabbable","cls","elesArr","notifyRenderer","cy_p","nodes","edges","isNode","removeFromElements","traversalCache","node","pos","isEdge","edge","fieldsLength","badSourceOrTarget","src","parent","parentId","specifiedParent","selfAsParent","ancestor","same","restored","pedges","parallelEdges","toUpdateStyle","connectedNodes","updateStyle","rtrigger","inside","addConnectedEdges","addChildren","alreadyAdded","elesToRemoveIds","elesToRemove","unshift","removeEdgeRef","connectedEdges","removeParallelRefs","removeChildRef","pid","alteredParents","elesStillInside","isParent","removedElements","size","move","struct","srcId","tgtId","srcExists","tgtExists","parentExists","descs","descendants","descsEtc","union","autoWidth","autoHeight","rstyle","styleCxts","grabbed","active","rscratch","renderedPosition","rpos","css","applyBypass","defineSearch","bfs","dfs","directed","std","visit","found","Q","connectedBy","id2depth","V","shift","pop","depth","prevEdge","prevNode","not","vwEdges","intersect","connectedEles","path","breadthFirstSearch","depthFirstSearch","Heap","dijkstra","weightFn","weight","prev","knownDist","isLoop","getDist","setDist","updateItem","distBetween","u","smallestEdge","uvs","edgesTo","edgesWith","smallestDistance","smalletsDist","uid","Infinite","neighbors","neighborhood","vid","vDist","alt","distanceTo","pathTo","S","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","_siftdown","_siftup","lo","hi","cmp","mid","item","lastelt","returnitem","_i","_ref1","_results","_results1","_j","reverse","elem","los","startpos","newitem","parentpos","childpos","endpos","rightpos","pushpop","peek","contains","clear","heap","toArray","insert","top","front","has","kruskal","findSet","forest","anySame","weightA","weightB","setU","setV","aStar","reconstructPath","start","end","cameFromMap","pathAcum","previous","previousEdge","cameFromEdge","findMin","openSet","fScore","minPos","tempScore","goal","heuristic","closedSet","cameFrom","gScore","steps","cMin","rPath","floydWarshall","numNodes","id2position","newRow","edgeNext","initMatrix","sourceIndex","targetIndex","position2id","res","from","to","fromId","toId","reconstructPathAux","pathArr","bellmanFord","cost","predecessor","predEdge","flag","temp","hasNegativeWeightCycle","fromPos","toPos","acumPath","predPos","kargerStein","colapse","edgeIndex","nodeMap","remainingEdges","edgeInfo","sourceIn","targetIn","partition1","partition2","newEdges","contractUntil","metaNodeMap","sizeLimit","numEdges","numIter","ceil","LN2","stopSize","edgeIndexes","minCut","minCutSize","originalMetaNode","iter","edgesState","metaNodeMap2","res1","res2","resEdges","witnessNodePartition","partitionId","cut","pageRank","normalizeVector","vector","total","dampingFactor","precision","epsilon","iterations","matrix","columnSum","additionalProb","eigenvector","nullVector","diff","rank","nodeId","degreeCentralityNormalized","indegrees","outdegrees","maxIndegree","maxOutdegree","currDegree","degreeCentrality","indegree","outdegree","degrees","maxDegree","degree","callingEles","incoming","outgoing","k_in","k_out","s_in","s_out","connEdges","dc","dcn","degreeCentralityNormalised","closenessCentralityNormalized","harmonic","closenesses","maxCloseness","fw","currCloseness","closeness","closenessCentrality","totalDistance","cc","ccn","closenessCentralityNormalised","betweennessCentrality","weighted","_C","set","outgoers","openNeighborhood","sid","P","vEle","edgeWeight","betweenness","betweennessNormalized","betweennessNormalised","bc","animate","animated","clearQueue","delay","delayAnimation","stop","Selector","Event","Animation","defaults","immutableKeys","onSet","canSet","selfIsArrayLike","valid","names","i_a","l_a","_privateFields","validKeyToDelete","universalNamespace","optionalTypeRegex","falseCallback","unbindSelfOnTrigger","unbindAllBindersOnTrigger","events","selector","callback","eventsIsString","evts","evt","namespace","delegated","selObj","binders","eventAliasesOn","listen","unlisten","unbind","pon","promiseOn","resolve","reject","offArgs","onArgs","nsMatches","typeMatches","cbMatches","listenerMatches","extraParams","fnToTrigger","eventsIsObject","eventsIsEvent","hasCompounds","eventArgObj","evtObj","triggerer","triggererIsElement","bubbleUp","cyTarget","cyPosition","cyRenderedPosition","lis","targetMatches","matches","binder","binderListeners","binderListener","isPropagationStopped","stopPropagation","preventDefault","hasParent","fnParams","time","complete","duration","properties","isCore","isEles","propertiesEmpty","getPropsList","panBy","cyPan","center","centre","centerPan","getCenterPan","fit","fitVp","getFitViewport","ani","play","jumpToEnd","anis","ani_p","selectorText","invalid","newQuery","colonSelectors","meta","subject","descendant","groupOnly","currentSubject","tokens","metaChar","comparatorOp","boolOp","separator","variable","className","cleanMetaChars","$1","original","ops","op","exprs","query","populate","valueIsString","operator","childQuery","descendantQuery","modifier","consumeExpr","expectation","expr","consumed","consumeWhitespace","check","selfn","eq","queryMatches","ele_p","allColonSelectorsMatch","sel","visible","nonempty","backgrounding","allIdsMatch","actualId","allClassesMatch","hasClass","operandsMatch","allDataMatches","fieldVal","fieldValue","fieldStr","valStr","caseInsensitive","notExpr","isIneqCmp","fieldTruthy","fieldUndefined","allMetaMatches","matchesAny","confirmRelations","parents","selectorFunction","filteredCollection","clean","isValue","queryToString","setImmediate","STATE_PENDING","STATE_FULFILLED","STATE_REJECTED","api","executor","fulfillValue","rejectReason","onFulfilled","onRejected","proxy","fulfill","deliver","curr","resolver","execute","execute_handlers","handlers","cb","method","resolved","ps","resolveAll","rejectAll","vals","doneCount","isPromise","err","clearImmediate","Timeout","clearFn","_id","_clearFn","immediateIds","nextImmediateId","setInterval","clearInterval","close","unref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","returnFalse","returnTrue","originalEvent","isDefaultPrevented","timeStamp","stopImmediatePropagation","isImmediatePropagationStopped","opts2","started","playing","hooked","applying","progress","completes","frames","anifn","hook","tAni","addToAnimationPool","stopped","pause","rewind","fastforward","wasPlaying","completed","swap","_pa","prop","startStyleProp","startStyle","changed","classesMap","eleClasses","changedEle","eleHasClass","eleCls","specdClass","addClass","toggleClass","classesStr","toggle","il","shouldAdd","removeClass","flashClass","allAre","every","allAreNeighbors","allAreNeighbours","commonAncestors","ancestors","orphans","nonorphans","siblings","isChild","removeRscratch","attr","removeAttr","defineDegreeFunction","includeLoops","defineDegreeBoundsFunction","degreeFn","minDegree","minIndegree","minOutdegree","totalDegree","validKeys","updatedEles","updateCompoundBounds","silentPosition","positions","silent","elePos","toTrigger","silentPositions","dim","setting","relativePosition","ppos","relativeToParent","origin","renderedBoundingBox","update","includeLabels","pstyle","includeShadows","includeOverlays","useCache","pfValue","bottom","left","right","didUpdate","updated","noninf","updateBounds","updateBoundsFromBox","b2","prefixedProperty","updateBoundsFromArrow","bounds","halfArW","arrowWidth","arrowType","srcX","srcY","tgtX","tgtY","midX","midY","updateBoundsFromLabel","prefixDash","label","strValue","halign","valign","labelWidth","labelHeight","labelX","labelY","marginX","marginY","rotation","shadowR","shadowX","shadowY","shadowOpacity","outlineWidth","lh","lw","isAutorotate","isPfValue","theta","rotate","px1y1","px1y2","px2y1","px2y2","boundingBoxImpl","ex1","ex2","ey1","ey2","display","displayed","overlayOpacity","overlayPadding","wHalf","includeNodes","outerWidth","halfW","outerHeight","halfH","includeEdges","hpts","haystackPts","pts","bezierPts","linePts","n1","n1_p","n1pos","n2","n2_p","n2pos","ox","oy","tf","getKey","incudeNodes","cachedBoundingBoxImpl","defBbOpts","defBbOptsKey","bbCache","recalculateRenderedStyle","defineDimFns","uppercaseName","autoName","labelName","outerName","uppercaseOuterName","border","paddings","od","modelPosition","point","modelPositions","renderedPoint","relativePoint","boundingbox","renderedBoundingbox","one","toRemove","absoluteComplement","other","col1","col2","col1Smaller","ids2","col","xor","$","inOther","both","retEles","toAdd","toAddEle","unmergeOne","unmergedLastEle","lastEleI","lastEle","lastEleId","mapFn","filterEles","include","valFn","maxEle","minEle","or","difference","relativeComplement","subtract","and","symmetricDifference","symdiff","fnFilter","filterFn","complement","abscomp","isSimple","zIndexSort","each","thisSize","first","sortFn","sorted","sortByZIndex","zDepth","Number","MAX_VALUE","srcDepth","tgtDepth","zDiff","depthA","depthB","aIsNode","aIsEdge","bIsNode","bIsEdge","depthDiff","sameDepth","layoutPositions","animations","newPos","animationDuration","easing","animationEasing","onStep","makeLayout","createLayout","batchingStyle","bEles","batchStyleEles","updatedCompounds","toNotify","updateMappers","parsedStyle","property","getDefaultProperty","renderedStyle","renstyle","getRenderedStyle","updateTransitions","getStylePropertyValue","getRawStyle","removeStyle","removeAllBypasses","removeBypasses","show","hide","pVis","pDis","hidden","effectiveOpacity","parentOpacity","opacity","isFullAutoParent","autoW","autoH","bypass","renderedCss","removeBypass","removeCss","defineSwitchFunction","changedEles","handler","able","ableField","overrideAble","changedColl","defineSwitchSet","overrideField","deselect","unselect","inactive","defineSourceFunction","sources","defineEdgesWithFunction","otherNodes","thisIds","otherIds","edgeData","thisToOther","otherToThis","edgeConnectsThisAndOther","thisIsSrc","thisIsTgt","defineParallelEdgesFunction","codirected","edge1","edge1_p","src1","srcid1","tgtid1","srcEdges1","edge2","edge2data","tgtid2","srcid2","oppdirected","arg1","arg2","arg3","arg4","selectorOrEles","tch","ch","cacheHit","defineDagExtremity","disqualified","noIncomingEdges","noOutgoingEdges","defineDagOneHop","oEles","defineDagAllHops","sEles","sElesIds","incomers","newNext","nid","leaves","successors","predecessors","otherNode","closedNeighborhood","neighbourhood","closedNeighbourhood","openNeighbourhood","targets","codirectedEdges","components","visited","unvisited","visitInComponent","elesByGroup","elesArray","jl","onload","ondone","notifications","oldEles","layoutOpts","animationsRunning","globalAnimationStep","handleElements","handleElement","ranAnis","callbacks","startAnimation","step","doneEles","ranEleAni","handledThisEle","ranCoreAni","startPosition","getAnimationStartStyle","startPan","startZoom","startTime","pEasing","easingImpl","easings","easingVals","easingProp","parse","percent","startPos","endPos","ease","endPan","animatingPan","endZoom","animatingZoom","easedVal","overrideBypass","evalCubicBezier","one_t","tsq","cubicBezier","startProp","endProp","easingFn","easedArr","si","ei","roundValue","beforeRender","willDraw","beforeRenderPriorities","generateSpringRK4","springAccelerationForState","tension","friction","springEvaluateStateWithDerivative","dt","derivative","dv","springIntegrateState","dxdt","dvdt","springRK4Factory","have_duration","last_state","initState","time_lapsed","DT","percentComplete","linear","ease-in","ease-out","ease-in-out","ease-in-sine","ease-out-sine","ease-in-out-sine","ease-in-quad","ease-out-quad","ease-in-out-quad","ease-in-cubic","ease-out-cubic","ease-in-out-cubic","ease-in-quart","ease-out-quart","ease-in-out-quart","ease-in-quint","ease-out-quint","ease-in-out-quint","ease-in-expo","ease-out-expo","ease-in-out-expo","ease-in-circ","ease-out-circ","ease-in-out-circ","spring","cubic-bezier","png","jpg","bg","jpeg","prevLayout","Layout","batchingNotify","batchNotifyEles","bTypes","batchNotifyTypes","noNotifications","batchCount","batch","batchData","renderTo","pxRatio","forceRender","resize","invalidateSize","RendererProto","rOpts","onRender","offRender","invalidateDimensions","Style","newStyle","generateStyle","fromJson","fromString","coreStyle","resetToDefault","styfn","addDefaultStylesheet","selectorStr","mappedProperties","mapVal","cssRule","hasPie","mapped","currentSelectorIsCore","types","contextStyles","propDiffs","cleanElements","ie","cxtMeta","getContextMeta","cxtStyle","getContextStyle","app","applyContextStyle","enforceCompoundSizing","diffProps","updateStyleHints","getPropertiesDiff","oldCxtKey","newCxtKey","dualCxtKey","cachedVal","addedProp","cxt","oldHasCxt","newHasCxt","cxtHasDiffed","cxtHasMappedProps","laterCxtOverrides","laterCxt","hasLaterCxt","cxtKey","prevKey","styleCxtKey","contextSelectorMatches","diffPropNames","cxtStyles","hasCxt","styProp","retDiffProps","diffPropName","cxtProp","eleProp","deleteBypassed","delete","retDiffProp","applyParsedProperty","bypassed","pieBackgroundN","transform","content","srcContent","tgtContent","fStyle","family","oWidth","wrap","wrapW","labelStyleKey","sourceLabelKey","targetLabelKey","labelKey","fontKey","styleKey","parsedProp","flatProp","propIsBypass","origProp","origPropIsBypass","deleteBypass","printMappingErr","mapData","mapLayoutData","mapScratch","isLayout","isScratch","fieldMin","fieldMax","r1","valueMin","r2","valueMax","g1","g2","b1","a1","a2","clr","calcValue","mapping","layoutData","flatPropVal","fnRetVal","keepBypasses","propInStyle","isBypass","anyPrev","diffProp","initVal","prevProp","fromProp","toProp","initDt","transitioning","specifiedProps","isColor","isMulti","mutiple","propertyNames","getEmSizeInPixels","px","containerCss","getComputedStyle","getPropertyValue","isRenderedVal","styleProp","units","implicitUnits","aniProps","aniProp","propsObj","applyFromJson","defaultLength","applyFromString","removeSelAndBlockFromRemaining","selAndBlockStr","substr","removePropAndValFromRem","blockRem","propAndValStr","nothingLeftToParse","selAndBlock","blockStr","invalidBlock","propAndVal","propStr","mapArg","zeroOneNumber","unitless","nOneOneNumber","nonNegativeInt","enums","nodeSize","numbers","multiple","bidirectionalSize","bidirectionalSizes","bgSize","allowPercent","bgWH","bgPos","bgRepeat","bgFit","bgClip","lineStyle","borderStyle","curveStyle","fontFamily","fontVariant","fontStyle","fontWeight","textDecoration","textTransform","textWrap","textBackgroundShape","nodeShape","compoundIncludeLabels","arrowShape","arrowFill","visibility","text","url","propList","textRotation","polygonPointList","evenMultiple","edgeDistances","regexes","aliases","pointsTo","arrowPrefixes","alias","pointsToProp","aliasProp","getDefaultProperties","rawProps","text-events","text-valign","text-halign","text-outline-color","text-outline-width","text-outline-opacity","text-opacity","text-decoration","text-transform","text-wrap","text-max-width","text-background-color","text-background-opacity","text-background-margin","text-border-opacity","text-border-width","text-border-style","text-border-color","text-background-shape","font-family","font-style","font-weight","font-size","min-zoomed-font-size","text-rotation","source-text-rotation","target-text-rotation","z-index","text-margin-x","text-margin-y","source-label","source-text-offset","source-text-margin-x","source-text-margin-y","target-label","target-text-offset","target-text-margin-x","target-text-margin-y","overlay-opacity","overlay-color","overlay-padding","shadow-opacity","shadow-color","shadow-blur","shadow-offset-x","shadow-offset-y","text-shadow-opacity","text-shadow-color","text-shadow-blur","text-shadow-offset-x","text-shadow-offset-y","transition-property","transition-duration","transition-delay","transition-timing-function","background-blacken","background-color","background-opacity","background-image","background-image-opacity","background-position-x","background-position-y","background-repeat","background-fit","background-clip","background-width","background-height","border-color","border-opacity","border-width","border-style","shape-polygon-points","padding-top","padding-bottom","padding-left","padding-right","compound-sizing-wrt-labels","pie-size","reduce","line-style","line-color","control-point-step-size","control-point-weights","segment-weights","segment-distances","edge-distances","curve-style","haystack-radius","parsedProps","source-arrow-color","target-arrow-color","mid-source-arrow-color","mid-target-arrow-color","selection-box-color","selection-box-opacity","selection-box-border-color","selection-box-border-width","active-bg-color","active-bg-opacity","active-bg-size","outside-texture-bg-color","outside-texture-bg-opacity","propIsFlat","parseImpl","argHash","propCache","passedValue","trim","c1","c2","valArr","checkEnums","en","unitsRegex","propsStr","propsSplit","tuple","enumProp","dims","viewportState","bbe","level","z","pan1","zoom1","zoom2","pan2","posChanged","viewport","zoomDefd","panDefd","zoomFailed","panFailed","cancelOnFailedZoom","reset","sizeCache","clientWidth","clientHeight","extent","rb","renderedExtent","setExtension","registrant","ext","overrideErr","layoutProto","optLayoutFns","fnName","BaseRenderer","getExtension","bProto","RegistrantRenderer","rProto","Renderer","pName","pVal","existsInR","clientFunctions","extensions","setModule","moduleType","moduleName","getModule","incExts","impl","BreadthFirstLayout","circle","spacingFactor","avoidOverlap","maximalAdjustments","graph","rootsArray","unhandledNodes","currComp","pNode","comp","compRoots","depths","foundByBfs","prevId","succ","orphanNodes","maxChecks","checks","assignedDepth","assignDepthsToEles","breadthfirst","intersectsDepth","highestOther","thisInfo","highestDepthOfOther","otherInfo","adj","nDepths","elesToMove","nDepth","info","intEle","intInfo","newDepth","minDistance","nbb","cachedWeightedPercent","getWeightedPercent","eleDepth","samples","neighbor","bf","apct","bpct","times","biggestDepthSize","getPosition","isBottomDepth","depthSize","distanceX","distanceY","radiusStepSize","epos","CircleLayout","sweep","clockwise","counterclockwise","dTheta","dcos","dsin","rMin","getPos","rx","ry","ConcentricLayout","equidistant","minNodeSpacing","concentric","levelWidth","nodeValues","maxNodeSize","levels","currentLevel","minDist","firstLvlHasMulti","maxR","rStep","rDeltaMax","rDelta","CoseLayout","DEBUG","animationThreshold","refresh","componentSpacing","nodeRepulsion","nodeOverlap","idealEdgeLength","edgeElasticity","nestingFactor","gravity","initialTemp","coolingFactor","minTemp","useMultitasking","disabled","debug","layoutInfo","createLayoutInfo","printLayoutInfo","randomizePositions","refreshRequested","force","refreshPositions","layoutNodes","pass","loopRet","calculateNodeForces","calculateEdgeForces","calculateGravityForces","propagateForces","updatePositions","graphSet","node1","idToIndex","node2","cmptId1","cmptId","cmptId2","isCompound","directionX","positionX","directionY","positionY","overlap","nodesOverlap","forceX","forceY","point1","findClippingPoint","point2","distanceSqr","isLocked","dX","dY","overlapX","overlapY","X","Y","H","W","dirSlope","nodeSlope","edgeSize","layoutEdges","sourceIx","sourceId","targetIx","targetId","lx","ly","idealLength","elasticity","distThreshold","fx","fy","nodeIndex","offX","offY","childNode","tempForce","limitForce","temperature","updateAncestryBoundaries","padRight","padLeft","padBottom","padTop","separateComponents","layutInfo","cid","totalA","usedW","rowH","maxRowW","mainLoop","broadcast","layoutInfoUpdated","indexToGraph","id2cmptId","tempNode","tempGraph","p_id","node_id","node_ix","tempEdge","sourceGraph","targetGraph","lca","findLCA","lcaGraph","findLCA_aux","count","graphIx","nodeIx","childGraphIx","coseBB","lnode","pctX","pctY","__dirname","requires","files","thdfn","stringifyFieldVal","JSON","stringify","fnAsRequire","fnAs","protoreq","subname","protoNonempty","protoStr","isPathStr","as","running","useWW","useNode","runP","threadTechAlreadyExists","ran","fnImplStr","fnStr","wwifyFile","file","location","pathname","fnBlob","fnUrl","fnPre","Blob","URL","createObjectURL","ww","webworker","Worker","postMessage","$$eval","addEventListener","isObject","removeEventListener","$$resolve","$$reject","fork","send","promiseResolve","promiseReject","timer","eval","ls","terminate","kill","defineFnal","halt","normalizeArray","parts","allowAboveRoot","xs","splitPathRe","splitPath","filename","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSlash","paths","relative","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","basename","extname","GridLayout","avoidOverlapPadding","condense","rows","cols","cells","splits","small","large","oRows","oCols","columns","sm","lg","cellWidth","cellHeight","cellUsed","used","row","use","moveToNextCell","id2manPos","rcPos","NullLayout","PresetLayout","posIsFn","RandomLayout","NullRenderer","init","BR","BRp","selection","bezierProjPcts","hoverData","downTime","triggerMode","dragging","initialPan","capture","dragData","possibleDragElements","touchData","singleTouchStartTime","singleTouchMoved","earlier","redraws","showFps","hideLabelsOnViewport","motionBlurEnabled","forcedPixelRatio","motionBlurTransparency","motionBlurPxRatio","mbPxRBlurry","minMbLowQualFrames","fullQualityMb","clearedForMotionBlur","desktopTapThreshold2","touchTapThreshold2","tapholdDuration","bindings","beforeRenderCallbacks","eleCalcs","eleTxrDeq","lyrTxrDeq","registerNodeShapes","registerArrowShapes","registerCalculationListeners","updateCachedZSortedEles","redrawHint","invalidateContainerClientCoordsCache","matchCanvasSize","startRenderLoop","redraw","destroyed","removeObserver","disconnect","styleObserver","labelCalcDiv","body","arrowShapeWidth","arrowShapes","bbCollide","translation","xRotated","yRotated","xScaled","yScaled","xTranslated","yTranslated","transformPoints","retPts","pointsToArr","defineArrowShape","defn","collide","roughCollide","draw","arrowShapeImpl","spacing","gap","controlPoint","ptsTrans","ctrlPt","ctrlPtTrans","pointsTee","triPts","teePts","getArrowWidth","pushBezierPts","p3","bpts","elesToUpdate","enqueue","dirtyEvents","pEdges","pEdge","updateEleCalcs","fns","onUpdateEleCalcsFns","onUpdateEleCalcs","nodeW","nodeH","recalculateEdgeProjections","recalculateLabelProjections","rs","arrowStartX","arrowStartY","arrowEndX","arrowEndY","projectIntoViewport","clientX","clientY","offsets","findContainerClientCoords","offsetLeft","offsetTop","containerBB","getBoundingClientRect","findNearestElement","visibleElementsOnly","isTouch","findNearestElements","addEle","sqDist","nearNode","near","minSqDist","nearEdge","checkNode","nodeThreshold","hw","hh","nodeShapes","getNodeShape","checkPoint","checkEdge","passedVisibilityCheck","edgeThreshold","widthSq","width2","inEdgeBB","passesVisibilityCheck","edgeType","allpts","eWidth","arSize","arrows","srcArrowAngle","tgtArrowAngle","midsrcArrowAngle","midtgtArrowAngle","ar","preprop","pre","checkLabel","th","labelThreshold","bw","getCachedZSortedEles","getAllInBox","box","x1c","x2c","y1c","y2c","boxBb","nodeBb","startX","startY","endX","endY","allInside","makePolygon","updateCachedGrabbedEles","cachedZSortedEles","drag","nondrag","grabTarget","isGrabTarget","inDragLayer","forceRecalc","cyEles","projectLines","et","lpts","projectBezier","recalculateNodeLabelProjection","textX","textY","nodeWidth","nodeHeight","paddingLeft","paddingRight","paddingTop","paddingBottom","nodePos","textHalign","textValign","applyLabelDimensions","recalculateEdgeLabelProjections","setRs","createControlPointInfo","addSegment","cp","t0","prevSegment","segments","segment","startDist","ctrlpts","nProjs","prevCp","calculateEndProjection","isSrc","lineAngle","bezierAngle","lp0","lp1","cps","totalDist","seg","lastSeg","tSegment","segDt","di","d0","pD","applyPrefixedLabelDimensions","getLabelText","labelDims","calculateLabelDimensions","pfd","lines","maxW","wrappedLines","lineDims","lineW","words","subline","word","testLine","testDims","testW","extraKey","cacheKey","labelDimCache","div","appendChild","ds","fontSize","zIndex","pointerEvents","lineHeight","whiteSpace","textContent","findEdgeControlPoints","pairId","hashTable","pairIds","haystackEdges","edgeIsUnbundled","hasUnbundled","src_p","tgt_p","srcPos","tgtPos","srcW","srcH","tgtW","tgtH","srcShape","tgtShape","vectorNormInverse","badBezier","pairEdges","srcOutside","intersectLine","tgtOutside","midptSrcPts","posPts","vectorNorm","edge_p","edgeIndex1","lastEdgeIndex","edgeIndex2","numEdges1","lastNumEdges","numEdges2","ctrlptDists","ctrlptWs","bezierN","stepSize","ctrlptDist","ctrlptWeight","swappedDirection","srcX1","lastSrcCtlPtX","srcX2","srcY1","lastSrcCtlPtY","srcY2","srcW1","lastSrcCtlPtW","srcW2","srcH1","lastSrcCtlPtH","srcH2","tgtX1","lastTgtCtlPtX","tgtX2","tgtY1","lastTgtCtlPtY","tgtY2","tgtW1","lastTgtCtlPtW","tgtW2","tgtH1","lastTgtCtlPtH","tgtH2","width1","lastW","lastWidth","loopDist","loopW","loopaPos","loopbPos","loopPos","minCompoundStretch","compoundStretchA","compoundStretchB","segpts","segmentWs","segmentDs","segmentsN","w1","w2","midptPts","adjustedMidpt","multi","manctrlptDist","normctrlptDist","sign","distanceFromMidpoint","findEndpoints","badStart","badAStart","badEnd","badAEnd","minCpADistFactor","arrowW","minCpADist","startACpDist","closeStartACp","endACpDist","closeEndACp","overlapping","cpD","cpL","cpM","cpProj","srcCtrlPtIntn","tgtCtrlPtIntn","mt","i2","i1","calculateArrowAngles","calculateLabelAngles","haystack","halfRadius","getAngleFromDisp","atan2","isHaystack","isMultibezier","isSegments","isSelf","i3","bp0x","bp0y","bp1x","bp1y","cpts","ic","midDispX","midDispY","rot","rotStr","labelAngle","sourceLabelAngle","targetLabelAngle","sourceLabelAutoAngle","targetLabelAutoAngle","tgtArShape","srcArShape","bezier","hasEndpts","cpStart","cpEnd","srcArrowFromPt","tgtArrowFromPt","arrowEnd","edgeEnd","arrowStart","edgeStart","badLine","getArrowHeight","edgeWidth","arrowWidthCache","getCachedImage","onLoad","imageCache","image","Image","crossOrigin","registerBinding","useCapture","nodeIsDraggable","nodeIsGrabbable","triggerEvents","isMultSelKeyDown","shiftKey","metaKey","ctrlKey","allowPanningPassthrough","downs","allowPassthrough","getDragListIds","listHasId","addToList","hasId","setGrabbed","setFreed","setInDragLayer","setOutDragLayer","setGrabTarget","removeGrabTarget","addToDragList","addDescendantsToDrag","innerNodes","addNodesToDrag","updateAncestorsInDragLayer","addNodeToDrag","freeDraggedElements","grabbedEles","haveMutationsApi","MutationObserver","mutns","mutn","rNodes","removedNodes","rNode","parentNode","observe","childList","onResize","attributes","invalCtnrBBOnScroll","bbCtnr","inBoxSelection","which","gpos","select","nears","draggedElements","mdownPos","mdownGPos","checkForTaphold","tapholdCancelled","tapholdTimeout","cxtStarted","cxtEvt","activate","getTime","cxtDragged","grabEvent","selectedNodes","bgActivePosistion","containerPageCoords","canvasWidth","canvasHeight","cyContainer","tParent","containerIsTarget","draggingEles","selecting","isOverThresholdDrag","dx2","dy2","dist2","multSelKeyDown","updateDragDelta","dragDelta","cxtOver","deltaP","justStartedPan","mdPos","dragged","unactivate","justStartedDrag","didDrag","dEle","dPos","updatePos","tcol","cxtTap","eleWouldBeSelected","downWasGrabbed","wheelHandler","scrollingPage","wheelZooming","wheelTimeout","deltaY","wheelDeltaY","wheelDelta","needsWheelFix","deltaMode","scrollingPageTimeout","f1x1","f1y1","f2x1","f2y1","distance1","distance1Sq","center1","modelCenter1","containerWidth","containerHeight","twoFingersStartInside","touchstartHandler","distanceSq","touches","touchDragEles","cxtDistThreshold","cxtDistThresholdSq","near1","near2","starts","draggedEles","startGPosition","pinching","touchmoveHandler","startGPos","f1x2","f1y2","f2x2","f2y2","distance2Sq","factorSq","distThresholdSq","factorThreshold","factorThresholdSq","lastThreeTouch","distance2","factor","df1x","df1y","df2x","df2y","tx","ty","ctrx","ctry","swipePanning","draggedEle","touchcancelHandler","touchendHandler","ctxTapend","ctxTap","startWasGrabbed","rdist2","TouchEvent","pointers","makeTouch","identifier","pointerId","pageX","pageY","radiusX","radiusY","screenX","screenY","makePointer","addPointer","removePointer","updatePointer","addTouchesToEvent","pointerType","generatePolygon","nodeShapeImpl","checkInEllipse","star5Points","outerPoints","innerPoints","innerRadius","timeToRender","redrawTotalTime","redrawCount","averageRedrawTime","lastRedrawTime","lastDrawTime","requestedFrame","priority","cbs","renderLoopStarted","renderFn","requestTime","skipFrame","endTime","CanvasRenderer","canvases","CRp","CANVAS_LAYERS","contexts","canvasNeedsRedraw","bufferCanvases","BUFFER_COUNT","bufferContexts","canvasContainer","containerStyle","setAttribute","overflow","getAttribute","canvas","getContext","String","topCanvas","NODE","SELECT_BOX","DRAG","pathsEnabled","eleTxrCache","ElementTextureCache","lyrTxrCache","LayeredTextureCache","de","invalidateElement","invalidateElements","CR","TEXTURE_BUFFER","MOTIONBLUR_BUFFER_NODE","MOTIONBLUR_BUFFER_DRAG","pathsImpld","Path2D","path2dEnabled","usePaths","defs","minTxrH","txrStepH","minLvl","maxLvl","eleTxrSpacing","defTxrWidth","maxTxrW","maxTxrH","minUtility","maxFullness","maxFullnessChecks","allowEdgeTxrCaching","allowParentTxrCaching","deqCost","deqAvgCost","deqNoDrawCost","deqFastCost","deqRedrawThreshold","maxDeqSize","getTxrReasons","dequeue","downscale","highQuality","onDequeues","setupDequeueing","ETCp","reasons","getTextureQueue","txrH","eleImgCaches","getRetiredTextureQueue","rtxtrQs","retired","rtxtrQ","getElementQueue","eleCacheQueue","reqs","getElementIdToQueue","id2q","eleIdToCacheQueue","getElement","lvl","reason","scale","eleScaledH","eleScaledW","caches","imgCaches","eleCache","txrQ","txr","addNewTxr","recycleTexture","addTexture","usedWidth","higherCache","scaledLabelShown","eleTextBiggerThanMin","scalableFrom","otherCache","deqing","highQualityReq","downscaleReq","oneUpCache","drawImage","texture","queueElement","lowerCache","translate","drawElement","eleCaches","checkTextureFullness","invalidatedWidth","checkTextureUtility","retireTexture","fullnessChecks","minW","clearRect","existingReq","dequeued","onDequeue","offDequeue","deq","onDeqd","deqd","shouldRedraw","fullFpsTime","dequeueingSetup","queueRedraw","frameStartTime","avgRenderTime","renderTime","getPixelRatio","frameDuration","timeAvailable","thisDeqd","imgSmoothing","imageSmoothingEnabled","webkitImageSmoothingEnabled","mozImageSmoothingEnabled","msImageSmoothingEnabled","defNumLayers","refineEleDebounceTime","disableEleImgSmoothing","invalidThreshold","maxLayerArea","alwaysQueue","useHighQualityEleTxrReqs","useEleTxrCaching","layersByLevel","firstGet","lastInvalidationTime","skipping","qSort","layersQueue","setupEleCacheInvalidation","LTCp","layerIdPool","MAX_INT","makeLayer","layer","elesQueue","getLayers","validateLayersElesOrdering","tmpLayers","layersByLvl","layers","lvlComplete","levelIsComplete","checkTempLevels","canUseAsTmpLvl","checkLvls","getBb","after","area","maxElesPerLayer","allowLazyQueueing","imgLayerCaches","existingLayer","queueLayer","drawEleInLayer","getEleLevelForLayerLevel","numElesInLayers","invalidateLayer","o","updateElementsInLayers","haveLayers","replacement","refineElementTextures","rLyr","replaces","eleDeqs","updatedElesInLayers","elesQ","applyLayerReplacement","requestRedraw","layersInLevel","replaced","polygon","lineTo","triangle-backcurve","firstPt","quadraticCurveTo","triangle-tee","trianglePoints","teePoints","firstTeePt","moveTo","arc","shiftToOriginWithBb","showLabel","drawNode","drawEdge","drawCachedElement","drawElements","drawCachedElements","drawCachedNodes","drawLayeredElements","drawLabel","drawOverlayInstead","overlayColor","strokeStyle","lineCap","lineColor","lineJoin","lineWidth","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","shadowStyle","drawEdgePath","drawArrowheads","drawElementText","canvasCxt","pathCacheHit","pathCacheKey","keyMatches","pathCache","setLineDash","beginPath","stroke","drawArrowhead","gco","globalCompositeOperation","arrowClearFill","fillStyle","drawArrowShape","fill","canvasContext","shapeImpl","arrowPathCacheKey","arrowPathCache","alreadyCached","leavePathOpen","closePath","matchEdgeWidth","safeDrawImage","img","ix","iy","iw","ih","drawingImage","drawInscribedImage","xPos","yPos","repeat","clip","shouldClip","imgOpacity","imgW","cachedW","imgH","cachedH","offsetWidth","offsetHeight","bgW","bgH","gAlpha","globalAlpha","save","pattern","createPattern","roundRect","computedSize","minSize","textAlign","textBaseline","srcLabel","tgtLabel","drawText","drawNodeText","drawEdgeText","getFontCache","fontCaches","setupTextStyle","labelStyle","labelSize","labelFamily","labelWeight","outlineOpacity","outlineColor","fontCacheKey","font","pdash","textW","textH","textAngle","orgTextX","orgTextY","pLeft","pRight","pTop","pBottom","backgroundOpacity","borderOpacity","textBorderWidth","bgWidth","bgHeight","bgX","bgY","textFill","textBackgroundColor","styleShape","fillRect","textStroke","textLineWidth","textBorderColor","textBorderStyle","strokeRect","whiteWidth","labelWrapCachedLines","strokeText","fillText","bgImgProp","prevBging","bgColor","borderColor","npos","darkness","borderWidth","drawPie","nodeOpacity","cyStyle","pieSize","lastPercent","angleStart","angleDelta","angleEnd","motionBlurDelay","backingStore","backingStorePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","devicePixelRatio","paintCache","paintCaches","needToCreateCache","blur","mbPxRatio","textureMult","forcedContext","forcedZoom","forcedPan","drawAllLayers","forcedPxRatio","mbclear","setContextTransform","ePan","eZoom","clearingMotionBlur","effectivePan","effectiveZoom","setTransform","drawOnlyNodeLayer","needDraw","textureDraw","inNodeDragGesture","motionBlurFadeEffect","prevPxRatio","motionBlurTimeout","mbFrames","textureDrawLastFrame","vp","prevVp","prevViewport","viewportIsDiff","textureCache","mpan","outsideBgColor","outsideBgOpacity","vpManip","hideEdges","needMbClear","useBuffer","fps","maxFps","cxtNode","txtNode","cxtDrag","txtDrag","drawMotionBlur","txt","needClear","pxr","motionBlurCleared","drawPolygonPath","drawRoundRectanglePath","arcTo","sin0","cos0","ellipseStepSize","drawEllipsePath","ellipse","rw","rh","createBuffer","buffer","bufferCanvasImage","full","specdMaxDims","maxWidth","maxHeight","maxScaleW","maxScaleH","buffCanvas","buffCxt","rect","zsortedEles","toDataURL","roundrectangle","cyReg","$ele","$this","sheetfn","N","defN","hardwareConcurrency","cpus","fabfn","spreadSize","subsize","spread","runPs","doneEarly","postpass","origResolve","oldLen","_$_$_fabmap","nothingInsdByResolve","datum","incDatum","sortedSplit","_$_$_cmp","joined","eleI","eleJ","splitL","defineRandomPasser","threadFn","randomMap","endianness","hostname","loadavg","uptime","freemem","totalmem","release","networkInterfaces","getNetworkInterfaces","arch","platform","tmpdir","tmpDir","EOL","networkStore","defaultState","ADD_NETWORK","networkId","_immutable","Map","DELETE_NETWORK","addNetwork","deleteNetwork","createClass","ctor","Iterable","isIterable","Seq","KeyedIterable","isKeyed","KeyedSeq","IndexedIterable","isIndexed","IndexedSeq","SetIterable","isAssociative","SetSeq","maybeIterable","IS_ITERABLE_SENTINEL","maybeKeyed","IS_KEYED_SENTINEL","maybeIndexed","IS_INDEXED_SENTINEL","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","MakeRef","SetRef","OwnerID","arrCopy","newArr","ii","ensureSize","__iterate","wrapIndex","uint32Index","NaN","wholeSlice","begin","resolveBegin","resolveIndex","resolveEnd","defaultIndex","Iterator","iteratorValue","iteratorResult","iteratorDone","hasIterator","getIteratorFn","isIterator","maybeIterator","getIterator","iterable","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","isArrayLike","emptySequence","toSeq","seqFromValue","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","entrySeq","toIndexedSeq","indexedSeqFromValue","toSetSeq","ArraySeq","_array","ObjectSeq","_object","_keys","IterableSeq","_iterable","IteratorSeq","iterator","_iterator","_iteratorCache","isSeq","maybeSeq","IS_SEQ_SENTINEL","EMPTY_SEQ","seq","maybeIndexedSeqFromValue","seqIterate","useKeys","_cache","maxIndex","entry","__iterateUncached","seqIterator","__iteratorUncached","fromJS","converter","fromJSWith","","fromJSDefault","parentJSON","isPlainObj","toList","toMap","valueA","valueB","valueOf","deepEqual","__hash","notAssociative","entries","flipped","cacheResult","_","allEqual","bSize","NOT_SET","Repeat","_value","EMPTY_REPEAT","Range","_start","_end","_step","EMPTY_RANGE","KeyedCollection","IndexedCollection","SetCollection","smi","i32","hash","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashCode","hashJSObj","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","charCodeAt","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","isExtensible","nodeType","uniqueID","assertNotInfinite","emptyMap","isMap","withMutations","maybeMap","IS_MAP_SENTINEL","ArrayMapNode","ownerID","BitmapIndexedNode","bitmap","HashArrayMapNode","HashCollisionNode","keyHash","ValueNode","MapIterator","_type","_reverse","_stack","_root","mapIteratorFrame","mapIteratorValue","__prev","makeMap","MapPrototype","__ownerID","__altered","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","isLeafNode","mergeIntoNode","newNode","idx1","MASK","idx2","SHIFT","createNodes","packNodes","excluding","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","mergeIntoMapWith","merger","iterables","iters","mergeIntoCollectionWith","deepMerger","existing","mergeDeep","deepMergerWith","mergeDeepWith","nextValue","mergeIntoMap","updateInDeepMap","keyPathIter","notSetValue","updater","isNotSet","existingValue","newValue","nextExisting","nextUpdated","popCount","setIn","idx","canEdit","newArray","spliceIn","newLen","spliceOut","List","emptyList","isList","makeList","VNode","list","setSize","maybeList","IS_LIST_SENTINEL","iterateList","iterateNodeOrLeaf","iterateLeaf","iterateNode","tailPos","tail","DONE","values","_origin","_capacity","getTailOffset","_tail","_level","capacity","ListPrototype","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","OrderedMap","emptyOrderedMap","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","_list","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","flip","ToKeyedSequence","indexed","_iter","_useKeys","ToIndexedSequence","ToSetSequence","FromEntriesSequence","flipFactory","flipSequence","makeSequence","reversedSequence","includes","cacheResultThrough","this$0","ITERATE_ENTRIES","__iterator","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mapper","mappedSequence","reverseFactory","filterFactory","predicate","filterSequence","countByFactory","grouper","groups","asMutable","asImmutable","groupByFactory","isKeyedIter","coerce","iterableClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","resolvedSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","concatFactory","isKeyedIterable","singleton","concatSeq","flatten","sum","flattenFactory","flatSequence","flatDeep","currentDepth","stack","flatMapFactory","interposeFactory","interposedSequence","sortFactory","comparator","defaultComparator","maxFactory","maxCompare","zipWithFactory","keyIter","zipper","zipSequence","iterators","isDone","validateEntry","resolveSize","forceIterator","keyPath","Record","defaultValues","hasInitialized","RecordType","setProps","RecordTypePrototype","_name","_defaultValues","RecordPrototype","makeRecord","likeRecord","record","recordName","setProp","Set","emptySet","isSet","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","EMPTY_SET","OrderedSet","emptyOrderedSet","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","EMPTY_ORDERED_SET","Stack","emptyStack","isStack","unshiftAll","maybeStack","IS_STACK_SENTINEL","makeStack","StackPrototype","_head","EMPTY_STACK","mixin","methods","keyCopier","keyMapper","entryMapper","neg","quoteString","defaultZipper","defaultNegComparator","hashIterable","ordered","keyed","hashMerge","murmurHashOfSize","imul","SLICE$0","Keyed","Indexed","DELETE","ITERATOR_SYMBOL","KEYS","VALUES","ENTRIES","inspect","toSource","of","__toString","searchValue","lastIndexOf","possibleIndex","offsetValue","WeakMap","keyValues","updateIn","deleteIn","updatedValue","mergeWith","mergeIn","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","iterate","removeIn","exists","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","subNode","oldSize","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","valueSeq","indexedIterable","defaultVal","_empty","fromKeys","keySeq","originalSet","pushAll","__toJS","toJSON","toObject","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","returnValue","find","findEntry","sideEffect","isFirst","initialReduction","reduction","useFirst","reversed","butLast","isEmpty","countBy","entriesSequence","filterNot","findKey","findLast","findLastEntry","findLastKey","flatMap","searchKey","getIn","searchKeyPath","nested","groupBy","hasIn","isSubset","isSuperset","keyOf","lastKeyOf","maxBy","minBy","skip","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","IterablePrototype","mapEntries","mapKeys","KeyedIterablePrototype","findIndex","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","Immutable","downloadState","DOWNLOAD_BEGIN","downloading","DOWNLOAD_SUCCESS","DOWNLOAD_ERROR","downloadSuccess","downloadError","headers","Accept","Content-Type","fetch","response","status","alert","locals","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","firstChild","removeStyleElement","createStyleElement","createLinkElement","linkElement","rel","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","revokeObjectURL","btoa","updateLink","href","applyToTag","styleSheet","cssText","replaceText","cssNode","createTextNode","unescape","encodeURIComponent","blob","oldSrc","memo","isOldIE","test","getElementsByTagName","mayRemove","textStore"],"mappings":"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","file":"CyNetworkViewer.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"React\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"React\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CyNetworkViewer\"] = factory(require(\"React\"));\n\telse\n\t\troot[\"CyNetworkViewer\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_17__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"React\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"React\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CyNetworkViewer\"] = factory(require(\"React\"));\n\telse\n\t\troot[\"CyNetworkViewer\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_17__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.store = exports.storeName = exports.component = undefined;\n\t\n\tvar _redux = __webpack_require__(1);\n\t\n\tvar _reactRedux = __webpack_require__(15);\n\t\n\tvar _CyNetworkViewer = __webpack_require__(25);\n\t\n\tvar _CyNetworkViewer2 = _interopRequireDefault(_CyNetworkViewer);\n\t\n\tvar _networks = __webpack_require__(139);\n\t\n\tvar networkActions = _interopRequireWildcard(_networks);\n\t\n\tvar _networkDownload = __webpack_require__(141);\n\t\n\tvar networkDownloadActions = _interopRequireWildcard(_networkDownload);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t__webpack_require__(142);\n\t\n\tfunction mapStateToProps(state) {\n\t  return {\n\t    networks: state.cy_network.networks,\n\t    networkDownload: state.cy_network.networkDownload\n\t  };\n\t}\n\t\n\tfunction mapDispatchToProps(dispatch) {\n\t  return {\n\t    downloadActions: (0, _redux.bindActionCreators)(networkDownloadActions, dispatch),\n\t    networkActions: (0, _redux.bindActionCreators)(networkActions, dispatch)\n\t  };\n\t}\n\t\n\tvar component = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_CyNetworkViewer2.default);\n\t\n\tvar storeName = 'cy_network_viewer';\n\tvar store = {};\n\t\n\texports.component = component;\n\texports.storeName = storeName;\n\texports.store = store;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\texports.__esModule = true;\n\texports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;\n\t\n\tvar _createStore = __webpack_require__(3);\n\t\n\tvar _createStore2 = _interopRequireDefault(_createStore);\n\t\n\tvar _combineReducers = __webpack_require__(10);\n\t\n\tvar _combineReducers2 = _interopRequireDefault(_combineReducers);\n\t\n\tvar _bindActionCreators = __webpack_require__(12);\n\t\n\tvar _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);\n\t\n\tvar _applyMiddleware = __webpack_require__(13);\n\t\n\tvar _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);\n\t\n\tvar _compose = __webpack_require__(14);\n\t\n\tvar _compose2 = _interopRequireDefault(_compose);\n\t\n\tvar _warning = __webpack_require__(11);\n\t\n\tvar _warning2 = _interopRequireDefault(_warning);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\t/*\n\t* This is a dummy function to check if the function name has been altered by minification.\n\t* If the function has been minified and NODE_ENV !== 'production', warn the user.\n\t*/\n\tfunction isCrushed() {}\n\t\n\tif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n\t  (0, _warning2[\"default\"])('You are currently using minified code outside of NODE_ENV === \\'production\\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n\t}\n\t\n\texports.createStore = _createStore2[\"default\"];\n\texports.combineReducers = _combineReducers2[\"default\"];\n\texports.bindActionCreators = _bindActionCreators2[\"default\"];\n\texports.applyMiddleware = _applyMiddleware2[\"default\"];\n\texports.compose = _compose2[\"default\"];\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\t(function () {\n\t  try {\n\t    cachedSetTimeout = setTimeout;\n\t  } catch (e) {\n\t    cachedSetTimeout = function () {\n\t      throw new Error('setTimeout is not defined');\n\t    }\n\t  }\n\t  try {\n\t    cachedClearTimeout = clearTimeout;\n\t  } catch (e) {\n\t    cachedClearTimeout = function () {\n\t      throw new Error('clearTimeout is not defined');\n\t    }\n\t  }\n\t} ())\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = cachedSetTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    cachedClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        cachedSetTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.ActionTypes = undefined;\n\texports[\"default\"] = createStore;\n\t\n\tvar _isPlainObject = __webpack_require__(4);\n\t\n\tvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\t\n\tvar _symbolObservable = __webpack_require__(8);\n\t\n\tvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\t/**\n\t * These are private action types reserved by Redux.\n\t * For any unknown actions, you must return the current state.\n\t * If the current state is undefined, you must return the initial state.\n\t * Do not reference these action types directly in your code.\n\t */\n\tvar ActionTypes = exports.ActionTypes = {\n\t  INIT: '@@redux/INIT'\n\t};\n\t\n\t/**\n\t * Creates a Redux store that holds the state tree.\n\t * The only way to change the data in the store is to call `dispatch()` on it.\n\t *\n\t * There should only be a single store in your app. To specify how different\n\t * parts of the state tree respond to actions, you may combine several reducers\n\t * into a single reducer function by using `combineReducers`.\n\t *\n\t * @param {Function} reducer A function that returns the next state tree, given\n\t * the current state tree and the action to handle.\n\t *\n\t * @param {any} [initialState] The initial state. You may optionally specify it\n\t * to hydrate the state from the server in universal apps, or to restore a\n\t * previously serialized user session.\n\t * If you use `combineReducers` to produce the root reducer function, this must be\n\t * an object with the same shape as `combineReducers` keys.\n\t *\n\t * @param {Function} enhancer The store enhancer. You may optionally specify it\n\t * to enhance the store with third-party capabilities such as middleware,\n\t * time travel, persistence, etc. The only store enhancer that ships with Redux\n\t * is `applyMiddleware()`.\n\t *\n\t * @returns {Store} A Redux store that lets you read the state, dispatch actions\n\t * and subscribe to changes.\n\t */\n\tfunction createStore(reducer, initialState, enhancer) {\n\t  var _ref2;\n\t\n\t  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {\n\t    enhancer = initialState;\n\t    initialState = undefined;\n\t  }\n\t\n\t  if (typeof enhancer !== 'undefined') {\n\t    if (typeof enhancer !== 'function') {\n\t      throw new Error('Expected the enhancer to be a function.');\n\t    }\n\t\n\t    return enhancer(createStore)(reducer, initialState);\n\t  }\n\t\n\t  if (typeof reducer !== 'function') {\n\t    throw new Error('Expected the reducer to be a function.');\n\t  }\n\t\n\t  var currentReducer = reducer;\n\t  var currentState = initialState;\n\t  var currentListeners = [];\n\t  var nextListeners = currentListeners;\n\t  var isDispatching = false;\n\t\n\t  function ensureCanMutateNextListeners() {\n\t    if (nextListeners === currentListeners) {\n\t      nextListeners = currentListeners.slice();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Reads the state tree managed by the store.\n\t   *\n\t   * @returns {any} The current state tree of your application.\n\t   */\n\t  function getState() {\n\t    return currentState;\n\t  }\n\t\n\t  /**\n\t   * Adds a change listener. It will be called any time an action is dispatched,\n\t   * and some part of the state tree may potentially have changed. You may then\n\t   * call `getState()` to read the current state tree inside the callback.\n\t   *\n\t   * You may call `dispatch()` from a change listener, with the following\n\t   * caveats:\n\t   *\n\t   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n\t   * If you subscribe or unsubscribe while the listeners are being invoked, this\n\t   * will not have any effect on the `dispatch()` that is currently in progress.\n\t   * However, the next `dispatch()` call, whether nested or not, will use a more\n\t   * recent snapshot of the subscription list.\n\t   *\n\t   * 2. The listener should not expect to see all state changes, as the state\n\t   * might have been updated multiple times during a nested `dispatch()` before\n\t   * the listener is called. It is, however, guaranteed that all subscribers\n\t   * registered before the `dispatch()` started will be called with the latest\n\t   * state by the time it exits.\n\t   *\n\t   * @param {Function} listener A callback to be invoked on every dispatch.\n\t   * @returns {Function} A function to remove this change listener.\n\t   */\n\t  function subscribe(listener) {\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('Expected listener to be a function.');\n\t    }\n\t\n\t    var isSubscribed = true;\n\t\n\t    ensureCanMutateNextListeners();\n\t    nextListeners.push(listener);\n\t\n\t    return function unsubscribe() {\n\t      if (!isSubscribed) {\n\t        return;\n\t      }\n\t\n\t      isSubscribed = false;\n\t\n\t      ensureCanMutateNextListeners();\n\t      var index = nextListeners.indexOf(listener);\n\t      nextListeners.splice(index, 1);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Dispatches an action. It is the only way to trigger a state change.\n\t   *\n\t   * The `reducer` function, used to create the store, will be called with the\n\t   * current state tree and the given `action`. Its return value will\n\t   * be considered the **next** state of the tree, and the change listeners\n\t   * will be notified.\n\t   *\n\t   * The base implementation only supports plain object actions. If you want to\n\t   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n\t   * wrap your store creating function into the corresponding middleware. For\n\t   * example, see the documentation for the `redux-thunk` package. Even the\n\t   * middleware will eventually dispatch plain object actions using this method.\n\t   *\n\t   * @param {Object} action A plain object representing “what changed”. It is\n\t   * a good idea to keep actions serializable so you can record and replay user\n\t   * sessions, or use the time travelling `redux-devtools`. An action must have\n\t   * a `type` property which may not be `undefined`. It is a good idea to use\n\t   * string constants for action types.\n\t   *\n\t   * @returns {Object} For convenience, the same action object you dispatched.\n\t   *\n\t   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n\t   * return something else (for example, a Promise you can await).\n\t   */\n\t  function dispatch(action) {\n\t    if (!(0, _isPlainObject2[\"default\"])(action)) {\n\t      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n\t    }\n\t\n\t    if (typeof action.type === 'undefined') {\n\t      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n\t    }\n\t\n\t    if (isDispatching) {\n\t      throw new Error('Reducers may not dispatch actions.');\n\t    }\n\t\n\t    try {\n\t      isDispatching = true;\n\t      currentState = currentReducer(currentState, action);\n\t    } finally {\n\t      isDispatching = false;\n\t    }\n\t\n\t    var listeners = currentListeners = nextListeners;\n\t    for (var i = 0; i < listeners.length; i++) {\n\t      listeners[i]();\n\t    }\n\t\n\t    return action;\n\t  }\n\t\n\t  /**\n\t   * Replaces the reducer currently used by the store to calculate the state.\n\t   *\n\t   * You might need this if your app implements code splitting and you want to\n\t   * load some of the reducers dynamically. You might also need this if you\n\t   * implement a hot reloading mechanism for Redux.\n\t   *\n\t   * @param {Function} nextReducer The reducer for the store to use instead.\n\t   * @returns {void}\n\t   */\n\t  function replaceReducer(nextReducer) {\n\t    if (typeof nextReducer !== 'function') {\n\t      throw new Error('Expected the nextReducer to be a function.');\n\t    }\n\t\n\t    currentReducer = nextReducer;\n\t    dispatch({ type: ActionTypes.INIT });\n\t  }\n\t\n\t  /**\n\t   * Interoperability point for observable/reactive libraries.\n\t   * @returns {observable} A minimal observable of state changes.\n\t   * For more information, see the observable proposal:\n\t   * https://github.com/zenparsing/es-observable\n\t   */\n\t  function observable() {\n\t    var _ref;\n\t\n\t    var outerSubscribe = subscribe;\n\t    return _ref = {\n\t      /**\n\t       * The minimal observable subscription method.\n\t       * @param {Object} observer Any object that can be used as an observer.\n\t       * The observer object should have a `next` method.\n\t       * @returns {subscription} An object with an `unsubscribe` method that can\n\t       * be used to unsubscribe the observable from the store, and prevent further\n\t       * emission of values from the observable.\n\t       */\n\t\n\t      subscribe: function subscribe(observer) {\n\t        if (typeof observer !== 'object') {\n\t          throw new TypeError('Expected the observer to be an object.');\n\t        }\n\t\n\t        function observeState() {\n\t          if (observer.next) {\n\t            observer.next(getState());\n\t          }\n\t        }\n\t\n\t        observeState();\n\t        var unsubscribe = outerSubscribe(observeState);\n\t        return { unsubscribe: unsubscribe };\n\t      }\n\t    }, _ref[_symbolObservable2[\"default\"]] = function () {\n\t      return this;\n\t    }, _ref;\n\t  }\n\t\n\t  // When a store is created, an \"INIT\" action is dispatched so that every\n\t  // reducer returns their initial state. This effectively populates\n\t  // the initial state tree.\n\t  dispatch({ type: ActionTypes.INIT });\n\t\n\t  return _ref2 = {\n\t    dispatch: dispatch,\n\t    subscribe: subscribe,\n\t    getState: getState,\n\t    replaceReducer: replaceReducer\n\t  }, _ref2[_symbolObservable2[\"default\"]] = observable, _ref2;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getPrototype = __webpack_require__(5),\n\t    isHostObject = __webpack_require__(6),\n\t    isObjectLike = __webpack_require__(7);\n\t\n\t/** `Object#toString` result references. */\n\tvar objectTag = '[object Object]';\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = Function.prototype.toString;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Used to infer the `Object` constructor. */\n\tvar objectCtorString = funcToString.call(Object);\n\t\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString = objectProto.toString;\n\t\n\t/**\n\t * Checks if `value` is a plain object, that is, an object created by the\n\t * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.8.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a plain object,\n\t *  else `false`.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t * }\n\t *\n\t * _.isPlainObject(new Foo);\n\t * // => false\n\t *\n\t * _.isPlainObject([1, 2, 3]);\n\t * // => false\n\t *\n\t * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t * // => true\n\t *\n\t * _.isPlainObject(Object.create(null));\n\t * // => true\n\t */\n\tfunction isPlainObject(value) {\n\t  if (!isObjectLike(value) ||\n\t      objectToString.call(value) != objectTag || isHostObject(value)) {\n\t    return false;\n\t  }\n\t  var proto = getPrototype(value);\n\t  if (proto === null) {\n\t    return true;\n\t  }\n\t  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\t\n\tmodule.exports = isPlainObject;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeGetPrototype = Object.getPrototypeOf;\n\t\n\t/**\n\t * Gets the `[[Prototype]]` of `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {null|Object} Returns the `[[Prototype]]`.\n\t */\n\tfunction getPrototype(value) {\n\t  return nativeGetPrototype(Object(value));\n\t}\n\t\n\tmodule.exports = getPrototype;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is a host object in IE < 9.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n\t */\n\tfunction isHostObject(value) {\n\t  // Many host objects are `Object` objects that can coerce to strings\n\t  // despite having improperly defined `toString` methods.\n\t  var result = false;\n\t  if (value != null && typeof value.toString != 'function') {\n\t    try {\n\t      result = !!(value + '');\n\t    } catch (e) {}\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = isHostObject;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\t\n\tmodule.exports = isObjectLike;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/* global window */\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(9)(global || window || this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function symbolObservablePonyfill(root) {\n\t\tvar result;\n\t\tvar Symbol = root.Symbol;\n\t\n\t\tif (typeof Symbol === 'function') {\n\t\t\tif (Symbol.observable) {\n\t\t\t\tresult = Symbol.observable;\n\t\t\t} else {\n\t\t\t\tresult = Symbol('observable');\n\t\t\t\tSymbol.observable = result;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = '@@observable';\n\t\t}\n\t\n\t\treturn result;\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = combineReducers;\n\t\n\tvar _createStore = __webpack_require__(3);\n\t\n\tvar _isPlainObject = __webpack_require__(4);\n\t\n\tvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\t\n\tvar _warning = __webpack_require__(11);\n\t\n\tvar _warning2 = _interopRequireDefault(_warning);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\tfunction getUndefinedStateErrorMessage(key, action) {\n\t  var actionType = action && action.type;\n\t  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\t\n\t  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';\n\t}\n\t\n\tfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {\n\t  var reducerKeys = Object.keys(reducers);\n\t  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';\n\t\n\t  if (reducerKeys.length === 0) {\n\t    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n\t  }\n\t\n\t  if (!(0, _isPlainObject2[\"default\"])(inputState)) {\n\t    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n\t  }\n\t\n\t  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n\t    return !reducers.hasOwnProperty(key);\n\t  });\n\t\n\t  if (unexpectedKeys.length > 0) {\n\t    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n\t  }\n\t}\n\t\n\tfunction assertReducerSanity(reducers) {\n\t  Object.keys(reducers).forEach(function (key) {\n\t    var reducer = reducers[key];\n\t    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });\n\t\n\t    if (typeof initialState === 'undefined') {\n\t      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');\n\t    }\n\t\n\t    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n\t    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n\t      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Turns an object whose values are different reducer functions, into a single\n\t * reducer function. It will call every child reducer, and gather their results\n\t * into a single state object, whose keys correspond to the keys of the passed\n\t * reducer functions.\n\t *\n\t * @param {Object} reducers An object whose values correspond to different\n\t * reducer functions that need to be combined into one. One handy way to obtain\n\t * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n\t * undefined for any action. Instead, they should return their initial state\n\t * if the state passed to them was undefined, and the current state for any\n\t * unrecognized action.\n\t *\n\t * @returns {Function} A reducer function that invokes every reducer inside the\n\t * passed object, and builds a state object with the same shape.\n\t */\n\tfunction combineReducers(reducers) {\n\t  var reducerKeys = Object.keys(reducers);\n\t  var finalReducers = {};\n\t  for (var i = 0; i < reducerKeys.length; i++) {\n\t    var key = reducerKeys[i];\n\t    if (typeof reducers[key] === 'function') {\n\t      finalReducers[key] = reducers[key];\n\t    }\n\t  }\n\t  var finalReducerKeys = Object.keys(finalReducers);\n\t\n\t  var sanityError;\n\t  try {\n\t    assertReducerSanity(finalReducers);\n\t  } catch (e) {\n\t    sanityError = e;\n\t  }\n\t\n\t  return function combination() {\n\t    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var action = arguments[1];\n\t\n\t    if (sanityError) {\n\t      throw sanityError;\n\t    }\n\t\n\t    if (process.env.NODE_ENV !== 'production') {\n\t      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);\n\t      if (warningMessage) {\n\t        (0, _warning2[\"default\"])(warningMessage);\n\t      }\n\t    }\n\t\n\t    var hasChanged = false;\n\t    var nextState = {};\n\t    for (var i = 0; i < finalReducerKeys.length; i++) {\n\t      var key = finalReducerKeys[i];\n\t      var reducer = finalReducers[key];\n\t      var previousStateForKey = state[key];\n\t      var nextStateForKey = reducer(previousStateForKey, action);\n\t      if (typeof nextStateForKey === 'undefined') {\n\t        var errorMessage = getUndefinedStateErrorMessage(key, action);\n\t        throw new Error(errorMessage);\n\t      }\n\t      nextState[key] = nextStateForKey;\n\t      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n\t    }\n\t    return hasChanged ? nextState : state;\n\t  };\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = warning;\n\t/**\n\t * Prints a warning in the console if it exists.\n\t *\n\t * @param {String} message The warning message.\n\t * @returns {void}\n\t */\n\tfunction warning(message) {\n\t  /* eslint-disable no-console */\n\t  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n\t    console.error(message);\n\t  }\n\t  /* eslint-enable no-console */\n\t  try {\n\t    // This error was thrown as a convenience so that if you enable\n\t    // \"break on all exceptions\" in your console,\n\t    // it would pause the execution at this line.\n\t    throw new Error(message);\n\t    /* eslint-disable no-empty */\n\t  } catch (e) {}\n\t  /* eslint-enable no-empty */\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = bindActionCreators;\n\tfunction bindActionCreator(actionCreator, dispatch) {\n\t  return function () {\n\t    return dispatch(actionCreator.apply(undefined, arguments));\n\t  };\n\t}\n\t\n\t/**\n\t * Turns an object whose values are action creators, into an object with the\n\t * same keys, but with every function wrapped into a `dispatch` call so they\n\t * may be invoked directly. This is just a convenience method, as you can call\n\t * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n\t *\n\t * For convenience, you can also pass a single function as the first argument,\n\t * and get a function in return.\n\t *\n\t * @param {Function|Object} actionCreators An object whose values are action\n\t * creator functions. One handy way to obtain it is to use ES6 `import * as`\n\t * syntax. You may also pass a single function.\n\t *\n\t * @param {Function} dispatch The `dispatch` function available on your Redux\n\t * store.\n\t *\n\t * @returns {Function|Object} The object mimicking the original object, but with\n\t * every action creator wrapped into the `dispatch` call. If you passed a\n\t * function as `actionCreators`, the return value will also be a single\n\t * function.\n\t */\n\tfunction bindActionCreators(actionCreators, dispatch) {\n\t  if (typeof actionCreators === 'function') {\n\t    return bindActionCreator(actionCreators, dispatch);\n\t  }\n\t\n\t  if (typeof actionCreators !== 'object' || actionCreators === null) {\n\t    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n\t  }\n\t\n\t  var keys = Object.keys(actionCreators);\n\t  var boundActionCreators = {};\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    var actionCreator = actionCreators[key];\n\t    if (typeof actionCreator === 'function') {\n\t      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n\t    }\n\t  }\n\t  return boundActionCreators;\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports[\"default\"] = applyMiddleware;\n\t\n\tvar _compose = __webpack_require__(14);\n\t\n\tvar _compose2 = _interopRequireDefault(_compose);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\t/**\n\t * Creates a store enhancer that applies middleware to the dispatch method\n\t * of the Redux store. This is handy for a variety of tasks, such as expressing\n\t * asynchronous actions in a concise manner, or logging every action payload.\n\t *\n\t * See `redux-thunk` package as an example of the Redux middleware.\n\t *\n\t * Because middleware is potentially asynchronous, this should be the first\n\t * store enhancer in the composition chain.\n\t *\n\t * Note that each middleware will be given the `dispatch` and `getState` functions\n\t * as named arguments.\n\t *\n\t * @param {...Function} middlewares The middleware chain to be applied.\n\t * @returns {Function} A store enhancer applying the middleware.\n\t */\n\tfunction applyMiddleware() {\n\t  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n\t    middlewares[_key] = arguments[_key];\n\t  }\n\t\n\t  return function (createStore) {\n\t    return function (reducer, initialState, enhancer) {\n\t      var store = createStore(reducer, initialState, enhancer);\n\t      var _dispatch = store.dispatch;\n\t      var chain = [];\n\t\n\t      var middlewareAPI = {\n\t        getState: store.getState,\n\t        dispatch: function dispatch(action) {\n\t          return _dispatch(action);\n\t        }\n\t      };\n\t      chain = middlewares.map(function (middleware) {\n\t        return middleware(middlewareAPI);\n\t      });\n\t      _dispatch = _compose2[\"default\"].apply(undefined, chain)(store.dispatch);\n\t\n\t      return _extends({}, store, {\n\t        dispatch: _dispatch\n\t      });\n\t    };\n\t  };\n\t}\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = compose;\n\t/**\n\t * Composes single-argument functions from right to left. The rightmost\n\t * function can take multiple arguments as it provides the signature for\n\t * the resulting composite function.\n\t *\n\t * @param {...Function} funcs The functions to compose.\n\t * @returns {Function} A function obtained by composing the argument functions\n\t * from right to left. For example, compose(f, g, h) is identical to doing\n\t * (...args) => f(g(h(...args))).\n\t */\n\t\n\tfunction compose() {\n\t  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n\t    funcs[_key] = arguments[_key];\n\t  }\n\t\n\t  if (funcs.length === 0) {\n\t    return function (arg) {\n\t      return arg;\n\t    };\n\t  } else {\n\t    var _ret = function () {\n\t      var last = funcs[funcs.length - 1];\n\t      var rest = funcs.slice(0, -1);\n\t      return {\n\t        v: function v() {\n\t          return rest.reduceRight(function (composed, f) {\n\t            return f(composed);\n\t          }, last.apply(undefined, arguments));\n\t        }\n\t      };\n\t    }();\n\t\n\t    if (typeof _ret === \"object\") return _ret.v;\n\t  }\n\t}\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.connect = exports.Provider = undefined;\n\t\n\tvar _Provider = __webpack_require__(16);\n\t\n\tvar _Provider2 = _interopRequireDefault(_Provider);\n\t\n\tvar _connect = __webpack_require__(20);\n\t\n\tvar _connect2 = _interopRequireDefault(_connect);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\texports.Provider = _Provider2[\"default\"];\n\texports.connect = _connect2[\"default\"];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = undefined;\n\t\n\tvar _react = __webpack_require__(17);\n\t\n\tvar _storeShape = __webpack_require__(18);\n\t\n\tvar _storeShape2 = _interopRequireDefault(_storeShape);\n\t\n\tvar _warning = __webpack_require__(19);\n\t\n\tvar _warning2 = _interopRequireDefault(_warning);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar didWarnAboutReceivingStore = false;\n\tfunction warnAboutReceivingStore() {\n\t  if (didWarnAboutReceivingStore) {\n\t    return;\n\t  }\n\t  didWarnAboutReceivingStore = true;\n\t\n\t  (0, _warning2[\"default\"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');\n\t}\n\t\n\tvar Provider = function (_Component) {\n\t  _inherits(Provider, _Component);\n\t\n\t  Provider.prototype.getChildContext = function getChildContext() {\n\t    return { store: this.store };\n\t  };\n\t\n\t  function Provider(props, context) {\n\t    _classCallCheck(this, Provider);\n\t\n\t    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));\n\t\n\t    _this.store = props.store;\n\t    return _this;\n\t  }\n\t\n\t  Provider.prototype.render = function render() {\n\t    var children = this.props.children;\n\t\n\t    return _react.Children.only(children);\n\t  };\n\t\n\t  return Provider;\n\t}(_react.Component);\n\t\n\texports[\"default\"] = Provider;\n\t\n\tif (process.env.NODE_ENV !== 'production') {\n\t  Provider.prototype.componentWillReceiveProps = function (nextProps) {\n\t    var store = this.store;\n\t    var nextStore = nextProps.store;\n\t\n\t    if (store !== nextStore) {\n\t      warnAboutReceivingStore();\n\t    }\n\t  };\n\t}\n\t\n\tProvider.propTypes = {\n\t  store: _storeShape2[\"default\"].isRequired,\n\t  children: _react.PropTypes.element.isRequired\n\t};\n\tProvider.childContextTypes = {\n\t  store: _storeShape2[\"default\"].isRequired\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_17__;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(17);\n\t\n\texports[\"default\"] = _react.PropTypes.shape({\n\t  subscribe: _react.PropTypes.func.isRequired,\n\t  dispatch: _react.PropTypes.func.isRequired,\n\t  getState: _react.PropTypes.func.isRequired\n\t});\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = warning;\n\t/**\n\t * Prints a warning in the console if it exists.\n\t *\n\t * @param {String} message The warning message.\n\t * @returns {void}\n\t */\n\tfunction warning(message) {\n\t  /* eslint-disable no-console */\n\t  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n\t    console.error(message);\n\t  }\n\t  /* eslint-enable no-console */\n\t  try {\n\t    // This error was thrown as a convenience so that you can use this stack\n\t    // to find the callsite that caused this warning to fire.\n\t    throw new Error(message);\n\t    /* eslint-disable no-empty */\n\t  } catch (e) {}\n\t  /* eslint-enable no-empty */\n\t}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = connect;\n\t\n\tvar _react = __webpack_require__(17);\n\t\n\tvar _storeShape = __webpack_require__(18);\n\t\n\tvar _storeShape2 = _interopRequireDefault(_storeShape);\n\t\n\tvar _shallowEqual = __webpack_require__(21);\n\t\n\tvar _shallowEqual2 = _interopRequireDefault(_shallowEqual);\n\t\n\tvar _wrapActionCreators = __webpack_require__(22);\n\t\n\tvar _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);\n\t\n\tvar _warning = __webpack_require__(19);\n\t\n\tvar _warning2 = _interopRequireDefault(_warning);\n\t\n\tvar _isPlainObject = __webpack_require__(4);\n\t\n\tvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\t\n\tvar _hoistNonReactStatics = __webpack_require__(23);\n\t\n\tvar _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);\n\t\n\tvar _invariant = __webpack_require__(24);\n\t\n\tvar _invariant2 = _interopRequireDefault(_invariant);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar defaultMapStateToProps = function defaultMapStateToProps(state) {\n\t  return {};\n\t}; // eslint-disable-line no-unused-vars\n\tvar defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {\n\t  return { dispatch: dispatch };\n\t};\n\tvar defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {\n\t  return _extends({}, parentProps, stateProps, dispatchProps);\n\t};\n\t\n\tfunction getDisplayName(WrappedComponent) {\n\t  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n\t}\n\t\n\tvar errorObject = { value: null };\n\tfunction tryCatch(fn, ctx) {\n\t  try {\n\t    return fn.apply(ctx);\n\t  } catch (e) {\n\t    errorObject.value = e;\n\t    return errorObject;\n\t  }\n\t}\n\t\n\t// Helps track hot reloading.\n\tvar nextVersion = 0;\n\t\n\tfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n\t  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t  var shouldSubscribe = Boolean(mapStateToProps);\n\t  var mapState = mapStateToProps || defaultMapStateToProps;\n\t\n\t  var mapDispatch = undefined;\n\t  if (typeof mapDispatchToProps === 'function') {\n\t    mapDispatch = mapDispatchToProps;\n\t  } else if (!mapDispatchToProps) {\n\t    mapDispatch = defaultMapDispatchToProps;\n\t  } else {\n\t    mapDispatch = (0, _wrapActionCreators2[\"default\"])(mapDispatchToProps);\n\t  }\n\t\n\t  var finalMergeProps = mergeProps || defaultMergeProps;\n\t  var _options$pure = options.pure;\n\t  var pure = _options$pure === undefined ? true : _options$pure;\n\t  var _options$withRef = options.withRef;\n\t  var withRef = _options$withRef === undefined ? false : _options$withRef;\n\t\n\t  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;\n\t\n\t  // Helps track hot reloading.\n\t  var version = nextVersion++;\n\t\n\t  return function wrapWithConnect(WrappedComponent) {\n\t    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';\n\t\n\t    function checkStateShape(props, methodName) {\n\t      if (!(0, _isPlainObject2[\"default\"])(props)) {\n\t        (0, _warning2[\"default\"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));\n\t      }\n\t    }\n\t\n\t    function computeMergedProps(stateProps, dispatchProps, parentProps) {\n\t      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);\n\t      if (process.env.NODE_ENV !== 'production') {\n\t        checkStateShape(mergedProps, 'mergeProps');\n\t      }\n\t      return mergedProps;\n\t    }\n\t\n\t    var Connect = function (_Component) {\n\t      _inherits(Connect, _Component);\n\t\n\t      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {\n\t        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;\n\t      };\n\t\n\t      function Connect(props, context) {\n\t        _classCallCheck(this, Connect);\n\t\n\t        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));\n\t\n\t        _this.version = version;\n\t        _this.store = props.store || context.store;\n\t\n\t        (0, _invariant2[\"default\"])(_this.store, 'Could not find \"store\" in either the context or ' + ('props of \"' + connectDisplayName + '\". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass \"store\" as a prop to \"' + connectDisplayName + '\".'));\n\t\n\t        var storeState = _this.store.getState();\n\t        _this.state = { storeState: storeState };\n\t        _this.clearCache();\n\t        return _this;\n\t      }\n\t\n\t      Connect.prototype.computeStateProps = function computeStateProps(store, props) {\n\t        if (!this.finalMapStateToProps) {\n\t          return this.configureFinalMapState(store, props);\n\t        }\n\t\n\t        var state = store.getState();\n\t        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);\n\t\n\t        if (process.env.NODE_ENV !== 'production') {\n\t          checkStateShape(stateProps, 'mapStateToProps');\n\t        }\n\t        return stateProps;\n\t      };\n\t\n\t      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {\n\t        var mappedState = mapState(store.getState(), props);\n\t        var isFactory = typeof mappedState === 'function';\n\t\n\t        this.finalMapStateToProps = isFactory ? mappedState : mapState;\n\t        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;\n\t\n\t        if (isFactory) {\n\t          return this.computeStateProps(store, props);\n\t        }\n\t\n\t        if (process.env.NODE_ENV !== 'production') {\n\t          checkStateShape(mappedState, 'mapStateToProps');\n\t        }\n\t        return mappedState;\n\t      };\n\t\n\t      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {\n\t        if (!this.finalMapDispatchToProps) {\n\t          return this.configureFinalMapDispatch(store, props);\n\t        }\n\t\n\t        var dispatch = store.dispatch;\n\t\n\t        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);\n\t\n\t        if (process.env.NODE_ENV !== 'production') {\n\t          checkStateShape(dispatchProps, 'mapDispatchToProps');\n\t        }\n\t        return dispatchProps;\n\t      };\n\t\n\t      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {\n\t        var mappedDispatch = mapDispatch(store.dispatch, props);\n\t        var isFactory = typeof mappedDispatch === 'function';\n\t\n\t        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;\n\t        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;\n\t\n\t        if (isFactory) {\n\t          return this.computeDispatchProps(store, props);\n\t        }\n\t\n\t        if (process.env.NODE_ENV !== 'production') {\n\t          checkStateShape(mappedDispatch, 'mapDispatchToProps');\n\t        }\n\t        return mappedDispatch;\n\t      };\n\t\n\t      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {\n\t        var nextStateProps = this.computeStateProps(this.store, this.props);\n\t        if (this.stateProps && (0, _shallowEqual2[\"default\"])(nextStateProps, this.stateProps)) {\n\t          return false;\n\t        }\n\t\n\t        this.stateProps = nextStateProps;\n\t        return true;\n\t      };\n\t\n\t      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {\n\t        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);\n\t        if (this.dispatchProps && (0, _shallowEqual2[\"default\"])(nextDispatchProps, this.dispatchProps)) {\n\t          return false;\n\t        }\n\t\n\t        this.dispatchProps = nextDispatchProps;\n\t        return true;\n\t      };\n\t\n\t      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {\n\t        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);\n\t        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2[\"default\"])(nextMergedProps, this.mergedProps)) {\n\t          return false;\n\t        }\n\t\n\t        this.mergedProps = nextMergedProps;\n\t        return true;\n\t      };\n\t\n\t      Connect.prototype.isSubscribed = function isSubscribed() {\n\t        return typeof this.unsubscribe === 'function';\n\t      };\n\t\n\t      Connect.prototype.trySubscribe = function trySubscribe() {\n\t        if (shouldSubscribe && !this.unsubscribe) {\n\t          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));\n\t          this.handleChange();\n\t        }\n\t      };\n\t\n\t      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {\n\t        if (this.unsubscribe) {\n\t          this.unsubscribe();\n\t          this.unsubscribe = null;\n\t        }\n\t      };\n\t\n\t      Connect.prototype.componentDidMount = function componentDidMount() {\n\t        this.trySubscribe();\n\t      };\n\t\n\t      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n\t        if (!pure || !(0, _shallowEqual2[\"default\"])(nextProps, this.props)) {\n\t          this.haveOwnPropsChanged = true;\n\t        }\n\t      };\n\t\n\t      Connect.prototype.componentWillUnmount = function componentWillUnmount() {\n\t        this.tryUnsubscribe();\n\t        this.clearCache();\n\t      };\n\t\n\t      Connect.prototype.clearCache = function clearCache() {\n\t        this.dispatchProps = null;\n\t        this.stateProps = null;\n\t        this.mergedProps = null;\n\t        this.haveOwnPropsChanged = true;\n\t        this.hasStoreStateChanged = true;\n\t        this.haveStatePropsBeenPrecalculated = false;\n\t        this.statePropsPrecalculationError = null;\n\t        this.renderedElement = null;\n\t        this.finalMapDispatchToProps = null;\n\t        this.finalMapStateToProps = null;\n\t      };\n\t\n\t      Connect.prototype.handleChange = function handleChange() {\n\t        if (!this.unsubscribe) {\n\t          return;\n\t        }\n\t\n\t        var storeState = this.store.getState();\n\t        var prevStoreState = this.state.storeState;\n\t        if (pure && prevStoreState === storeState) {\n\t          return;\n\t        }\n\t\n\t        if (pure && !this.doStatePropsDependOnOwnProps) {\n\t          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);\n\t          if (!haveStatePropsChanged) {\n\t            return;\n\t          }\n\t          if (haveStatePropsChanged === errorObject) {\n\t            this.statePropsPrecalculationError = errorObject.value;\n\t          }\n\t          this.haveStatePropsBeenPrecalculated = true;\n\t        }\n\t\n\t        this.hasStoreStateChanged = true;\n\t        this.setState({ storeState: storeState });\n\t      };\n\t\n\t      Connect.prototype.getWrappedInstance = function getWrappedInstance() {\n\t        (0, _invariant2[\"default\"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');\n\t\n\t        return this.refs.wrappedInstance;\n\t      };\n\t\n\t      Connect.prototype.render = function render() {\n\t        var haveOwnPropsChanged = this.haveOwnPropsChanged;\n\t        var hasStoreStateChanged = this.hasStoreStateChanged;\n\t        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;\n\t        var statePropsPrecalculationError = this.statePropsPrecalculationError;\n\t        var renderedElement = this.renderedElement;\n\t\n\t        this.haveOwnPropsChanged = false;\n\t        this.hasStoreStateChanged = false;\n\t        this.haveStatePropsBeenPrecalculated = false;\n\t        this.statePropsPrecalculationError = null;\n\t\n\t        if (statePropsPrecalculationError) {\n\t          throw statePropsPrecalculationError;\n\t        }\n\t\n\t        var shouldUpdateStateProps = true;\n\t        var shouldUpdateDispatchProps = true;\n\t        if (pure && renderedElement) {\n\t          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;\n\t          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;\n\t        }\n\t\n\t        var haveStatePropsChanged = false;\n\t        var haveDispatchPropsChanged = false;\n\t        if (haveStatePropsBeenPrecalculated) {\n\t          haveStatePropsChanged = true;\n\t        } else if (shouldUpdateStateProps) {\n\t          haveStatePropsChanged = this.updateStatePropsIfNeeded();\n\t        }\n\t        if (shouldUpdateDispatchProps) {\n\t          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();\n\t        }\n\t\n\t        var haveMergedPropsChanged = true;\n\t        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {\n\t          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();\n\t        } else {\n\t          haveMergedPropsChanged = false;\n\t        }\n\t\n\t        if (!haveMergedPropsChanged && renderedElement) {\n\t          return renderedElement;\n\t        }\n\t\n\t        if (withRef) {\n\t          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {\n\t            ref: 'wrappedInstance'\n\t          }));\n\t        } else {\n\t          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);\n\t        }\n\t\n\t        return this.renderedElement;\n\t      };\n\t\n\t      return Connect;\n\t    }(_react.Component);\n\t\n\t    Connect.displayName = connectDisplayName;\n\t    Connect.WrappedComponent = WrappedComponent;\n\t    Connect.contextTypes = {\n\t      store: _storeShape2[\"default\"]\n\t    };\n\t    Connect.propTypes = {\n\t      store: _storeShape2[\"default\"]\n\t    };\n\t\n\t    if (process.env.NODE_ENV !== 'production') {\n\t      Connect.prototype.componentWillUpdate = function componentWillUpdate() {\n\t        if (this.version === version) {\n\t          return;\n\t        }\n\t\n\t        // We are hot reloading!\n\t        this.version = version;\n\t        this.trySubscribe();\n\t        this.clearCache();\n\t      };\n\t    }\n\t\n\t    return (0, _hoistNonReactStatics2[\"default\"])(Connect, WrappedComponent);\n\t  };\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = shallowEqual;\n\tfunction shallowEqual(objA, objB) {\n\t  if (objA === objB) {\n\t    return true;\n\t  }\n\t\n\t  var keysA = Object.keys(objA);\n\t  var keysB = Object.keys(objB);\n\t\n\t  if (keysA.length !== keysB.length) {\n\t    return false;\n\t  }\n\t\n\t  // Test for A's keys different from B.\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  for (var i = 0; i < keysA.length; i++) {\n\t    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports[\"default\"] = wrapActionCreators;\n\t\n\tvar _redux = __webpack_require__(1);\n\t\n\tfunction wrapActionCreators(actionCreators) {\n\t  return function (dispatch) {\n\t    return (0, _redux.bindActionCreators)(actionCreators, dispatch);\n\t  };\n\t}\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015, Yahoo! Inc.\n\t * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n\t */\n\t'use strict';\n\t\n\tvar REACT_STATICS = {\n\t    childContextTypes: true,\n\t    contextTypes: true,\n\t    defaultProps: true,\n\t    displayName: true,\n\t    getDefaultProps: true,\n\t    mixins: true,\n\t    propTypes: true,\n\t    type: true\n\t};\n\t\n\tvar KNOWN_STATICS = {\n\t    name: true,\n\t    length: true,\n\t    prototype: true,\n\t    caller: true,\n\t    arguments: true,\n\t    arity: true\n\t};\n\t\n\tvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\t\n\tmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n\t    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\t        var keys = Object.getOwnPropertyNames(sourceComponent);\n\t\n\t        /* istanbul ignore else */\n\t        if (isGetOwnPropertySymbolsAvailable) {\n\t            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n\t        }\n\t\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n\t                try {\n\t                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n\t                } catch (error) {\n\t\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return targetComponent;\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * Copyright 2013-2015, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */\n\t\n\tvar invariant = function(condition, format, a, b, c, d, e, f) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    if (format === undefined) {\n\t      throw new Error('invariant requires an error message argument');\n\t    }\n\t  }\n\t\n\t  if (!condition) {\n\t    var error;\n\t    if (format === undefined) {\n\t      error = new Error(\n\t        'Minified exception occurred; use the non-minified dev environment ' +\n\t        'for the full error message and additional helpful warnings.'\n\t      );\n\t    } else {\n\t      var args = [a, b, c, d, e, f];\n\t      var argIndex = 0;\n\t      error = new Error(\n\t        format.replace(/%s/g, function() { return args[argIndex++]; })\n\t      );\n\t      error.name = 'Invariant Violation';\n\t    }\n\t\n\t    error.framesToPop = 1; // we don't care about invariant's own frame\n\t    throw error;\n\t  }\n\t};\n\t\n\tmodule.exports = invariant;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(17);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _CytoscapeRenderer = __webpack_require__(26);\n\t\n\tvar _CytoscapeRenderer2 = _interopRequireDefault(_CytoscapeRenderer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar CyNetworkViewer = function (_React$Component) {\n\t  _inherits(CyNetworkViewer, _React$Component);\n\t\n\t  function CyNetworkViewer() {\n\t    _classCallCheck(this, CyNetworkViewer);\n\t\n\t    return _possibleConstructorReturn(this, Object.getPrototypeOf(CyNetworkViewer).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(CyNetworkViewer, [{\n\t    key: 'componentWillMount',\n\t    value: function componentWillMount() {\n\t      this.props.downloadActions.downloadBegin();\n\t      this.props.downloadActions.download(this.props.networkUrl);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      var renderer;\n\t      if (!this.props.networkDownload.get('downloading')) {\n\t        var network = this.props.networks.get(this.props.networkUrl);\n\t        renderer = _react2.default.createElement(_CytoscapeRenderer2.default, {\n\t          networkData: network,\n\t          renderOptions: this.props.renderOptions\n\t        });\n\t      } else {\n\t        console.log(\"Network is downloading...\");\n\t        renderer = _react2.default.createElement('div', null);\n\t      }\n\t      return _react2.default.createElement(\n\t        'div',\n\t        { style: this.props.style },\n\t        renderer\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return CyNetworkViewer;\n\t}(_react2.default.Component);\n\t\n\tCyNetworkViewer.defaultProps = {\n\t  style: {\n\t    height: '100%',\n\t    width: '100%'\n\t  },\n\t  networkUrl: '',\n\t  renderOptions: {}\n\t};\n\texports.default = CyNetworkViewer;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(17);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _cytoscape = __webpack_require__(27);\n\t\n\tvar _cytoscape2 = _interopRequireDefault(_cytoscape);\n\t\n\tvar _VisualStyle = __webpack_require__(138);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// TODO: consolidate Cytoscape-dependent tags\n\tvar CYTOSCAPE_TAG = 'cy';\n\t\n\t// Original position will be used when layout is positions are available\n\tvar DEF_LAYOUT = 'preset';\n\t\n\t// Layout to be used when there is no layout information\n\tvar DEF_NO_LAYOUT = 'cose';\n\t\n\tvar CytoscapeRenderer = function (_React$Component) {\n\t  _inherits(CytoscapeRenderer, _React$Component);\n\t\n\t  function CytoscapeRenderer() {\n\t    _classCallCheck(this, CytoscapeRenderer);\n\t\n\t    return _possibleConstructorReturn(this, Object.getPrototypeOf(CytoscapeRenderer).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(CytoscapeRenderer, [{\n\t    key: \"updateCyjs\",\n\t    value: function updateCyjs() {\n\t      console.log('* Cytoscape.js is rendering new network...');\n\t\n\t      var network = this.props.networkData.toJS();\n\t\n\t      var visualStyle = _VisualStyle.DEF_VISUAL_STYLE;\n\t      var layout = DEF_LAYOUT;\n\t\n\t      if (visualStyle === undefined || visualStyle === null) {\n\t        visualStyle = _VisualStyle.DEF_VISUAL_STYLE;\n\t        layout = DEF_NO_LAYOUT;\n\t      }\n\t\n\t      this.cy = (0, _cytoscape2.default)(Object.assign(this.props.renderOptions, {\n\t        container: document.getElementById(CYTOSCAPE_TAG),\n\t        elements: network.elements,\n\t        style: visualStyle,\n\t        layout: {\n\t          name: layout\n\t        }\n\t\n\t      }));\n\t    }\n\t  }, {\n\t    key: \"componentDidMount\",\n\t    value: function componentDidMount() {\n\t      this.updateCyjs();\n\t    }\n\t  }, {\n\t    key: \"shouldComponentUpdate\",\n\t    value: function shouldComponentUpdate(nextProps, nextState) {\n\t      if (nextProps.networkData.equals(this.props.networkData)) {\n\t        console.log(\"Network unchanged, not updating cytoscapejs\");\n\t        return false;\n\t      }\n\t      console.log(\"Network changed, updating cytoscapejs\");\n\t      return true;\n\t    }\n\t  }, {\n\t    key: \"render\",\n\t    value: function render() {\n\t      return _react2.default.createElement(\n\t        \"div\",\n\t        { \"class\": \"network-widget\", style: { height: '100%', width: '100%' } },\n\t        _react2.default.createElement(\"div\", { id: CYTOSCAPE_TAG, style: { height: '100%', width: '100%' } })\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return CytoscapeRenderer;\n\t}(_react2.default.Component);\n\t\n\texports.default = CytoscapeRenderer;\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(28);\n\t\n\tvar window = __webpack_require__( 29 );\n\tvar is = __webpack_require__( 30 );\n\tvar Core = __webpack_require__( 31 );\n\tvar extension = __webpack_require__( 96 );\n\tvar registerJquery = __webpack_require__( 133 );\n\tvar Stylesheet = __webpack_require__( 134 );\n\tvar Thread = __webpack_require__( 103 );\n\tvar Fabric = __webpack_require__( 135 );\n\t\n\tvar cytoscape = function( options ){ // jshint ignore:line\n\t  // if no options specified, use default\n\t  if( options === undefined ){\n\t    options = {};\n\t  }\n\t\n\t  // create instance\n\t  if( is.plainObject( options ) ){\n\t    return new Core( options );\n\t  }\n\t\n\t  // allow for registration of extensions\n\t  else if( is.string( options ) ){\n\t    return extension.apply( extension, arguments );\n\t  }\n\t};\n\t\n\t// replaced by build system\n\tcytoscape.version = __webpack_require__(137);\n\t\n\t// try to register w/ jquery\n\tif( window && window.jQuery ){\n\t  registerJquery( window.jQuery, cytoscape );\n\t}\n\t\n\t// expose register api\n\tcytoscape.registerJquery = function( jQuery ){\n\t  registerJquery( jQuery, cytoscape );\n\t};\n\t\n\t// expose public apis (mostly for extensions)\n\tcytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n\tcytoscape.thread = cytoscape.Thread = Thread;\n\tcytoscape.fabric = cytoscape.Fabric = Fabric;\n\t\n\tmodule.exports = cytoscape;\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t\n\t/*!\n\t\n\tCytoscape.js {{VERSION}} (MIT licensed)\n\t\n\tCopyright (c) The Cytoscape Consortium\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy of\n\tthis software and associated documentation files (the “Software”), to deal in\n\tthe Software without restriction, including without limitation the rights to\n\tuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n\tof the Software, and to permit persons to whom the Software is furnished to do\n\tso, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n\t\n\t*/\n\t\n\t'use strict';\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\tmodule.exports = ( typeof window === 'undefined' ? null : window );\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar window = __webpack_require__( 29 );\n\tvar navigator = window ? window.navigator : null;\n\t\n\tvar typeofstr = typeof '';\n\tvar typeofobj = typeof {};\n\tvar typeoffn = typeof function(){};\n\tvar typeofhtmlele = typeof HTMLElement;\n\t\n\tvar instanceStr = function( obj ){\n\t  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;\n\t};\n\t\n\tvar is = {\n\t  defined: function( obj ){\n\t    return obj != null; // not undefined or null\n\t  },\n\t\n\t  string: function( obj ){\n\t    return obj != null && typeof obj == typeofstr;\n\t  },\n\t\n\t  fn: function( obj ){\n\t    return obj != null && typeof obj === typeoffn;\n\t  },\n\t\n\t  array: function( obj ){\n\t    return Array.isArray ? Array.isArray( obj ) : obj != null && obj instanceof Array;\n\t  },\n\t\n\t  plainObject: function( obj ){\n\t    return obj != null && typeof obj === typeofobj && !is.array( obj ) && obj.constructor === Object;\n\t  },\n\t\n\t  object: function( obj ){\n\t    return obj != null && typeof obj === typeofobj;\n\t  },\n\t\n\t  number: function( obj ){\n\t    return obj != null && typeof obj === typeof 1 && !isNaN( obj );\n\t  },\n\t\n\t  integer: function( obj ){\n\t    return is.number( obj ) && Math.floor( obj ) === obj;\n\t  },\n\t\n\t  bool: function( obj ){\n\t    return obj != null && typeof obj === typeof true;\n\t  },\n\t\n\t  htmlElement: function( obj ){\n\t    if( 'undefined' === typeofhtmlele ){\n\t      return undefined;\n\t    } else {\n\t      return null != obj && obj instanceof HTMLElement;\n\t    }\n\t  },\n\t\n\t  elementOrCollection: function( obj ){\n\t    return is.element( obj ) || is.collection( obj );\n\t  },\n\t\n\t  element: function( obj ){\n\t    return instanceStr( obj ) === 'collection' && obj._private.single;\n\t  },\n\t\n\t  collection: function( obj ){\n\t    return instanceStr( obj ) === 'collection' && !obj._private.single;\n\t  },\n\t\n\t  core: function( obj ){\n\t    return instanceStr( obj ) === 'core';\n\t  },\n\t\n\t  style: function( obj ){\n\t    return instanceStr( obj ) === 'style';\n\t  },\n\t\n\t  stylesheet: function( obj ){\n\t    return instanceStr( obj ) === 'stylesheet';\n\t  },\n\t\n\t  event: function( obj ){\n\t    return instanceStr( obj ) === 'event';\n\t  },\n\t\n\t  thread: function( obj ){\n\t    return instanceStr( obj ) === 'thread';\n\t  },\n\t\n\t  fabric: function( obj ){\n\t    return instanceStr( obj ) === 'fabric';\n\t  },\n\t\n\t  emptyString: function( obj ){\n\t    if( obj === undefined || obj === null ){ // null is empty\n\t      return true;\n\t    } else if( obj === '' || obj.match( /^\\s+$/ ) ){\n\t      return true; // empty string is empty\n\t    }\n\t\n\t    return false; // otherwise, we don't know what we've got\n\t  },\n\t\n\t  nonemptyString: function( obj ){\n\t    if( obj && is.string( obj ) && obj !== '' && !obj.match( /^\\s+$/ ) ){\n\t      return true;\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  domElement: function( obj ){\n\t    if( typeof HTMLElement === 'undefined' ){\n\t      return false; // we're not in a browser so it doesn't matter\n\t    } else {\n\t      return obj instanceof HTMLElement;\n\t    }\n\t  },\n\t\n\t  boundingBox: function( obj ){\n\t    return is.plainObject( obj ) &&\n\t      is.number( obj.x1 ) && is.number( obj.x2 ) &&\n\t      is.number( obj.y1 ) && is.number( obj.y2 )\n\t    ;\n\t  },\n\t\n\t  promise: function( obj ){\n\t    return is.object( obj ) && is.fn( obj.then );\n\t  },\n\t\n\t  touch: function(){\n\t    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );\n\t  },\n\t\n\t  gecko: function(){\n\t    return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);\n\t  },\n\t\n\t  webkit: function(){\n\t    return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);\n\t  },\n\t\n\t  chromium: function(){\n\t    return typeof chrome !== 'undefined';\n\t  },\n\t\n\t  khtml: function(){\n\t    return navigator && navigator.vendor.match( /kde/i ); // probably a better way to detect this...\n\t  },\n\t\n\t  khtmlEtc: function(){\n\t    return is.khtml() || is.webkit() || is.chromium();\n\t  },\n\t\n\t  ms: function(){\n\t    return navigator && navigator.userAgent.match( /msie|trident|edge/i ); // probably a better way to detect this...\n\t  },\n\t\n\t  windows: function(){\n\t    return navigator && navigator.appVersion.match( /Win/i );\n\t  },\n\t\n\t  mac: function(){\n\t    return navigator && navigator.appVersion.match( /Mac/i );\n\t  },\n\t\n\t  linux: function(){\n\t    return navigator && navigator.appVersion.match( /Linux/i );\n\t  },\n\t\n\t  unix: function(){\n\t    return navigator && navigator.appVersion.match( /X11/i );\n\t  }\n\t};\n\t\n\tmodule.exports = is;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar window = __webpack_require__( 29 );\n\tvar util = __webpack_require__( 32 );\n\tvar Collection = __webpack_require__( 40 );\n\tvar is = __webpack_require__( 30 );\n\tvar Promise = __webpack_require__( 58 );\n\tvar define = __webpack_require__( 56 );\n\t\n\tvar Core = function( opts ){\n\t  var cy = this;\n\t\n\t  opts = util.extend( {}, opts );\n\t\n\t  var container = opts.container;\n\t\n\t  // allow for passing a wrapped jquery object\n\t  // e.g. cytoscape({ container: $('#cy') })\n\t  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){\n\t    container = container[0];\n\t  }\n\t\n\t  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n\t  reg = reg || {};\n\t\n\t  if( reg && reg.cy ){\n\t    reg.cy.destroy();\n\t\n\t    reg = {}; // old instance => replace reg completely\n\t  }\n\t\n\t  var readies = reg.readies = reg.readies || [];\n\t\n\t  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy\n\t  reg.cy = cy;\n\t\n\t  var head = window !== undefined && container !== undefined && !opts.headless;\n\t  var options = opts;\n\t  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );\n\t  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );\n\t\n\t  var defVal = function( def, val, altVal ){\n\t    if( val !== undefined ){\n\t      return val;\n\t    } else if( altVal !== undefined ){\n\t      return altVal;\n\t    } else {\n\t      return def;\n\t    }\n\t  };\n\t\n\t  var _p = this._private = {\n\t    container: container, // html dom ele container\n\t    ready: false, // whether ready has been triggered\n\t    initrender: false, // has initrender has been triggered\n\t    options: options, // cached options\n\t    elements: new Collection( this ), // elements in the graph\n\t    listeners: [], // list of listeners\n\t    aniEles: new Collection( this ), // elements being animated\n\t    scratch: {}, // scratch object for core\n\t    layout: null,\n\t    renderer: null,\n\t    notificationsEnabled: true, // whether notifications are sent to the renderer\n\t    minZoom: 1e-50,\n\t    maxZoom: 1e50,\n\t    zoomingEnabled: defVal( true, options.zoomingEnabled ),\n\t    userZoomingEnabled: defVal( true, options.userZoomingEnabled ),\n\t    panningEnabled: defVal( true, options.panningEnabled ),\n\t    userPanningEnabled: defVal( true, options.userPanningEnabled ),\n\t    boxSelectionEnabled: defVal( true, options.boxSelectionEnabled ),\n\t    autolock: defVal( false, options.autolock, options.autolockNodes ),\n\t    autoungrabify: defVal( false, options.autoungrabify, options.autoungrabifyNodes ),\n\t    autounselectify: defVal( false, options.autounselectify ),\n\t    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n\t    zoom: is.number( options.zoom ) ? options.zoom : 1,\n\t    pan: {\n\t      x: is.plainObject( options.pan ) && is.number( options.pan.x ) ? options.pan.x : 0,\n\t      y: is.plainObject( options.pan ) && is.number( options.pan.y ) ? options.pan.y : 0\n\t    },\n\t    animation: { // object for currently-running animations\n\t      current: [],\n\t      queue: []\n\t    },\n\t    hasCompoundNodes: false\n\t  };\n\t\n\t  // set selection type\n\t  var selType = options.selectionType;\n\t  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){\n\t    // then set default\n\t\n\t    _p.selectionType = 'single';\n\t  } else {\n\t    _p.selectionType = selType;\n\t  }\n\t\n\t  // init zoom bounds\n\t  if( is.number( options.minZoom ) && is.number( options.maxZoom ) && options.minZoom < options.maxZoom ){\n\t    _p.minZoom = options.minZoom;\n\t    _p.maxZoom = options.maxZoom;\n\t  } else if( is.number( options.minZoom ) && options.maxZoom === undefined ){\n\t    _p.minZoom = options.minZoom;\n\t  } else if( is.number( options.maxZoom ) && options.minZoom === undefined ){\n\t    _p.maxZoom = options.maxZoom;\n\t  }\n\t\n\t  var loadExtData = function( extData, next ){\n\t    var anyIsPromise = extData.some( is.promise );\n\t\n\t    if( anyIsPromise ){\n\t      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init\n\t    } else {\n\t      next( extData ); // exec synchronously for convenience\n\t    }\n\t  };\n\t\n\t  // create the renderer\n\t  cy.initRenderer( util.extend( {\n\t    hideEdgesOnViewport: options.hideEdgesOnViewport,\n\t    textureOnViewport: options.textureOnViewport,\n\t    wheelSensitivity: is.number( options.wheelSensitivity ) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,\n\t    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default\n\t    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,\n\t    pixelRatio: is.number( options.pixelRatio ) && options.pixelRatio > 0 ? options.pixelRatio : undefined,\n\t    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,\n\t    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold\n\t  }, options.renderer ) );\n\t\n\t  loadExtData([ options.style, options.elements ], function( thens ){\n\t    var initStyle = thens[0];\n\t    var initEles = thens[1];\n\t\n\t    // init style\n\t    if( _p.styleEnabled ){\n\t      cy.setStyle( initStyle );\n\t    }\n\t\n\t    // trigger the passed function for the `initrender` event\n\t    if( options.initrender ){\n\t      cy.on( 'initrender', options.initrender );\n\t      cy.on( 'initrender', function(){\n\t        _p.initrender = true;\n\t      } );\n\t    }\n\t\n\t    // initial load\n\t    cy.load( initEles, function(){ // onready\n\t      cy.startAnimationLoop();\n\t      _p.ready = true;\n\t\n\t      // if a ready callback is specified as an option, the bind it\n\t      if( is.fn( options.ready ) ){\n\t        cy.on( 'ready', options.ready );\n\t      }\n\t\n\t      // bind all the ready handlers registered before creating this instance\n\t      for( var i = 0; i < readies.length; i++ ){\n\t        var fn = readies[ i ];\n\t        cy.on( 'ready', fn );\n\t      }\n\t      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\t\n\t      cy.trigger( 'ready' );\n\t    }, options.done );\n\t\n\t  } );\n\t};\n\t\n\tvar corefn = Core.prototype; // short alias\n\t\n\tutil.extend( corefn, {\n\t  instanceString: function(){\n\t    return 'core';\n\t  },\n\t\n\t  isReady: function(){\n\t    return this._private.ready;\n\t  },\n\t\n\t  ready: function( fn ){\n\t    if( this.isReady() ){\n\t      this.trigger( 'ready', [], fn ); // just calls fn as though triggered via ready event\n\t    } else {\n\t      this.on( 'ready', fn );\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  initrender: function(){\n\t    return this._private.initrender;\n\t  },\n\t\n\t  destroy: function(){\n\t    var cy = this;\n\t\n\t    cy.stopAnimationLoop();\n\t\n\t    cy.notify( { type: 'destroy' } ); // destroy the renderer\n\t\n\t    var domEle = cy.container();\n\t    if( domEle ){\n\t      domEle._cyreg = null;\n\t\n\t      while( domEle.childNodes.length > 0 ){\n\t        domEle.removeChild( domEle.childNodes[0] );\n\t      }\n\t    }\n\t\n\t    return cy;\n\t  },\n\t\n\t  hasElementWithId: function( id ){\n\t    return this._private.elements.hasElementWithId( id );\n\t  },\n\t\n\t  getElementById: function( id ){\n\t    return this._private.elements.getElementById( id );\n\t  },\n\t\n\t  selectionType: function(){\n\t    return this._private.selectionType;\n\t  },\n\t\n\t  hasCompoundNodes: function(){\n\t    return this._private.hasCompoundNodes;\n\t  },\n\t\n\t  headless: function(){\n\t    return this._private.options.renderer.name === 'null';\n\t  },\n\t\n\t  styleEnabled: function(){\n\t    return this._private.styleEnabled;\n\t  },\n\t\n\t  addToPool: function( eles ){\n\t    this._private.elements.merge( eles );\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  removeFromPool: function( eles ){\n\t    this._private.elements.unmerge( eles );\n\t\n\t    return this;\n\t  },\n\t\n\t  container: function(){\n\t    return this._private.container;\n\t  },\n\t\n\t  options: function(){\n\t    return util.copy( this._private.options );\n\t  },\n\t\n\t  json: function( obj ){\n\t    var cy = this;\n\t    var _p = cy._private;\n\t    var eles = cy.mutableElements();\n\t\n\t    if( is.plainObject( obj ) ){ // set\n\t\n\t      cy.startBatch();\n\t\n\t      if( obj.elements ){\n\t        var idInJson = {};\n\t\n\t        var updateEles = function( jsons, gr ){\n\t          for( var i = 0; i < jsons.length; i++ ){\n\t            var json = jsons[ i ];\n\t            var id = json.data.id;\n\t            var ele = cy.getElementById( id );\n\t\n\t            idInJson[ id ] = true;\n\t\n\t            if( ele.length !== 0 ){ // existing element should be updated\n\t              ele.json( json );\n\t            } else { // otherwise should be added\n\t              if( gr ){\n\t                cy.add( util.extend( { group: gr }, json ) );\n\t              } else {\n\t                cy.add( json );\n\t              }\n\t            }\n\t          }\n\t        };\n\t\n\t        if( is.array( obj.elements ) ){ // elements: []\n\t          updateEles( obj.elements );\n\t\n\t        } else { // elements: { nodes: [], edges: [] }\n\t          var grs = [ 'nodes', 'edges' ];\n\t          for( var i = 0; i < grs.length; i++ ){\n\t            var gr = grs[ i ];\n\t            var elements = obj.elements[ gr ];\n\t\n\t            if( is.array( elements ) ){\n\t              updateEles( elements, gr );\n\t            }\n\t          }\n\t        }\n\t\n\t        // elements not specified in json should be removed\n\t        eles.stdFilter( function( ele ){\n\t          return !idInJson[ ele.id() ];\n\t        } ).remove();\n\t      }\n\t\n\t      if( obj.style ){\n\t        cy.style( obj.style );\n\t      }\n\t\n\t      if( obj.zoom != null && obj.zoom !== _p.zoom ){\n\t        cy.zoom( obj.zoom );\n\t      }\n\t\n\t      if( obj.pan ){\n\t        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){\n\t          cy.pan( obj.pan );\n\t        }\n\t      }\n\t\n\t      var fields = [\n\t        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',\n\t        'panningEnabled', 'userPanningEnabled',\n\t        'boxSelectionEnabled',\n\t        'autolock', 'autoungrabify', 'autounselectify'\n\t      ];\n\t\n\t      for( var i = 0; i < fields.length; i++ ){\n\t        var f = fields[ i ];\n\t\n\t        if( obj[ f ] != null ){\n\t          cy[ f ]( obj[ f ] );\n\t        }\n\t      }\n\t\n\t      cy.endBatch();\n\t\n\t      return this; // chaining\n\t    } else if( obj === undefined ){ // get\n\t      var json = {};\n\t\n\t      json.elements = {};\n\t      eles.forEach( function( ele ){\n\t        var group = ele.group();\n\t\n\t        if( !json.elements[ group ] ){\n\t          json.elements[ group ] = [];\n\t        }\n\t\n\t        json.elements[ group ].push( ele.json() );\n\t      } );\n\t\n\t      if( this._private.styleEnabled ){\n\t        json.style = cy.style().json();\n\t      }\n\t\n\t      json.zoomingEnabled = cy._private.zoomingEnabled;\n\t      json.userZoomingEnabled = cy._private.userZoomingEnabled;\n\t      json.zoom = cy._private.zoom;\n\t      json.minZoom = cy._private.minZoom;\n\t      json.maxZoom = cy._private.maxZoom;\n\t      json.panningEnabled = cy._private.panningEnabled;\n\t      json.userPanningEnabled = cy._private.userPanningEnabled;\n\t      json.pan = util.copy( cy._private.pan );\n\t      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;\n\t      json.renderer = util.copy( cy._private.options.renderer );\n\t      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;\n\t      json.textureOnViewport = cy._private.options.textureOnViewport;\n\t      json.wheelSensitivity = cy._private.options.wheelSensitivity;\n\t      json.motionBlur = cy._private.options.motionBlur;\n\t\n\t      return json;\n\t    }\n\t  },\n\t\n\t  scratch: define.data( {\n\t    field: 'scratch',\n\t    bindingEvent: 'scratch',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'scratch',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: true\n\t  } ),\n\t\n\t  removeScratch: define.removeData( {\n\t    field: 'scratch',\n\t    event: 'scratch',\n\t    triggerFnName: 'trigger',\n\t    triggerEvent: true\n\t  } )\n\t\n\t} );\n\t\n\t[\n\t  __webpack_require__( 77 ),\n\t  __webpack_require__( 78 ),\n\t  __webpack_require__( 79 ),\n\t  __webpack_require__( 80 ),\n\t  __webpack_require__( 81 ),\n\t  __webpack_require__( 82 ),\n\t  __webpack_require__( 83 ),\n\t  __webpack_require__( 84 ),\n\t  __webpack_require__( 85 ),\n\t  __webpack_require__( 95 )\n\t].forEach( function( props ){\n\t  util.extend( corefn, props );\n\t} );\n\t\n\tmodule.exports = Core;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar util = {\n\t\n\t  trueify: function(){ return true; },\n\t\n\t  falsify: function(){ return false; },\n\t\n\t  zeroify: function(){ return 0; },\n\t\n\t  noop: function(){},\n\t\n\t  /* jshint ignore:start */\n\t  error: function( msg ){\n\t    if( console.error ){\n\t      console.error.apply( console, arguments );\n\t\n\t      if( console.trace ){ console.trace(); }\n\t    } else {\n\t      console.log.apply( console, arguments );\n\t\n\t      if( console.trace ){ console.trace(); }\n\t    }\n\t  },\n\t  /* jshint ignore:end */\n\t\n\t  clone: function( obj ){\n\t    return this.extend( {}, obj );\n\t  },\n\t\n\t  // gets a shallow copy of the argument\n\t  copy: function( obj ){\n\t    if( obj == null ){\n\t      return obj;\n\t    } if( is.array( obj ) ){\n\t      return obj.slice();\n\t    } else if( is.plainObject( obj ) ){\n\t      return this.clone( obj );\n\t    } else {\n\t      return obj;\n\t    }\n\t  },\n\t\n\t  uuid: function(\n\t      a,b                // placeholders\n\t  ){\n\t      for(               // loop :)\n\t          b=a='';        // b - result , a - numeric variable\n\t          a++<36;        //\n\t          b+=a*51&52  // if \"a\" is not 9 or 14 or 19 or 24\n\t                      ?  //  return a random number or 4\n\t             (\n\t               a^15      // if \"a\" is not 15\n\t                  ?      // genetate a random number from 0 to 15\n\t               8^Math.random()*\n\t               (a^20?16:4)  // unless \"a\" is 20, in which case a random number from 8 to 11\n\t                  :\n\t               4            //  otherwise 4\n\t               ).toString(16)\n\t                      :\n\t             '-'            //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n\t          );\n\t      return b;\n\t  }\n\t\n\t};\n\t\n\tutil.makeBoundingBox = math.makeBoundingBox.bind( math );\n\t\n\tutil._staticEmptyObject = {};\n\t\n\tutil.staticEmptyObject = function(){\n\t  return util._staticEmptyObject;\n\t};\n\t\n\tutil.extend = Object.assign != null ? Object.assign : function( tgt ){\n\t  var args = arguments;\n\t\n\t  for( var i = 1; i < args.length; i++ ){\n\t    var obj = args[ i ];\n\t\n\t    if( !obj ){ continue; }\n\t\n\t    var keys = Object.keys( obj );\n\t\n\t    for( var j = 0; j < keys.length; j++ ){\n\t      var k = keys[j];\n\t\n\t      tgt[ k ] = obj[ k ];\n\t    }\n\t  }\n\t\n\t  return tgt;\n\t};\n\t\n\tutil.default = function( val, def ){\n\t  if( val === undefined ){\n\t    return def;\n\t  } else {\n\t    return val;\n\t  }\n\t};\n\t\n\tutil.removeFromArray = function( arr, ele, manyCopies ){\n\t  for( var i = arr.length; i >= 0; i-- ){\n\t    if( arr[i] === ele ){\n\t      arr.splice( i, 1 );\n\t\n\t      if( !manyCopies ){ break; }\n\t    }\n\t  }\n\t};\n\t\n\tutil.clearArray = function( arr ){\n\t  arr.splice( 0, arr.length );\n\t};\n\t\n\tutil.getPrefixedProperty = function( obj, propName, prefix ){\n\t  if( prefix ){\n\t    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth\n\t  }\n\t\n\t  return obj[ propName ];\n\t};\n\t\n\tutil.setPrefixedProperty = function( obj, propName, prefix, value ){\n\t  if( prefix ){\n\t    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth\n\t  }\n\t\n\t  obj[ propName ] = value;\n\t};\n\t\n\t[\n\t  __webpack_require__( 34 ),\n\t  __webpack_require__( 35 ),\n\t  { memoize: __webpack_require__( 36 ) },\n\t  __webpack_require__( 37 ),\n\t  __webpack_require__( 38 ),\n\t  __webpack_require__( 39 )\n\t].forEach( function( req ){\n\t  util.extend( util, req );\n\t} );\n\t\n\tmodule.exports = util;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar math = {};\n\t\n\tmath.arePositionsSame = function( p1, p2 ){\n\t  return p1.x === p2.x && p1.y === p2.y;\n\t};\n\t\n\tmath.copyPosition = function( p ){\n\t  return { x: p.x, y: p.y };\n\t};\n\t\n\tmath.array2point = function( arr ){\n\t  return {\n\t    x: arr[0],\n\t    y: arr[1]\n\t  };\n\t};\n\t\n\tmath.deg2rad = function( deg ){\n\t  return Math.PI * deg / 180;\n\t};\n\t\n\tmath.log2 = Math.log2 || function( n ){\n\t  return Math.log( n ) / Math.log( 2 );\n\t};\n\t\n\tmath.signum = function( x ){\n\t  if( x > 0 ){\n\t    return 1;\n\t  } else if( x < 0 ){\n\t    return -1;\n\t  } else {\n\t    return 0;\n\t  }\n\t};\n\t\n\tmath.dist = function( p1, p2 ){\n\t  return Math.sqrt( math.sqdist( p1, p2 ) );\n\t};\n\t\n\tmath.sqdist = function( p1, p2 ){\n\t  var dx = p2.x - p1.x;\n\t  var dy = p2.y - p1.y;\n\t\n\t  return dx * dx + dy * dy;\n\t};\n\t\n\t// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves\n\tmath.qbezierAt = function( p0, p1, p2, t ){\n\t  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n\t};\n\t\n\tmath.qbezierPtAt = function( p0, p1, p2, t ){\n\t  return {\n\t    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),\n\t    y: math.qbezierAt( p0.y, p1.y, p2.y, t )\n\t  };\n\t};\n\t\n\tmath.lineAt = function( p0, p1, t, d ){\n\t  var vec = {\n\t    x: p1.x - p0.x,\n\t    y: p1.y - p0.y\n\t  };\n\t\n\t  var vecDist = math.dist( p0, p1 );\n\t\n\t  var normVec = {\n\t    x: vec.x / vecDist,\n\t    y: vec.y / vecDist\n\t  };\n\t\n\t  t = t == null ? 0 : t;\n\t\n\t  var d = d != null ? d : t * vecDist;\n\t\n\t  return {\n\t    x: p0.x + normVec.x * d,\n\t    y: p0.y + normVec.y * d\n\t  };\n\t};\n\t\n\tmath.lineAtDist = function( p0, p1, d ){\n\t  return math.lineAt( p0, p1, undefined, d );\n\t};\n\t\n\t// get angle at A via cosine law\n\tmath.triangleAngle = function( A, B, C ){\n\t  var a = math.dist( B, C );\n\t  var b = math.dist( A, C );\n\t  var c = math.dist( A, B );\n\t\n\t  return Math.acos( (a*a + b*b - c*c)/(2*a*b) );\n\t};\n\t\n\tmath.bound = function( min, val, max ){\n\t  return Math.max( min, Math.min( max, val ) );\n\t};\n\t\n\t// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n\tmath.makeBoundingBox = function( bb ){\n\t  if( bb == null ){\n\t    return {\n\t      x1: Infinity,\n\t      y1: Infinity,\n\t      x2: -Infinity,\n\t      y2: -Infinity,\n\t      w: 0,\n\t      h: 0\n\t    };\n\t  } else if( bb.x1 != null && bb.y1 != null ){\n\t    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){\n\t      return {\n\t        x1: bb.x1,\n\t        y1: bb.y1,\n\t        x2: bb.x2,\n\t        y2: bb.y2,\n\t        w: bb.x2 - bb.x1,\n\t        h: bb.y2 - bb.y1\n\t      };\n\t    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){\n\t      return {\n\t        x1: bb.x1,\n\t        y1: bb.y1,\n\t        x2: bb.x1 + bb.w,\n\t        y2: bb.y1 + bb.h,\n\t        w: bb.w,\n\t        h: bb.h\n\t      };\n\t    }\n\t  }\n\t};\n\t\n\tmath.updateBoundingBox = function( bb1, bb2 ){\n\t  // update bb1 with bb2 bounds\n\t\n\t  bb1.x1 = Math.min( bb1.x1, bb2.x1 );\n\t  bb1.x2 = Math.max( bb1.x2, bb2.x2 );\n\t  bb1.w = bb1.x2 - bb1.x1;\n\t\n\t  bb1.y1 = Math.min( bb1.y1, bb2.y1 );\n\t  bb1.y2 = Math.max( bb1.y2, bb2.y2 );\n\t  bb1.h = bb1.y2 - bb1.y1;\n\t};\n\t\n\tmath.expandBoundingBox = function( bb, padding ){\n\t  bb.x1 -= padding;\n\t  bb.x2 += padding;\n\t  bb.y1 -= padding;\n\t  bb.y2 += padding;\n\t  bb.w = bb.x2 - bb.x1;\n\t  bb.h = bb.y2 - bb.y1;\n\t\n\t  return bb;\n\t};\n\t\n\tmath.boundingBoxesIntersect = function( bb1, bb2 ){\n\t  // case: one bb to right of other\n\t  if( bb1.x1 > bb2.x2 ){ return false; }\n\t  if( bb2.x1 > bb1.x2 ){ return false; }\n\t\n\t  // case: one bb to left of other\n\t  if( bb1.x2 < bb2.x1 ){ return false; }\n\t  if( bb2.x2 < bb1.x1 ){ return false; }\n\t\n\t  // case: one bb above other\n\t  if( bb1.y2 < bb2.y1 ){ return false; }\n\t  if( bb2.y2 < bb1.y1 ){ return false; }\n\t\n\t  // case: one bb below other\n\t  if( bb1.y1 > bb2.y2 ){ return false; }\n\t  if( bb2.y1 > bb1.y2 ){ return false; }\n\t\n\t  // otherwise, must have some overlap\n\t  return true;\n\t};\n\t\n\tmath.inBoundingBox = function( bb, x, y ){\n\t  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n\t};\n\t\n\tmath.pointInBoundingBox = function( bb, pt ){\n\t  return this.inBoundingBox( bb, pt.x, pt.y );\n\t};\n\t\n\tmath.boundingBoxInBoundingBox = function( bb1, bb2 ){\n\t  return (\n\t       math.inBoundingBox( bb1, bb2.x1, bb2.y1 )\n\t    && math.inBoundingBox( bb1, bb2.x2, bb2.y2 )\n\t  );\n\t};\n\t\n\tmath.roundRectangleIntersectLine = function(\n\t  x, y, nodeX, nodeY, width, height, padding ){\n\t\n\t  var cornerRadius = this.getRoundRectangleRadius( width, height );\n\t\n\t  var halfWidth = width / 2;\n\t  var halfHeight = height / 2;\n\t\n\t  // Check intersections with straight line segments\n\t  var straightLineIntersections;\n\t\n\t  // Top segment, left to right\n\t  {\n\t    var topStartX = nodeX - halfWidth + cornerRadius - padding;\n\t    var topStartY = nodeY - halfHeight - padding;\n\t    var topEndX = nodeX + halfWidth - cornerRadius + padding;\n\t    var topEndY = topStartY;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(\n\t      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false );\n\t\n\t    if( straightLineIntersections.length > 0 ){\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Right segment, top to bottom\n\t  {\n\t    var rightStartX = nodeX + halfWidth + padding;\n\t    var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n\t    var rightEndX = rightStartX;\n\t    var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(\n\t      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false );\n\t\n\t    if( straightLineIntersections.length > 0 ){\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Bottom segment, left to right\n\t  {\n\t    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n\t    var bottomStartY = nodeY + halfHeight + padding;\n\t    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n\t    var bottomEndY = bottomStartY;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(\n\t      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false );\n\t\n\t    if( straightLineIntersections.length > 0 ){\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Left segment, top to bottom\n\t  {\n\t    var leftStartX = nodeX - halfWidth - padding;\n\t    var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n\t    var leftEndX = leftStartX;\n\t    var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n\t\n\t    straightLineIntersections = this.finiteLinesIntersect(\n\t      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false );\n\t\n\t    if( straightLineIntersections.length > 0 ){\n\t      return straightLineIntersections;\n\t    }\n\t  }\n\t\n\t  // Check intersections with arc segments\n\t  var arcIntersections;\n\t\n\t  // Top Left\n\t  {\n\t    var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n\t    var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(\n\t      x, y, nodeX, nodeY,\n\t      topLeftCenterX, topLeftCenterY, cornerRadius + padding );\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if( arcIntersections.length > 0\n\t      && arcIntersections[0] <= topLeftCenterX\n\t      && arcIntersections[1] <= topLeftCenterY ){\n\t      return [ arcIntersections[0], arcIntersections[1] ];\n\t    }\n\t  }\n\t\n\t  // Top Right\n\t  {\n\t    var topRightCenterX = nodeX + halfWidth - cornerRadius;\n\t    var topRightCenterY = nodeY - halfHeight + cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(\n\t      x, y, nodeX, nodeY,\n\t      topRightCenterX, topRightCenterY, cornerRadius + padding );\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if( arcIntersections.length > 0\n\t      && arcIntersections[0] >= topRightCenterX\n\t      && arcIntersections[1] <= topRightCenterY ){\n\t      return [ arcIntersections[0], arcIntersections[1] ];\n\t    }\n\t  }\n\t\n\t  // Bottom Right\n\t  {\n\t    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n\t    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(\n\t      x, y, nodeX, nodeY,\n\t      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding );\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if( arcIntersections.length > 0\n\t      && arcIntersections[0] >= bottomRightCenterX\n\t      && arcIntersections[1] >= bottomRightCenterY ){\n\t      return [ arcIntersections[0], arcIntersections[1] ];\n\t    }\n\t  }\n\t\n\t  // Bottom Left\n\t  {\n\t    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n\t    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n\t    arcIntersections = this.intersectLineCircle(\n\t      x, y, nodeX, nodeY,\n\t      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding );\n\t\n\t    // Ensure the intersection is on the desired quarter of the circle\n\t    if( arcIntersections.length > 0\n\t      && arcIntersections[0] <= bottomLeftCenterX\n\t      && arcIntersections[1] >= bottomLeftCenterY ){\n\t      return [ arcIntersections[0], arcIntersections[1] ];\n\t    }\n\t  }\n\t\n\t  return []; // if nothing\n\t};\n\t\n\tmath.inLineVicinity = function( x, y, lx1, ly1, lx2, ly2, tolerance ){\n\t  var t = tolerance;\n\t\n\t  var x1 = Math.min( lx1, lx2 );\n\t  var x2 = Math.max( lx1, lx2 );\n\t  var y1 = Math.min( ly1, ly2 );\n\t  var y2 = Math.max( ly1, ly2 );\n\t\n\t  return x1 - t <= x && x <= x2 + t\n\t    && y1 - t <= y && y <= y2 + t;\n\t};\n\t\n\tmath.inBezierVicinity = function(\n\t  x, y, x1, y1, x2, y2, x3, y3, tolerance ){\n\t\n\t  var bb = {\n\t    x1: Math.min( x1, x3, x2 ) - tolerance,\n\t    x2: Math.max( x1, x3, x2 ) + tolerance,\n\t    y1: Math.min( y1, y3, y2 ) - tolerance,\n\t    y2: Math.max( y1, y3, y2 ) + tolerance\n\t  };\n\t\n\t  // if outside the rough bounding box for the bezier, then it can't be a hit\n\t  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){\n\t    // console.log('bezier out of rough bb')\n\t    return false;\n\t  } else {\n\t    // console.log('do more expensive check');\n\t    return true;\n\t  }\n\t\n\t};\n\t\n\tmath.solveCubic = function( a, b, c, d, result ){\n\t\n\t  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n\t  // r is the real component, i is the imaginary component\n\t\n\t  // An implementation of the Cardano method from the year 1545\n\t  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n\t\n\t  b /= a;\n\t  c /= a;\n\t  d /= a;\n\t\n\t  var discriminant, q, r, dum1, s, t, term1, r13;\n\t\n\t  q = (3.0 * c - (b * b)) / 9.0;\n\t  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n\t  r /= 54.0;\n\t\n\t  discriminant = q * q * q + r * r;\n\t  result[1] = 0;\n\t  term1 = (b / 3.0);\n\t\n\t  if( discriminant > 0 ){\n\t    s = r + Math.sqrt( discriminant );\n\t    s = ((s < 0) ? -Math.pow( -s, (1.0 / 3.0) ) : Math.pow( s, (1.0 / 3.0) ));\n\t    t = r - Math.sqrt( discriminant );\n\t    t = ((t < 0) ? -Math.pow( -t, (1.0 / 3.0) ) : Math.pow( t, (1.0 / 3.0) ));\n\t    result[0] = -term1 + s + t;\n\t    term1 += (s + t) / 2.0;\n\t    result[4] = result[2] = -term1;\n\t    term1 = Math.sqrt( 3.0 ) * (-t + s) / 2;\n\t    result[3] = term1;\n\t    result[5] = -term1;\n\t    return;\n\t  }\n\t\n\t  result[5] = result[3] = 0;\n\t\n\t  if( discriminant === 0 ){\n\t    r13 = ((r < 0) ? -Math.pow( -r, (1.0 / 3.0) ) : Math.pow( r, (1.0 / 3.0) ));\n\t    result[0] = -term1 + 2.0 * r13;\n\t    result[4] = result[2] = -(r13 + term1);\n\t    return;\n\t  }\n\t\n\t  q = -q;\n\t  dum1 = q * q * q;\n\t  dum1 = Math.acos( r / Math.sqrt( dum1 ) );\n\t  r13 = 2.0 * Math.sqrt( q );\n\t  result[0] = -term1 + r13 * Math.cos( dum1 / 3.0 );\n\t  result[2] = -term1 + r13 * Math.cos( (dum1 + 2.0 * Math.PI) / 3.0 );\n\t  result[4] = -term1 + r13 * Math.cos( (dum1 + 4.0 * Math.PI) / 3.0 );\n\t\n\t  return;\n\t};\n\t\n\tmath.sqdistToQuadraticBezier = function(\n\t  x, y, x1, y1, x2, y2, x3, y3 ){\n\t\n\t  // Find minimum distance by using the minimum of the distance\n\t  // function between the given point and the curve\n\t\n\t  // This gives the coefficients of the resulting cubic equation\n\t  // whose roots tell us where a possible minimum is\n\t  // (Coefficients are divided by 4)\n\t\n\t  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3\n\t    + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n\t\n\t  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3\n\t    + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n\t\n\t  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x\n\t    + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n\t\n\t  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x\n\t    + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n\t\n\t  // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\t\n\t  var roots = [];\n\t\n\t  // Use the cubic solving algorithm\n\t  this.solveCubic( a, b, c, d, roots );\n\t\n\t  var zeroThreshold = 0.0000001;\n\t\n\t  var params = [];\n\t\n\t  for( var index = 0; index < 6; index += 2 ){\n\t    if( Math.abs( roots[ index + 1] ) < zeroThreshold\n\t        && roots[ index ] >= 0\n\t        && roots[ index ] <= 1.0 ){\n\t      params.push( roots[ index ] );\n\t    }\n\t  }\n\t\n\t  params.push( 1.0 );\n\t  params.push( 0.0 );\n\t\n\t  var minDistanceSquared = -1;\n\t  var closestParam;\n\t\n\t  var curX, curY, distSquared;\n\t  for( var i = 0; i < params.length; i++ ){\n\t    curX = Math.pow( 1.0 - params[ i ], 2.0 ) * x1\n\t      + 2.0 * (1 - params[ i ]) * params[ i ] * x2\n\t      + params[ i ] * params[ i ] * x3;\n\t\n\t    curY = Math.pow( 1 - params[ i ], 2.0 ) * y1\n\t      + 2 * (1.0 - params[ i ]) * params[ i ] * y2\n\t      + params[ i ] * params[ i ] * y3;\n\t\n\t    distSquared = Math.pow( curX - x, 2 ) + Math.pow( curY - y, 2 );\n\t    // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n\t    if( minDistanceSquared >= 0 ){\n\t      if( distSquared < minDistanceSquared ){\n\t        minDistanceSquared = distSquared;\n\t        closestParam = params[ i ];\n\t      }\n\t    } else {\n\t      minDistanceSquared = distSquared;\n\t      closestParam = params[ i ];\n\t    }\n\t  }\n\t\n\t  return minDistanceSquared;\n\t};\n\t\n\tmath.sqdistToFiniteLine = function( x, y, x1, y1, x2, y2 ){\n\t  var offset = [ x - x1, y - y1 ];\n\t  var line = [ x2 - x1, y2 - y1 ];\n\t\n\t  var lineSq = line[0] * line[0] + line[1] * line[1];\n\t  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n\t\n\t  var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n\t  var adjSq = dotProduct * dotProduct / lineSq;\n\t\n\t  if( dotProduct < 0 ){\n\t    return hypSq;\n\t  }\n\t\n\t  if( adjSq > lineSq ){\n\t    return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n\t  }\n\t\n\t  return hypSq - adjSq;\n\t};\n\t\n\tmath.pointInsidePolygonPoints = function( x, y, points ){\n\t  var x1, y1, x2, y2;\n\t  var y3;\n\t\n\t  // Intersect with vertical line through (x, y)\n\t  var up = 0;\n\t  var down = 0;\n\t  for( var i = 0; i < points.length / 2; i++ ){\n\t\n\t    x1 = points[ i * 2];\n\t    y1 = points[ i * 2 + 1];\n\t\n\t    if( i + 1 < points.length / 2 ){\n\t      x2 = points[ (i + 1) * 2];\n\t      y2 = points[ (i + 1) * 2 + 1];\n\t    } else {\n\t      x2 = points[ (i + 1 - points.length / 2) * 2];\n\t      y2 = points[ (i + 1 - points.length / 2) * 2 + 1];\n\t    }\n\t\n\t    if( x1 == x && x2 == x ){\n\t\n\t    } else if( (x1 >= x && x >= x2)\n\t      || (x1 <= x && x <= x2) ){\n\t\n\t      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n\t\n\t      if( y3 > y ){\n\t        up++;\n\t      }\n\t\n\t      if( y3 < y ){\n\t        down++;\n\t      }\n\t\n\t    } else {\n\t      continue;\n\t    }\n\t\n\t  }\n\t\n\t  if( up % 2 === 0 ){\n\t    return false;\n\t  } else {\n\t    return true;\n\t  }\n\t};\n\t\n\tmath.pointInsidePolygon = function(\n\t  x, y, basePoints, centerX, centerY, width, height, direction, padding ){\n\t\n\t  //var direction = arguments[6];\n\t  var transformedPoints = new Array( basePoints.length );\n\t\n\t  // Gives negative angle\n\t  var angle;\n\t\n\t  if( direction[0] != null ){\n\t    angle = Math.atan( direction[1] / direction[0] );\n\t\n\t    if( direction[0] < 0 ){\n\t      angle = angle + Math.PI / 2;\n\t    } else {\n\t      angle = -angle - Math.PI / 2;\n\t    }\n\t  } else {\n\t    angle = direction;\n\t  }\n\t\n\t  var cos = Math.cos( -angle );\n\t  var sin = Math.sin( -angle );\n\t\n\t  //    console.log(\"base: \" + basePoints);\n\t  for( var i = 0; i < transformedPoints.length / 2; i++ ){\n\t    transformedPoints[ i * 2] =\n\t      width / 2 * (basePoints[ i * 2] * cos\n\t        - basePoints[ i * 2 + 1] * sin);\n\t\n\t    transformedPoints[ i * 2 + 1] =\n\t      height / 2 * (basePoints[ i * 2 + 1] * cos\n\t        + basePoints[ i * 2] * sin);\n\t\n\t    transformedPoints[ i * 2] += centerX;\n\t    transformedPoints[ i * 2 + 1] += centerY;\n\t  }\n\t\n\t  var points;\n\t\n\t  if( padding > 0 ){\n\t    var expandedLineSet = this.expandPolygon(\n\t      transformedPoints,\n\t      -padding );\n\t\n\t    points = this.joinLines( expandedLineSet );\n\t  } else {\n\t    points = transformedPoints;\n\t  }\n\t\n\t  return math.pointInsidePolygonPoints( x, y, points );\n\t};\n\t\n\tmath.joinLines = function( lineSet ){\n\t\n\t  var vertices = new Array( lineSet.length / 2 );\n\t\n\t  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n\t  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n\t\n\t  for( var i = 0; i < lineSet.length / 4; i++ ){\n\t    currentLineStartX = lineSet[ i * 4];\n\t    currentLineStartY = lineSet[ i * 4 + 1];\n\t    currentLineEndX = lineSet[ i * 4 + 2];\n\t    currentLineEndY = lineSet[ i * 4 + 3];\n\t\n\t    if( i < lineSet.length / 4 - 1 ){\n\t      nextLineStartX = lineSet[ (i + 1) * 4];\n\t      nextLineStartY = lineSet[ (i + 1) * 4 + 1];\n\t      nextLineEndX = lineSet[ (i + 1) * 4 + 2];\n\t      nextLineEndY = lineSet[ (i + 1) * 4 + 3];\n\t    } else {\n\t      nextLineStartX = lineSet[0];\n\t      nextLineStartY = lineSet[1];\n\t      nextLineEndX = lineSet[2];\n\t      nextLineEndY = lineSet[3];\n\t    }\n\t\n\t    var intersection = this.finiteLinesIntersect(\n\t      currentLineStartX, currentLineStartY,\n\t      currentLineEndX, currentLineEndY,\n\t      nextLineStartX, nextLineStartY,\n\t      nextLineEndX, nextLineEndY,\n\t      true );\n\t\n\t    vertices[ i * 2] = intersection[0];\n\t    vertices[ i * 2 + 1] = intersection[1];\n\t  }\n\t\n\t  return vertices;\n\t};\n\t\n\tmath.expandPolygon = function( points, pad ){\n\t\n\t  var expandedLineSet = new Array( points.length * 2 );\n\t\n\t  var currentPointX, currentPointY, nextPointX, nextPointY;\n\t\n\t  for( var i = 0; i < points.length / 2; i++ ){\n\t    currentPointX = points[ i * 2];\n\t    currentPointY = points[ i * 2 + 1];\n\t\n\t    if( i < points.length / 2 - 1 ){\n\t      nextPointX = points[ (i + 1) * 2];\n\t      nextPointY = points[ (i + 1) * 2 + 1];\n\t    } else {\n\t      nextPointX = points[0];\n\t      nextPointY = points[1];\n\t    }\n\t\n\t    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n\t\n\t    // Assume CCW polygon winding\n\t\n\t    var offsetX = (nextPointY - currentPointY);\n\t    var offsetY = -(nextPointX - currentPointX);\n\t\n\t    // Normalize\n\t    var offsetLength = Math.sqrt( offsetX * offsetX + offsetY * offsetY );\n\t    var normalizedOffsetX = offsetX / offsetLength;\n\t    var normalizedOffsetY = offsetY / offsetLength;\n\t\n\t    expandedLineSet[ i * 4] = currentPointX + normalizedOffsetX * pad;\n\t    expandedLineSet[ i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n\t    expandedLineSet[ i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n\t    expandedLineSet[ i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n\t  }\n\t\n\t  return expandedLineSet;\n\t};\n\t\n\tmath.intersectLineEllipse = function(\n\t  x, y, centerX, centerY, ellipseWradius, ellipseHradius ){\n\t\n\t  var dispX = centerX - x;\n\t  var dispY = centerY - y;\n\t\n\t  dispX /= ellipseWradius;\n\t  dispY /= ellipseHradius;\n\t\n\t  var len = Math.sqrt( dispX * dispX + dispY * dispY );\n\t\n\t  var newLength = len - 1;\n\t\n\t  if( newLength < 0 ){\n\t    return [];\n\t  }\n\t\n\t  var lenProportion = newLength / len;\n\t\n\t  return [ (centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y ];\n\t};\n\t\n\t// Returns intersections of increasing distance from line's start point\n\tmath.intersectLineCircle = function(\n\t  x1, y1, x2, y2, centerX, centerY, radius ){\n\t\n\t  // Calculate d, direction vector of line\n\t  var d = [ x2 - x1, y2 - y1 ]; // Direction vector of line\n\t  var c = [ centerX, centerY ]; // Center of circle\n\t  var f = [ x1 - centerX, y1 - centerY ];\n\t\n\t  var a = d[0] * d[0] + d[1] * d[1];\n\t  var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n\t  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;\n\t\n\t  var discriminant = b * b - 4 * a * c;\n\t\n\t  if( discriminant < 0 ){\n\t    return [];\n\t  }\n\t\n\t  var t1 = (-b + Math.sqrt( discriminant )) / (2 * a);\n\t  var t2 = (-b - Math.sqrt( discriminant )) / (2 * a);\n\t\n\t  var tMin = Math.min( t1, t2 );\n\t  var tMax = Math.max( t1, t2 );\n\t  var inRangeParams = [];\n\t\n\t  if( tMin >= 0 && tMin <= 1 ){\n\t    inRangeParams.push( tMin );\n\t  }\n\t\n\t  if( tMax >= 0 && tMax <= 1 ){\n\t    inRangeParams.push( tMax );\n\t  }\n\t\n\t  if( inRangeParams.length === 0 ){\n\t    return [];\n\t  }\n\t\n\t  var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n\t  var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n\t\n\t  if( inRangeParams.length > 1 ){\n\t\n\t    if( inRangeParams[0] == inRangeParams[1] ){\n\t      return [ nearIntersectionX, nearIntersectionY ];\n\t    } else {\n\t\n\t      var farIntersectionX = inRangeParams[1] * d[0] + x1;\n\t      var farIntersectionY = inRangeParams[1] * d[1] + y1;\n\t\n\t      return [ nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY ];\n\t    }\n\t\n\t  } else {\n\t    return [ nearIntersectionX, nearIntersectionY ];\n\t  }\n\t\n\t};\n\t\n\tmath.findCircleNearPoint = function( centerX, centerY,\n\t  radius, farX, farY ){\n\t\n\t  var displacementX = farX - centerX;\n\t  var displacementY = farY - centerY;\n\t  var distance = Math.sqrt( displacementX * displacementX\n\t    + displacementY * displacementY );\n\t\n\t  var unitDisplacementX = displacementX / distance;\n\t  var unitDisplacementY = displacementY / distance;\n\t\n\t  return [ centerX + unitDisplacementX * radius,\n\t    centerY + unitDisplacementY * radius ];\n\t};\n\t\n\tmath.findMaxSqDistanceToOrigin = function( points ){\n\t  var maxSqDistance = 0.000001;\n\t  var sqDistance;\n\t\n\t  for( var i = 0; i < points.length / 2; i++ ){\n\t\n\t    sqDistance = points[ i * 2] * points[ i * 2]\n\t      + points[ i * 2 + 1] * points[ i * 2 + 1];\n\t\n\t    if( sqDistance > maxSqDistance ){\n\t      maxSqDistance = sqDistance;\n\t    }\n\t  }\n\t\n\t  return maxSqDistance;\n\t};\n\t\n\tmath.finiteLinesIntersect = function(\n\t  x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines ){\n\t\n\t  var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n\t  var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\t  var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\n\t  if( u_b !== 0 ){\n\t    var ua = ua_t / u_b;\n\t    var ub = ub_t / u_b;\n\t\n\t    if( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ){\n\t      return [ x1 + ua * (x2 - x1), y1 + ua * (y2 - y1) ];\n\t\n\t    } else {\n\t      if( !infiniteLines ){\n\t        return [];\n\t      } else {\n\t        return [ x1 + ua * (x2 - x1), y1 + ua * (y2 - y1) ];\n\t      }\n\t    }\n\t  } else {\n\t    if( ua_t === 0 || ub_t === 0 ){\n\t\n\t      // Parallel, coincident lines. Check if overlap\n\t\n\t      // Check endpoint of second line\n\t      if( [ x1, x2, x4 ].sort()[1] === x4 ){\n\t        return [ x4, y4 ];\n\t      }\n\t\n\t      // Check start point of second line\n\t      if( [ x1, x2, x3 ].sort()[1] === x3 ){\n\t        return [ x3, y3 ];\n\t      }\n\t\n\t      // Endpoint of first line\n\t      if( [ x3, x4, x2 ].sort()[1] === x2 ){\n\t        return [ x2, y2 ];\n\t      }\n\t\n\t      return [];\n\t    } else {\n\t\n\t      // Parallel, non-coincident\n\t      return [];\n\t    }\n\t  }\n\t};\n\t\n\tmath.polygonIntersectLine = function(\n\t  x, y, basePoints, centerX, centerY, width, height, padding ){\n\t\n\t  var intersections = [];\n\t  var intersection;\n\t\n\t  var transformedPoints = new Array( basePoints.length );\n\t\n\t  for( var i = 0; i < transformedPoints.length / 2; i++ ){\n\t    transformedPoints[ i * 2] = basePoints[ i * 2] * width + centerX;\n\t    transformedPoints[ i * 2 + 1] = basePoints[ i * 2 + 1] * height + centerY;\n\t  }\n\t\n\t  var points;\n\t\n\t  if( padding > 0 ){\n\t    var expandedLineSet = math.expandPolygon(\n\t      transformedPoints,\n\t      -padding );\n\t\n\t    points = math.joinLines( expandedLineSet );\n\t  } else {\n\t    points = transformedPoints;\n\t  }\n\t  // var points = transformedPoints;\n\t\n\t  var currentX, currentY, nextX, nextY;\n\t\n\t  for( var i = 0; i < points.length / 2; i++ ){\n\t\n\t    currentX = points[ i * 2];\n\t    currentY = points[ i * 2 + 1];\n\t\n\t    if( i < points.length / 2 - 1 ){\n\t      nextX = points[ (i + 1) * 2];\n\t      nextY = points[ (i + 1) * 2 + 1];\n\t    } else {\n\t      nextX = points[0];\n\t      nextY = points[1];\n\t    }\n\t\n\t    intersection = this.finiteLinesIntersect(\n\t      x, y, centerX, centerY,\n\t      currentX, currentY,\n\t      nextX, nextY );\n\t\n\t    if( intersection.length !== 0 ){\n\t      intersections.push( intersection[0], intersection[1] );\n\t    }\n\t  }\n\t\n\t  return intersections;\n\t};\n\t\n\tmath.shortenIntersection = function(\n\t  intersection, offset, amount ){\n\t\n\t  var disp = [ intersection[0] - offset[0], intersection[1] - offset[1] ];\n\t\n\t  var length = Math.sqrt( disp[0] * disp[0] + disp[1] * disp[1] );\n\t\n\t  var lenRatio = (length - amount) / length;\n\t\n\t  if( lenRatio < 0 ){\n\t    lenRatio = 0.00001;\n\t  }\n\t\n\t  return [ offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1] ];\n\t};\n\t\n\tmath.generateUnitNgonPointsFitToSquare = function( sides, rotationRadians ){\n\t  var points = math.generateUnitNgonPoints( sides, rotationRadians );\n\t  points = math.fitPolygonToSquare( points );\n\t\n\t  return points;\n\t};\n\t\n\tmath.fitPolygonToSquare = function( points ){\n\t  var x, y;\n\t  var sides = points.length / 2;\n\t  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n\t\n\t  for( var i = 0; i < sides; i++ ){\n\t    x = points[2 * i ];\n\t    y = points[2 * i + 1];\n\t\n\t    minX = Math.min( minX, x );\n\t    maxX = Math.max( maxX, x );\n\t    minY = Math.min( minY, y );\n\t    maxY = Math.max( maxY, y );\n\t  }\n\t\n\t  // stretch factors\n\t  var sx = 2 / (maxX - minX);\n\t  var sy = 2 / (maxY - minY);\n\t\n\t  for( var i = 0; i < sides; i++ ){\n\t    x = points[2 * i ] = points[2 * i ] * sx;\n\t    y = points[2 * i + 1] = points[2 * i + 1] * sy;\n\t\n\t    minX = Math.min( minX, x );\n\t    maxX = Math.max( maxX, x );\n\t    minY = Math.min( minY, y );\n\t    maxY = Math.max( maxY, y );\n\t  }\n\t\n\t  if( minY < -1 ){\n\t    for( var i = 0; i < sides; i++ ){\n\t      y = points[2 * i + 1] = points[2 * i + 1] + (-1 - minY);\n\t    }\n\t  }\n\t\n\t  return points;\n\t};\n\t\n\tmath.generateUnitNgonPoints = function( sides, rotationRadians ){\n\t\n\t  var increment = 1.0 / sides * 2 * Math.PI;\n\t  var startAngle = sides % 2 === 0 ?\n\t    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n\t  //    console.log(nodeShapes['square']);\n\t  startAngle += rotationRadians;\n\t\n\t  var points = new Array( sides * 2 );\n\t\n\t  var currentAngle, x, y;\n\t  for( var i = 0; i < sides; i++ ){\n\t    currentAngle = i * increment + startAngle;\n\t\n\t    x = points[2 * i ] = Math.cos( currentAngle );// * (1 + i/2);\n\t    y = points[2 * i + 1] = Math.sin( -currentAngle );//  * (1 + i/2);\n\t  }\n\t\n\t  return points;\n\t};\n\t\n\tmath.getRoundRectangleRadius = function( width, height ){\n\t\n\t  // Set the default radius, unless half of width or height is smaller than default\n\t  return Math.min( width / 4, height / 4, 8 );\n\t};\n\t\n\tmodule.exports = math;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tmodule.exports = {\n\t  // get [r, g, b] from #abc or #aabbcc\n\t  hex2tuple: function( hex ){\n\t    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== '#' ){ return; }\n\t\n\t    var shortHex = hex.length === 4;\n\t    var r, g, b;\n\t    var base = 16;\n\t\n\t    if( shortHex ){\n\t      r = parseInt( hex[1] + hex[1], base );\n\t      g = parseInt( hex[2] + hex[2], base );\n\t      b = parseInt( hex[3] + hex[3], base );\n\t    } else {\n\t      r = parseInt( hex[1] + hex[2], base );\n\t      g = parseInt( hex[3] + hex[4], base );\n\t      b = parseInt( hex[5] + hex[6], base );\n\t    }\n\t\n\t    return [ r, g, b ];\n\t  },\n\t\n\t  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n\t  hsl2tuple: function( hsl ){\n\t    var ret;\n\t    var h, s, l, a, r, g, b;\n\t    function hue2rgb( p, q, t ){\n\t      if( t < 0 ) t += 1;\n\t      if( t > 1 ) t -= 1;\n\t      if( t < 1 / 6 ) return p + (q - p) * 6 * t;\n\t      if( t < 1 / 2 ) return q;\n\t      if( t < 2 / 3 ) return p + (q - p) * (2 / 3 - t) * 6;\n\t      return p;\n\t    }\n\t\n\t    var m = new RegExp( '^' + this.regex.hsla + '$' ).exec( hsl );\n\t    if( m ){\n\t\n\t      // get hue\n\t      h = parseInt( m[1] );\n\t      if( h < 0 ){\n\t        h = ( 360 - (-1 * h % 360) ) % 360;\n\t      } else if( h > 360 ){\n\t        h = h % 360;\n\t      }\n\t      h /= 360; // normalise on [0, 1]\n\t\n\t      s = parseFloat( m[2] );\n\t      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]\n\t      s = s / 100; // normalise on [0, 1]\n\t\n\t      l = parseFloat( m[3] );\n\t      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]\n\t      l = l / 100; // normalise on [0, 1]\n\t\n\t      a = m[4];\n\t      if( a !== undefined ){\n\t        a = parseFloat( a );\n\t\n\t        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]\n\t      }\n\t\n\t      // now, convert to rgb\n\t      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n\t      if( s === 0 ){\n\t        r = g = b = Math.round( l * 255 ); // achromatic\n\t      } else {\n\t        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t        var p = 2 * l - q;\n\t        r = Math.round( 255 * hue2rgb( p, q, h + 1 / 3 ) );\n\t        g = Math.round( 255 * hue2rgb( p, q, h ) );\n\t        b = Math.round( 255 * hue2rgb( p, q, h - 1 / 3 ) );\n\t      }\n\t\n\t      ret = [ r, g, b, a ];\n\t    }\n\t\n\t    return ret;\n\t  },\n\t\n\t  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n\t  rgb2tuple: function( rgb ){\n\t    var ret;\n\t\n\t    var m = new RegExp( '^' + this.regex.rgba + '$' ).exec( rgb );\n\t    if( m ){\n\t      ret = [];\n\t\n\t      var isPct = [];\n\t      for( var i = 1; i <= 3; i++ ){\n\t        var channel = m[ i ];\n\t\n\t        if( channel[ channel.length - 1 ] === '%' ){\n\t          isPct[ i ] = true;\n\t        }\n\t        channel = parseFloat( channel );\n\t\n\t        if( isPct[ i ] ){\n\t          channel = channel / 100 * 255; // normalise to [0, 255]\n\t        }\n\t\n\t        if( channel < 0 || channel > 255 ){ return; } // invalid channel value\n\t\n\t        ret.push( Math.floor( channel ) );\n\t      }\n\t\n\t      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n\t      var allArePct = isPct[1] && isPct[2] && isPct[3];\n\t      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is\n\t\n\t      var alpha = m[4];\n\t      if( alpha !== undefined ){\n\t        alpha = parseFloat( alpha );\n\t\n\t        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value\n\t\n\t        ret.push( alpha );\n\t      }\n\t    }\n\t\n\t    return ret;\n\t  },\n\t\n\t  colorname2tuple: function( color ){\n\t    return this.colors[ color.toLowerCase() ];\n\t  },\n\t\n\t  color2tuple: function( color ){\n\t    return ( is.array( color ) ? color : null )\n\t      || this.colorname2tuple( color )\n\t      || this.hex2tuple( color )\n\t      || this.rgb2tuple( color )\n\t      || this.hsl2tuple( color );\n\t  },\n\t\n\t  colors: {\n\t    // special colour names\n\t    transparent: [0, 0, 0, 0], // NB alpha === 0\n\t\n\t    // regular colours\n\t    aliceblue: [ 240, 248, 255 ],\n\t    antiquewhite: [ 250, 235, 215 ],\n\t    aqua: [0, 255, 255 ],\n\t    aquamarine: [ 127, 255, 212 ],\n\t    azure: [ 240, 255, 255 ],\n\t    beige: [ 245, 245, 220 ],\n\t    bisque: [ 255, 228, 196 ],\n\t    black: [0, 0, 0],\n\t    blanchedalmond: [ 255, 235, 205 ],\n\t    blue: [0, 0, 255 ],\n\t    blueviolet: [ 138, 43, 226 ],\n\t    brown: [ 165, 42, 42 ],\n\t    burlywood: [ 222, 184, 135 ],\n\t    cadetblue: [ 95, 158, 160 ],\n\t    chartreuse: [ 127, 255, 0],\n\t    chocolate: [ 210, 105, 30 ],\n\t    coral: [ 255, 127, 80 ],\n\t    cornflowerblue: [ 100, 149, 237 ],\n\t    cornsilk: [ 255, 248, 220 ],\n\t    crimson: [ 220, 20, 60 ],\n\t    cyan: [0, 255, 255 ],\n\t    darkblue: [0, 0, 139 ],\n\t    darkcyan: [0, 139, 139 ],\n\t    darkgoldenrod: [ 184, 134, 11 ],\n\t    darkgray: [ 169, 169, 169 ],\n\t    darkgreen: [0, 100, 0],\n\t    darkgrey: [ 169, 169, 169 ],\n\t    darkkhaki: [ 189, 183, 107 ],\n\t    darkmagenta: [ 139, 0, 139 ],\n\t    darkolivegreen: [ 85, 107, 47 ],\n\t    darkorange: [ 255, 140, 0],\n\t    darkorchid: [ 153, 50, 204 ],\n\t    darkred: [ 139, 0, 0],\n\t    darksalmon: [ 233, 150, 122 ],\n\t    darkseagreen: [ 143, 188, 143 ],\n\t    darkslateblue: [ 72, 61, 139 ],\n\t    darkslategray: [ 47, 79, 79 ],\n\t    darkslategrey: [ 47, 79, 79 ],\n\t    darkturquoise: [0, 206, 209 ],\n\t    darkviolet: [ 148, 0, 211 ],\n\t    deeppink: [ 255, 20, 147 ],\n\t    deepskyblue: [0, 191, 255 ],\n\t    dimgray: [ 105, 105, 105 ],\n\t    dimgrey: [ 105, 105, 105 ],\n\t    dodgerblue: [ 30, 144, 255 ],\n\t    firebrick: [ 178, 34, 34 ],\n\t    floralwhite: [ 255, 250, 240 ],\n\t    forestgreen: [ 34, 139, 34 ],\n\t    fuchsia: [ 255, 0, 255 ],\n\t    gainsboro: [ 220, 220, 220 ],\n\t    ghostwhite: [ 248, 248, 255 ],\n\t    gold: [ 255, 215, 0],\n\t    goldenrod: [ 218, 165, 32 ],\n\t    gray: [ 128, 128, 128 ],\n\t    grey: [ 128, 128, 128 ],\n\t    green: [0, 128, 0],\n\t    greenyellow: [ 173, 255, 47 ],\n\t    honeydew: [ 240, 255, 240 ],\n\t    hotpink: [ 255, 105, 180 ],\n\t    indianred: [ 205, 92, 92 ],\n\t    indigo: [ 75, 0, 130 ],\n\t    ivory: [ 255, 255, 240 ],\n\t    khaki: [ 240, 230, 140 ],\n\t    lavender: [ 230, 230, 250 ],\n\t    lavenderblush: [ 255, 240, 245 ],\n\t    lawngreen: [ 124, 252, 0],\n\t    lemonchiffon: [ 255, 250, 205 ],\n\t    lightblue: [ 173, 216, 230 ],\n\t    lightcoral: [ 240, 128, 128 ],\n\t    lightcyan: [ 224, 255, 255 ],\n\t    lightgoldenrodyellow: [ 250, 250, 210 ],\n\t    lightgray: [ 211, 211, 211 ],\n\t    lightgreen: [ 144, 238, 144 ],\n\t    lightgrey: [ 211, 211, 211 ],\n\t    lightpink: [ 255, 182, 193 ],\n\t    lightsalmon: [ 255, 160, 122 ],\n\t    lightseagreen: [ 32, 178, 170 ],\n\t    lightskyblue: [ 135, 206, 250 ],\n\t    lightslategray: [ 119, 136, 153 ],\n\t    lightslategrey: [ 119, 136, 153 ],\n\t    lightsteelblue: [ 176, 196, 222 ],\n\t    lightyellow: [ 255, 255, 224 ],\n\t    lime: [0, 255, 0],\n\t    limegreen: [ 50, 205, 50 ],\n\t    linen: [ 250, 240, 230 ],\n\t    magenta: [ 255, 0, 255 ],\n\t    maroon: [ 128, 0, 0],\n\t    mediumaquamarine: [ 102, 205, 170 ],\n\t    mediumblue: [0, 0, 205 ],\n\t    mediumorchid: [ 186, 85, 211 ],\n\t    mediumpurple: [ 147, 112, 219 ],\n\t    mediumseagreen: [ 60, 179, 113 ],\n\t    mediumslateblue: [ 123, 104, 238 ],\n\t    mediumspringgreen: [0, 250, 154 ],\n\t    mediumturquoise: [ 72, 209, 204 ],\n\t    mediumvioletred: [ 199, 21, 133 ],\n\t    midnightblue: [ 25, 25, 112 ],\n\t    mintcream: [ 245, 255, 250 ],\n\t    mistyrose: [ 255, 228, 225 ],\n\t    moccasin: [ 255, 228, 181 ],\n\t    navajowhite: [ 255, 222, 173 ],\n\t    navy: [0, 0, 128 ],\n\t    oldlace: [ 253, 245, 230 ],\n\t    olive: [ 128, 128, 0],\n\t    olivedrab: [ 107, 142, 35 ],\n\t    orange: [ 255, 165, 0],\n\t    orangered: [ 255, 69, 0],\n\t    orchid: [ 218, 112, 214 ],\n\t    palegoldenrod: [ 238, 232, 170 ],\n\t    palegreen: [ 152, 251, 152 ],\n\t    paleturquoise: [ 175, 238, 238 ],\n\t    palevioletred: [ 219, 112, 147 ],\n\t    papayawhip: [ 255, 239, 213 ],\n\t    peachpuff: [ 255, 218, 185 ],\n\t    peru: [ 205, 133, 63 ],\n\t    pink: [ 255, 192, 203 ],\n\t    plum: [ 221, 160, 221 ],\n\t    powderblue: [ 176, 224, 230 ],\n\t    purple: [ 128, 0, 128 ],\n\t    red: [ 255, 0, 0],\n\t    rosybrown: [ 188, 143, 143 ],\n\t    royalblue: [ 65, 105, 225 ],\n\t    saddlebrown: [ 139, 69, 19 ],\n\t    salmon: [ 250, 128, 114 ],\n\t    sandybrown: [ 244, 164, 96 ],\n\t    seagreen: [ 46, 139, 87 ],\n\t    seashell: [ 255, 245, 238 ],\n\t    sienna: [ 160, 82, 45 ],\n\t    silver: [ 192, 192, 192 ],\n\t    skyblue: [ 135, 206, 235 ],\n\t    slateblue: [ 106, 90, 205 ],\n\t    slategray: [ 112, 128, 144 ],\n\t    slategrey: [ 112, 128, 144 ],\n\t    snow: [ 255, 250, 250 ],\n\t    springgreen: [0, 255, 127 ],\n\t    steelblue: [ 70, 130, 180 ],\n\t    tan: [ 210, 180, 140 ],\n\t    teal: [0, 128, 128 ],\n\t    thistle: [ 216, 191, 216 ],\n\t    tomato: [ 255, 99, 71 ],\n\t    turquoise: [ 64, 224, 208 ],\n\t    violet: [ 238, 130, 238 ],\n\t    wheat: [ 245, 222, 179 ],\n\t    white: [ 255, 255, 255 ],\n\t    whitesmoke: [ 245, 245, 245 ],\n\t    yellow: [ 255, 255, 0],\n\t    yellowgreen: [ 154, 205, 50 ]\n\t  }\n\t};\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tmodule.exports = {\n\t  // has anything been set in the map\n\t  mapEmpty: function( map ){\n\t    var empty = true;\n\t\n\t    if( map != null ){\n\t      return Object.keys( map ).length === 0;\n\t    }\n\t\n\t    return empty;\n\t  },\n\t\n\t  // pushes to the array at the end of a map (map may not be built)\n\t  pushMap: function( options ){\n\t    var array = this.getMap( options );\n\t\n\t    if( array == null ){ // if empty, put initial array\n\t      this.setMap( this.extend( {}, options, {\n\t        value: [ options.value ]\n\t      } ) );\n\t    } else {\n\t      array.push( options.value );\n\t    }\n\t  },\n\t\n\t  // sets the value in a map (map may not be built)\n\t  setMap: function( options ){\n\t    var obj = options.map;\n\t    var key;\n\t    var keys = options.keys;\n\t    var l = keys.length;\n\t\n\t    for( var i = 0; i < l; i++ ){\n\t      var key = keys[ i ];\n\t\n\t      if( is.plainObject( key ) ){\n\t        this.error( 'Tried to set map with object key' );\n\t      }\n\t\n\t      if( i < keys.length - 1 ){\n\t\n\t        // extend the map if necessary\n\t        if( obj[ key ] == null ){\n\t          obj[ key ] = {};\n\t        }\n\t\n\t        obj = obj[ key ];\n\t      } else {\n\t        // set the value\n\t        obj[ key ] = options.value;\n\t      }\n\t    }\n\t  },\n\t\n\t  // gets the value in a map even if it's not built in places\n\t  getMap: function( options ){\n\t    var obj = options.map;\n\t    var keys = options.keys;\n\t    var l = keys.length;\n\t\n\t    for( var i = 0; i < l; i++ ){\n\t      var key = keys[ i ];\n\t\n\t      if( is.plainObject( key ) ){\n\t        this.error( 'Tried to get map with object key' );\n\t      }\n\t\n\t      obj = obj[ key ];\n\t\n\t      if( obj == null ){\n\t        return obj;\n\t      }\n\t    }\n\t\n\t    return obj;\n\t  },\n\t\n\t  // deletes the entry in the map\n\t  deleteMap: function( options ){\n\t    var obj = options.map;\n\t    var keys = options.keys;\n\t    var l = keys.length;\n\t    var keepChildren = options.keepChildren;\n\t\n\t    for( var i = 0; i < l; i++ ){\n\t      var key = keys[ i ];\n\t\n\t      if( is.plainObject( key ) ){\n\t        this.error( 'Tried to delete map with object key' );\n\t      }\n\t\n\t      var lastKey = i === options.keys.length - 1;\n\t      if( lastKey ){\n\t\n\t        if( keepChildren ){ // then only delete child fields not in keepChildren\n\t          var children = Object.keys( obj );\n\t\n\t          for( var j = 0; j < children.length; j++ ){\n\t            var child = children[j];\n\t\n\t            if( !keepChildren[ child ] ){\n\t              obj[ child ] = undefined;\n\t            }\n\t          }\n\t        } else {\n\t          obj[ key ] = undefined;\n\t        }\n\t\n\t      } else {\n\t        obj = obj[ key ];\n\t      }\n\t    }\n\t  }\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function memoize( fn, keyFn ){\n\t  var cache = {};\n\t\n\t  if( !keyFn ){\n\t    keyFn = function(){\n\t      if( arguments.length === 1 ){\n\t        return arguments[0];\n\t      } else if( arguments.length === 0 ){\n\t        return 'undefined';\n\t      }\n\t\n\t      var args = [];\n\t\n\t      for( var i = 0; i < arguments.length; i++ ){\n\t        args.push( arguments[ i ] );\n\t      }\n\t\n\t      return args.join( '$' );\n\t    };\n\t  }\n\t\n\t  return function memoizedFn(){\n\t    var self = this;\n\t    var args = arguments;\n\t    var ret;\n\t    var k = keyFn.apply( self, args );\n\t\n\t    if( !(ret = cache[ k ]) ){\n\t      ret = cache[ k ] = fn.apply( self, args );\n\t    }\n\t\n\t    return ret;\n\t  };\n\t};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\n\t\n\tvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n\tvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\t\n\tvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n\tvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\t\n\tvar hex3 = '\\\\#[0-9a-fA-F]{3}';\n\tvar hex6 = '\\\\#[0-9a-fA-F]{6}';\n\t\n\tmodule.exports = {\n\t  regex: {\n\t    number: number,\n\t    rgba: rgba,\n\t    rgbaNoBackRefs: rgbaNoBackRefs,\n\t    hsla: hsla,\n\t    hslaNoBackRefs: hslaNoBackRefs,\n\t    hex3: hex3,\n\t    hex6: hex6\n\t  }\n\t};\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar memoize = __webpack_require__( 36 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tmodule.exports = {\n\t\n\t  camel2dash: memoize( function( str ){\n\t    return str.replace( /([A-Z])/g, function( v ){\n\t      return '-' + v.toLowerCase();\n\t    } );\n\t  } ),\n\t\n\t  dash2camel: memoize( function( str ){\n\t    return str.replace( /(-\\w)/g, function( v ){\n\t      return v[1].toUpperCase();\n\t    } );\n\t  } ),\n\t\n\t  prependCamel: memoize( function( prefix, str ){\n\t    return prefix + str[0].toUpperCase() + str.substring(1);\n\t  }, function( prefix, str ){\n\t    return prefix + '$' + str;\n\t  } ),\n\t\n\t  capitalize: function( str ){\n\t    if( is.emptyString( str ) ){\n\t      return str;\n\t    }\n\t\n\t    return str.charAt( 0 ).toUpperCase() + str.substring( 1 );\n\t  }\n\t\n\t};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar window = __webpack_require__( 29 );\n\tvar is = __webpack_require__( 30 );\n\tvar performance = window ? window.performance : null;\n\t\n\tvar util = {};\n\t\n\tvar raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||\n\t      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );\n\t\n\traf = raf || function( fn ){\n\t  if( fn ){\n\t    setTimeout( function(){\n\t      fn( pnow() );\n\t    }, 1000 / 60 );\n\t  }\n\t};\n\t\n\tutil.requestAnimationFrame = function( fn ){\n\t  raf( fn );\n\t};\n\t\n\tvar pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };\n\t\n\tutil.performanceNow = pnow;\n\t\n\t// ported lodash throttle function\n\tutil.throttle = function( func, wait, options ){\n\t  var leading = true,\n\t      trailing = true;\n\t\n\t  if( options === false ){\n\t    leading = false;\n\t  } else if( is.plainObject( options ) ){\n\t    leading = 'leading' in options ? options.leading : leading;\n\t    trailing = 'trailing' in options ? options.trailing : trailing;\n\t  }\n\t  options = options || {};\n\t  options.leading = leading;\n\t  options.maxWait = wait;\n\t  options.trailing = trailing;\n\t\n\t  return util.debounce( func, wait, options );\n\t};\n\t\n\tutil.now = function(){\n\t  return Date.now();\n\t};\n\t\n\tutil.debounce = function( func, wait, options ){ // ported lodash debounce function\n\t  var util = this;\n\t  var args,\n\t      maxTimeoutId,\n\t      result,\n\t      stamp,\n\t      thisArg,\n\t      timeoutId,\n\t      trailingCall,\n\t      lastCalled = 0,\n\t      maxWait = false,\n\t      trailing = true;\n\t\n\t  if( !is.fn( func ) ){\n\t    return;\n\t  }\n\t  wait = Math.max( 0, wait ) || 0;\n\t  if( options === true ){\n\t    var leading = true;\n\t    trailing = false;\n\t  } else if( is.plainObject( options ) ){\n\t    leading = options.leading;\n\t    maxWait = 'maxWait' in options && (Math.max( wait, options.maxWait ) || 0);\n\t    trailing = 'trailing' in options ? options.trailing : trailing;\n\t  }\n\t  var delayed = function(){\n\t    var remaining = wait - (util.now() - stamp);\n\t    if( remaining <= 0 ){\n\t      if( maxTimeoutId ){\n\t        clearTimeout( maxTimeoutId );\n\t      }\n\t      var isCalled = trailingCall;\n\t      maxTimeoutId = timeoutId = trailingCall = undefined;\n\t      if( isCalled ){\n\t        lastCalled = util.now();\n\t        result = func.apply( thisArg, args );\n\t        if( !timeoutId && !maxTimeoutId ){\n\t          args = thisArg = null;\n\t        }\n\t      }\n\t    } else {\n\t      timeoutId = setTimeout( delayed, remaining );\n\t    }\n\t  };\n\t\n\t  var maxDelayed = function(){\n\t    if( timeoutId ){\n\t      clearTimeout( timeoutId );\n\t    }\n\t    maxTimeoutId = timeoutId = trailingCall = undefined;\n\t    if( trailing || (maxWait !== wait) ){\n\t      lastCalled = util.now();\n\t      result = func.apply( thisArg, args );\n\t      if( !timeoutId && !maxTimeoutId ){\n\t        args = thisArg = null;\n\t      }\n\t    }\n\t  };\n\t\n\t  return function(){\n\t    args = arguments;\n\t    stamp = util.now();\n\t    thisArg = this;\n\t    trailingCall = trailing && (timeoutId || !leading);\n\t\n\t    if( maxWait === false ){\n\t      var leadingCall = leading && !timeoutId;\n\t    } else {\n\t      if( !maxTimeoutId && !leading ){\n\t        lastCalled = stamp;\n\t      }\n\t      var remaining = maxWait - (stamp - lastCalled),\n\t          isCalled = remaining <= 0;\n\t\n\t      if( isCalled ){\n\t        if( maxTimeoutId ){\n\t          maxTimeoutId = clearTimeout( maxTimeoutId );\n\t        }\n\t        lastCalled = stamp;\n\t        result = func.apply( thisArg, args );\n\t      }\n\t      else if( !maxTimeoutId ){\n\t        maxTimeoutId = setTimeout( maxDelayed, remaining );\n\t      }\n\t    }\n\t    if( isCalled && timeoutId ){\n\t      timeoutId = clearTimeout( timeoutId );\n\t    }\n\t    else if( !timeoutId && wait !== maxWait ){\n\t      timeoutId = setTimeout( delayed, wait );\n\t    }\n\t    if( leadingCall ){\n\t      isCalled = true;\n\t      result = func.apply( thisArg, args );\n\t    }\n\t    if( isCalled && !timeoutId && !maxTimeoutId ){\n\t      args = thisArg = null;\n\t    }\n\t    return result;\n\t  };\n\t};\n\t\n\tmodule.exports = util;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar Element = __webpack_require__( 41 );\n\t\n\t// factory for generating edge ids when no id is specified for a new element\n\tvar idFactory = {\n\t  generate: function( cy, element, tryThisId ){\n\t    var id = tryThisId != null ? tryThisId : util.uuid();\n\t\n\t    while( cy.hasElementWithId( id ) ){\n\t      id = util.uuid();\n\t    }\n\t\n\t    return id;\n\t  }\n\t};\n\t\n\t// represents a set of nodes, edges, or both together\n\tvar Collection = function( cy, elements, options ){\n\t  if( cy === undefined || !is.core( cy ) ){\n\t    util.error( 'A collection must have a reference to the core' );\n\t    return;\n\t  }\n\t\n\t  var ids = {};\n\t  var indexes = {};\n\t  var createdElements = false;\n\t\n\t  if( !elements ){\n\t    elements = [];\n\t  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){\n\t    createdElements = true;\n\t\n\t    // make elements from json and restore all at once later\n\t    var eles = [];\n\t    var elesIds = {};\n\t\n\t    for( var i = 0, l = elements.length; i < l; i++ ){\n\t      var json = elements[ i ];\n\t\n\t      if( json.data == null ){\n\t        json.data = {};\n\t      }\n\t\n\t      var data = json.data;\n\t\n\t      // make sure newly created elements have valid ids\n\t      if( data.id == null ){\n\t        data.id = idFactory.generate( cy, json );\n\t      } else if( cy.hasElementWithId( data.id ) || elesIds[ data.id ] ){\n\t        continue; // can't create element if prior id already exists\n\t      }\n\t\n\t      var ele = new Element( cy, json, false );\n\t      eles.push( ele );\n\t      elesIds[ data.id ] = true;\n\t    }\n\t\n\t    elements = eles;\n\t  }\n\t\n\t  this.length = 0;\n\t\n\t  for( var i = 0, l = elements.length; i < l; i++ ){\n\t    var element = elements[ i ];\n\t    if( !element ){  continue; }\n\t\n\t    var id = element._private.data.id;\n\t\n\t    if( !options || (options.unique && !ids[ id ] ) ){\n\t      ids[ id ] = element;\n\t      indexes[ id ] = this.length;\n\t\n\t      this[ this.length ] = element;\n\t      this.length++;\n\t    }\n\t  }\n\t\n\t  this._private = {\n\t    cy: cy,\n\t    ids: ids,\n\t    indexes: indexes\n\t  };\n\t\n\t  // restore the elements if we created them from json\n\t  if( createdElements ){\n\t    this.restore();\n\t  }\n\t};\n\t\n\t// Functions\n\t////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\t// keep the prototypes in sync (an element has the same functions as a collection)\n\t// and use elefn and elesfn as shorthands to the prototypes\n\tvar elesfn = Element.prototype = Collection.prototype;\n\t\n\telesfn.instanceString = function(){\n\t  return 'collection';\n\t};\n\t\n\telesfn.spawn = function( cy, eles, opts ){\n\t  if( !is.core( cy ) ){ // cy is optional\n\t    opts = eles;\n\t    eles = cy;\n\t    cy = this.cy();\n\t  }\n\t\n\t  return new Collection( cy, eles, opts );\n\t};\n\t\n\telesfn.spawnSelf = function(){\n\t  return this.spawn( this );\n\t};\n\t\n\telesfn.cy = function(){\n\t  return this._private.cy;\n\t};\n\t\n\telesfn.element = function(){\n\t  return this[0];\n\t};\n\t\n\telesfn.collection = function(){\n\t  if( is.collection( this ) ){\n\t    return this;\n\t  } else { // an element\n\t    return new Collection( this._private.cy, [ this ] );\n\t  }\n\t};\n\t\n\telesfn.unique = function(){\n\t  return new Collection( this._private.cy, this, { unique: true } );\n\t};\n\t\n\telesfn.hasElementWithId = function( id ){\n\t  return !!this._private.ids[ id ];\n\t};\n\t\n\telesfn.getElementById = function( id ){\n\t  var cy = this._private.cy;\n\t  var ele = this._private.ids[ id ];\n\t\n\t  return ele ? ele : new Collection( cy ); // get ele or empty collection\n\t};\n\t\n\telesfn.poolIndex = function(){\n\t  var cy = this._private.cy;\n\t  var eles = cy._private.elements;\n\t  var id = this._private.data.id;\n\t\n\t  return eles._private.indexes[ id ];\n\t},\n\t\n\telesfn.json = function( obj ){\n\t  var ele = this.element();\n\t  var cy = this.cy();\n\t\n\t  if( ele == null && obj ){ return this; } // can't set to no eles\n\t\n\t  if( ele == null ){ return undefined; } // can't get from no eles\n\t\n\t  var p = ele._private;\n\t\n\t  if( is.plainObject( obj ) ){ // set\n\t\n\t    cy.startBatch();\n\t\n\t    if( obj.data ){\n\t      ele.data( obj.data );\n\t    }\n\t\n\t    if( obj.position ){\n\t      ele.position( obj.position );\n\t    }\n\t\n\t    // ignore group -- immutable\n\t\n\t    var checkSwitch = function( k, trueFnName, falseFnName ){\n\t      var obj_k = obj[ k ];\n\t\n\t      if( obj_k != null && obj_k !== p[ k ] ){\n\t        if( obj_k ){\n\t          ele[ trueFnName ]();\n\t        } else {\n\t          ele[ falseFnName ]();\n\t        }\n\t      }\n\t    };\n\t\n\t    checkSwitch( 'removed', 'remove', 'restore' );\n\t\n\t    checkSwitch( 'selected', 'select', 'unselect' );\n\t\n\t    checkSwitch( 'selectable', 'selectify', 'unselectify' );\n\t\n\t    checkSwitch( 'locked', 'lock', 'unlock' );\n\t\n\t    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );\n\t\n\t    if( obj.classes != null ){\n\t      ele.classes( obj.classes );\n\t    }\n\t\n\t    cy.endBatch();\n\t\n\t    return this;\n\t\n\t  } else if( obj === undefined ){ // get\n\t\n\t    var json = {\n\t      data: util.copy( p.data ),\n\t      position: util.copy( p.position ),\n\t      group: p.group,\n\t      removed: p.removed,\n\t      selected: p.selected,\n\t      selectable: p.selectable,\n\t      locked: p.locked,\n\t      grabbable: p.grabbable,\n\t      classes: null\n\t    };\n\t\n\t    json.classes = Object.keys( p.classes ).filter(function( cls ){\n\t      return p.classes[cls];\n\t    }).join(' ');\n\t\n\t    return json;\n\t  }\n\t};\n\t\n\telesfn.jsons = function(){\n\t  var jsons = [];\n\t\n\t  for( var i = 0; i < this.length; i++ ){\n\t    var ele = this[ i ];\n\t    var json = ele.json();\n\t\n\t    jsons.push( json );\n\t  }\n\t\n\t  return jsons;\n\t};\n\t\n\telesfn.clone = function(){\n\t  var cy = this.cy();\n\t  var elesArr = [];\n\t\n\t  for( var i = 0; i < this.length; i++ ){\n\t    var ele = this[ i ];\n\t    var json = ele.json();\n\t    var clone = new Element( cy, json, false ); // NB no restore\n\t\n\t    elesArr.push( clone );\n\t  }\n\t\n\t  return new Collection( cy, elesArr );\n\t};\n\telesfn.copy = elesfn.clone;\n\t\n\telesfn.restore = function( notifyRenderer ){\n\t  var self = this;\n\t  var cy = self.cy();\n\t  var cy_p = cy._private;\n\t\n\t  if( notifyRenderer === undefined ){\n\t    notifyRenderer = true;\n\t  }\n\t\n\t  // create arrays of nodes and edges, since we need to\n\t  // restore the nodes first\n\t  var nodes = [];\n\t  var edges = [];\n\t  var elements;\n\t  for( var i = 0, l = self.length; i < l; i++ ){\n\t    var ele = self[ i ];\n\t\n\t    if( !ele.removed() ){\n\t      // don't need to handle this ele\n\t      continue;\n\t    }\n\t\n\t    // keep nodes first in the array and edges after\n\t    if( ele.isNode() ){ // put to front of array if node\n\t      nodes.push( ele );\n\t    } else { // put to end of array if edge\n\t      edges.push( ele );\n\t    }\n\t  }\n\t\n\t  elements = nodes.concat( edges );\n\t\n\t  var i;\n\t  var removeFromElements = function(i){\n\t    elements.splice( i, 1 );\n\t    i--;\n\t  };\n\t\n\t  // now, restore each element\n\t  for( i = 0, l = elements.length; i < l; i++ ){\n\t    var ele = elements[ i ];\n\t\n\t    var _private = ele._private;\n\t    var data = _private.data;\n\t\n\t    // the traversal cache should start fresh when ele is added\n\t    _private.traversalCache = null;\n\t\n\t    // set id and validate\n\t    if( data.id === undefined ){\n\t      data.id = idFactory.generate( cy, ele );\n\t\n\t    } else if( is.number( data.id ) ){\n\t      data.id = '' + data.id; // now it's a string\n\t\n\t    } else if( is.emptyString( data.id ) || !is.string( data.id ) ){\n\t      util.error( 'Can not create element with invalid string ID `' + data.id + '`' );\n\t\n\t      // can't create element if it has empty string as id or non-string id\n\t      removeFromElements(i);\n\t      continue;\n\t    } else if( cy.hasElementWithId( data.id ) ){\n\t      util.error( 'Can not create second element with ID `' + data.id + '`' );\n\t\n\t      // can't create element if one already has that id\n\t      removeFromElements(i);\n\t      continue;\n\t    }\n\t\n\t    var id = data.id; // id is finalised, now let's keep a ref\n\t\n\t    if( ele.isNode() ){ // extra checks for nodes\n\t      var node = ele;\n\t      var pos = _private.position;\n\t\n\t      // make sure the nodes have a defined position\n\t\n\t      if( pos.x == null ){\n\t        pos.x = 0;\n\t      }\n\t\n\t      if( pos.y == null ){\n\t        pos.y = 0;\n\t      }\n\t    }\n\t\n\t    if( ele.isEdge() ){ // extra checks for edges\n\t\n\t      var edge = ele;\n\t      var fields = [ 'source', 'target' ];\n\t      var fieldsLength = fields.length;\n\t      var badSourceOrTarget = false;\n\t      for( var j = 0; j < fieldsLength; j++ ){\n\t\n\t        var field = fields[ j ];\n\t        var val = data[ field ];\n\t\n\t        if( is.number( val ) ){\n\t          val = data[ field ] = '' + data[ field ]; // now string\n\t        }\n\t\n\t        if( val == null || val === '' ){\n\t          // can't create if source or target is not defined properly\n\t          util.error( 'Can not create edge `' + id + '` with unspecified ' + field );\n\t          badSourceOrTarget = true;\n\t        } else if( !cy.hasElementWithId( val ) ){\n\t          // can't create edge if one of its nodes doesn't exist\n\t          util.error( 'Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`' );\n\t          badSourceOrTarget = true;\n\t        }\n\t      }\n\t\n\t      if( badSourceOrTarget ){ removeFromElements(i); continue; } // can't create this\n\t\n\t      var src = cy.getElementById( data.source );\n\t      var tgt = cy.getElementById( data.target );\n\t\n\t      src._private.edges.push( edge );\n\t      tgt._private.edges.push( edge );\n\t\n\t      edge._private.source = src;\n\t      edge._private.target = tgt;\n\t    } // if is edge\n\t\n\t    // create mock ids / indexes maps for element so it can be used like collections\n\t    _private.ids = {};\n\t    _private.ids[ id ] = ele;\n\t    _private.indexes = {};\n\t    _private.indexes[ id ] = ele;\n\t\n\t    _private.removed = false;\n\t    cy.addToPool( ele );\n\t  } // for each element\n\t\n\t  // do compound node sanity checks\n\t  for( var i = 0; i < nodes.length; i++ ){ // each node\n\t    var node = nodes[ i ];\n\t    var data = node._private.data;\n\t\n\t    if( is.number( data.parent ) ){ // then automake string\n\t      data.parent = '' + data.parent;\n\t    }\n\t\n\t    var parentId = data.parent;\n\t\n\t    var specifiedParent = parentId != null;\n\t\n\t    if( specifiedParent ){\n\t      var parent = cy.getElementById( parentId );\n\t\n\t      if( parent.empty() ){\n\t        // non-existant parent; just remove it\n\t        data.parent = undefined;\n\t      } else {\n\t        var selfAsParent = false;\n\t        var ancestor = parent;\n\t        while( !ancestor.empty() ){\n\t          if( node.same( ancestor ) ){\n\t            // mark self as parent and remove from data\n\t            selfAsParent = true;\n\t            data.parent = undefined; // remove parent reference\n\t\n\t            // exit or we loop forever\n\t            break;\n\t          }\n\t\n\t          ancestor = ancestor.parent();\n\t        }\n\t\n\t        if( !selfAsParent ){\n\t          // connect with children\n\t          parent[0]._private.children.push( node );\n\t          node._private.parent = parent[0];\n\t\n\t          // let the core know we have a compound graph\n\t          cy_p.hasCompoundNodes = true;\n\t        }\n\t      } // else\n\t    } // if specified parent\n\t  } // for each node\n\t\n\t  if( elements.length > 0 ){\n\t    var restored = new Collection( cy, elements );\n\t\n\t    for( var i = 0; i < restored.length; i++ ){\n\t      var ele = restored[i];\n\t\n\t      if( ele.isNode() ){ continue; }\n\t\n\t      // adding an edge invalidates the traversal caches for the parallel edges\n\t      var pedges = ele.parallelEdges();\n\t      for( var j = 0; j < pedges.length; j++ ){\n\t        pedges[j]._private.traversalCache = null;\n\t      }\n\t\n\t      // adding an edge invalidates the traversal cache for the connected nodes\n\t      ele.source()[0]._private.traversalCache = null;\n\t      ele.target()[0]._private.traversalCache = null;\n\t    }\n\t\n\t    var toUpdateStyle;\n\t\n\t    if( cy_p.hasCompoundNodes ){\n\t      toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );\n\t    } else {\n\t      toUpdateStyle = restored;\n\t    }\n\t\n\t    toUpdateStyle.updateStyle( notifyRenderer );\n\t\n\t    if( notifyRenderer ){\n\t      restored.rtrigger( 'add' );\n\t    } else {\n\t      restored.trigger( 'add' );\n\t    }\n\t  }\n\t\n\t  return self; // chainability\n\t};\n\t\n\telesfn.removed = function(){\n\t  var ele = this[0];\n\t  return ele && ele._private.removed;\n\t};\n\t\n\telesfn.inside = function(){\n\t  var ele = this[0];\n\t  return ele && !ele._private.removed;\n\t};\n\t\n\telesfn.remove = function( notifyRenderer ){\n\t  var self = this;\n\t  var removed = [];\n\t  var elesToRemove = [];\n\t  var elesToRemoveIds = {};\n\t  var cy = self._private.cy;\n\t\n\t  if( notifyRenderer === undefined ){\n\t    notifyRenderer = true;\n\t  }\n\t\n\t  // add connected edges\n\t  function addConnectedEdges( node ){\n\t    var edges = node._private.edges;\n\t    for( var i = 0; i < edges.length; i++ ){\n\t      add( edges[ i ] );\n\t    }\n\t  }\n\t\n\t\n\t  // add descendant nodes\n\t  function addChildren( node ){\n\t    var children = node._private.children;\n\t\n\t    for( var i = 0; i < children.length; i++ ){\n\t      add( children[ i ] );\n\t    }\n\t  }\n\t\n\t  function add( ele ){\n\t    var alreadyAdded =  elesToRemoveIds[ ele.id() ];\n\t    if( alreadyAdded ){\n\t      return;\n\t    } else {\n\t      elesToRemoveIds[ ele.id() ] = true;\n\t    }\n\t\n\t    if( ele.isNode() ){\n\t      elesToRemove.push( ele ); // nodes are removed last\n\t\n\t      addConnectedEdges( ele );\n\t      addChildren( ele );\n\t    } else {\n\t      elesToRemove.unshift( ele ); // edges are removed first\n\t    }\n\t  }\n\t\n\t  // make the list of elements to remove\n\t  // (may be removing more than specified due to connected edges etc)\n\t\n\t  for( var i = 0, l = self.length; i < l; i++ ){\n\t    var ele = self[ i ];\n\t\n\t    add( ele );\n\t  }\n\t\n\t  function removeEdgeRef( node, edge ){\n\t    var connectedEdges = node._private.edges;\n\t\n\t    util.removeFromArray( connectedEdges, edge );\n\t\n\t    // removing an edges invalidates the traversal cache for its nodes\n\t    node._private.traversalCache = null;\n\t  }\n\t\n\t  function removeParallelRefs( edge ){\n\t    // removing an edge invalidates the traversal caches for the parallel edges\n\t    var pedges = edge.parallelEdges();\n\t    for( var j = 0; j < pedges.length; j++ ){\n\t      pedges[j]._private.traversalCache = null;\n\t    }\n\t  }\n\t\n\t  var alteredParents = [];\n\t  alteredParents.ids = {};\n\t\n\t  function removeChildRef( parent, ele ){\n\t    ele = ele[0];\n\t    parent = parent[0];\n\t\n\t    var children = parent._private.children;\n\t    var pid = parent.id();\n\t\n\t    util.removeFromArray( children, ele );\n\t\n\t    if( !alteredParents.ids[ pid ] ){\n\t      alteredParents.ids[ pid ] = true;\n\t      alteredParents.push( parent );\n\t    }\n\t  }\n\t\n\t  // remove from core pool\n\t  cy.removeFromPool( elesToRemove );\n\t\n\t  for( var i = 0; i < elesToRemove.length; i++ ){\n\t    var ele = elesToRemove[ i ];\n\t\n\t    // mark as removed\n\t    ele._private.removed = true;\n\t\n\t    // add to list of removed elements\n\t    removed.push( ele );\n\t\n\t    if( ele.isEdge() ){ // remove references to this edge in its connected nodes\n\t      var src = ele.source()[0];\n\t      var tgt = ele.target()[0];\n\t\n\t      removeEdgeRef( src, ele );\n\t      removeEdgeRef( tgt, ele );\n\t      removeParallelRefs( ele );\n\t\n\t    } else { // remove reference to parent\n\t      var parent = ele.parent();\n\t\n\t      if( parent.length !== 0 ){\n\t        removeChildRef( parent, ele );\n\t      }\n\t    }\n\t  }\n\t\n\t  // check to see if we have a compound graph or not\n\t  var elesStillInside = cy._private.elements;\n\t  cy._private.hasCompoundNodes = false;\n\t  for( var i = 0; i < elesStillInside.length; i++ ){\n\t    var ele = elesStillInside[ i ];\n\t\n\t    if( ele.isParent() ){\n\t      cy._private.hasCompoundNodes = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var removedElements = new Collection( this.cy(), removed );\n\t  if( removedElements.size() > 0 ){\n\t    // must manually notify since trigger won't do this automatically once removed\n\t\n\t    if( notifyRenderer ){\n\t      this.cy().notify( {\n\t        type: 'remove',\n\t        eles: removedElements\n\t      } );\n\t    }\n\t\n\t    removedElements.trigger( 'remove' );\n\t  }\n\t\n\t  // the parents who were modified by the removal need their style updated\n\t  for( var i = 0; i < alteredParents.length; i++ ){\n\t    var ele = alteredParents[ i ];\n\t\n\t    if( !ele.removed() ){\n\t      ele.updateStyle();\n\t    }\n\t  }\n\t\n\t  return new Collection( cy, removed );\n\t};\n\t\n\telesfn.move = function( struct ){\n\t  var cy = this._private.cy;\n\t\n\t  if( struct.source !== undefined || struct.target !== undefined ){\n\t    var srcId = struct.source;\n\t    var tgtId = struct.target;\n\t    var srcExists = cy.hasElementWithId( srcId );\n\t    var tgtExists = cy.hasElementWithId( tgtId );\n\t\n\t    if( srcExists || tgtExists ){\n\t      var jsons = this.jsons();\n\t\n\t      this.remove();\n\t\n\t      for( var i = 0; i < jsons.length; i++ ){\n\t        var json = jsons[ i ];\n\t\n\t        if( json.group === 'edges' ){\n\t          if( srcExists ){ json.data.source = srcId; }\n\t          if( tgtExists ){ json.data.target = tgtId; }\n\t        }\n\t      }\n\t\n\t      return cy.add( jsons );\n\t    }\n\t\n\t  } else if( struct.parent !== undefined ){ // move node to new parent\n\t    var parentId = struct.parent;\n\t    var parentExists = parentId === null || cy.hasElementWithId( parentId );\n\t\n\t    if( parentExists ){\n\t      var jsons = this.jsons();\n\t      var descs = this.descendants();\n\t      var descsEtc = descs.union( descs.union( this ).connectedEdges() );\n\t\n\t      this.remove(); // NB: also removes descendants and their connected edges\n\t\n\t      for( var i = 0; i < this.length; i++ ){\n\t        var json = jsons[ i ];\n\t\n\t        if( json.group === 'nodes' ){\n\t          json.data.parent = parentId === null ? undefined : parentId;\n\t        }\n\t      }\n\t\n\t      return cy.add( jsons ).union( descsEtc.restore() );\n\t    }\n\t  }\n\t\n\t  return this; // if nothing done\n\t};\n\t\n\t[\n\t  __webpack_require__( 42 ),\n\t  __webpack_require__( 55 ),\n\t  __webpack_require__( 62 ),\n\t  __webpack_require__( 63 ),\n\t  __webpack_require__( 64 ),\n\t  __webpack_require__( 65 ),\n\t  __webpack_require__( 66 ),\n\t  __webpack_require__( 67 ),\n\t  __webpack_require__( 68 ),\n\t  __webpack_require__( 69 ),\n\t  __webpack_require__( 70 ),\n\t  __webpack_require__( 40 ),\n\t  __webpack_require__( 71 ),\n\t  __webpack_require__( 73 ),\n\t  __webpack_require__( 74 ),\n\t  __webpack_require__( 75 ),\n\t  __webpack_require__( 76 )\n\t].forEach( function( props ){\n\t  util.extend( elesfn, props );\n\t} );\n\t\n\tmodule.exports = Collection;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\t// represents a node or an edge\n\tvar Element = function( cy, params, restore ){\n\t  var self = this;\n\t  restore = (restore === undefined || restore ? true : false);\n\t\n\t  if( cy === undefined || params === undefined || !is.core( cy ) ){\n\t    util.error( 'An element must have a core reference and parameters set' );\n\t    return;\n\t  }\n\t\n\t  var group = params.group;\n\t\n\t  // try to automatically infer the group if unspecified\n\t  if( group == null ){\n\t    if( params.data && params.data.source != null && params.data.target != null ){\n\t      group = 'edges';\n\t    } else {\n\t      group = 'nodes';\n\t    }\n\t  }\n\t\n\t  // validate group\n\t  if( group !== 'nodes' && group !== 'edges' ){\n\t    util.error( 'An element must be of type `nodes` or `edges`; you specified `' + group + '`' );\n\t    return;\n\t  }\n\t\n\t  // make the element array-like, just like a collection\n\t  this.length = 1;\n\t  this[0] = this;\n\t\n\t  // NOTE: when something is added here, add also to ele.json()\n\t  this._private = {\n\t    cy: cy,\n\t    single: true, // indicates this is an element\n\t    data: params.data || {}, // data object\n\t    position: params.position || {}, // (x, y) position pair\n\t    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value\n\t    autoHeight: undefined,\n\t    listeners: [], // array of bound listeners\n\t    group: group, // string; 'nodes' or 'edges'\n\t    style: {}, // properties as set by the style\n\t    rstyle: {}, // properties for style sent from the renderer to the core\n\t    styleCxts: [], // applied style contexts from the styler\n\t    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)\n\t    selected: params.selected ? true : false, // whether it's selected\n\t    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable\n\t    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)\n\t    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately\n\t    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed\n\t    active: false, // whether the element is active from user interaction\n\t    classes: {}, // map ( className => true )\n\t    animation: { // object for currently-running animations\n\t      current: [],\n\t      queue: []\n\t    },\n\t    rscratch: {}, // object in which the renderer can store information\n\t    scratch: params.scratch || {}, // scratch objects\n\t    edges: [], // array of connected edges\n\t    children: [], // array of children\n\t    traversalCache: {} // cache of output of traversal functions\n\t  };\n\t\n\t  // renderedPosition overrides if specified\n\t  if( params.renderedPosition ){\n\t    var rpos = params.renderedPosition;\n\t    var pan = cy.pan();\n\t    var zoom = cy.zoom();\n\t\n\t    this._private.position = {\n\t      x: (rpos.x - pan.x) / zoom,\n\t      y: (rpos.y - pan.y) / zoom\n\t    };\n\t  }\n\t\n\t  if( is.string( params.classes ) ){\n\t    var classes = params.classes.split( /\\s+/ );\n\t    for( var i = 0, l = classes.length; i < l; i++ ){\n\t      var cls = classes[ i ];\n\t      if( !cls || cls === '' ){ continue; }\n\t\n\t      self._private.classes[ cls ] = true;\n\t    }\n\t  }\n\t\n\t  if( params.style || params.css ){\n\t    cy.style().applyBypass( this, params.style || params.css );\n\t  }\n\t\n\t  if( restore === undefined || restore ){\n\t    this.restore();\n\t  }\n\t\n\t};\n\t\n\tmodule.exports = Element;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar elesfn = {};\n\t\n\t[\n\t  __webpack_require__( 43 ),\n\t  __webpack_require__( 44 ),\n\t  __webpack_require__( 46 ),\n\t  __webpack_require__( 47 ),\n\t  __webpack_require__( 48 ),\n\t  __webpack_require__( 49 ),\n\t  __webpack_require__( 50 ),\n\t  __webpack_require__( 51 ),\n\t  __webpack_require__( 52 ),\n\t  __webpack_require__( 53 ),\n\t  __webpack_require__( 54 )\n\t].forEach( function( props ){\n\t  util.extend( elesfn, props );\n\t} );\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar defineSearch = function( params ){\n\t  params = {\n\t    bfs: params.bfs || !params.dfs,\n\t    dfs: params.dfs || !params.bfs\n\t  };\n\t\n\t  // from pseudocode on wikipedia\n\t  return function searchFn( roots, fn, directed ){\n\t    var options;\n\t    var std;\n\t    var thisArg;\n\t    if( is.plainObject( roots ) && !is.elementOrCollection( roots ) ){\n\t      options = roots;\n\t      roots = options.roots || options.root;\n\t      fn = options.visit;\n\t      directed = options.directed;\n\t      std = options.std;\n\t      thisArg = options.thisArg;\n\t    }\n\t\n\t    directed = arguments.length === 2 && !is.fn( fn ) ? fn : directed;\n\t    fn = is.fn( fn ) ? fn : function(){};\n\t\n\t    var cy = this._private.cy;\n\t    var v = roots = is.string( roots ) ? this.filter( roots ) : roots;\n\t    var Q = [];\n\t    var connectedNodes = [];\n\t    var connectedBy = {};\n\t    var id2depth = {};\n\t    var V = {};\n\t    var j = 0;\n\t    var found;\n\t    var nodes = this.nodes();\n\t    var edges = this.edges();\n\t\n\t    // enqueue v\n\t    for( var i = 0; i < v.length; i++ ){\n\t      if( v[ i ].isNode() ){\n\t        Q.unshift( v[ i ] );\n\t\n\t        if( params.bfs ){\n\t          V[ v[ i ].id() ] = true;\n\t\n\t          connectedNodes.push( v[ i ] );\n\t        }\n\t\n\t        id2depth[ v[ i ].id() ] = 0;\n\t      }\n\t    }\n\t\n\t    while( Q.length !== 0 ){\n\t      var v = params.bfs ? Q.shift() : Q.pop();\n\t\n\t      if( params.dfs ){\n\t        if( V[ v.id() ] ){ continue; }\n\t\n\t        V[ v.id() ] = true;\n\t\n\t        connectedNodes.push( v );\n\t      }\n\t\n\t      var depth = id2depth[ v.id() ];\n\t      var prevEdge = connectedBy[ v.id() ];\n\t      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];\n\t      var ret;\n\t\n\t      if( std ){\n\t        ret = fn.call( thisArg, v, prevEdge, prevNode, j++, depth );\n\t      } else {\n\t        ret = fn.call( v, j++, depth, v, prevEdge, prevNode );\n\t      }\n\t\n\t      if( ret === true ){\n\t        found = v;\n\t        break;\n\t      }\n\t\n\t      if( ret === false ){\n\t        break;\n\t      }\n\t\n\t      var vwEdges = v.connectedEdges( directed ? function(){ return this.data( 'source' ) === v.id(); } : undefined ).intersect( edges );\n\t      for( var i = 0; i < vwEdges.length; i++ ){\n\t        var e = vwEdges[ i ];\n\t        var w = e.connectedNodes( function(){ return this.id() !== v.id(); } ).intersect( nodes );\n\t\n\t        if( w.length !== 0 && !V[ w.id() ] ){\n\t          w = w[0];\n\t\n\t          Q.push( w );\n\t\n\t          if( params.bfs ){\n\t            V[ w.id() ] = true;\n\t\n\t            connectedNodes.push( w );\n\t          }\n\t\n\t          connectedBy[ w.id() ] = e;\n\t\n\t          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;\n\t        }\n\t      }\n\t\n\t    }\n\t\n\t    var connectedEles = [];\n\t\n\t    for( var i = 0; i < connectedNodes.length; i++ ){\n\t      var node = connectedNodes[ i ];\n\t      var edge = connectedBy[ node.id() ];\n\t\n\t      if( edge ){\n\t        connectedEles.push( edge );\n\t      }\n\t\n\t      connectedEles.push( node );\n\t    }\n\t\n\t    return {\n\t      path: cy.collection( connectedEles, { unique: true } ),\n\t      found: cy.collection( found )\n\t    };\n\t  };\n\t};\n\t\n\t// search, spanning trees, etc\n\tvar elesfn = ({\n\t  breadthFirstSearch: defineSearch( { bfs: true } ),\n\t  depthFirstSearch: defineSearch( { dfs: true } )\n\t});\n\t\n\t// nice, short mathemathical alias\n\telesfn.bfs = elesfn.breadthFirstSearch;\n\telesfn.dfs = elesfn.depthFirstSearch;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar Heap = __webpack_require__( 45 );\n\t\n\tvar elesfn = ({\n\t\n\t  dijkstra: function( root, weightFn, directed ){\n\t    var options;\n\t    if( is.plainObject( root ) && !is.elementOrCollection( root ) ){\n\t      options = root;\n\t      root = options.root;\n\t      weightFn = options.weight;\n\t      directed = options.directed;\n\t    }\n\t\n\t    var cy = this._private.cy;\n\t    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\t\n\t    var source = is.string( root ) ? this.filter( root )[0] : root[0];\n\t    var dist = {};\n\t    var prev = {};\n\t    var knownDist = {};\n\t\n\t    var edges = this.edges().filter( function(){ return !this.isLoop(); } );\n\t    var nodes = this.nodes();\n\t\n\t    var getDist = function( node ){\n\t      return dist[ node.id() ];\n\t    };\n\t\n\t    var setDist = function( node, d ){\n\t      dist[ node.id() ] = d;\n\t\n\t      Q.updateItem( node );\n\t    };\n\t\n\t    var Q = new Heap( function( a, b ){\n\t      return getDist( a ) - getDist( b );\n\t    } );\n\t\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      var node = nodes[ i ];\n\t\n\t      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;\n\t      Q.push( node );\n\t    }\n\t\n\t    var distBetween = function( u, v ){\n\t      var uvs = ( directed ? u.edgesTo( v ) : u.edgesWith( v ) ).intersect( edges );\n\t      var smallestDistance = Infinity;\n\t      var smallestEdge;\n\t\n\t      for( var i = 0; i < uvs.length; i++ ){\n\t        var edge = uvs[ i ];\n\t        var weight = weightFn.apply( edge, [ edge ] );\n\t\n\t        if( weight < smallestDistance || !smallestEdge ){\n\t          smallestDistance = weight;\n\t          smallestEdge = edge;\n\t        }\n\t      }\n\t\n\t      return {\n\t        edge: smallestEdge,\n\t        dist: smallestDistance\n\t      };\n\t    };\n\t\n\t    while( Q.size() > 0 ){\n\t      var u = Q.pop();\n\t      var smalletsDist = getDist( u );\n\t      var uid = u.id();\n\t\n\t      knownDist[ uid ] = smalletsDist;\n\t\n\t      if( smalletsDist === Math.Infinite ){\n\t        break;\n\t      }\n\t\n\t      var neighbors = u.neighborhood().intersect( nodes );\n\t      for( var i = 0; i < neighbors.length; i++ ){\n\t        var v = neighbors[ i ];\n\t        var vid = v.id();\n\t        var vDist = distBetween( u, v );\n\t\n\t        var alt = smalletsDist + vDist.dist;\n\t\n\t        if( alt < getDist( v ) ){\n\t          setDist( v, alt );\n\t\n\t          prev[ vid ] = {\n\t            node: u,\n\t            edge: vDist.edge\n\t          };\n\t        }\n\t      } // for\n\t    } // while\n\t\n\t    return {\n\t      distanceTo: function( node ){\n\t        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];\n\t\n\t        return knownDist[ target.id() ];\n\t      },\n\t\n\t      pathTo: function( node ){\n\t        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];\n\t        var S = [];\n\t        var u = target;\n\t\n\t        if( target.length > 0 ){\n\t          S.unshift( target );\n\t\n\t          while( prev[ u.id() ] ){\n\t            var p = prev[ u.id() ];\n\t\n\t            S.unshift( p.edge );\n\t            S.unshift( p.node );\n\t\n\t            u = p.node;\n\t          }\n\t        }\n\t\n\t        return cy.collection( S );\n\t      }\n\t    };\n\t  }\n\t});\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\tPorted by Xueqiao Xu <xueqiaoxu@gmail.com>;\n\t\n\tPSF LICENSE AGREEMENT FOR PYTHON 2.7.2\n\t\n\t1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or Organization (“Licensee”) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.\n\t2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSF’s License Agreement and PSF’s notice of copyright, i.e., “Copyright © 2001-2012 Python Software Foundation; All Rights Reserved” are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.\n\t3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.\n\t4. PSF is making Python 2.7.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.\n\t5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\n\t6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.\n\t7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.\n\t8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.\n\t*/\n\t\n\t'use strict';\n\t/* jshint ignore:start */\n\t\n\t// Generated by CoffeeScript 1.8.0\n\t(function(){\n\t  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\t\n\t  floor = Math.floor, min = Math.min;\n\t\n\t\n\t  /*\n\t  Default comparison function to be used\n\t   */\n\t\n\t  defaultCmp = function( x, y ){\n\t    if( x < y ){\n\t      return -1;\n\t    }\n\t    if( x > y ){\n\t      return 1;\n\t    }\n\t    return 0;\n\t  };\n\t\n\t\n\t  /*\n\t  Insert item x in list a, and keep it sorted assuming a is sorted.\n\t\n\t  If x is already in a, insert it to the right of the rightmost x.\n\t\n\t  Optional args lo (default 0) and hi (default a.length) bound the slice\n\t  of a to be searched.\n\t   */\n\t\n\t  insort = function( a, x, lo, hi, cmp ){\n\t    var mid;\n\t    if( lo == null ){\n\t      lo = 0;\n\t    }\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    if( lo < 0 ){\n\t      throw new Error( 'lo must be non-negative' );\n\t    }\n\t    if( hi == null ){\n\t      hi = a.length;\n\t    }\n\t    while( lo < hi ){\n\t      mid = floor( (lo + hi) / 2 );\n\t      if( cmp( x, a[ mid ] ) < 0 ){\n\t        hi = mid;\n\t      } else {\n\t        lo = mid + 1;\n\t      }\n\t    }\n\t    return ([].splice.apply( a, [ lo, lo - lo ].concat( x ) ), x);\n\t  };\n\t\n\t\n\t  /*\n\t  Push item onto heap, maintaining the heap invariant.\n\t   */\n\t\n\t  heappush = function( array, item, cmp ){\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    array.push( item );\n\t    return _siftdown( array, 0, array.length - 1, cmp );\n\t  };\n\t\n\t\n\t  /*\n\t  Pop the smallest item off the heap, maintaining the heap invariant.\n\t   */\n\t\n\t  heappop = function( array, cmp ){\n\t    var lastelt, returnitem;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    lastelt = array.pop();\n\t    if( array.length ){\n\t      returnitem = array[0];\n\t      array[0] = lastelt;\n\t      _siftup( array, 0, cmp );\n\t    } else {\n\t      returnitem = lastelt;\n\t    }\n\t    return returnitem;\n\t  };\n\t\n\t\n\t  /*\n\t  Pop and return the current smallest value, and add the new item.\n\t\n\t  This is more efficient than heappop() followed by heappush(), and can be\n\t  more appropriate when using a fixed size heap. Note that the value\n\t  returned may be larger than item! That constrains reasonable use of\n\t  this routine unless written as part of a conditional replacement:\n\t      if item > array[0]\n\t        item = heapreplace(array, item)\n\t   */\n\t\n\t  heapreplace = function( array, item, cmp ){\n\t    var returnitem;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    returnitem = array[0];\n\t    array[0] = item;\n\t    _siftup( array, 0, cmp );\n\t    return returnitem;\n\t  };\n\t\n\t\n\t  /*\n\t  Fast version of a heappush followed by a heappop.\n\t   */\n\t\n\t  heappushpop = function( array, item, cmp ){\n\t    var _ref;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    if( array.length && cmp( array[0], item ) < 0 ){\n\t      _ref = [ array[0], item ], item = _ref[0], array[0] = _ref[1];\n\t      _siftup( array, 0, cmp );\n\t    }\n\t    return item;\n\t  };\n\t\n\t\n\t  /*\n\t  Transform list into a heap, in-place, in O(array.length) time.\n\t   */\n\t\n\t  heapify = function( array, cmp ){\n\t    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    _ref1 = (function(){\n\t      _results1 = [];\n\t      for( var _j = 0, _ref = floor( array.length / 2 ); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j-- ){ _results1.push( _j ); }\n\t      return _results1;\n\t    }).apply( this ).reverse();\n\t    _results = [];\n\t    for( _i = 0, _len = _ref1.length; _i < _len; _i++ ){\n\t      i = _ref1[ _i ];\n\t      _results.push( _siftup( array, i, cmp ) );\n\t    }\n\t    return _results;\n\t  };\n\t\n\t\n\t  /*\n\t  Update the position of the given item in the heap.\n\t  This function should be called every time the item is being modified.\n\t   */\n\t\n\t  updateItem = function( array, item, cmp ){\n\t    var pos;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    pos = array.indexOf( item );\n\t    if( pos === -1 ){\n\t      return;\n\t    }\n\t    _siftdown( array, 0, pos, cmp );\n\t    return _siftup( array, pos, cmp );\n\t  };\n\t\n\t\n\t  /*\n\t  Find the n largest elements in a dataset.\n\t   */\n\t\n\t  nlargest = function( array, n, cmp ){\n\t    var elem, result, _i, _len, _ref;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    result = array.slice( 0, n );\n\t    if( !result.length ){\n\t      return result;\n\t    }\n\t    heapify( result, cmp );\n\t    _ref = array.slice( n );\n\t    for( _i = 0, _len = _ref.length; _i < _len; _i++ ){\n\t      elem = _ref[ _i ];\n\t      heappushpop( result, elem, cmp );\n\t    }\n\t    return result.sort( cmp ).reverse();\n\t  };\n\t\n\t\n\t  /*\n\t  Find the n smallest elements in a dataset.\n\t   */\n\t\n\t  nsmallest = function( array, n, cmp ){\n\t    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    if( n * 10 <= array.length ){\n\t      result = array.slice( 0, n ).sort( cmp );\n\t      if( !result.length ){\n\t        return result;\n\t      }\n\t      los = result[ result.length - 1];\n\t      _ref = array.slice( n );\n\t      for( _i = 0, _len = _ref.length; _i < _len; _i++ ){\n\t        elem = _ref[ _i ];\n\t        if( cmp( elem, los ) < 0 ){\n\t          insort( result, elem, 0, null, cmp );\n\t          result.pop();\n\t          los = result[ result.length - 1];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t    heapify( array, cmp );\n\t    _results = [];\n\t    for( i = _j = 0, _ref1 = min( n, array.length ); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j ){\n\t      _results.push( heappop( array, cmp ) );\n\t    }\n\t    return _results;\n\t  };\n\t\n\t  _siftdown = function( array, startpos, pos, cmp ){\n\t    var newitem, parent, parentpos;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    newitem = array[ pos ];\n\t    while( pos > startpos ){\n\t      parentpos = (pos - 1) >> 1;\n\t      parent = array[ parentpos ];\n\t      if( cmp( newitem, parent ) < 0 ){\n\t        array[ pos ] = parent;\n\t        pos = parentpos;\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\t    return array[ pos ] = newitem;\n\t  };\n\t\n\t  _siftup = function( array, pos, cmp ){\n\t    var childpos, endpos, newitem, rightpos, startpos;\n\t    if( cmp == null ){\n\t      cmp = defaultCmp;\n\t    }\n\t    endpos = array.length;\n\t    startpos = pos;\n\t    newitem = array[ pos ];\n\t    childpos = 2 * pos + 1;\n\t    while( childpos < endpos ){\n\t      rightpos = childpos + 1;\n\t      if( rightpos < endpos && !(cmp( array[ childpos ], array[ rightpos ] ) < 0) ){\n\t        childpos = rightpos;\n\t      }\n\t      array[ pos ] = array[ childpos ];\n\t      pos = childpos;\n\t      childpos = 2 * pos + 1;\n\t    }\n\t    array[ pos ] = newitem;\n\t    return _siftdown( array, startpos, pos, cmp );\n\t  };\n\t\n\t  Heap = (function(){\n\t    Heap.push = heappush;\n\t\n\t    Heap.pop = heappop;\n\t\n\t    Heap.replace = heapreplace;\n\t\n\t    Heap.pushpop = heappushpop;\n\t\n\t    Heap.heapify = heapify;\n\t\n\t    Heap.updateItem = updateItem;\n\t\n\t    Heap.nlargest = nlargest;\n\t\n\t    Heap.nsmallest = nsmallest;\n\t\n\t    function Heap( cmp ){\n\t      this.cmp = cmp != null ? cmp : defaultCmp;\n\t      this.nodes = [];\n\t    }\n\t\n\t    Heap.prototype.push = function( x ){\n\t      return heappush( this.nodes, x, this.cmp );\n\t    };\n\t\n\t    Heap.prototype.pop = function(){\n\t      return heappop( this.nodes, this.cmp );\n\t    };\n\t\n\t    Heap.prototype.peek = function(){\n\t      return this.nodes[0];\n\t    };\n\t\n\t    Heap.prototype.contains = function( x ){\n\t      return this.nodes.indexOf( x ) !== -1;\n\t    };\n\t\n\t    Heap.prototype.replace = function( x ){\n\t      return heapreplace( this.nodes, x, this.cmp );\n\t    };\n\t\n\t    Heap.prototype.pushpop = function( x ){\n\t      return heappushpop( this.nodes, x, this.cmp );\n\t    };\n\t\n\t    Heap.prototype.heapify = function(){\n\t      return heapify( this.nodes, this.cmp );\n\t    };\n\t\n\t    Heap.prototype.updateItem = function( x ){\n\t      return updateItem( this.nodes, x, this.cmp );\n\t    };\n\t\n\t    Heap.prototype.clear = function(){\n\t      return this.nodes = [];\n\t    };\n\t\n\t    Heap.prototype.empty = function(){\n\t      return this.nodes.length === 0;\n\t    };\n\t\n\t    Heap.prototype.size = function(){\n\t      return this.nodes.length;\n\t    };\n\t\n\t    Heap.prototype.clone = function(){\n\t      var heap;\n\t      heap = new Heap();\n\t      heap.nodes = this.nodes.slice( 0 );\n\t      return heap;\n\t    };\n\t\n\t    Heap.prototype.toArray = function(){\n\t      return this.nodes.slice( 0 );\n\t    };\n\t\n\t    Heap.prototype.insert = Heap.prototype.push;\n\t\n\t    Heap.prototype.top = Heap.prototype.peek;\n\t\n\t    Heap.prototype.front = Heap.prototype.peek;\n\t\n\t    Heap.prototype.has = Heap.prototype.contains;\n\t\n\t    Heap.prototype.copy = Heap.prototype.clone;\n\t\n\t    return Heap;\n\t\n\t  })();\n\t\n\t  (function( root, factory ){\n\t    if( true ){\n\t      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if( typeof exports === 'object' ){\n\t      return module.exports = factory();\n\t    } else {\n\t      return root.Heap = factory();\n\t    }\n\t  })( this, function(){\n\t    return Heap;\n\t  } );\n\t\n\t}).call( this );\n\t\n\t/* jshint ignore:end */\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\t// search, spanning trees, etc\n\tvar elesfn = ({\n\t\n\t  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n\t  // implemented from pseudocode from wikipedia\n\t  kruskal: function( weightFn ){\n\t    var cy = this.cy();\n\t\n\t    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\t\n\t    function findSet( ele ){\n\t      for( var i = 0; i < forest.length; i++ ){\n\t        var eles = forest[ i ];\n\t\n\t        if( eles.anySame( ele ) ){\n\t          return {\n\t            eles: eles,\n\t            index: i\n\t          };\n\t        }\n\t      }\n\t    }\n\t\n\t    var A = cy.collection( cy, [] );\n\t    var forest = [];\n\t    var nodes = this.nodes();\n\t\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      forest.push( nodes[ i ].collection() );\n\t    }\n\t\n\t    var edges = this.edges();\n\t    var S = edges.toArray().sort( function( a, b ){\n\t      var weightA = weightFn.call( a, a );\n\t      var weightB = weightFn.call( b, b );\n\t\n\t      return weightA - weightB;\n\t    } );\n\t\n\t    for( var i = 0; i < S.length; i++ ){\n\t      var edge = S[ i ];\n\t      var u = edge.source()[0];\n\t      var v = edge.target()[0];\n\t      var setU = findSet( u );\n\t      var setV = findSet( v );\n\t\n\t      if( setU.index !== setV.index ){\n\t        A = A.add( edge );\n\t\n\t        // combine forests for u and v\n\t        forest[ setU.index ] = setU.eles.add( setV.eles );\n\t        forest.splice( setV.index, 1 );\n\t      }\n\t    }\n\t\n\t    return nodes.add( A );\n\t  }\n\t});\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar elesfn = ({\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  aStar: function( options ){\n\t    var eles = this;\n\t\n\t    options = options || {};\n\t\n\t    // Reconstructs the path from Start to End, acumulating the result in pathAcum\n\t    var reconstructPath = function( start, end, cameFromMap, pathAcum ){\n\t      // Base case\n\t      if( start == end ){\n\t        pathAcum.push( cy.getElementById( end ) );\n\t        return pathAcum;\n\t      }\n\t\n\t      if( end in cameFromMap ){\n\t        // We know which node is before the last one\n\t        var previous = cameFromMap[ end ];\n\t        var previousEdge = cameFromEdge[ end ];\n\t\n\t        pathAcum.push( cy.getElementById( end ) );\n\t        pathAcum.push( cy.getElementById( previousEdge ) );\n\t\n\t\n\t        return reconstructPath( start,\n\t                     previous,\n\t                     cameFromMap,\n\t                     pathAcum );\n\t      }\n\t\n\t      // We should not reach here!\n\t      return undefined;\n\t    };\n\t\n\t    // Returns the index of the element in openSet which has minimum fScore\n\t    var findMin = function( openSet, fScore ){\n\t      if( openSet.length === 0 ){\n\t        // Should never be the case\n\t        return undefined;\n\t      }\n\t      var minPos = 0;\n\t      var tempScore = fScore[ openSet[0] ];\n\t      for( var i = 1; i < openSet.length; i++ ){\n\t        var s = fScore[ openSet[ i ] ];\n\t        if( s < tempScore ){\n\t          tempScore = s;\n\t          minPos = i;\n\t        }\n\t      }\n\t      return minPos;\n\t    };\n\t\n\t    var cy = this._private.cy;\n\t\n\t    // root - mandatory!\n\t    if( options != null && options.root != null ){\n\t      var source = is.string( options.root ) ?\n\t        // use it as a selector, e.g. \"#rootID\n\t        this.filter( options.root )[0] :\n\t        options.root[0];\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // goal - mandatory!\n\t    if( options.goal != null ){\n\t      var target = is.string( options.goal ) ?\n\t        // use it as a selector, e.g. \"#goalID\n\t        this.filter( options.goal )[0] :\n\t        options.goal[0];\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // Heuristic function - optional\n\t    if( options.heuristic != null && is.fn( options.heuristic ) ){\n\t      var heuristic = options.heuristic;\n\t    } else {\n\t      var heuristic = function(){ return 0; }; // use constant if unspecified\n\t    }\n\t\n\t    // Weight function - optional\n\t    if( options.weight != null && is.fn( options.weight ) ){\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function( e ){return 1;};\n\t    }\n\t\n\t    // directed - optional\n\t    if( options.directed != null ){\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var closedSet = [];\n\t    var openSet = [ source.id() ];\n\t    var cameFrom = {};\n\t    var cameFromEdge = {};\n\t    var gScore = {};\n\t    var fScore = {};\n\t\n\t    gScore[ source.id() ] = 0;\n\t    fScore[ source.id() ] = heuristic( source );\n\t\n\t    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n\t    var nodes = this.nodes();\n\t\n\t    // Counter\n\t    var steps = 0;\n\t\n\t    // Main loop\n\t    while( openSet.length > 0 ){\n\t      var minPos = findMin( openSet, fScore );\n\t      var cMin = cy.getElementById( openSet[ minPos ] );\n\t      steps++;\n\t\n\t      // If we've found our goal, then we are done\n\t      if( cMin.id() == target.id() ){\n\t        var rPath = reconstructPath( source.id(), target.id(), cameFrom, [] );\n\t        rPath.reverse();\n\t        return {\n\t          found: true,\n\t          distance: gScore[ cMin.id() ],\n\t          path: eles.spawn( rPath ),\n\t          steps: steps\n\t        };\n\t      }\n\t\n\t      // Add cMin to processed nodes\n\t      closedSet.push( cMin.id() );\n\t      // Remove cMin from boundary nodes\n\t      openSet.splice( minPos, 1 );\n\t\n\t      // Update scores for neighbors of cMin\n\t      // Take into account if graph is directed or not\n\t      var vwEdges = cMin.connectedEdges();\n\t      if( directed ){ vwEdges = vwEdges.stdFilter( function( ele ){ return ele.data( 'source' ) === cMin.id(); } ); }\n\t      vwEdges = vwEdges.intersect( edges );\n\t\n\t      for( var i = 0; i < vwEdges.length; i++ ){\n\t        var e = vwEdges[ i ];\n\t        var w = e.connectedNodes().stdFilter( function( n ){ return n.id() !== cMin.id(); } ).intersect( nodes );\n\t\n\t        // if node is in closedSet, ignore it\n\t        if( closedSet.indexOf( w.id() ) != -1 ){\n\t          continue;\n\t        }\n\t\n\t        // New tentative score for node w\n\t        var tempScore = gScore[ cMin.id() ] + weightFn.apply( e, [ e ] );\n\t\n\t        // Update gScore for node w if:\n\t        //   w not present in openSet\n\t        // OR\n\t        //   tentative gScore is less than previous value\n\t\n\t        // w not in openSet\n\t        if( openSet.indexOf( w.id() ) == -1 ){\n\t          gScore[ w.id() ] = tempScore;\n\t          fScore[ w.id() ] = tempScore + heuristic( w );\n\t          openSet.push( w.id() ); // Add node to openSet\n\t          cameFrom[ w.id() ] = cMin.id();\n\t          cameFromEdge[ w.id() ] = e.id();\n\t          continue;\n\t        }\n\t        // w already in openSet, but with greater gScore\n\t        if( tempScore < gScore[ w.id() ] ){\n\t          gScore[ w.id() ] = tempScore;\n\t          fScore[ w.id() ] = tempScore + heuristic( w );\n\t          cameFrom[ w.id() ] = cMin.id();\n\t        }\n\t\n\t      } // End of neighbors update\n\t\n\t    } // End of main loop\n\t\n\t    // If we've reached here, then we've not reached our goal\n\t    return {\n\t      found: false,\n\t      distance: undefined,\n\t      path: undefined,\n\t      steps: steps\n\t    };\n\t  }\n\t\n\t}); // elesfn\n\t\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar elesfn = ({\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  floydWarshall: function( options ){\n\t    options = options || {};\n\t\n\t    var cy = this.cy();\n\t\n\t    // Weight function - optional\n\t    if( options.weight != null && is.fn( options.weight ) ){\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function( e ){return 1;};\n\t    }\n\t\n\t    // directed - optional\n\t    if( options.directed != null ){\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t\n\t    // mapping: node id -> position in nodes array\n\t    var id2position = {};\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      id2position[ nodes[ i ].id() ] = i;\n\t    }\n\t\n\t    // Initialize distance matrix\n\t    var dist = [];\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      var newRow = new Array( numNodes );\n\t      for( var j = 0; j < numNodes; j++ ){\n\t        if( i == j ){\n\t          newRow[ j ] = 0;\n\t        } else {\n\t          newRow[ j ] = Infinity;\n\t        }\n\t      }\n\t      dist.push( newRow );\n\t    }\n\t\n\t    // Initialize matrix used for path reconstruction\n\t    // Initialize distance matrix\n\t    var next = [];\n\t    var edgeNext = [];\n\t\n\t    var initMatrix = function( next ){\n\t      for( var i = 0; i < numNodes; i++ ){\n\t        var newRow = new Array( numNodes );\n\t        for( var j = 0; j < numNodes; j++ ){\n\t          newRow[ j ] = undefined;\n\t        }\n\t        next.push( newRow );\n\t      }\n\t    };\n\t\n\t    initMatrix( next );\n\t    initMatrix( edgeNext );\n\t\n\t    // Process edges\n\t    for( var i = 0; i < edges.length ; i++ ){\n\t      var sourceIndex = id2position[ edges[ i ].source().id() ];\n\t      var targetIndex = id2position[ edges[ i ].target().id() ];\n\t      var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );\n\t\n\t      // Check if already process another edge between same 2 nodes\n\t      if( dist[ sourceIndex ][ targetIndex ] > weight ){\n\t        dist[ sourceIndex ][ targetIndex ] = weight;\n\t        next[ sourceIndex ][ targetIndex ] = targetIndex;\n\t        edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];\n\t      }\n\t    }\n\t\n\t    // If undirected graph, process 'reversed' edges\n\t    if( !directed ){\n\t      for( var i = 0; i < edges.length ; i++ ){\n\t        var sourceIndex = id2position[ edges[ i ].target().id() ];\n\t        var targetIndex = id2position[ edges[ i ].source().id() ];\n\t        var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );\n\t\n\t        // Check if already process another edge between same 2 nodes\n\t        if( dist[ sourceIndex ][ targetIndex ] > weight ){\n\t          dist[ sourceIndex ][ targetIndex ] = weight;\n\t          next[ sourceIndex ][ targetIndex ] = targetIndex;\n\t          edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];\n\t        }\n\t      }\n\t    }\n\t\n\t    // Main loop\n\t    for( var k = 0; k < numNodes; k++ ){\n\t      for( var i = 0; i < numNodes; i++ ){\n\t        for( var j = 0; j < numNodes; j++ ){\n\t          if( dist[ i ][ k ] + dist[ k ][ j ] < dist[ i ][ j ] ){\n\t            dist[ i ][ j ] = dist[ i ][ k ] + dist[ k ][ j ];\n\t            next[ i ][ j ] = next[ i ][ k ];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Build result object\n\t    var position2id = [];\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      position2id.push( nodes[ i ].id() );\n\t    }\n\t\n\t    var res = {\n\t      distance: function( from, to ){\n\t        if( is.string( from ) ){\n\t          // from is a selector string\n\t          var fromId = (cy.filter( from )[0]).id();\n\t        } else {\n\t          // from is a node\n\t          var fromId = from.id();\n\t        }\n\t\n\t        if( is.string( to ) ){\n\t          // to is a selector string\n\t          var toId = (cy.filter( to )[0]).id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t\n\t        return dist[ id2position[ fromId ] ][ id2position[ toId ] ];\n\t      },\n\t\n\t      path: function( from, to ){\n\t        var reconstructPathAux = function( from, to, next, position2id, edgeNext ){\n\t          if( from === to ){\n\t            return cy.getElementById( position2id[ from ] );\n\t          }\n\t          if( next[ from ][ to ] === undefined ){\n\t            return undefined;\n\t          }\n\t\n\t          var path = [ cy.getElementById( position2id[ from ] ) ];\n\t          var prev = from;\n\t          while( from !== to ){\n\t            prev = from;\n\t            from = next[ from ][ to ];\n\t\n\t            var edge = edgeNext[ prev ][ from ];\n\t            path.push( edge );\n\t\n\t            path.push( cy.getElementById( position2id[ from ] ) );\n\t          }\n\t          return path;\n\t        };\n\t\n\t        if( is.string( from ) ){\n\t          // from is a selector string\n\t          var fromId = (cy.filter( from )[0]).id();\n\t        } else {\n\t          // from is a node\n\t          var fromId = from.id();\n\t        }\n\t\n\t        if( is.string( to ) ){\n\t          // to is a selector string\n\t          var toId = (cy.filter( to )[0]).id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t\n\t        var pathArr = reconstructPathAux( id2position[ fromId ],\n\t                      id2position[ toId ],\n\t                      next,\n\t                      position2id,\n\t                      edgeNext );\n\t\n\t        return cy.collection( pathArr );\n\t      }\n\t    };\n\t\n\t    return res;\n\t\n\t  } // floydWarshall\n\t\n\t}); // elesfn\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar elesfn = ({\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  bellmanFord: function( options ){\n\t    var eles = this;\n\t\n\t    options = options || {};\n\t\n\t    // Weight function - optional\n\t    if( options.weight != null && is.fn( options.weight ) ){\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function( e ){return 1;};\n\t    }\n\t\n\t    // directed - optional\n\t    if( options.directed != null ){\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    // root - mandatory!\n\t    if( options.root != null ){\n\t      if( is.string( options.root ) ){\n\t        // use it as a selector, e.g. \"#rootID\n\t        var source = this.filter( options.root )[0];\n\t      } else {\n\t        var source = options.root[0];\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    var cy = this._private.cy;\n\t    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t\n\t    // mapping: node id -> position in nodes array\n\t    var id2position = {};\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      id2position[ nodes[ i ].id() ] = i;\n\t    }\n\t\n\t    // Initializations\n\t    var cost = [];\n\t    var predecessor = [];\n\t    var predEdge = [];\n\t\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      if( nodes[ i ].id() === source.id() ){\n\t        cost[ i ] = 0;\n\t      } else {\n\t        cost[ i ] = Infinity;\n\t      }\n\t      predecessor[ i ] = undefined;\n\t    }\n\t\n\t    // Edges relaxation\n\t    var flag = false;\n\t    for( var i = 1; i < numNodes; i++ ){\n\t      flag = false;\n\t      for( var e = 0; e < edges.length; e++ ){\n\t        var sourceIndex = id2position[ edges[ e ].source().id() ];\n\t        var targetIndex = id2position[ edges[ e ].target().id() ];\n\t        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );\n\t\n\t        var temp = cost[ sourceIndex ] + weight;\n\t        if( temp < cost[ targetIndex ] ){\n\t          cost[ targetIndex ] = temp;\n\t          predecessor[ targetIndex ] = sourceIndex;\n\t          predEdge[ targetIndex ] = edges[ e ];\n\t          flag = true;\n\t        }\n\t\n\t        // If undirected graph, we need to take into account the 'reverse' edge\n\t        if( !directed ){\n\t          var temp = cost[ targetIndex ] + weight;\n\t          if( temp < cost[ sourceIndex ] ){\n\t            cost[ sourceIndex ] = temp;\n\t            predecessor[ sourceIndex ] = targetIndex;\n\t            predEdge[ sourceIndex ] = edges[ e ];\n\t            flag = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if( !flag ){\n\t        break;\n\t      }\n\t    }\n\t\n\t    if( flag ){\n\t      // Check for negative weight cycles\n\t      for( var e = 0; e < edges.length; e++ ){\n\t        var sourceIndex = id2position[ edges[ e ].source().id() ];\n\t        var targetIndex = id2position[ edges[ e ].target().id() ];\n\t        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );\n\t\n\t        if( cost[ sourceIndex ] + weight < cost[ targetIndex ] ){\n\t          util.error( 'Graph contains a negative weight cycle for Bellman-Ford' );\n\t          return { pathTo: undefined,\n\t               distanceTo: undefined,\n\t               hasNegativeWeightCycle: true};\n\t        }\n\t      }\n\t    }\n\t\n\t    // Build result object\n\t    var position2id = [];\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      position2id.push( nodes[ i ].id() );\n\t    }\n\t\n\t\n\t    var res = {\n\t      distanceTo: function( to ){\n\t        if( is.string( to ) ){\n\t          // to is a selector string\n\t          var toId = (cy.filter( to )[0]).id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t\n\t        return cost[ id2position[ toId ] ];\n\t      },\n\t\n\t      pathTo: function( to ){\n\t\n\t        var reconstructPathAux = function( predecessor, fromPos, toPos, position2id, acumPath, predEdge ){\n\t          for( ;; ){\n\t            // Add toId to path\n\t            acumPath.push( cy.getElementById( position2id[ toPos ] ) );\n\t            acumPath.push( predEdge[ toPos ] );\n\t\n\t            if( fromPos === toPos ){\n\t              // reached starting node\n\t              return acumPath;\n\t            }\n\t\n\t            // If no path exists, discart acumulated path and return undefined\n\t            var predPos = predecessor[ toPos ];\n\t            if( typeof predPos === 'undefined' ){\n\t              return undefined;\n\t            }\n\t\n\t            toPos = predPos;\n\t          }\n\t\n\t        };\n\t\n\t        if( is.string( to ) ){\n\t          // to is a selector string\n\t          var toId = (cy.filter( to )[0]).id();\n\t        } else {\n\t          // to is a node\n\t          var toId = to.id();\n\t        }\n\t        var path = [];\n\t\n\t        // This returns a reversed path\n\t        var res =  reconstructPathAux( predecessor,\n\t                      id2position[ source.id() ],\n\t                      id2position[ toId ],\n\t                      position2id,\n\t                      path,\n\t                      predEdge );\n\t\n\t        // Get it in the correct order and return it\n\t        if( res != null ){\n\t          res.reverse();\n\t        }\n\t\n\t        return eles.spawn( res );\n\t      },\n\t\n\t      hasNegativeWeightCycle: false\n\t    };\n\t\n\t    return res;\n\t\n\t  } // bellmanFord\n\t\n\t}); // elesfn\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar elesfn = ({\n\t\n\t  // Computes the minimum cut of an undirected graph\n\t  // Returns the correct answer with high probability\n\t  kargerStein: function( options ){\n\t    var eles = this;\n\t\n\t    options = options || {};\n\t\n\t    // Function which colapses 2 (meta) nodes into one\n\t    // Updates the remaining edge lists\n\t    // Receives as a paramater the edge which causes the collapse\n\t    var colapse = function( edgeIndex, nodeMap, remainingEdges ){\n\t      var edgeInfo = remainingEdges[ edgeIndex ];\n\t      var sourceIn = edgeInfo[1];\n\t      var targetIn = edgeInfo[2];\n\t      var partition1 = nodeMap[ sourceIn ];\n\t      var partition2 = nodeMap[ targetIn ];\n\t\n\t      // Delete all edges between partition1 and partition2\n\t      var newEdges = remainingEdges.filter( function( edge ){\n\t        if( nodeMap[ edge[1] ] === partition1 && nodeMap[ edge[2] ] === partition2 ){\n\t          return false;\n\t        }\n\t        if( nodeMap[ edge[1] ] === partition2 && nodeMap[ edge[2] ] === partition1 ){\n\t          return false;\n\t        }\n\t        return true;\n\t      } );\n\t\n\t      // All edges pointing to partition2 should now point to partition1\n\t      for( var i = 0; i < newEdges.length; i++ ){\n\t        var edge = newEdges[ i ];\n\t        if( edge[1] === partition2 ){ // Check source\n\t          newEdges[ i ] = edge.slice( 0 );\n\t          newEdges[ i ][1] = partition1;\n\t        } else if( edge[2] === partition2 ){ // Check target\n\t          newEdges[ i ] = edge.slice( 0 );\n\t          newEdges[ i ][2] = partition1;\n\t        }\n\t      }\n\t\n\t      // Move all nodes from partition2 to partition1\n\t      for( var i = 0; i < nodeMap.length; i++ ){\n\t        if( nodeMap[ i ] === partition2 ){\n\t          nodeMap[ i ] = partition1;\n\t        }\n\t      }\n\t\n\t      return newEdges;\n\t    };\n\t\n\t\n\t    // Contracts a graph until we reach a certain number of meta nodes\n\t    var contractUntil = function( metaNodeMap,\n\t                   remainingEdges,\n\t                   size,\n\t                   sizeLimit ){\n\t      // Stop condition\n\t      if( size <= sizeLimit ){\n\t        return remainingEdges;\n\t      }\n\t\n\t      // Choose an edge randomly\n\t      var edgeIndex = Math.floor( (Math.random() * remainingEdges.length) );\n\t\n\t      // Colapse graph based on edge\n\t      var newEdges = colapse( edgeIndex, metaNodeMap, remainingEdges );\n\t\n\t      return contractUntil( metaNodeMap,\n\t                 newEdges,\n\t                 size - 1,\n\t                 sizeLimit );\n\t    };\n\t\n\t    var cy = this._private.cy;\n\t    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t    var numEdges = edges.length;\n\t    var numIter = Math.ceil( Math.pow( Math.log( numNodes ) / Math.LN2, 2 ) );\n\t    var stopSize = Math.floor( numNodes / Math.sqrt( 2 ) );\n\t\n\t    if( numNodes < 2 ){\n\t      util.error( 'At least 2 nodes are required for Karger-Stein algorithm' );\n\t      return undefined;\n\t    }\n\t\n\t    // Create numerical identifiers for each node\n\t    // mapping: node id -> position in nodes array\n\t    // for reverse mapping, simply use nodes array\n\t    var id2position = {};\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      id2position[ nodes[ i ].id() ] = i;\n\t    }\n\t\n\t    // Now store edge destination as indexes\n\t    // Format for each edge (edge index, source node index, target node index)\n\t    var edgeIndexes = [];\n\t    for( var i = 0; i < numEdges; i++ ){\n\t      var e = edges[ i ];\n\t      edgeIndexes.push( [ i, id2position[ e.source().id() ], id2position[ e.target().id() ] ] );\n\t    }\n\t\n\t    // We will store the best cut found here\n\t    var minCutSize = Infinity;\n\t    var minCut;\n\t\n\t    // Initial meta node partition\n\t    var originalMetaNode = [];\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      originalMetaNode.push( i );\n\t    }\n\t\n\t    // Main loop\n\t    for( var iter = 0; iter <= numIter; iter++ ){\n\t      // Create new meta node partition\n\t      var metaNodeMap = originalMetaNode.slice( 0 );\n\t\n\t      // Contract until stop point (stopSize nodes)\n\t      var edgesState = contractUntil( metaNodeMap, edgeIndexes, numNodes, stopSize );\n\t\n\t      // Create a copy of the colapsed nodes state\n\t      var metaNodeMap2 = metaNodeMap.slice( 0 );\n\t\n\t      // Run 2 iterations starting in the stop state\n\t      var res1 = contractUntil( metaNodeMap, edgesState, stopSize, 2 );\n\t      var res2 = contractUntil( metaNodeMap2, edgesState, stopSize, 2 );\n\t\n\t      // Is any of the 2 results the best cut so far?\n\t      if( res1.length <= res2.length && res1.length < minCutSize ){\n\t        minCutSize = res1.length;\n\t        minCut = [ res1, metaNodeMap ];\n\t      } else if( res2.length <= res1.length && res2.length < minCutSize ){\n\t        minCutSize = res2.length;\n\t        minCut = [ res2, metaNodeMap2 ];\n\t      }\n\t    } // end of main loop\n\t\n\t\n\t    // Construct result\n\t    var resEdges = (minCut[0]).map( function( e ){ return edges[ e[0] ]; } );\n\t    var partition1 = [];\n\t    var partition2 = [];\n\t\n\t    // traverse metaNodeMap for best cut\n\t    var witnessNodePartition = minCut[1][0];\n\t    for( var i = 0; i < minCut[1].length; i++ ){\n\t      var partitionId = minCut[1][ i ];\n\t      if( partitionId === witnessNodePartition ){\n\t        partition1.push( nodes[ i ] );\n\t      } else {\n\t        partition2.push( nodes[ i ] );\n\t      }\n\t    }\n\t\n\t    var ret = {\n\t      cut: eles.spawn( cy, resEdges ),\n\t      partition1: eles.spawn( partition1 ),\n\t      partition2: eles.spawn( partition2 )\n\t    };\n\t\n\t    return ret;\n\t  }\n\t}); // elesfn\n\t\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar elesfn = ({\n\t\n\t  pageRank: function( options ){\n\t    options = options || {};\n\t\n\t    var normalizeVector = function( vector ){\n\t      var length = vector.length;\n\t\n\t      // First, get sum of all elements\n\t      var total = 0;\n\t      for( var i = 0; i < length; i++ ){\n\t        total += vector[ i ];\n\t      }\n\t\n\t      // Now, divide each by the sum of all elements\n\t      for( var i = 0; i < length; i++ ){\n\t        vector[ i ] = vector[ i ] / total;\n\t      }\n\t    };\n\t\n\t    // dampingFactor - optional\n\t    if( options != null &&\n\t      options.dampingFactor != null ){\n\t      var dampingFactor = options.dampingFactor;\n\t    } else {\n\t      var dampingFactor = 0.8; // Default damping factor\n\t    }\n\t\n\t    // desired precision - optional\n\t    if( options != null &&\n\t      options.precision != null ){\n\t      var epsilon = options.precision;\n\t    } else {\n\t      var epsilon = 0.000001; // Default precision\n\t    }\n\t\n\t    // Max number of iterations - optional\n\t    if( options != null &&\n\t      options.iterations != null ){\n\t      var numIter = options.iterations;\n\t    } else {\n\t      var numIter = 200; // Default number of iterations\n\t    }\n\t\n\t    // Weight function - optional\n\t    if( options != null &&\n\t      options.weight != null &&\n\t      is.fn( options.weight ) ){\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function( e ){return 1;};\n\t    }\n\t\n\t    var cy = this._private.cy;\n\t    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t    var numEdges = edges.length;\n\t\n\t    // Create numerical identifiers for each node\n\t    // mapping: node id -> position in nodes array\n\t    // for reverse mapping, simply use nodes array\n\t    var id2position = {};\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      id2position[ nodes[ i ].id() ] = i;\n\t    }\n\t\n\t    // Construct transposed adjacency matrix\n\t    // First lets have a zeroed matrix of the right size\n\t    // We'll also keep track of the sum of each column\n\t    var matrix = [];\n\t    var columnSum = [];\n\t    var additionalProb = (1 - dampingFactor) / numNodes;\n\t\n\t    // Create null matric\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      var newRow = [];\n\t      for( var j = 0; j < numNodes; j++ ){\n\t        newRow.push( 0.0 );\n\t      }\n\t      matrix.push( newRow );\n\t      columnSum.push( 0.0 );\n\t    }\n\t\n\t    // Now, process edges\n\t    for( var i = 0; i < numEdges; i++ ){\n\t      var edge = edges[ i ];\n\t      var s = id2position[ edge.source().id() ];\n\t      var t = id2position[ edge.target().id() ];\n\t      var w = weightFn.apply( edge, [ edge ] );\n\t\n\t      // Update matrix\n\t      matrix[ t ][ s ] += w;\n\t\n\t      // Update column sum\n\t      columnSum[ s ] += w;\n\t    }\n\t\n\t    // Add additional probability based on damping factor\n\t    // Also, take into account columns that have sum = 0\n\t    var p = 1.0 / numNodes + additionalProb; // Shorthand\n\t    // Traverse matrix, column by column\n\t    for( var j = 0; j < numNodes; j++ ){\n\t      if( columnSum[ j ] === 0 ){\n\t        // No 'links' out from node jth, assume equal probability for each possible node\n\t        for( var i = 0; i < numNodes; i++ ){\n\t          matrix[ i ][ j ] = p;\n\t        }\n\t      } else {\n\t        // Node jth has outgoing link, compute normalized probabilities\n\t        for( var i = 0; i < numNodes; i++ ){\n\t          matrix[ i ][ j ] = matrix[ i ][ j ] / columnSum[ j ] + additionalProb;\n\t        }\n\t      }\n\t    }\n\t\n\t    // Compute dominant eigenvector using power method\n\t    var eigenvector = [];\n\t    var nullVector = [];\n\t    var previous;\n\t\n\t    // Start with a vector of all 1's\n\t    // Also, initialize a null vector which will be used as shorthand\n\t    for( var i = 0; i < numNodes; i++ ){\n\t      eigenvector.push( 1.0 );\n\t      nullVector.push( 0.0 );\n\t    }\n\t\n\t    for( var iter = 0; iter < numIter; iter++ ){\n\t      // New array with all 0's\n\t      var temp = nullVector.slice( 0 );\n\t\n\t      // Multiply matrix with previous result\n\t      for( var i = 0; i < numNodes; i++ ){\n\t        for( var j = 0; j < numNodes; j++ ){\n\t          temp[ i ] += matrix[ i ][ j ] * eigenvector[ j ];\n\t        }\n\t      }\n\t\n\t      normalizeVector( temp );\n\t      previous = eigenvector;\n\t      eigenvector = temp;\n\t\n\t      var diff = 0;\n\t      // Compute difference (squared module) of both vectors\n\t      for( var i = 0; i < numNodes; i++ ){\n\t        diff += Math.pow( previous[ i ] - eigenvector[ i ], 2 );\n\t      }\n\t\n\t      // If difference is less than the desired threshold, stop iterating\n\t      if( diff < epsilon ){\n\t        break;\n\t      }\n\t    }\n\t\n\t    // Construct result\n\t    var res = {\n\t      rank: function( node ){\n\t        if( is.string( node ) ){\n\t          // is a selector string\n\t          var nodeId = (cy.filter( node )[0]).id();\n\t        } else {\n\t          // is a node object\n\t          var nodeId = node.id();\n\t        }\n\t        return eigenvector[ id2position[ nodeId ] ];\n\t      }\n\t    };\n\t\n\t\n\t    return res;\n\t  } // pageRank\n\t\n\t}); // elesfn\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar elesfn = ({\n\t\n\t  degreeCentralityNormalized: function( options ){\n\t    options = options || {};\n\t\n\t    var cy = this.cy();\n\t\n\t    // directed - optional\n\t    if( options.directed != null ){\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var nodes = this.nodes();\n\t    var numNodes = nodes.length;\n\t\n\t    if( !directed ){\n\t      var degrees = {};\n\t      var maxDegree = 0;\n\t\n\t      for( var i = 0; i < numNodes; i++ ){\n\t        var node = nodes[ i ];\n\t        // add current node to the current options object and call degreeCentrality\n\t        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );\n\t        if( maxDegree < currDegree.degree )\n\t          maxDegree = currDegree.degree;\n\t\n\t        degrees[ node.id() ] = currDegree.degree;\n\t      }\n\t\n\t      return {\n\t        degree: function( node ){\n\t          if( is.string( node ) ){\n\t            // from is a selector string\n\t            var node = (cy.filter( node )[0]).id();\n\t          } else {\n\t            // from is a node\n\t            var node = node.id();\n\t          }\n\t\n\t          return degrees[ node ] / maxDegree;\n\t        }\n\t      };\n\t    } else {\n\t      var indegrees = {};\n\t      var outdegrees = {};\n\t      var maxIndegree = 0;\n\t      var maxOutdegree = 0;\n\t\n\t      for( var i = 0; i < numNodes; i++ ){\n\t        var node = nodes[ i ];\n\t        // add current node to the current options object and call degreeCentrality\n\t        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );\n\t\n\t        if( maxIndegree < currDegree.indegree )\n\t          maxIndegree = currDegree.indegree;\n\t\n\t        if( maxOutdegree < currDegree.outdegree )\n\t          maxOutdegree = currDegree.outdegree;\n\t\n\t        indegrees[ node.id() ] = currDegree.indegree;\n\t        outdegrees[ node.id() ] = currDegree.outdegree;\n\t      }\n\t\n\t      return {\n\t        indegree: function( node ){\n\t          if( is.string( node ) ){\n\t            // from is a selector string\n\t            var node = (cy.filter( node )[0]).id();\n\t          } else {\n\t            // from is a node\n\t            var node = node.id();\n\t          }\n\t\n\t          return indegrees[ node ] / maxIndegree;\n\t        },\n\t        outdegree: function( node ){\n\t          if( is.string( node ) ){\n\t            // from is a selector string\n\t            var node = (cy.filter( node )[0]).id();\n\t          } else {\n\t            // from is a node\n\t            var node = node.id();\n\t          }\n\t\n\t          return outdegrees[ node ] / maxOutdegree;\n\t        }\n\t\n\t      };\n\t    }\n\t\n\t  }, // degreeCentralityNormalized\n\t\n\t  // Implemented from the algorithm in Opsahl's paper\n\t  // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n\t  // check the heading 2 \"Degree\"\n\t  degreeCentrality: function( options ){\n\t    options = options || {};\n\t\n\t    var callingEles = this;\n\t\n\t    // root - mandatory!\n\t    if( options != null && options.root != null ){\n\t      var root = is.string( options.root ) ? this.filter( options.root )[0] : options.root[0];\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // weight - optional\n\t    if( options.weight != null && is.fn( options.weight ) ){\n\t      var weightFn = options.weight;\n\t    } else {\n\t      // If not specified, assume each edge has equal weight (1)\n\t      var weightFn = function( e ){\n\t        return 1;\n\t      };\n\t    }\n\t\n\t    // directed - optional\n\t    if( options.directed != null ){\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    // alpha - optional\n\t    if( options.alpha != null && is.number( options.alpha ) ){\n\t      var alpha = options.alpha;\n\t    } else {\n\t      alpha = 0;\n\t    }\n\t\n\t\n\t    if( !directed ){\n\t      var connEdges = root.connectedEdges().intersection( callingEles );\n\t      var k = connEdges.length;\n\t      var s = 0;\n\t\n\t      // Now, sum edge weights\n\t      for( var i = 0; i < connEdges.length; i++ ){\n\t        var edge = connEdges[ i ];\n\t        s += weightFn.apply( edge, [ edge ] );\n\t      }\n\t\n\t      return {\n\t        degree: Math.pow( k, 1 - alpha ) * Math.pow( s, alpha )\n\t      };\n\t    } else {\n\t      var incoming = root.connectedEdges( 'edge[target = \"' + root.id() + '\"]' ).intersection( callingEles );\n\t      var outgoing = root.connectedEdges( 'edge[source = \"' + root.id() + '\"]' ).intersection( callingEles );\n\t      var k_in = incoming.length;\n\t      var k_out = outgoing.length;\n\t      var s_in = 0;\n\t      var s_out = 0;\n\t\n\t      // Now, sum incoming edge weights\n\t      for( var i = 0; i < incoming.length; i++ ){\n\t        var edge = incoming[ i ];\n\t        s_in += weightFn.apply( edge, [ edge ] );\n\t      }\n\t\n\t      // Now, sum outgoing edge weights\n\t      for( var i = 0; i < outgoing.length; i++ ){\n\t        var edge = outgoing[ i ];\n\t        s_out += weightFn.apply( edge, [ edge ] );\n\t      }\n\t\n\t      return {\n\t        indegree: Math.pow( k_in, 1 - alpha ) * Math.pow( s_in, alpha ),\n\t        outdegree: Math.pow( k_out, 1 - alpha ) * Math.pow( s_out, alpha )\n\t      };\n\t    }\n\t  } // degreeCentrality\n\t\n\t}); // elesfn\n\t\n\t// nice, short mathemathical alias\n\telesfn.dc = elesfn.degreeCentrality;\n\telesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar elesfn = ({\n\t\n\t  closenessCentralityNormalized: function( options ){\n\t    options = options || {};\n\t\n\t    var cy = this.cy();\n\t\n\t    var harmonic = options.harmonic;\n\t    if( harmonic === undefined ){\n\t      harmonic = true;\n\t    }\n\t\n\t    var closenesses = {};\n\t    var maxCloseness = 0;\n\t    var nodes = this.nodes();\n\t    var fw = this.floydWarshall( { weight: options.weight, directed: options.directed } );\n\t\n\t    // Compute closeness for every node and find the maximum closeness\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      var currCloseness = 0;\n\t      for( var j = 0; j < nodes.length; j++ ){\n\t        if( i != j ){\n\t          var d = fw.distance( nodes[ i ], nodes[ j ] );\n\t\n\t          if( harmonic ){\n\t            currCloseness += 1 / d;\n\t          } else {\n\t            currCloseness += d;\n\t          }\n\t        }\n\t      }\n\t\n\t      if( !harmonic ){\n\t        currCloseness = 1 / currCloseness;\n\t      }\n\t\n\t      if( maxCloseness < currCloseness ){\n\t        maxCloseness = currCloseness;\n\t      }\n\t\n\t      closenesses[ nodes[ i ].id() ] = currCloseness;\n\t    }\n\t\n\t    return {\n\t      closeness: function( node ){\n\t        if( is.string( node ) ){\n\t          // from is a selector string\n\t          var node = (cy.filter( node )[0]).id();\n\t        } else {\n\t          // from is a node\n\t          var node = node.id();\n\t        }\n\t\n\t        return closenesses[ node ] / maxCloseness;\n\t      }\n\t    };\n\t  },\n\t\n\t  // Implemented from pseudocode from wikipedia\n\t  closenessCentrality: function( options ){\n\t    options = options || {};\n\t\n\t    // root - mandatory!\n\t    if( options.root != null ){\n\t      if( is.string( options.root ) ){\n\t        // use it as a selector, e.g. \"#rootID\n\t        var root = this.filter( options.root )[0];\n\t      } else {\n\t        var root = options.root[0];\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t\n\t    // weight - optional\n\t    if( options.weight != null && is.fn( options.weight ) ){\n\t      var weight = options.weight;\n\t    } else {\n\t      var weight = function(){return 1;};\n\t    }\n\t\n\t    // directed - optional\n\t    if( options.directed != null && is.bool( options.directed ) ){\n\t      var directed = options.directed;\n\t    } else {\n\t      var directed = false;\n\t    }\n\t\n\t    var harmonic = options.harmonic;\n\t    if( harmonic === undefined ){\n\t      harmonic = true;\n\t    }\n\t\n\t    // we need distance from this node to every other node\n\t    var dijkstra = this.dijkstra( {\n\t      root: root,\n\t      weight: weight,\n\t      directed: directed\n\t    } );\n\t    var totalDistance = 0;\n\t\n\t    var nodes = this.nodes();\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      if( nodes[ i ].id() != root.id() ){\n\t        var d = dijkstra.distanceTo( nodes[ i ] );\n\t\n\t        if( harmonic ){\n\t          totalDistance += 1 / d;\n\t        } else {\n\t          totalDistance += d;\n\t        }\n\t      }\n\t    }\n\t\n\t    return harmonic ? totalDistance : 1 / totalDistance;\n\t  } // closenessCentrality\n\t\n\t}); // elesfn\n\t\n\t// nice, short mathemathical alias\n\telesfn.cc = elesfn.closenessCentrality;\n\telesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar Heap = __webpack_require__( 45 );\n\t\n\tvar elesfn = ({\n\t\n\t  // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n\t  betweennessCentrality: function( options ){\n\t    options = options || {};\n\t\n\t    // Weight - optional\n\t    var weighted, weightFn;\n\t    if( is.fn( options.weight ) ){\n\t      weightFn = options.weight;\n\t      weighted = true;\n\t    } else {\n\t      weighted = false;\n\t    }\n\t\n\t    // Directed - default false\n\t    var directed = options.directed != null ? options.directed : false;\n\t\n\t    var cy = this._private.cy;\n\t\n\t    // starting\n\t    var V = this.nodes();\n\t    var A = {};\n\t    var _C = {};\n\t    var max;\n\t    var C = {\n\t      set: function( key, val ){\n\t        _C[ key ] = val;\n\t\n\t        if( val > max ){ max = val; }\n\t      },\n\t\n\t      get: function( key ){ return _C[ key ]; }\n\t    };\n\t\n\t    // A contains the neighborhoods of every node\n\t    for( var i = 0; i < V.length; i++ ){\n\t      var v = V[ i ];\n\t      var vid = v.id();\n\t\n\t      if( directed ){\n\t        A[ vid ] = v.outgoers().nodes(); // get outgoers of every node\n\t      } else {\n\t        A[ vid ] = v.openNeighborhood().nodes(); // get neighbors of every node\n\t      }\n\t\n\t      C.set( vid, 0 );\n\t    }\n\t\n\t    for( var s = 0; s < V.length; s++ ){\n\t      var sid = V[s].id();\n\t      var S = []; // stack\n\t      var P = {};\n\t      var g = {};\n\t      var d = {};\n\t      var Q = new Heap(function( a, b ){\n\t        return d[a] - d[b];\n\t      }); // queue\n\t\n\t      // init dictionaries\n\t      for( var i = 0; i < V.length; i++ ){\n\t        var vid = V[ i ].id();\n\t\n\t        P[ vid ] = [];\n\t        g[ vid ] = 0;\n\t        d[ vid ] = Infinity;\n\t      }\n\t\n\t      g[ sid ] = 1; // sigma\n\t      d[ sid ] = 0; // distance to s\n\t\n\t      Q.push( sid );\n\t\n\t      while( !Q.empty() ){\n\t        var v = Q.pop();\n\t\n\t        S.push( v );\n\t\n\t        if( weighted ){\n\t          for( var j = 0; j < A[v].length; j++ ){\n\t            var w = A[v][j];\n\t            var vEle = cy.getElementById( v );\n\t\n\t            var edge;\n\t            if( vEle.edgesTo( w ).length > 0 ){\n\t              edge = vEle.edgesTo( w )[0];\n\t            } else {\n\t              edge = w.edgesTo( vEle )[0];\n\t            }\n\t\n\t            var edgeWeight = weightFn.apply( edge, [ edge ] );\n\t\n\t            w = w.id();\n\t\n\t            if( d[w] > d[v] + edgeWeight ){\n\t              d[w] = d[v] + edgeWeight;\n\t\n\t              if( Q.nodes.indexOf( w ) < 0 ){ //if w is not in Q\n\t                Q.push( w );\n\t              } else { // update position if w is in Q\n\t                Q.updateItem( w );\n\t              }\n\t\n\t              g[w] = 0;\n\t              P[w] = [];\n\t            }\n\t\n\t            if( d[w] == d[v] + edgeWeight ){\n\t              g[w] = g[w] + g[v];\n\t              P[w].push( v );\n\t            }\n\t          }\n\t        } else {\n\t          for( var j = 0; j < A[v].length; j++ ){\n\t            var w = A[v][j].id();\n\t\n\t            if( d[w] == Infinity ){\n\t              Q.push( w );\n\t\n\t              d[w] = d[v] + 1;\n\t            }\n\t\n\t            if( d[w] == d[v] + 1 ){\n\t              g[w] = g[w] + g[v];\n\t              P[w].push( v );\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      var e = {};\n\t      for( var i = 0; i < V.length; i++ ){\n\t        e[ V[ i ].id() ] = 0;\n\t      }\n\t\n\t      while( S.length > 0 ){\n\t        var w = S.pop();\n\t\n\t        for( var j = 0; j < P[w].length; j++ ){\n\t          var v = P[w][j];\n\t\n\t          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);\n\t\n\t          if( w != V[s].id() ){\n\t            C.set( w, C.get( w ) + e[w] );\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    var ret = {\n\t      betweenness: function( node ){\n\t        if( is.string( node ) ){\n\t          var node = cy.filter( node ).id();\n\t        } else {\n\t          var node = node.id();\n\t        }\n\t\n\t        return C.get( node );\n\t      },\n\t\n\t      betweennessNormalized: function( node ){\n\t        if( is.string( node ) ){\n\t          var node = cy.filter( node ).id();\n\t        } else {\n\t          var node = node.id();\n\t        }\n\t\n\t        return C.get( node ) / max;\n\t      }\n\t    };\n\t\n\t    // alias\n\t    ret.betweennessNormalised = ret.betweennessNormalized;\n\t\n\t    return ret;\n\t  } // betweennessCentrality\n\t\n\t}); // elesfn\n\t\n\t// nice, short mathemathical alias\n\telesfn.bc = elesfn.betweennessCentrality;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar define = __webpack_require__( 56 );\n\t\n\tvar elesfn = ({\n\t  animate: define.animate(),\n\t  animation: define.animation(),\n\t  animated: define.animated(),\n\t  clearQueue: define.clearQueue(),\n\t  delay: define.delay(),\n\t  delayAnimation: define.delayAnimation(),\n\t  stop: define.stop()\n\t});\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// use this module to cherry pick functions into your prototype\n\t// (useful for functions shared between the core and collections, for example)\n\t\n\t// e.g.\n\t// var foo = define.foo({ /* params... */ })\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\tvar Selector = __webpack_require__( 57 );\n\tvar Promise = __webpack_require__( 58 );\n\tvar Event = __webpack_require__( 60 );\n\tvar Animation = __webpack_require__( 61 );\n\t\n\tvar define = {\n\t\n\t  // access data field\n\t  data: function( params ){\n\t    var defaults = {\n\t      field: 'data',\n\t      bindingEvent: 'data',\n\t      allowBinding: false,\n\t      allowSetting: false,\n\t      allowGetting: false,\n\t      settingEvent: 'data',\n\t      settingTriggersEvent: false,\n\t      triggerFnName: 'trigger',\n\t      immutableKeys: {}, // key => true if immutable\n\t      updateStyle: false,\n\t      onSet: function( self ){},\n\t      canSet: function( self ){ return true; }\n\t    };\n\t    params = util.extend( {}, defaults, params );\n\t\n\t    return function dataImpl( name, value ){\n\t      var p = params;\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var single = selfIsArrayLike ? self[0] : self;\n\t\n\t      // .data('foo', ...)\n\t      if( is.string( name ) ){ // set or get property\n\t\n\t        // .data('foo')\n\t        if( p.allowGetting && value === undefined ){ // get\n\t\n\t          var ret;\n\t          if( single ){\n\t            ret = single._private[ p.field ][ name ];\n\t          }\n\t          return ret;\n\t\n\t        // .data('foo', 'bar')\n\t        } else if( p.allowSetting && value !== undefined ){ // set\n\t          var valid = !p.immutableKeys[ name ];\n\t          if( valid ){\n\t            for( var i = 0, l = all.length; i < l; i++ ){\n\t              if( p.canSet( all[ i ] ) ){\n\t                all[ i ]._private[ p.field ][ name ] = value;\n\t              }\n\t            }\n\t\n\t            // update mappers if asked\n\t            if( p.updateStyle ){ self.updateStyle(); }\n\t\n\t            // call onSet callback\n\t            p.onSet( self );\n\t\n\t            if( p.settingTriggersEvent ){\n\t              self[ p.triggerFnName ]( p.settingEvent );\n\t            }\n\t          }\n\t        }\n\t\n\t      // .data({ 'foo': 'bar' })\n\t      } else if( p.allowSetting && is.plainObject( name ) ){ // extend\n\t        var obj = name;\n\t        var k, v;\n\t        var keys = Object.keys( obj );\n\t\n\t        for( var i = 0; i < keys.length; i++ ){\n\t          k = keys[ i ];\n\t          v = obj[ k ];\n\t\n\t          var valid = !p.immutableKeys[ k ];\n\t          if( valid ){\n\t            for( var j = 0; j < all.length; j++ ){\n\t              var ele = all[j];\n\t\n\t              if( p.canSet( ele ) ){\n\t                ele._private[ p.field ][ k ] = v;\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        // update mappers if asked\n\t        if( p.updateStyle ){ self.updateStyle(); }\n\t\n\t        // call onSet callback\n\t        p.onSet( self );\n\t\n\t        if( p.settingTriggersEvent ){\n\t          self[ p.triggerFnName ]( p.settingEvent );\n\t        }\n\t\n\t      // .data(function(){ ... })\n\t      } else if( p.allowBinding && is.fn( name ) ){ // bind to event\n\t        var fn = name;\n\t        self.on( p.bindingEvent, fn );\n\t\n\t      // .data()\n\t      } else if( p.allowGetting && name === undefined ){ // get whole object\n\t        var ret;\n\t        if( single ){\n\t          ret = single._private[ p.field ];\n\t        }\n\t        return ret;\n\t      }\n\t\n\t      return self; // maintain chainability\n\t    }; // function\n\t  }, // data\n\t\n\t  // remove data field\n\t  removeData: function( params ){\n\t    var defaults = {\n\t      field: 'data',\n\t      event: 'data',\n\t      triggerFnName: 'trigger',\n\t      triggerEvent: false,\n\t      immutableKeys: {} // key => true if immutable\n\t    };\n\t    params = util.extend( {}, defaults, params );\n\t\n\t    return function removeDataImpl( names ){\n\t      var p = params;\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t\n\t      // .removeData('foo bar')\n\t      if( is.string( names ) ){ // then get the list of keys, and delete them\n\t        var keys = names.split( /\\s+/ );\n\t        var l = keys.length;\n\t\n\t        for( var i = 0; i < l; i++ ){ // delete each non-empty key\n\t          var key = keys[ i ];\n\t          if( is.emptyString( key ) ){ continue; }\n\t\n\t          var valid = !p.immutableKeys[ key ]; // not valid if immutable\n\t          if( valid ){\n\t            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n\t              all[ i_a ]._private[ p.field ][ key ] = undefined;\n\t            }\n\t          }\n\t        }\n\t\n\t        if( p.triggerEvent ){\n\t          self[ p.triggerFnName ]( p.event );\n\t        }\n\t\n\t      // .removeData()\n\t      } else if( names === undefined ){ // then delete all keys\n\t\n\t        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n\t          var _privateFields = all[ i_a ]._private[ p.field ];\n\t          var keys = Object.keys( _privateFields );\n\t\n\t          for( var i = 0; i < keys.length; i++ ){\n\t            var key = keys[i];\n\t            var validKeyToDelete = !p.immutableKeys[ key ];\n\t\n\t            if( validKeyToDelete ){\n\t              _privateFields[ key ] = undefined;\n\t            }\n\t          }\n\t        }\n\t\n\t        if( p.triggerEvent ){\n\t          self[ p.triggerFnName ]( p.event );\n\t        }\n\t      }\n\t\n\t      return self; // maintain chaining\n\t    }; // function\n\t  }, // removeData\n\t\n\t  // event function reusable stuff\n\t  event: {\n\t    regex: /(\\w+)(\\.(?:\\w+|\\*))?/, // regex for matching event strings (e.g. \"click.namespace\")\n\t    universalNamespace: '.*', // matches as if no namespace specified and prevents users from unbinding accidentally\n\t    optionalTypeRegex: /(\\w+)?(\\.(?:\\w+|\\*))?/,\n\t    falseCallback: function(){ return false; }\n\t  },\n\t\n\t  // event binding\n\t  on: function( params ){\n\t    var defaults = {\n\t      unbindSelfOnTrigger: false,\n\t      unbindAllBindersOnTrigger: false\n\t    };\n\t    params = util.extend( {}, defaults, params );\n\t\n\t    return function onImpl( events, selector, data, callback ){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var eventsIsString = is.string( events );\n\t      var p = params;\n\t\n\t      if( is.plainObject( selector ) ){ // selector is actually data\n\t        callback = data;\n\t        data = selector;\n\t        selector = undefined;\n\t      } else if( is.fn( selector ) || selector === false ){ // selector is actually callback\n\t        callback = selector;\n\t        data = undefined;\n\t        selector = undefined;\n\t      }\n\t\n\t      if( is.fn( data ) || data === false ){ // data is actually callback\n\t        callback = data;\n\t        data = undefined;\n\t      }\n\t\n\t      // if there isn't a callback, we can't really do anything\n\t      // (can't speak for mapped events arg version)\n\t      if( !(is.fn( callback ) || callback === false) && eventsIsString ){\n\t        return self; // maintain chaining\n\t      }\n\t\n\t      if( eventsIsString ){ // then convert to map\n\t        var map = {};\n\t        map[ events ] = callback;\n\t        events = map;\n\t      }\n\t\n\t      var keys = Object.keys( events );\n\t\n\t      for( var k = 0; k < keys.length; k++ ){\n\t        var evts = keys[k];\n\t\n\t        callback = events[ evts ];\n\t        if( callback === false ){\n\t          callback = define.event.falseCallback;\n\t        }\n\t\n\t        if( !is.fn( callback ) ){ continue; }\n\t\n\t        evts = evts.split( /\\s+/ );\n\t        for( var i = 0; i < evts.length; i++ ){\n\t          var evt = evts[ i ];\n\t          if( is.emptyString( evt ) ){ continue; }\n\t\n\t          var match = evt.match( define.event.regex ); // type[.namespace]\n\t\n\t          if( match ){\n\t            var type = match[1];\n\t            var namespace = match[2] ? match[2] : undefined;\n\t\n\t            var listener = {\n\t              callback: callback, // callback to run\n\t              data: data, // extra data in eventObj.data\n\t              delegated: selector ? true : false, // whether the evt is delegated\n\t              selector: selector, // the selector to match for delegated events\n\t              selObj: new Selector( selector ), // cached selector object to save rebuilding\n\t              type: type, // the event type (e.g. 'click')\n\t              namespace: namespace, // the event namespace (e.g. \".foo\")\n\t              unbindSelfOnTrigger: p.unbindSelfOnTrigger,\n\t              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,\n\t              binders: all // who bound together\n\t            };\n\t\n\t            for( var j = 0; j < all.length; j++ ){\n\t              var _p = all[ j ]._private = all[ j ]._private || {};\n\t\n\t              _p.listeners = _p.listeners || [];\n\t              _p.listeners.push( listener );\n\t            }\n\t          }\n\t        } // for events array\n\t      } // for events map\n\t\n\t      return self; // maintain chaining\n\t    }; // function\n\t  }, // on\n\t\n\t  eventAliasesOn: function( proto ){\n\t    var p = proto;\n\t\n\t    p.addListener = p.listen = p.bind = p.on;\n\t    p.removeListener = p.unlisten = p.unbind = p.off;\n\t    p.emit = p.trigger;\n\t\n\t    // this is just a wrapper alias of .on()\n\t    p.pon = p.promiseOn = function( events, selector ){\n\t      var self = this;\n\t      var args = Array.prototype.slice.call( arguments, 0 );\n\t\n\t      return new Promise( function( resolve, reject ){\n\t        var callback = function( e ){\n\t          self.off.apply( self, offArgs );\n\t\n\t          resolve( e );\n\t        };\n\t\n\t        var onArgs = args.concat( [ callback ] );\n\t        var offArgs = onArgs.concat( [] );\n\t\n\t        self.on.apply( self, onArgs );\n\t      } );\n\t    };\n\t  },\n\t\n\t  off: function offImpl( params ){\n\t    var defaults = {\n\t    };\n\t    params = util.extend( {}, defaults, params );\n\t\n\t    return function( events, selector, callback ){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var eventsIsString = is.string( events );\n\t\n\t      if( arguments.length === 0 ){ // then unbind all\n\t\n\t        for( var i = 0; i < all.length; i++ ){\n\t          all[ i ]._private = all[ i ]._private || {};\n\t\n\t          _p.listeners = [];\n\t        }\n\t\n\t        return self; // maintain chaining\n\t      }\n\t\n\t      if( is.fn( selector ) || selector === false ){ // selector is actually callback\n\t        callback = selector;\n\t        selector = undefined;\n\t      }\n\t\n\t      if( eventsIsString ){ // then convert to map\n\t        var map = {};\n\t        map[ events ] = callback;\n\t        events = map;\n\t      }\n\t\n\t      var keys = Object.keys( events );\n\t\n\t      for( var k = 0; k < keys.length; k++ ){\n\t        var evts = keys[k];\n\t\n\t        callback = events[ evts ];\n\t\n\t        if( callback === false ){\n\t          callback = define.event.falseCallback;\n\t        }\n\t\n\t        evts = evts.split( /\\s+/ );\n\t        for( var h = 0; h < evts.length; h++ ){\n\t          var evt = evts[ h ];\n\t          if( is.emptyString( evt ) ){ continue; }\n\t\n\t          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]\n\t          if( match ){\n\t            var type = match[1] ? match[1] : undefined;\n\t            var namespace = match[2] ? match[2] : undefined;\n\t\n\t            for( var i = 0; i < all.length; i++ ){ //\n\t              var _p = all[ i ]._private = all[ i ]._private || {};\n\t              var listeners = _p.listeners = _p.listeners || [];\n\t\n\t              for( var j = 0; j < listeners.length; j++ ){\n\t                var listener = listeners[ j ];\n\t                var nsMatches = !namespace || namespace === listener.namespace;\n\t                var typeMatches = !type || listener.type === type;\n\t                var cbMatches = !callback || callback === listener.callback;\n\t                var listenerMatches = nsMatches && typeMatches && cbMatches;\n\t\n\t                // delete listener if it matches\n\t                if( listenerMatches ){\n\t                  listeners.splice( j, 1 );\n\t                  j--;\n\t                }\n\t              } // for listeners\n\t            } // for all\n\t          } // if match\n\t        } // for events array\n\t\n\t      } // for events map\n\t\n\t      return self; // maintain chaining\n\t    }; // function\n\t  }, // off\n\t\n\t  trigger: function( params ){\n\t    var defaults = {};\n\t    params = util.extend( {}, defaults, params );\n\t\n\t    return function triggerImpl( events, extraParams, fnToTrigger ){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var eventsIsString = is.string( events );\n\t      var eventsIsObject = is.plainObject( events );\n\t      var eventsIsEvent = is.event( events );\n\t      var _p = this._private = this._private || {};\n\t      var cy = _p.cy || ( is.core( this ) ? this : null );\n\t      var hasCompounds = cy ? cy.hasCompoundNodes() : false;\n\t\n\t      if( eventsIsString ){ // then make a plain event object for each event name\n\t        var evts = events.split( /\\s+/ );\n\t        events = [];\n\t\n\t        for( var i = 0; i < evts.length; i++ ){\n\t          var evt = evts[ i ];\n\t          if( is.emptyString( evt ) ){ continue; }\n\t\n\t          var match = evt.match( define.event.regex ); // type[.namespace]\n\t          var type = match[1];\n\t          var namespace = match[2] ? match[2] : undefined;\n\t\n\t          events.push( {\n\t            type: type,\n\t            namespace: namespace\n\t          } );\n\t        }\n\t      } else if( eventsIsObject ){ // put in length 1 array\n\t        var eventArgObj = events;\n\t\n\t        events = [ eventArgObj ];\n\t      }\n\t\n\t      if( extraParams ){\n\t        if( !is.array( extraParams ) ){ // make sure extra params are in an array if specified\n\t          extraParams = [ extraParams ];\n\t        }\n\t      } else { // otherwise, we've got nothing\n\t        extraParams = [];\n\t      }\n\t\n\t      for( var i = 0; i < events.length; i++ ){ // trigger each event in order\n\t        var evtObj = events[ i ];\n\t\n\t        for( var j = 0; j < all.length; j++ ){ // for each\n\t          var triggerer = all[ j ];\n\t          var _p = triggerer._private = triggerer._private || {};\n\t          var listeners = _p.listeners = _p.listeners || [];\n\t          var triggererIsElement = is.element( triggerer );\n\t          var bubbleUp = triggererIsElement || params.layout;\n\t\n\t          // create the event for this element from the event object\n\t          var evt;\n\t\n\t          if( eventsIsEvent ){ // then just get the object\n\t            evt = evtObj;\n\t\n\t            evt.cyTarget = evt.cyTarget || triggerer;\n\t            evt.cy = evt.cy || cy;\n\t\n\t          } else { // then we have to make one\n\t            evt = new Event( evtObj, {\n\t              cyTarget: triggerer,\n\t              cy: cy,\n\t              namespace: evtObj.namespace\n\t            } );\n\t          }\n\t\n\t          // if a layout was specified, then put it in the typed event\n\t          if( evtObj.layout ){\n\t            evt.layout = evtObj.layout;\n\t          }\n\t\n\t          // if triggered by layout, put in event\n\t          if( params.layout ){\n\t            evt.layout = triggerer;\n\t          }\n\t\n\t          // create a rendered position based on the passed position\n\t          if( evt.cyPosition ){\n\t            var pos = evt.cyPosition;\n\t            var zoom = cy.zoom();\n\t            var pan = cy.pan();\n\t\n\t            evt.cyRenderedPosition = {\n\t              x: pos.x * zoom + pan.x,\n\t              y: pos.y * zoom + pan.y\n\t            };\n\t          }\n\t\n\t          if( fnToTrigger ){ // then override the listeners list with just the one we specified\n\t            listeners = [ {\n\t              namespace: evt.namespace,\n\t              type: evt.type,\n\t              callback: fnToTrigger\n\t            } ];\n\t          }\n\t\n\t          for( var k = 0; k < listeners.length; k++ ){ // check each listener\n\t            var lis = listeners[ k ];\n\t            var nsMatches = !lis.namespace || lis.namespace === evt.namespace || lis.namespace === define.event.universalNamespace;\n\t            var typeMatches = lis.type === evt.type;\n\t            var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && is.element( evt.cyTarget ) && lis.selObj.matches( evt.cyTarget ) ) : (true); // we're not going to validate the hierarchy; that's too expensive\n\t            var listenerMatches = nsMatches && typeMatches && targetMatches;\n\t\n\t            if( listenerMatches ){ // then trigger it\n\t              var args = [ evt ];\n\t              args = args.concat( extraParams ); // add extra params to args list\n\t\n\t              if( lis.data ){ // add on data plugged into binding\n\t                evt.data = lis.data;\n\t              } else { // or clear it in case the event obj is reused\n\t                evt.data = undefined;\n\t              }\n\t\n\t              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener\n\t                listeners.splice( k, 1 );\n\t                k--;\n\t              }\n\t\n\t              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders\n\t                var binders = lis.binders;\n\t                for( var l = 0; l < binders.length; l++ ){\n\t                  var binder = binders[ l ];\n\t                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it\n\t\n\t                  var binderListeners = binder._private.listeners;\n\t                  for( var m = 0; m < binderListeners.length; m++ ){\n\t                    var binderListener = binderListeners[ m ];\n\t\n\t                    if( binderListener === lis ){ // delete listener from list\n\t                      binderListeners.splice( m, 1 );\n\t                      m--;\n\t                    }\n\t                  }\n\t                }\n\t              }\n\t\n\t              // run the callback\n\t              var context = lis.delegated ? evt.cyTarget : triggerer;\n\t              var ret = lis.callback.apply( context, args );\n\t\n\t              if( ret === false || evt.isPropagationStopped() ){\n\t                // then don't bubble\n\t                bubbleUp = false;\n\t\n\t                if( ret === false ){\n\t                  // returning false is a shorthand for stopping propagation and preventing the def. action\n\t                  evt.stopPropagation();\n\t                  evt.preventDefault();\n\t                }\n\t              }\n\t            } // if listener matches\n\t          } // for each listener\n\t\n\t          // bubble up event for elements\n\t          if( bubbleUp ){\n\t            var parent = hasCompounds ? triggerer._private.parent : null;\n\t            var hasParent = parent != null && parent.length !== 0;\n\t\n\t            if( hasParent ){ // then bubble up to parent\n\t              parent = parent[0];\n\t              parent.trigger( evt );\n\t            } else { // otherwise, bubble up to the core\n\t              cy.trigger( evt );\n\t            }\n\t          }\n\t\n\t        } // for each of all\n\t      } // for each event\n\t\n\t      return self; // maintain chaining\n\t    }; // function\n\t  }, // trigger\n\t\n\t  animated: function( fnParams ){\n\t    var defaults = {};\n\t    fnParams = util.extend( {}, defaults, fnParams );\n\t\n\t    return function animatedImpl(){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if( !cy.styleEnabled() ){ return false; }\n\t\n\t      var ele = all[0];\n\t\n\t      if( ele ){\n\t        return ele._private.animation.current.length > 0;\n\t      }\n\t    };\n\t  }, // animated\n\t\n\t  clearQueue: function( fnParams ){\n\t    var defaults = {};\n\t    fnParams = util.extend( {}, defaults, fnParams );\n\t\n\t    return function clearQueueImpl(){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if( !cy.styleEnabled() ){ return this; }\n\t\n\t      for( var i = 0; i < all.length; i++ ){\n\t        var ele = all[ i ];\n\t        ele._private.animation.queue = [];\n\t      }\n\t\n\t      return this;\n\t    };\n\t  }, // clearQueue\n\t\n\t  delay: function( fnParams ){\n\t    var defaults = {};\n\t    fnParams = util.extend( {}, defaults, fnParams );\n\t\n\t    return function delayImpl( time, complete ){\n\t      var cy = this._private.cy || this;\n\t\n\t      if( !cy.styleEnabled() ){ return this; }\n\t\n\t      return this.animate( {\n\t        delay: time,\n\t        duration: time,\n\t        complete: complete\n\t      } );\n\t    };\n\t  }, // delay\n\t\n\t  delayAnimation: function( fnParams ){\n\t    var defaults = {};\n\t    fnParams = util.extend( {}, defaults, fnParams );\n\t\n\t    return function delayAnimationImpl( time, complete ){\n\t      var cy = this._private.cy || this;\n\t\n\t      if( !cy.styleEnabled() ){ return this; }\n\t\n\t      return this.animation( {\n\t        delay: time,\n\t        duration: time,\n\t        complete: complete\n\t      } );\n\t    };\n\t  }, // delay\n\t\n\t  animation: function( fnParams ){\n\t    var defaults = {};\n\t    fnParams = util.extend( {}, defaults, fnParams );\n\t\n\t    return function animationImpl( properties, params ){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t      var isCore = !selfIsArrayLike;\n\t      var isEles = !isCore;\n\t\n\t      if( !cy.styleEnabled() ){ return this; }\n\t\n\t      var style = cy.style();\n\t\n\t      properties = util.extend( {}, properties, params );\n\t\n\t      if( properties.duration === undefined ){\n\t        properties.duration = 400;\n\t      }\n\t\n\t      switch( properties.duration ){\n\t      case 'slow':\n\t        properties.duration = 600;\n\t        break;\n\t      case 'fast':\n\t        properties.duration = 200;\n\t        break;\n\t      }\n\t\n\t      var propertiesEmpty = Object.keys( properties ).length === 0;\n\t\n\t      if( propertiesEmpty ){\n\t        return new Animation( all[0], properties ); // nothing to animate\n\t      }\n\t\n\t      if( isEles ){\n\t        properties.style = style.getPropsList( properties.style || properties.css );\n\t\n\t        properties.css = undefined;\n\t      }\n\t\n\t      if( properties.renderedPosition && isEles ){\n\t        var rpos = properties.renderedPosition;\n\t        var pan = cy.pan();\n\t        var zoom = cy.zoom();\n\t\n\t        properties.position = {\n\t          x: ( rpos.x - pan.x ) / zoom,\n\t          y: ( rpos.y - pan.y ) / zoom\n\t        };\n\t      }\n\t\n\t      // override pan w/ panBy if set\n\t      if( properties.panBy && isCore ){\n\t        var panBy = properties.panBy;\n\t        var cyPan = cy.pan();\n\t\n\t        properties.pan = {\n\t          x: cyPan.x + panBy.x,\n\t          y: cyPan.y + panBy.y\n\t        };\n\t      }\n\t\n\t      // override pan w/ center if set\n\t      var center = properties.center || properties.centre;\n\t      if( center && isCore ){\n\t        var centerPan = cy.getCenterPan( center.eles, properties.zoom );\n\t\n\t        if( centerPan ){\n\t          properties.pan = centerPan;\n\t        }\n\t      }\n\t\n\t      // override pan & zoom w/ fit if set\n\t      if( properties.fit && isCore ){\n\t        var fit = properties.fit;\n\t        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );\n\t\n\t        if( fitVp ){\n\t          properties.pan = fitVp.pan;\n\t          properties.zoom = fitVp.zoom;\n\t        }\n\t      }\n\t\n\t      return new Animation( all[0], properties );\n\t    };\n\t  }, // animate\n\t\n\t  animate: function( fnParams ){\n\t    var defaults = {};\n\t    fnParams = util.extend( {}, defaults, fnParams );\n\t\n\t    return function animateImpl( properties, params ){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if( !cy.styleEnabled() ){ return this; }\n\t\n\t      if( params ){\n\t        properties = util.extend( {}, properties, params );\n\t      }\n\t\n\t      // manually hook and run the animation\n\t      for( var i = 0; i < all.length; i++ ){\n\t        var ele = all[ i ];\n\t        var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n\t\n\t        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );\n\t\n\t        ani.play();\n\t      }\n\t\n\t      return this; // chaining\n\t    };\n\t  }, // animate\n\t\n\t  stop: function( fnParams ){\n\t    var defaults = {};\n\t    fnParams = util.extend( {}, defaults, fnParams );\n\t\n\t    return function stopImpl( clearQueue, jumpToEnd ){\n\t      var self = this;\n\t      var selfIsArrayLike = self.length !== undefined;\n\t      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\t      var cy = this._private.cy || this;\n\t\n\t      if( !cy.styleEnabled() ){ return this; }\n\t\n\t      for( var i = 0; i < all.length; i++ ){\n\t        var ele = all[ i ];\n\t        var _p = ele._private;\n\t        var anis = _p.animation.current;\n\t\n\t        for( var j = 0; j < anis.length; j++ ){\n\t          var ani = anis[ j ];\n\t          var ani_p = ani._private;\n\t\n\t          if( jumpToEnd ){\n\t            // next iteration of the animation loop, the animation\n\t            // will go straight to the end and be removed\n\t            ani_p.duration = 0;\n\t          }\n\t        }\n\t\n\t        // clear the queue of future animations\n\t        if( clearQueue ){\n\t          _p.animation.queue = [];\n\t        }\n\t\n\t        if( !jumpToEnd ){\n\t          _p.animation.current = [];\n\t        }\n\t      }\n\t\n\t      // we have to notify (the animation loop doesn't do it for us on `stop`)\n\t      cy.notify( {\n\t        eles: this,\n\t        type: 'draw'\n\t      } );\n\t\n\t      return this;\n\t    };\n\t  } // stop\n\t\n\t}; // define\n\t\n\tmodule.exports = define;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar Selector = function( selector ){\n\t\n\t  if( !(this instanceof Selector) ){\n\t    return new Selector( selector );\n\t  }\n\t\n\t  var self = this;\n\t\n\t  self._private = {\n\t    selectorText: null,\n\t    invalid: true\n\t  };\n\t\n\t  // storage for parsed queries\n\t  var newQuery = function(){\n\t    return {\n\t      classes: [],\n\t      colonSelectors: [],\n\t      data: [],\n\t      group: null,\n\t      ids: [],\n\t      meta: [],\n\t\n\t      // fake selectors\n\t      collection: null, // a collection to match against\n\t      filter: null, // filter function\n\t\n\t      // these are defined in the upward direction rather than down (e.g. child)\n\t      // because we need to go up in Selector.filter()\n\t      parent: null, // parent query obj\n\t      ancestor: null, // ancestor query obj\n\t      subject: null, // defines subject in compound query (subject query obj; points to self if subject)\n\t\n\t      // use these only when subject has been defined\n\t      child: null,\n\t      descendant: null\n\t    };\n\t  };\n\t\n\t  if( !selector || ( is.string( selector ) && selector.match( /^\\s*$/ ) ) ){\n\t\n\t    self.length = 0;\n\t\n\t  } else if( selector === '*' || selector === 'edge' || selector === 'node' ){\n\t\n\t    // make single, group-only selectors cheap to make and cheap to filter\n\t\n\t    self[0] = newQuery();\n\t    self[0].group = selector === '*' ? selector : selector + 's';\n\t    self[0].groupOnly = true;\n\t    self._private.invalid = false;\n\t    self._private.selectorText = selector;\n\t    self.length = 1;\n\t\n\t  } else if( is.elementOrCollection( selector ) ){\n\t\n\t    var collection = selector.collection();\n\t\n\t    self[0] = newQuery();\n\t    self[0].collection = collection;\n\t    self.length = 1;\n\t\n\t  } else if( is.fn( selector ) ){\n\t\n\t    self[0] = newQuery();\n\t    self[0].filter = selector;\n\t    self.length = 1;\n\t\n\t  } else if( is.string( selector ) ){\n\t\n\t    // the current subject in the query\n\t    var currentSubject = null;\n\t\n\t    // tokens in the query language\n\t    var tokens = {\n\t      metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]', // chars we need to escape in var names, etc\n\t      comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=', // binary comparison op (used in data selectors)\n\t      boolOp: '\\\\?|\\\\!|\\\\^', // boolean (unary) operators (used in data selectors)\n\t      string: '\"(?:\\\\\\\\\"|[^\"])+\"' + '|' + \"'(?:\\\\\\\\'|[^'])+'\", // string literals (used in data selectors) -- doublequotes | singlequotes\n\t      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n\t      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)\n\t      separator: '\\\\s*,\\\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n\t      descendant: '\\\\s+',\n\t      child: '\\\\s+>\\\\s+',\n\t      subject: '\\\\$'\n\t    };\n\t    tokens.variable = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name\n\t    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n\t    tokens.className = tokens.variable; // a class name (follows variable conventions)\n\t    tokens.id = tokens.variable; // an element id (follows variable conventions)\n\t\n\t    // when a token like a variable has escaped meta characters, we need to clean the backslashes out\n\t    // so that values get compared properly in Selector.filter()\n\t    var cleanMetaChars = function( str ){\n\t      return str.replace( new RegExp( '\\\\\\\\(' + tokens.metaChar + ')', 'g' ), function( match, $1, offset, original ){\n\t        return $1;\n\t      } );\n\t    };\n\t\n\t    // add @ variants to comparatorOp\n\t    var ops = tokens.comparatorOp.split( '|' );\n\t    for( var i = 0; i < ops.length; i++ ){\n\t      var op = ops[ i ];\n\t      tokens.comparatorOp += '|@' + op;\n\t    }\n\t\n\t    // add ! variants to comparatorOp\n\t    var ops = tokens.comparatorOp.split( '|' );\n\t    for( var i = 0; i < ops.length; i++ ){\n\t      var op = ops[ i ];\n\t\n\t      if( op.indexOf( '!' ) >= 0 ){ continue; } // skip ops that explicitly contain !\n\t      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined\n\t\n\t      tokens.comparatorOp += '|\\\\!' + op;\n\t    }\n\t\n\t    // NOTE: add new expression syntax here to have it recognised by the parser;\n\t    // - a query contains all adjacent (i.e. no separator in between) expressions;\n\t    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;\n\t    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward\n\t    // - when you add something here, also add to Selector.toString()\n\t    var exprs = [\n\t      {\n\t        name: 'group',\n\t        query: true,\n\t        regex: '(node|edge|\\\\*)',\n\t        populate: function( group ){\n\t          this.group = group === '*' ? group : group + 's';\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'state',\n\t        query: true,\n\t        // NB: if one colon selector is a substring of another from its start, place the longer one first\n\t        // e.g. :foobar|:foo\n\t        regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',\n\t        populate: function( state ){\n\t          this.colonSelectors.push( state );\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'id',\n\t        query: true,\n\t        regex: '\\\\#(' + tokens.id + ')',\n\t        populate: function( id ){\n\t          this.ids.push( cleanMetaChars( id ) );\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'className',\n\t        query: true,\n\t        regex: '\\\\.(' + tokens.className + ')',\n\t        populate: function( className ){\n\t          this.classes.push( cleanMetaChars( className ) );\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'dataExists',\n\t        query: true,\n\t        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n\t        populate: function( variable ){\n\t          this.data.push( {\n\t            field: cleanMetaChars( variable )\n\t          } );\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'dataCompare',\n\t        query: true,\n\t        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n\t        populate: function( variable, comparatorOp, value ){\n\t          var valueIsString = new RegExp( '^' + tokens.string + '$' ).exec( value ) != null;\n\t\n\t          if( valueIsString ){\n\t            value = value.substring( 1, value.length - 1 );\n\t          } else {\n\t            value = parseFloat( value );\n\t          }\n\t\n\t          this.data.push( {\n\t            field: cleanMetaChars( variable ),\n\t            operator: comparatorOp,\n\t            value: value\n\t          } );\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'dataBool',\n\t        query: true,\n\t        regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n\t        populate: function( boolOp, variable ){\n\t          this.data.push( {\n\t            field: cleanMetaChars( variable ),\n\t            operator: boolOp\n\t          } );\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'metaCompare',\n\t        query: true,\n\t        regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n\t        populate: function( meta, comparatorOp, number ){\n\t          this.meta.push( {\n\t            field: cleanMetaChars( meta ),\n\t            operator: comparatorOp,\n\t            value: parseFloat( number )\n\t          } );\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'nextQuery',\n\t        separator: true,\n\t        regex: tokens.separator,\n\t        populate: function(){\n\t          // go on to next query\n\t          self[ ++i ] = newQuery();\n\t          currentSubject = null;\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'child',\n\t        separator: true,\n\t        regex: tokens.child,\n\t        populate: function(){\n\t          // this query is the parent of the following query\n\t          var childQuery = newQuery();\n\t          childQuery.parent = this;\n\t          childQuery.subject = currentSubject;\n\t\n\t          // we're now populating the child query with expressions that follow\n\t          self[ i ] = childQuery;\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'descendant',\n\t        separator: true,\n\t        regex: tokens.descendant,\n\t        populate: function(){\n\t          // this query is the ancestor of the following query\n\t          var descendantQuery = newQuery();\n\t          descendantQuery.ancestor = this;\n\t          descendantQuery.subject = currentSubject;\n\t\n\t          // we're now populating the descendant query with expressions that follow\n\t          self[ i ] = descendantQuery;\n\t        }\n\t      },\n\t\n\t      {\n\t        name: 'subject',\n\t        modifier: true,\n\t        regex: tokens.subject,\n\t        populate: function(){\n\t          if( currentSubject != null && this.subject != this ){\n\t            util.error( 'Redefinition of subject in selector `' + selector + '`' );\n\t            return false;\n\t          }\n\t\n\t          currentSubject = this;\n\t          this.subject = this;\n\t        }\n\t\n\t      }\n\t    ];\n\t\n\t    self._private.selectorText = selector;\n\t    var remaining = selector;\n\t    var i = 0;\n\t\n\t    // of all the expressions, find the first match in the remaining text\n\t    var consumeExpr = function( expectation ){\n\t      var expr;\n\t      var match;\n\t      var name;\n\t\n\t      for( var j = 0; j < exprs.length; j++ ){\n\t        var e = exprs[ j ];\n\t        var n = e.name;\n\t\n\t        // ignore this expression if it doesn't meet the expectation function\n\t        if( is.fn( expectation ) && !expectation( n, e ) ){ continue; }\n\t\n\t        var m = remaining.match( new RegExp( '^' + e.regex ) );\n\t\n\t        if( m != null ){\n\t          match = m;\n\t          expr = e;\n\t          name = n;\n\t\n\t          var consumed = m[0];\n\t          remaining = remaining.substring( consumed.length );\n\t\n\t          break; // we've consumed one expr, so we can return now\n\t        }\n\t      }\n\t\n\t      return {\n\t        expr: expr,\n\t        match: match,\n\t        name: name\n\t      };\n\t    };\n\t\n\t    // consume all leading whitespace\n\t    var consumeWhitespace = function(){\n\t      var match = remaining.match( /^\\s+/ );\n\t\n\t      if( match ){\n\t        var consumed = match[0];\n\t        remaining = remaining.substring( consumed.length );\n\t      }\n\t    };\n\t\n\t    self[0] = newQuery(); // get started\n\t\n\t    consumeWhitespace(); // get rid of leading whitespace\n\t    for( ;; ){\n\t      var check = consumeExpr();\n\t\n\t      if( check.expr == null ){\n\t        util.error( 'The selector `' + selector + '`is invalid' );\n\t        return;\n\t      } else {\n\t        var args = [];\n\t        for( var j = 1; j < check.match.length; j++ ){\n\t          args.push( check.match[ j ] );\n\t        }\n\t\n\t        // let the token populate the selector object (i.e. in self[i])\n\t        var ret = check.expr.populate.apply( self[ i ], args );\n\t\n\t        if( ret === false ){ return; } // exit if population failed\n\t      }\n\t\n\t      // we're done when there's nothing left to parse\n\t      if( remaining.match( /^\\s*$/ ) ){\n\t        break;\n\t      }\n\t    }\n\t\n\t    self.length = i + 1;\n\t\n\t    // adjust references for subject\n\t    for( var j = 0; j < self.length; j++ ){\n\t      var query = self[ j ];\n\t\n\t      if( query.subject != null ){\n\t        // go up the tree until we reach the subject\n\t        for( ;; ){\n\t          if( query.subject == query ){ break; } // done if subject is self\n\t\n\t          if( query.parent != null ){ // swap parent/child reference\n\t            var parent = query.parent;\n\t            var child = query;\n\t\n\t            child.parent = null;\n\t            parent.child = child;\n\t\n\t            query = parent; // go up the tree\n\t          } else if( query.ancestor != null ){ // swap ancestor/descendant\n\t            var ancestor = query.ancestor;\n\t            var descendant = query;\n\t\n\t            descendant.ancestor = null;\n\t            ancestor.descendant = descendant;\n\t\n\t            query = ancestor; // go up the tree\n\t          } else {\n\t            util.error( 'When adjusting references for the selector `' + query + '`, neither parent nor ancestor was found' );\n\t            break;\n\t          }\n\t        } // for\n\t\n\t        self[ j ] = query.subject; // subject should be the root query\n\t      } // if\n\t    } // for\n\t\n\t  } else {\n\t    util.error( 'A selector must be created from a string; found ' + selector );\n\t    return;\n\t  }\n\t\n\t  self._private.invalid = false;\n\t\n\t};\n\t\n\tvar selfn = Selector.prototype;\n\t\n\tselfn.size = function(){\n\t  return this.length;\n\t};\n\t\n\tselfn.eq = function( i ){\n\t  return this[ i ];\n\t};\n\t\n\tvar queryMatches = function( query, ele ){\n\t  var ele_p = ele._private;\n\t\n\t  // make single group-only selectors really cheap to check since they're the most common ones\n\t  if( query.groupOnly ){\n\t    return query.group === '*' || query.group === ele_p.group;\n\t  }\n\t\n\t  // check group\n\t  if( query.group != null && query.group != '*' && query.group != ele_p.group ){\n\t    return false;\n\t  }\n\t\n\t  var cy = ele.cy();\n\t\n\t  // check colon selectors\n\t  var allColonSelectorsMatch = true;\n\t  for( var k = 0; k < query.colonSelectors.length; k++ ){\n\t    var sel = query.colonSelectors[ k ];\n\t\n\t    switch( sel ){\n\t      case ':selected':\n\t        allColonSelectorsMatch = ele.selected();\n\t        break;\n\t      case ':unselected':\n\t        allColonSelectorsMatch = !ele.selected();\n\t        break;\n\t      case ':selectable':\n\t        allColonSelectorsMatch = ele.selectable();\n\t        break;\n\t      case ':unselectable':\n\t        allColonSelectorsMatch = !ele.selectable();\n\t        break;\n\t      case ':locked':\n\t        allColonSelectorsMatch = ele.locked();\n\t        break;\n\t      case ':unlocked':\n\t        allColonSelectorsMatch = !ele.locked();\n\t        break;\n\t      case ':visible':\n\t        allColonSelectorsMatch = ele.visible();\n\t        break;\n\t      case ':hidden':\n\t        allColonSelectorsMatch = !ele.visible();\n\t        break;\n\t      case ':transparent':\n\t        allColonSelectorsMatch = ele.transparent();\n\t        break;\n\t      case ':grabbed':\n\t        allColonSelectorsMatch = ele.grabbed();\n\t        break;\n\t      case ':free':\n\t        allColonSelectorsMatch = !ele.grabbed();\n\t        break;\n\t      case ':removed':\n\t        allColonSelectorsMatch = ele.removed();\n\t        break;\n\t      case ':inside':\n\t        allColonSelectorsMatch = !ele.removed();\n\t        break;\n\t      case ':grabbable':\n\t        allColonSelectorsMatch = ele.grabbable();\n\t        break;\n\t      case ':ungrabbable':\n\t        allColonSelectorsMatch = !ele.grabbable();\n\t        break;\n\t      case ':animated':\n\t        allColonSelectorsMatch = ele.animated();\n\t        break;\n\t      case ':unanimated':\n\t        allColonSelectorsMatch = !ele.animated();\n\t        break;\n\t      case ':parent':\n\t        allColonSelectorsMatch = ele.isNode() && ele.children().nonempty();\n\t        break;\n\t      case ':child':\n\t      case ':nonorphan':\n\t        allColonSelectorsMatch = ele.isNode() && ele.parent().nonempty();\n\t        break;\n\t      case ':orphan':\n\t        allColonSelectorsMatch = ele.isNode() && ele.parent().empty();\n\t        break;\n\t      case ':loop':\n\t        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) === ele.data( 'target' );\n\t        break;\n\t      case ':simple':\n\t        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) !== ele.data( 'target' );\n\t        break;\n\t      case ':active':\n\t        allColonSelectorsMatch = ele.active();\n\t        break;\n\t      case ':inactive':\n\t        allColonSelectorsMatch = !ele.active();\n\t        break;\n\t      case ':touch':\n\t        allColonSelectorsMatch = is.touch();\n\t        break;\n\t      case ':backgrounding':\n\t        allColonSelectorsMatch = ele.backgrounding();\n\t        break;\n\t      case ':nonbackgrounding':\n\t        allColonSelectorsMatch = !ele.backgrounding();\n\t        break;\n\t    }\n\t\n\t    if( !allColonSelectorsMatch ) break;\n\t  }\n\t  if( !allColonSelectorsMatch ) return false;\n\t\n\t  // check id\n\t  var allIdsMatch = true;\n\t  for( var k = 0; k < query.ids.length; k++ ){\n\t    var id = query.ids[ k ];\n\t    var actualId = ele_p.data.id;\n\t\n\t    allIdsMatch = allIdsMatch && (id == actualId);\n\t\n\t    if( !allIdsMatch ) break;\n\t  }\n\t  if( !allIdsMatch ) return false;\n\t\n\t  // check classes\n\t  var allClassesMatch = true;\n\t  for( var k = 0; k < query.classes.length; k++ ){\n\t    var cls = query.classes[ k ];\n\t\n\t    allClassesMatch = allClassesMatch && ele.hasClass( cls );\n\t\n\t    if( !allClassesMatch ) break;\n\t  }\n\t  if( !allClassesMatch ) return false;\n\t\n\t  // generic checking for data/metadata\n\t  var operandsMatch = function( params ){\n\t    var allDataMatches = true;\n\t    for( var k = 0; k < query[ params.name ].length; k++ ){\n\t      var data = query[ params.name ][ k ];\n\t      var operator = data.operator;\n\t      var value = data.value;\n\t      var field = data.field;\n\t      var matches;\n\t\n\t      if( operator != null && value != null ){\n\t\n\t        var fieldVal = params.fieldValue( field );\n\t        var fieldStr = !is.string( fieldVal ) && !is.number( fieldVal ) ? '' : '' + fieldVal;\n\t        var valStr = '' + value;\n\t\n\t        var caseInsensitive = false;\n\t        if( operator.indexOf( '@' ) >= 0 ){\n\t          fieldStr = fieldStr.toLowerCase();\n\t          valStr = valStr.toLowerCase();\n\t\n\t          operator = operator.replace( '@', '' );\n\t          caseInsensitive = true;\n\t        }\n\t\n\t        var notExpr = false;\n\t        if( operator.indexOf( '!' ) >= 0 ){\n\t          operator = operator.replace( '!', '' );\n\t          notExpr = true;\n\t        }\n\t\n\t        // if we're doing a case insensitive comparison, then we're using a STRING comparison\n\t        // even if we're comparing numbers\n\t        if( caseInsensitive ){\n\t          value = valStr.toLowerCase();\n\t          fieldVal = fieldStr.toLowerCase();\n\t        }\n\t\n\t        var isIneqCmp = false;\n\t\n\t        switch( operator ){\n\t        case '*=':\n\t          matches = fieldStr.indexOf( valStr ) >= 0;\n\t          break;\n\t        case '$=':\n\t          matches = fieldStr.indexOf( valStr, fieldStr.length - valStr.length ) >= 0;\n\t          break;\n\t        case '^=':\n\t          matches = fieldStr.indexOf( valStr ) === 0;\n\t          break;\n\t        case '=':\n\t          matches = fieldVal === value;\n\t          break;\n\t        case '>':\n\t          isIneqCmp = true;\n\t          matches = fieldVal > value;\n\t          break;\n\t        case '>=':\n\t          isIneqCmp = true;\n\t          matches = fieldVal >= value;\n\t          break;\n\t        case '<':\n\t          isIneqCmp = true;\n\t          matches = fieldVal < value;\n\t          break;\n\t        case '<=':\n\t          isIneqCmp = true;\n\t          matches = fieldVal <= value;\n\t          break;\n\t        default:\n\t          matches = false;\n\t          break;\n\t        }\n\t\n\t        // apply the not op, but null vals for inequalities should always stay non-matching\n\t        if( notExpr && ( fieldVal != null || !isIneqCmp ) ){\n\t          matches = !matches;\n\t        }\n\t      } else if( operator != null ){\n\t        switch( operator ){\n\t        case '?':\n\t          matches = params.fieldTruthy( field );\n\t          break;\n\t        case '!':\n\t          matches = !params.fieldTruthy( field );\n\t          break;\n\t        case '^':\n\t          matches = params.fieldUndefined( field );\n\t          break;\n\t        }\n\t      } else {\n\t        matches = !params.fieldUndefined( field );\n\t      }\n\t\n\t      if( !matches ){\n\t        allDataMatches = false;\n\t        break;\n\t      }\n\t    } // for\n\t\n\t    return allDataMatches;\n\t  }; // operandsMatch\n\t\n\t  // check data matches\n\t  var allDataMatches = operandsMatch( {\n\t    name: 'data',\n\t    fieldValue: function( field ){\n\t      return ele_p.data[ field ];\n\t    },\n\t    fieldUndefined: function( field ){\n\t      return ele_p.data[ field ] === undefined;\n\t    },\n\t    fieldTruthy: function( field ){\n\t      if( ele_p.data[ field ] ){\n\t        return true;\n\t      }\n\t      return false;\n\t    }\n\t  } );\n\t\n\t  if( !allDataMatches ){\n\t    return false;\n\t  }\n\t\n\t  // check metadata matches\n\t  var allMetaMatches = operandsMatch( {\n\t    name: 'meta',\n\t    fieldValue: function( field ){\n\t      return ele[ field ]();\n\t    },\n\t    fieldUndefined: function( field ){\n\t      return ele[ field ]() == null;\n\t    },\n\t    fieldTruthy: function( field ){\n\t      if( ele[ field ]() ){\n\t        return true;\n\t      }\n\t      return false;\n\t    }\n\t  } );\n\t\n\t  if( !allMetaMatches ){\n\t    return false;\n\t  }\n\t\n\t  // check collection\n\t  if( query.collection != null ){\n\t    var matchesAny = query.collection.hasElementWithId( ele.id() );\n\t\n\t    if( !matchesAny ){\n\t      return false;\n\t    }\n\t  }\n\t\n\t  // check filter function\n\t  if( query.filter != null && ele.collection().filter( query.filter ).size() === 0 ){\n\t    return false;\n\t  }\n\t\n\t  // check parent/child relations\n\t  var confirmRelations = function( query, eles ){\n\t    if( query != null ){\n\t      var matches = false;\n\t\n\t      if( !cy.hasCompoundNodes() ){\n\t        return false;\n\t      }\n\t\n\t      eles = eles(); // save cycles if query == null\n\t\n\t      // query must match for at least one element (may be recursive)\n\t      for( var i = 0; i < eles.length; i++ ){\n\t        if( queryMatches( query, eles[ i ] ) ){\n\t          matches = true;\n\t          break;\n\t        }\n\t      }\n\t\n\t      return matches;\n\t    } else {\n\t      return true;\n\t    }\n\t  };\n\t\n\t  if( !confirmRelations( query.parent, function(){\n\t    return ele.parent();\n\t  } ) ){ return false; }\n\t\n\t  if( !confirmRelations( query.ancestor, function(){\n\t    return ele.parents();\n\t  } ) ){ return false; }\n\t\n\t  if( !confirmRelations( query.child, function(){\n\t    return ele.children();\n\t  } ) ){ return false; }\n\t\n\t  if( !confirmRelations( query.descendant, function(){\n\t    return ele.descendants();\n\t  } ) ){ return false; }\n\t\n\t  // we've reached the end, so we've matched everything for this query\n\t  return true;\n\t}; // queryMatches\n\t\n\t// filter an existing collection\n\tselfn.filter = function( collection ){\n\t  var self = this;\n\t  var cy = collection.cy();\n\t\n\t  // don't bother trying if it's invalid\n\t  if( self._private.invalid ){\n\t    return cy.collection();\n\t  }\n\t\n\t  var selectorFunction = function( i, element ){\n\t    for( var j = 0; j < self.length; j++ ){\n\t      var query = self[ j ];\n\t\n\t      if( queryMatches( query, element ) ){\n\t        return true;\n\t      }\n\t    }\n\t\n\t    return false;\n\t  };\n\t\n\t  if( self._private.selectorText == null ){\n\t    selectorFunction = function(){ return true; };\n\t  }\n\t\n\t  var filteredCollection = collection.filter( selectorFunction );\n\t\n\t  return filteredCollection;\n\t}; // filter\n\t\n\t// does selector match a single element?\n\tselfn.matches = function( ele ){\n\t  var self = this;\n\t\n\t  // don't bother trying if it's invalid\n\t  if( self._private.invalid ){\n\t    return false;\n\t  }\n\t\n\t  for( var j = 0; j < self.length; j++ ){\n\t    var query = self[ j ];\n\t\n\t    if( queryMatches( query, ele ) ){\n\t      return true;\n\t    }\n\t  }\n\t\n\t  return false;\n\t}; // filter\n\t\n\t// ith query to string\n\tselfn.toString = selfn.selector = function(){\n\t\n\t  var str = '';\n\t\n\t  var clean = function( obj, isValue ){\n\t    if( is.string( obj ) ){\n\t      return isValue ? '\"' + obj + '\"' : obj;\n\t    }\n\t    return '';\n\t  };\n\t\n\t  var queryToString = function( query ){\n\t    var str = '';\n\t\n\t    if( query.subject === query ){\n\t      str += '$';\n\t    }\n\t\n\t    var group = clean( query.group );\n\t    str += group.substring( 0, group.length - 1 );\n\t\n\t    for( var j = 0; j < query.data.length; j++ ){\n\t      var data = query.data[ j ];\n\t\n\t      if( data.value ){\n\t        str += '[' + data.field + clean( data.operator ) + clean( data.value, true ) + ']';\n\t      } else {\n\t        str += '[' + clean( data.operator ) + data.field + ']';\n\t      }\n\t    }\n\t\n\t    for( var j = 0; j < query.meta.length; j++ ){\n\t      var meta = query.meta[ j ];\n\t      str += '[[' + meta.field + clean( meta.operator ) + clean( meta.value, true ) + ']]';\n\t    }\n\t\n\t    for( var j = 0; j < query.colonSelectors.length; j++ ){\n\t      var sel = query.colonSelectors[ i ];\n\t      str += sel;\n\t    }\n\t\n\t    for( var j = 0; j < query.ids.length; j++ ){\n\t      var sel = '#' + query.ids[ i ];\n\t      str += sel;\n\t    }\n\t\n\t    for( var j = 0; j < query.classes.length; j++ ){\n\t      var sel = '.' + query.classes[ j ];\n\t      str += sel;\n\t    }\n\t\n\t    if( query.parent != null ){\n\t      str = queryToString( query.parent ) + ' > ' + str;\n\t    }\n\t\n\t    if( query.ancestor != null ){\n\t      str = queryToString( query.ancestor ) + ' ' + str;\n\t    }\n\t\n\t    if( query.child != null ){\n\t      str += ' > ' + queryToString( query.child );\n\t    }\n\t\n\t    if( query.descendant != null ){\n\t      str += ' ' + queryToString( query.descendant );\n\t    }\n\t\n\t    return str;\n\t  };\n\t\n\t  for( var i = 0; i < this.length; i++ ){\n\t    var query = this[ i ];\n\t\n\t    str += queryToString( query );\n\t\n\t    if( this.length > 1 && i < this.length - 1 ){\n\t      str += ', ';\n\t    }\n\t  }\n\t\n\t  return str;\n\t};\n\t\n\tmodule.exports = Selector;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!\n\tEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\n\tCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\n\tLicensed under The MIT License (http://opensource.org/licenses/MIT)\n\t*/\n\t\n\t'use strict';\n\t\n\t/*  promise states [Promises/A+ 2.1]  */\n\tvar STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */\n\tvar STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */\n\tvar STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */\n\t\n\t/*  promise object constructor  */\n\tvar api = function( executor ){\n\t  /*  optionally support non-constructor/plain-function call  */\n\t  if( !(this instanceof api) )\n\t    return new api( executor );\n\t\n\t  /*  initialize object  */\n\t  this.id           = 'Thenable/1.0.7';\n\t  this.state        = STATE_PENDING; /*  initial state  */\n\t  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */\n\t  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */\n\t  this.onFulfilled  = [];            /*  initial handlers  */\n\t  this.onRejected   = [];            /*  initial handlers  */\n\t\n\t  /*  provide optional information-hiding proxy  */\n\t  this.proxy = {\n\t    then: this.then.bind( this )\n\t  };\n\t\n\t  /*  support optional executor function  */\n\t  if( typeof executor === 'function' )\n\t    executor.call( this, this.fulfill.bind( this ), this.reject.bind( this ) );\n\t};\n\t\n\t/*  promise API methods  */\n\tapi.prototype = {\n\t  /*  promise resolving methods  */\n\t  fulfill: function( value ){ return deliver( this, STATE_FULFILLED, 'fulfillValue', value ); },\n\t  reject:  function( value ){ return deliver( this, STATE_REJECTED,  'rejectReason', value ); },\n\t\n\t  /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n\t  then: function( onFulfilled, onRejected ){\n\t    var curr = this;\n\t    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */\n\t    curr.onFulfilled.push(\n\t      resolver( onFulfilled, next, 'fulfill' ) );             /*  [Promises/A+ 2.2.2/2.2.6]  */\n\t    curr.onRejected.push(\n\t      resolver( onRejected,  next, 'reject' ) );             /*  [Promises/A+ 2.2.3/2.2.6]  */\n\t    execute( curr );\n\t    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */\n\t  }\n\t};\n\t\n\t/*  deliver an action  */\n\tvar deliver = function( curr, state, name, value ){\n\t  if( curr.state === STATE_PENDING ){\n\t    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n\t    curr[ name ] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n\t    execute( curr );\n\t  }\n\t  return curr;\n\t};\n\t\n\t/*  execute all handlers  */\n\tvar execute = function( curr ){\n\t  if( curr.state === STATE_FULFILLED )\n\t    execute_handlers( curr, 'onFulfilled', curr.fulfillValue );\n\t  else if( curr.state === STATE_REJECTED )\n\t    execute_handlers( curr, 'onRejected',  curr.rejectReason );\n\t};\n\t\n\t/*  execute particular set of handlers  */\n\tvar execute_handlers = function( curr, name, value ){\n\t  /* global setImmediate: true */\n\t  /* global setTimeout: true */\n\t\n\t  /*  short-circuit processing  */\n\t  if( curr[ name ].length === 0 )\n\t    return;\n\t\n\t  /*  iterate over all handlers, exactly once  */\n\t  var handlers = curr[ name ];\n\t  curr[ name ] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n\t  var func = function(){\n\t    for( var i = 0; i < handlers.length; i++ )\n\t      handlers[ i ]( value );                                  /*  [Promises/A+ 2.2.5]  */\n\t  };\n\t\n\t  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */\n\t  if( typeof setImmediate === 'function' )\n\t    setImmediate( func );\n\t  else\n\t    setTimeout( func, 0 );\n\t};\n\t\n\t/*  generate a resolver function  */\n\tvar resolver = function( cb, next, method ){\n\t  return function( value ){\n\t    if( typeof cb !== 'function' )                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n\t      next[ method ].call( next, value );                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n\t    else {\n\t      var result;\n\t      try { result = cb( value ); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n\t      catch( e ){\n\t        next.reject( e );                                  /*  [Promises/A+ 2.2.7.2]  */\n\t        return;\n\t      }\n\t      resolve( next, result );                               /*  [Promises/A+ 2.2.7.1]  */\n\t    }\n\t  };\n\t};\n\t\n\t/*  \"Promise Resolution Procedure\"  */                           /*  [Promises/A+ 2.3]  */\n\tvar resolve = function( promise, x ){\n\t  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */\n\t  if( promise === x || promise.proxy === x ){\n\t    promise.reject( new TypeError( 'cannot resolve promise with itself' ) );\n\t    return;\n\t  }\n\t\n\t  /*  surgically check for a \"then\" method\n\t    (mainly to just call the \"getter\" of \"then\" only once)  */\n\t  var then;\n\t  if( (typeof x === 'object' && x !== null) || typeof x === 'function' ){\n\t    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */\n\t    catch( e ){\n\t      promise.reject( e );                                   /*  [Promises/A+ 2.3.3.2]  */\n\t      return;\n\t    }\n\t  }\n\t\n\t  /*  handle own Thenables    [Promises/A+ 2.3.2]\n\t    and similar \"thenables\" [Promises/A+ 2.3.3]  */\n\t  if( typeof then === 'function' ){\n\t    var resolved = false;\n\t    try {\n\t      /*  call retrieved \"then\" method */                  /*  [Promises/A+ 2.3.3.3]  */\n\t      then.call( x,\n\t        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */\n\t        function( y ){\n\t          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */\n\t          if( y === x )                                 /*  [Promises/A+ 3.6]  */\n\t            promise.reject( new TypeError( 'circular thenable chain' ) );\n\t          else\n\t            resolve( promise, y );\n\t        },\n\t\n\t        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */\n\t        function( r ){\n\t          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */\n\t          promise.reject( r );\n\t        }\n\t      );\n\t    }\n\t    catch( e ){\n\t      if( !resolved )                                       /*  [Promises/A+ 2.3.3.3.3]  */\n\t        promise.reject( e );                               /*  [Promises/A+ 2.3.3.3.4]  */\n\t    }\n\t    return;\n\t  }\n\t\n\t  /*  handle other values  */\n\t  promise.fulfill( x );                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n\t};\n\t\n\t// so we always have Promise.all()\n\tapi.all = function( ps ){\n\t  return new api(function( resolveAll, rejectAll ){\n\t    var vals = new Array( ps.length );\n\t    var doneCount = 0;\n\t\n\t    var fulfill = function( i, val ){\n\t      vals[ i ] = val;\n\t      doneCount++;\n\t\n\t      if( doneCount === ps.length ){\n\t        resolveAll( vals );\n\t      }\n\t    };\n\t\n\t    for( var i = 0; i < ps.length; i++ ){\n\t      (function( i ){\n\t        var p = ps[i];\n\t        var isPromise = p != null && p.then != null;\n\t\n\t        if( isPromise ){\n\t          p.then( function( val ){\n\t            fulfill( i, val );\n\t          }, function( err ){\n\t            rejectAll( err );\n\t          } );\n\t        } else {\n\t          var val = p;\n\t          fulfill( i, val );\n\t        }\n\t      })( i );\n\t    }\n\t\n\t  } );\n\t};\n\t\n\tapi.resolve = function( val ){\n\t  return new api(function( resolve, reject ){ resolve( val ); });\n\t};\n\t\n\tapi.reject = function( val ){\n\t  return new api(function( resolve, reject ){ reject( val ); });\n\t};\n\t\n\tmodule.exports = typeof Promise !== 'undefined' ? Promise : api;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59).setImmediate))\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(2).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59).setImmediate, __webpack_require__(59).clearImmediate))\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*!\n\tEvent object based on jQuery events, MIT license\n\t\n\thttps://jquery.org/license/\n\thttps://tldrlegal.com/license/mit-license\n\thttps://github.com/jquery/jquery/blob/master/src/event.js\n\t*/\n\t\n\tvar Event = function( src, props ){\n\t  // Allow instantiation without the 'new' keyword\n\t  if( !(this instanceof Event) ){\n\t    return new Event( src, props );\n\t  }\n\t\n\t  // Event object\n\t  if( src && src.type ){\n\t    this.originalEvent = src;\n\t    this.type = src.type;\n\t\n\t    // Events bubbling up the document may have been marked as prevented\n\t    // by a handler lower down the tree; reflect the correct value.\n\t    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;\n\t\n\t  // Event type\n\t  } else {\n\t    this.type = src;\n\t  }\n\t\n\t  // Put explicitly provided properties onto the event object\n\t  if( props ){\n\t    // util.extend( this, props );\n\t\n\t    // more efficient to manually copy fields we use\n\t    this.type = props.type !== undefined ? props.type : this.type;\n\t    this.cy = props.cy;\n\t    this.cyTarget = props.cyTarget;\n\t    this.cyPosition = props.cyPosition;\n\t    this.cyRenderedPosition = props.cyRenderedPosition;\n\t    this.namespace = props.namespace;\n\t    this.layout = props.layout;\n\t    this.data = props.data;\n\t    this.message = props.message;\n\t  }\n\t\n\t  // Create a timestamp if incoming event doesn't have one\n\t  this.timeStamp = src && src.timeStamp || Date.now();\n\t};\n\t\n\tfunction returnFalse(){\n\t  return false;\n\t}\n\t\n\tfunction returnTrue(){\n\t  return true;\n\t}\n\t\n\t// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tEvent.prototype = {\n\t  instanceString: function(){\n\t    return 'event';\n\t  },\n\t\n\t  preventDefault: function(){\n\t    this.isDefaultPrevented = returnTrue;\n\t\n\t    var e = this.originalEvent;\n\t    if( !e ){\n\t      return;\n\t    }\n\t\n\t    // if preventDefault exists run it on the original event\n\t    if( e.preventDefault ){\n\t      e.preventDefault();\n\t    }\n\t  },\n\t\n\t  stopPropagation: function(){\n\t    this.isPropagationStopped = returnTrue;\n\t\n\t    var e = this.originalEvent;\n\t    if( !e ){\n\t      return;\n\t    }\n\t\n\t    // if stopPropagation exists run it on the original event\n\t    if( e.stopPropagation ){\n\t      e.stopPropagation();\n\t    }\n\t  },\n\t\n\t  stopImmediatePropagation: function(){\n\t    this.isImmediatePropagationStopped = returnTrue;\n\t    this.stopPropagation();\n\t  },\n\t\n\t  isDefaultPrevented: returnFalse,\n\t  isPropagationStopped: returnFalse,\n\t  isImmediatePropagationStopped: returnFalse\n\t};\n\t\n\tmodule.exports = Event;\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\tvar Promise = __webpack_require__( 58 );\n\t\n\tvar Animation = function( target, opts, opts2 ){\n\t  if( !(this instanceof Animation) ){\n\t    return new Animation( target, opts, opts2 );\n\t  }\n\t\n\t  var _p = this._private = util.extend( {\n\t    duration: 1000\n\t  }, opts, opts2 );\n\t\n\t  _p.target = target;\n\t  _p.style = _p.style || _p.css;\n\t  _p.started = false;\n\t  _p.playing = false;\n\t  _p.hooked = false;\n\t  _p.applying = false;\n\t  _p.progress = 0;\n\t  _p.completes = [];\n\t  _p.frames = [];\n\t\n\t  if( _p.complete && is.fn( _p.complete ) ){\n\t    _p.completes.push( _p.complete );\n\t  }\n\t\n\t  // for future timeline/animations impl\n\t  this.length = 1;\n\t  this[0] = this;\n\t};\n\t\n\tvar anifn = Animation.prototype;\n\t\n\tutil.extend( anifn, {\n\t\n\t  instanceString: function(){ return 'animation'; },\n\t\n\t  hook: function(){\n\t    var _p = this._private;\n\t\n\t    if( !_p.hooked ){\n\t      // add to target's animation queue\n\t      var q;\n\t      var tAni = _p.target._private.animation;\n\t      if( _p.queue ){\n\t        q = tAni.queue;\n\t      } else {\n\t        q = tAni.current;\n\t      }\n\t      q.push( this );\n\t\n\t      // add to the animation loop pool\n\t      if( is.elementOrCollection( _p.target ) ){\n\t        _p.target.cy().addToAnimationPool( _p.target );\n\t      }\n\t\n\t      _p.hooked = true;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  play: function(){\n\t    var _p = this._private;\n\t\n\t    // autorewind\n\t    if( _p.progress === 1 ){\n\t      _p.progress = 0;\n\t    }\n\t\n\t    _p.playing = true;\n\t    _p.started = false; // needs to be started by animation loop\n\t    _p.stopped = false;\n\t\n\t    this.hook();\n\t\n\t    // the animation loop will start the animation...\n\t\n\t    return this;\n\t  },\n\t\n\t  playing: function(){\n\t    return this._private.playing;\n\t  },\n\t\n\t  apply: function(){\n\t    var _p = this._private;\n\t\n\t    _p.applying = true;\n\t    _p.started = false; // needs to be started by animation loop\n\t    _p.stopped = false;\n\t\n\t    this.hook();\n\t\n\t    // the animation loop will apply the animation at this progress\n\t\n\t    return this;\n\t  },\n\t\n\t  applying: function(){\n\t    return this._private.applying;\n\t  },\n\t\n\t  pause: function(){\n\t    var _p = this._private;\n\t\n\t    _p.playing = false;\n\t    _p.started = false;\n\t\n\t    return this;\n\t  },\n\t\n\t  stop: function(){\n\t    var _p = this._private;\n\t\n\t    _p.playing = false;\n\t    _p.started = false;\n\t    _p.stopped = true; // to be removed from animation queues\n\t\n\t    return this;\n\t  },\n\t\n\t  rewind: function(){\n\t    return this.progress( 0 );\n\t  },\n\t\n\t  fastforward: function(){\n\t    return this.progress( 1 );\n\t  },\n\t\n\t  time: function( t ){\n\t    var _p = this._private;\n\t\n\t    if( t === undefined ){\n\t      return _p.progress * _p.duration;\n\t    } else {\n\t      return this.progress( t / _p.duration );\n\t    }\n\t  },\n\t\n\t  progress: function( p ){\n\t    var _p = this._private;\n\t    var wasPlaying = _p.playing;\n\t\n\t    if( p === undefined ){\n\t      return _p.progress;\n\t    } else {\n\t      if( wasPlaying ){\n\t        this.pause();\n\t      }\n\t\n\t      _p.progress = p;\n\t      _p.started = false;\n\t\n\t      if( wasPlaying ){\n\t        this.play();\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  completed: function(){\n\t    return this._private.progress === 1;\n\t  },\n\t\n\t  reverse: function(){\n\t    var _p = this._private;\n\t    var wasPlaying = _p.playing;\n\t\n\t    if( wasPlaying ){\n\t      this.pause();\n\t    }\n\t\n\t    _p.progress = 1 - _p.progress;\n\t    _p.started = false;\n\t\n\t    var swap = function( a, b ){\n\t      var _pa = _p[ a ];\n\t\n\t      _p[ a ] = _p[ b ];\n\t      _p[ b ] = _pa;\n\t    };\n\t\n\t    swap( 'zoom', 'startZoom' );\n\t    swap( 'pan', 'startPan' );\n\t    swap( 'position', 'startPosition' );\n\t\n\t    // swap styles\n\t    for( var i = 0; i < _p.style.length; i++ ){\n\t      var prop = _p.style[ i ];\n\t      var name = prop.name;\n\t      var startStyleProp = _p.startStyle[ name ];\n\t\n\t      _p.startStyle[ name ] = prop;\n\t      _p.style[ i ] = startStyleProp;\n\t    }\n\t\n\t    if( wasPlaying ){\n\t      this.play();\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  promise: function( type ){\n\t    var _p = this._private;\n\t\n\t    var arr;\n\t\n\t    switch( type ){\n\t      case 'frame':\n\t        arr = _p.frames;\n\t        break;\n\t      default:\n\t      case 'complete':\n\t      case 'completed':\n\t        arr = _p.completes;\n\t    }\n\t\n\t    return new Promise( function( resolve, reject ){\n\t      arr.push( function(){\n\t        resolve();\n\t      } );\n\t    } );\n\t  }\n\t\n\t} );\n\t\n\tanifn.complete = anifn.completed;\n\t\n\tmodule.exports = Animation;\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar elesfn = ({\n\t  classes: function( classes ){\n\t    classes = classes.match( /\\S+/g ) || [];\n\t    var self = this;\n\t    var changed = [];\n\t    var classesMap = {};\n\t\n\t    // fill in classes map\n\t    for( var i = 0; i < classes.length; i++ ){\n\t      var cls = classes[ i ];\n\t\n\t      classesMap[ cls ] = true;\n\t    }\n\t\n\t    // check and update each ele\n\t    for( var j = 0; j < self.length; j++ ){\n\t      var ele = self[ j ];\n\t      var _p = ele._private;\n\t      var eleClasses = _p.classes;\n\t      var changedEle = false;\n\t\n\t      // check if ele has all of the passed classes\n\t      for( var i = 0; i < classes.length; i++ ){\n\t        var cls = classes[ i ];\n\t        var eleHasClass = eleClasses[ cls ];\n\t\n\t        if( !eleHasClass ){\n\t          changedEle = true;\n\t          break;\n\t        }\n\t      }\n\t\n\t      // check if ele has classes outside of those passed\n\t      if( !changedEle ){\n\t        var classes = Object.keys( eleClasses );\n\t\n\t        for( var i = 0; i < classes.length; i++ ){\n\t          var eleCls = classes[i];\n\t          var eleHasClass = eleClasses[ eleCls ];\n\t          var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function\n\t\n\t          if( eleHasClass && !specdClass ){\n\t            changedEle = true;\n\t            break;\n\t          }\n\t        }\n\t      }\n\t\n\t      if( changedEle ){\n\t        _p.classes = util.copy( classesMap );\n\t\n\t        changed.push( ele );\n\t      }\n\t    }\n\t\n\t    // trigger update style on those eles that had class changes\n\t    if( changed.length > 0 ){\n\t      this.spawn( changed )\n\t        .updateStyle()\n\t        .trigger( 'class' )\n\t      ;\n\t    }\n\t\n\t    return self;\n\t  },\n\t\n\t  addClass: function( classes ){\n\t    return this.toggleClass( classes, true );\n\t  },\n\t\n\t  hasClass: function( className ){\n\t    var ele = this[0];\n\t    return ( ele != null && ele._private.classes[ className ] ) ? true : false;\n\t  },\n\t\n\t  toggleClass: function( classesStr, toggle ){\n\t    var classes = classesStr.match( /\\S+/g ) || [];\n\t    var self = this;\n\t    var changed = []; // eles who had classes changed\n\t\n\t    for( var i = 0, il = self.length; i < il; i++ ){\n\t      var ele = self[ i ];\n\t      var changedEle = false;\n\t\n\t      for( var j = 0; j < classes.length; j++ ){\n\t        var cls = classes[ j ];\n\t        var eleClasses = ele._private.classes;\n\t        var hasClass = eleClasses[ cls ];\n\t        var shouldAdd = toggle || (toggle === undefined && !hasClass);\n\t\n\t        if( shouldAdd ){\n\t          eleClasses[ cls ] = true;\n\t\n\t          if( !hasClass && !changedEle ){\n\t            changed.push( ele );\n\t            changedEle = true;\n\t          }\n\t        } else { // then remove\n\t          eleClasses[ cls ] = false;\n\t\n\t          if( hasClass && !changedEle ){\n\t            changed.push( ele );\n\t            changedEle = true;\n\t          }\n\t        }\n\t\n\t      } // for j classes\n\t    } // for i eles\n\t\n\t    // trigger update style on those eles that had class changes\n\t    if( changed.length > 0 ){\n\t      this.spawn( changed )\n\t        .updateStyle()\n\t        .trigger( 'class' )\n\t      ;\n\t    }\n\t\n\t    return self;\n\t  },\n\t\n\t  removeClass: function( classes ){\n\t    return this.toggleClass( classes, false );\n\t  },\n\t\n\t  flashClass: function( classes, duration ){\n\t    var self = this;\n\t\n\t    if( duration == null ){\n\t      duration = 250;\n\t    } else if( duration === 0 ){\n\t      return self; // nothing to do really\n\t    }\n\t\n\t    self.addClass( classes );\n\t    setTimeout( function(){\n\t      self.removeClass( classes );\n\t    }, duration );\n\t\n\t    return self;\n\t  }\n\t});\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar elesfn = ({\n\t  allAre: function( selector ){\n\t    return this.filter( selector ).length === this.length;\n\t  },\n\t\n\t  is: function( selector ){\n\t    return this.filter( selector ).length > 0;\n\t  },\n\t\n\t  some: function( fn, thisArg ){\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );\n\t\n\t      if( ret ){\n\t        return true;\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  every: function( fn, thisArg ){\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );\n\t\n\t      if( !ret ){\n\t        return false;\n\t      }\n\t    }\n\t\n\t    return true;\n\t  },\n\t\n\t  same: function( collection ){\n\t    collection = this.cy().collection( collection );\n\t\n\t    // cheap extra check\n\t    if( this.length !== collection.length ){\n\t      return false;\n\t    }\n\t\n\t    return this.intersect( collection ).length === this.length;\n\t  },\n\t\n\t  anySame: function( collection ){\n\t    collection = this.cy().collection( collection );\n\t\n\t    return this.intersect( collection ).length > 0;\n\t  },\n\t\n\t  allAreNeighbors: function( collection ){\n\t    collection = this.cy().collection( collection );\n\t\n\t    return this.neighborhood().intersect( collection ).length === collection.length;\n\t  }\n\t});\n\t\n\telesfn.allAreNeighbours = elesfn.allAreNeighbors;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar elesfn = ({\n\t  parent: function( selector ){\n\t    var parents = [];\n\t    var cy = this._private.cy;\n\t\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var ele = this[ i ];\n\t      var parent = cy.getElementById( ele._private.data.parent );\n\t\n\t      if( parent.size() > 0 ){\n\t        parents.push( parent );\n\t      }\n\t    }\n\t\n\t    return this.spawn( parents, { unique: true } ).filter( selector );\n\t  },\n\t\n\t  parents: function( selector ){\n\t    var parents = [];\n\t\n\t    var eles = this.parent();\n\t    while( eles.nonempty() ){\n\t      for( var i = 0; i < eles.length; i++ ){\n\t        var ele = eles[ i ];\n\t        parents.push( ele );\n\t      }\n\t\n\t      eles = eles.parent();\n\t    }\n\t\n\t    return this.spawn( parents, { unique: true } ).filter( selector );\n\t  },\n\t\n\t  commonAncestors: function( selector ){\n\t    var ancestors;\n\t\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var ele = this[ i ];\n\t      var parents = ele.parents();\n\t\n\t      ancestors = ancestors || parents;\n\t\n\t      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set\n\t    }\n\t\n\t    return ancestors.filter( selector );\n\t  },\n\t\n\t  orphans: function( selector ){\n\t    return this.stdFilter( function( ele ){\n\t      return ele.isNode() && ele.parent().empty();\n\t    } ).filter( selector );\n\t  },\n\t\n\t  nonorphans: function( selector ){\n\t    return this.stdFilter( function( ele ){\n\t      return ele.isNode() && ele.parent().nonempty();\n\t    } ).filter( selector );\n\t  },\n\t\n\t  children: function( selector ){\n\t    var children = [];\n\t\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var ele = this[ i ];\n\t      children = children.concat( ele._private.children );\n\t    }\n\t\n\t    return this.spawn( children, { unique: true } ).filter( selector );\n\t  },\n\t\n\t  siblings: function( selector ){\n\t    return this.parent().children().not( this ).filter( selector );\n\t  },\n\t\n\t  isParent: function(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      return ele._private.children.length !== 0;\n\t    }\n\t  },\n\t\n\t  isChild: function(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      return ele._private.data.parent !== undefined && ele.parent().length !== 0;\n\t    }\n\t  },\n\t\n\t  descendants: function( selector ){\n\t    var elements = [];\n\t\n\t    function add( eles ){\n\t      for( var i = 0; i < eles.length; i++ ){\n\t        var ele = eles[ i ];\n\t\n\t        elements.push( ele );\n\t\n\t        if( ele.children().nonempty() ){\n\t          add( ele.children() );\n\t        }\n\t      }\n\t    }\n\t\n\t    add( this.children() );\n\t\n\t    return this.spawn( elements, { unique: true } ).filter( selector );\n\t  }\n\t});\n\t\n\t// aliases\n\telesfn.ancestors = elesfn.parents;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar define = __webpack_require__( 56 );\n\tvar fn, elesfn;\n\t\n\tfn = elesfn = ({\n\t\n\t  data: define.data( {\n\t    field: 'data',\n\t    bindingEvent: 'data',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'data',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: true,\n\t    immutableKeys: {\n\t      'id': true,\n\t      'source': true,\n\t      'target': true,\n\t      'parent': true\n\t    },\n\t    updateStyle: true\n\t  } ),\n\t\n\t  removeData: define.removeData( {\n\t    field: 'data',\n\t    event: 'data',\n\t    triggerFnName: 'trigger',\n\t    triggerEvent: true,\n\t    immutableKeys: {\n\t      'id': true,\n\t      'source': true,\n\t      'target': true,\n\t      'parent': true\n\t    },\n\t    updateStyle: true\n\t  } ),\n\t\n\t  scratch: define.data( {\n\t    field: 'scratch',\n\t    bindingEvent: 'scratch',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'scratch',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: true,\n\t    updateStyle: true\n\t  } ),\n\t\n\t  removeScratch: define.removeData( {\n\t    field: 'scratch',\n\t    event: 'scratch',\n\t    triggerFnName: 'trigger',\n\t    triggerEvent: true,\n\t    updateStyle: true\n\t  } ),\n\t\n\t  rscratch: define.data( {\n\t    field: 'rscratch',\n\t    allowBinding: false,\n\t    allowSetting: true,\n\t    settingTriggersEvent: false,\n\t    allowGetting: true\n\t  } ),\n\t\n\t  removeRscratch: define.removeData( {\n\t    field: 'rscratch',\n\t    triggerEvent: false\n\t  } ),\n\t\n\t  id: function(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      return ele._private.data.id;\n\t    }\n\t  }\n\t\n\t});\n\t\n\t// aliases\n\tfn.attr = fn.data;\n\tfn.removeAttr = fn.removeData;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar elesfn = {};\n\t\n\tfunction defineDegreeFunction( callback ){\n\t  return function( includeLoops ){\n\t    var self = this;\n\t\n\t    if( includeLoops === undefined ){\n\t      includeLoops = true;\n\t    }\n\t\n\t    if( self.length === 0 ){ return; }\n\t\n\t    if( self.isNode() && !self.removed() ){\n\t      var degree = 0;\n\t      var node = self[0];\n\t      var connectedEdges = node._private.edges;\n\t\n\t      for( var i = 0; i < connectedEdges.length; i++ ){\n\t        var edge = connectedEdges[ i ];\n\t\n\t        if( !includeLoops && edge.isLoop() ){\n\t          continue;\n\t        }\n\t\n\t        degree += callback( node, edge );\n\t      }\n\t\n\t      return degree;\n\t    } else {\n\t      return;\n\t    }\n\t  };\n\t}\n\t\n\tutil.extend( elesfn, {\n\t  degree: defineDegreeFunction( function( node, edge ){\n\t    if( edge.source().same( edge.target() ) ){\n\t      return 2;\n\t    } else {\n\t      return 1;\n\t    }\n\t  } ),\n\t\n\t  indegree: defineDegreeFunction( function( node, edge ){\n\t    if( edge.target().same( node ) ){\n\t      return 1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  } ),\n\t\n\t  outdegree: defineDegreeFunction( function( node, edge ){\n\t    if( edge.source().same( node ) ){\n\t      return 1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  } )\n\t} );\n\t\n\tfunction defineDegreeBoundsFunction( degreeFn, callback ){\n\t  return function( includeLoops ){\n\t    var ret;\n\t    var nodes = this.nodes();\n\t\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      var ele = nodes[ i ];\n\t      var degree = ele[ degreeFn ]( includeLoops );\n\t      if( degree !== undefined && (ret === undefined || callback( degree, ret )) ){\n\t        ret = degree;\n\t      }\n\t    }\n\t\n\t    return ret;\n\t  };\n\t}\n\t\n\tutil.extend( elesfn, {\n\t  minDegree: defineDegreeBoundsFunction( 'degree', function( degree, min ){\n\t    return degree < min;\n\t  } ),\n\t\n\t  maxDegree: defineDegreeBoundsFunction( 'degree', function( degree, max ){\n\t    return degree > max;\n\t  } ),\n\t\n\t  minIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, min ){\n\t    return degree < min;\n\t  } ),\n\t\n\t  maxIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, max ){\n\t    return degree > max;\n\t  } ),\n\t\n\t  minOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, min ){\n\t    return degree < min;\n\t  } ),\n\t\n\t  maxOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, max ){\n\t    return degree > max;\n\t  } )\n\t} );\n\t\n\tutil.extend( elesfn, {\n\t  totalDegree: function( includeLoops ){\n\t    var total = 0;\n\t    var nodes = this.nodes();\n\t\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      total += nodes[ i ].degree( includeLoops );\n\t    }\n\t\n\t    return total;\n\t  }\n\t} );\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar define = __webpack_require__( 56 );\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\tvar fn, elesfn;\n\t\n\tfn = elesfn = ({\n\t\n\t  position: define.data( {\n\t    field: 'position',\n\t    bindingEvent: 'position',\n\t    allowBinding: true,\n\t    allowSetting: true,\n\t    settingEvent: 'position',\n\t    settingTriggersEvent: true,\n\t    triggerFnName: 'rtrigger',\n\t    allowGetting: true,\n\t    validKeys: [ 'x', 'y' ],\n\t    onSet: function( eles ){\n\t      var updatedEles = eles.updateCompoundBounds();\n\t      updatedEles.rtrigger( 'position' );\n\t    },\n\t    canSet: function( ele ){\n\t      return !ele.locked() && !ele.isParent();\n\t    }\n\t  } ),\n\t\n\t  // position but no notification to renderer\n\t  silentPosition: define.data( {\n\t    field: 'position',\n\t    bindingEvent: 'position',\n\t    allowBinding: false,\n\t    allowSetting: true,\n\t    settingEvent: 'position',\n\t    settingTriggersEvent: false,\n\t    triggerFnName: 'trigger',\n\t    allowGetting: true,\n\t    validKeys: [ 'x', 'y' ],\n\t    onSet: function( eles ){\n\t      eles.updateCompoundBounds();\n\t    },\n\t    canSet: function( ele ){\n\t      return !ele.locked() && !ele.isParent();\n\t    }\n\t  } ),\n\t\n\t  positions: function( pos, silent ){\n\t    if( is.plainObject( pos ) ){\n\t      this.position( pos );\n\t\n\t    } else if( is.fn( pos ) ){\n\t      var fn = pos;\n\t\n\t      for( var i = 0; i < this.length; i++ ){\n\t        var ele = this[ i ];\n\t\n\t        var pos = fn.apply( ele, [ i, ele ] );\n\t\n\t        if( pos && !ele.locked() && !ele.isParent() ){\n\t          var elePos = ele._private.position;\n\t          elePos.x = pos.x;\n\t          elePos.y = pos.y;\n\t        }\n\t      }\n\t\n\t      var updatedEles = this.updateCompoundBounds();\n\t      var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;\n\t\n\t      if( silent ){\n\t        toTrigger.trigger( 'position' );\n\t      } else {\n\t        toTrigger.rtrigger( 'position' );\n\t      }\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  silentPositions: function( pos ){\n\t    return this.positions( pos, true );\n\t  },\n\t\n\t  // get/set the rendered (i.e. on screen) positon of the element\n\t  renderedPosition: function( dim, val ){\n\t    var ele = this[0];\n\t    var cy = this.cy();\n\t    var zoom = cy.zoom();\n\t    var pan = cy.pan();\n\t    var rpos = is.plainObject( dim ) ? dim : undefined;\n\t    var setting = rpos !== undefined || ( val !== undefined && is.string( dim ) );\n\t\n\t    if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n\t      if( setting ){\n\t        for( var i = 0; i < this.length; i++ ){\n\t          var ele = this[ i ];\n\t\n\t          if( val !== undefined ){ // set one dimension\n\t            ele._private.position[ dim ] = ( val - pan[ dim ] ) / zoom;\n\t          } else if( rpos !== undefined ){ // set whole position\n\t            ele._private.position = {\n\t              x: ( rpos.x - pan.x ) / zoom,\n\t              y: ( rpos.y - pan.y ) / zoom\n\t            };\n\t          }\n\t        }\n\t\n\t        this.rtrigger( 'position' );\n\t      } else { // getting\n\t        var pos = ele._private.position;\n\t        rpos = {\n\t          x: pos.x * zoom + pan.x,\n\t          y: pos.y * zoom + pan.y\n\t        };\n\t\n\t        if( dim === undefined ){ // then return the whole rendered position\n\t          return rpos;\n\t        } else { // then return the specified dimension\n\t          return rpos[ dim ];\n\t        }\n\t      }\n\t    } else if( !setting ){\n\t      return undefined; // for empty collection case\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  // get/set the position relative to the parent\n\t  relativePosition: function( dim, val ){\n\t    var ele = this[0];\n\t    var cy = this.cy();\n\t    var ppos = is.plainObject( dim ) ? dim : undefined;\n\t    var setting = ppos !== undefined || ( val !== undefined && is.string( dim ) );\n\t    var hasCompoundNodes = cy.hasCompoundNodes();\n\t\n\t    if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n\t      if( setting ){\n\t        for( var i = 0; i < this.length; i++ ){\n\t          var ele = this[ i ];\n\t          var parent = hasCompoundNodes ? ele.parent() : null;\n\t          var hasParent = parent && parent.length > 0;\n\t          var relativeToParent = hasParent;\n\t\n\t          if( hasParent ){\n\t            parent = parent[0];\n\t          }\n\t\n\t          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\t\n\t          if( val !== undefined ){ // set one dimension\n\t            ele._private.position[ dim ] = val + origin[ dim ];\n\t          } else if( ppos !== undefined ){ // set whole position\n\t            ele._private.position = {\n\t              x: ppos.x + origin.x,\n\t              y: ppos.y + origin.y\n\t            };\n\t          }\n\t        }\n\t\n\t        this.rtrigger( 'position' );\n\t\n\t      } else { // getting\n\t        var pos = ele._private.position;\n\t        var parent = hasCompoundNodes ? ele.parent() : null;\n\t        var hasParent = parent && parent.length > 0;\n\t        var relativeToParent = hasParent;\n\t\n\t        if( hasParent ){\n\t          parent = parent[0];\n\t        }\n\t\n\t        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\t\n\t        ppos = {\n\t          x: pos.x - origin.x,\n\t          y: pos.y - origin.y\n\t        };\n\t\n\t        if( dim === undefined ){ // then return the whole rendered position\n\t          return ppos;\n\t        } else { // then return the specified dimension\n\t          return ppos[ dim ];\n\t        }\n\t      }\n\t    } else if( !setting ){\n\t      return undefined; // for empty collection case\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  renderedBoundingBox: function( options ){\n\t    var bb = this.boundingBox( options );\n\t    var cy = this.cy();\n\t    var zoom = cy.zoom();\n\t    var pan = cy.pan();\n\t\n\t    var x1 = bb.x1 * zoom + pan.x;\n\t    var x2 = bb.x2 * zoom + pan.x;\n\t    var y1 = bb.y1 * zoom + pan.y;\n\t    var y2 = bb.y2 * zoom + pan.y;\n\t\n\t    return {\n\t      x1: x1,\n\t      x2: x2,\n\t      y1: y1,\n\t      y2: y2,\n\t      w: x2 - x1,\n\t      h: y2 - y1\n\t    };\n\t  },\n\t\n\t  updateCompoundBounds: function(){\n\t    var cy = this.cy();\n\t\n\t    // save cycles for non compound graphs or when style disabled\n\t    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); }\n\t\n\t    var updated = [];\n\t\n\t    function update( parent ){\n\t      if( !parent.isParent() ){ return; }\n\t\n\t      var _p = parent._private;\n\t      var children = parent.children();\n\t      var includeLabels = parent.pstyle( 'compound-sizing-wrt-labels' ).value === 'include';\n\t      var bb = children.boundingBox( {\n\t        includeLabels: includeLabels,\n\t        includeShadows: false,\n\t        includeOverlays: false,\n\t\n\t        // updating the compound bounds happens outside of the regular\n\t        // cache cycle (i.e. before fired events)\n\t        useCache: false\n\t      } );\n\t      var padding = {\n\t        top: parent.pstyle( 'padding-top' ).pfValue,\n\t        bottom: parent.pstyle( 'padding-bottom' ).pfValue,\n\t        left: parent.pstyle( 'padding-left' ).pfValue,\n\t        right: parent.pstyle( 'padding-right' ).pfValue\n\t      };\n\t      var pos = _p.position;\n\t      var didUpdate = false;\n\t\n\t      if( parent.pstyle( 'width' ).value === 'auto' ){\n\t        _p.autoWidth = bb.w;\n\t        pos.x = (bb.x1 + bb.x2 - padding.left + padding.right) / 2;\n\t        didUpdate = true;\n\t      }\n\t\n\t      if( parent.pstyle( 'height' ).value === 'auto' ){\n\t        _p.autoHeight = bb.h;\n\t        pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom) / 2;\n\t        didUpdate = true;\n\t      }\n\t\n\t      if( didUpdate ){\n\t        updated.push( parent );\n\t      }\n\t    }\n\t\n\t    // go up, level by level\n\t    var eles = this;\n\t    while( eles.nonempty() ){\n\t\n\t      // update each parent node in this level\n\t      for( var i = 0; i < eles.length; i++ ){\n\t        var ele = eles[ i ];\n\t\n\t        update( ele );\n\t      }\n\t\n\t      // next level\n\t      eles = eles.parent();\n\t    }\n\t\n\t    // return changed\n\t    return this.spawn( updated );\n\t  }\n\t});\n\t\n\tvar noninf = function( x ){\n\t  if( x === Infinity || x === -Infinity ){\n\t    return 0;\n\t  }\n\t\n\t  return x;\n\t};\n\t\n\tvar updateBounds = function( b, x1, y1, x2, y2 ){\n\t  // don't update with zero area boxes\n\t  if( x2 - x1 === 0 || y2 - y1 === 0 ){ return; }\n\t\n\t  b.x1 = x1 < b.x1 ? x1 : b.x1;\n\t  b.x2 = x2 > b.x2 ? x2 : b.x2;\n\t  b.y1 = y1 < b.y1 ? y1 : b.y1;\n\t  b.y2 = y2 > b.y2 ? y2 : b.y2;\n\t};\n\t\n\tvar updateBoundsFromBox = function( b, b2 ){\n\t  return updateBounds( b, b2.x1, b2.y1, b2.x2, b2.y2 );\n\t};\n\t\n\tvar prefixedProperty = function( obj, field, prefix ){\n\t  return util.getPrefixedProperty( obj, field, prefix );\n\t};\n\t\n\tvar updateBoundsFromArrow = function( bounds, ele, prefix, options ){\n\t  var _p = ele._private;\n\t  var rstyle = _p.rstyle;\n\t  var halfArW = rstyle.arrowWidth / 2;\n\t  var arrowType = ele.pstyle( prefix + '-arrow-shape' ).value;\n\t  var x;\n\t  var y;\n\t\n\t  if( arrowType !== 'none' ){\n\t    if( prefix === 'source' ){\n\t      x = rstyle.srcX;\n\t      y = rstyle.srcY;\n\t    } else if( prefix === 'target' ){\n\t      x = rstyle.tgtX;\n\t      y = rstyle.tgtY;\n\t    } else {\n\t      x = rstyle.midX;\n\t      y = rstyle.midY;\n\t    }\n\t\n\t    updateBounds( bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW );\n\t  }\n\t};\n\t\n\tvar updateBoundsFromLabel = function( bounds, ele, prefix, options ){\n\t  var prefixDash;\n\t\n\t  if( prefix ){\n\t    prefixDash = prefix + '-';\n\t  } else {\n\t    prefixDash = '';\n\t  }\n\t\n\t  var _p = ele._private;\n\t  var rstyle = _p.rstyle;\n\t  var label = ele.pstyle( prefixDash + 'label' ).strValue;\n\t\n\t  if( label ){\n\t    var halign = ele.pstyle( 'text-halign' );\n\t    var valign = ele.pstyle( 'text-valign' );\n\t    var labelWidth = prefixedProperty( rstyle, 'labelWidth', prefix );\n\t    var labelHeight = prefixedProperty( rstyle, 'labelHeight', prefix );\n\t    var labelX = prefixedProperty( rstyle, 'labelX', prefix );\n\t    var labelY = prefixedProperty( rstyle, 'labelY', prefix );\n\t    var marginX = ele.pstyle( prefixDash + 'text-margin-x' ).pfValue;\n\t    var marginY = ele.pstyle( prefixDash + 'text-margin-y' ).pfValue;\n\t    var isEdge = ele.isEdge();\n\t    var rotation = ele.pstyle( prefixDash + 'text-rotation' );\n\t    var shadowR = ele.pstyle( 'text-shadow-blur' ).pfValue / 2;\n\t    var shadowX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;\n\t    var shadowY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;\n\t    var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;\n\t    var outlineWidth = ele.pstyle( 'text-outline-width' ).pfValue;\n\t\n\t    var lh = labelHeight;\n\t    var lw = labelWidth;\n\t    var lx1, lx2, ly1, ly2;\n\t\n\t    if( isEdge ){\n\t      lx1 = labelX - lw / 2;\n\t      lx2 = labelX + lw / 2;\n\t      ly1 = labelY - lh / 2;\n\t      ly2 = labelY + lh / 2;\n\t    } else {\n\t      switch( halign.value ){\n\t        case 'left':\n\t          lx1 = labelX - lw;\n\t          lx2 = labelX;\n\t          break;\n\t\n\t        case 'center':\n\t          lx1 = labelX - lw / 2;\n\t          lx2 = labelX + lw / 2;\n\t          break;\n\t\n\t        case 'right':\n\t          lx1 = labelX;\n\t          lx2 = labelX + lw;\n\t          break;\n\t      }\n\t\n\t      switch( valign.value ){\n\t        case 'top':\n\t          ly1 = labelY - lh;\n\t          ly2 = labelY;\n\t          break;\n\t\n\t        case 'center':\n\t          ly1 = labelY - lh / 2;\n\t          ly2 = labelY + lh / 2;\n\t          break;\n\t\n\t        case 'bottom':\n\t          ly1 = labelY;\n\t          ly2 = labelY + lh;\n\t          break;\n\t      }\n\t    }\n\t\n\t    var isAutorotate = ( isEdge && rotation.strValue === 'autorotate' );\n\t    var isPfValue = ( rotation.pfValue != null && rotation.pfValue !== 0 );\n\t\n\t    if( isAutorotate || isPfValue ){\n\t      var theta = isAutorotate ? prefixedProperty( _p.rstyle, 'labelAngle', prefix ) : rotation.pfValue;\n\t      var cos = Math.cos( theta );\n\t      var sin = Math.sin( theta );\n\t\n\t      var rotate = function( x, y ){\n\t        x = x - labelX;\n\t        y = y - labelY;\n\t\n\t        return {\n\t          x: x * cos - y * sin + labelX,\n\t          y: x * sin + y * cos + labelY\n\t        };\n\t      };\n\t\n\t      var px1y1 = rotate( lx1, ly1 );\n\t      var px1y2 = rotate( lx1, ly2 );\n\t      var px2y1 = rotate( lx2, ly1 );\n\t      var px2y2 = rotate( lx2, ly2 );\n\t\n\t      lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );\n\t      lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );\n\t      ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );\n\t      ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );\n\t    }\n\t\n\t    lx1 += marginX - outlineWidth;\n\t    lx2 += marginX + outlineWidth;\n\t    ly1 += marginY - outlineWidth;\n\t    ly2 += marginY + outlineWidth;\n\t\n\t    updateBounds( bounds, lx1, ly1, lx2, ly2 );\n\t\n\t    if( options.includeShadows && shadowOpacity > 0 ){\n\t      lx1 += - shadowR + shadowX;\n\t      lx2 += + shadowR + shadowX;\n\t      ly1 += - shadowR + shadowY;\n\t      ly2 += + shadowR + shadowY;\n\t\n\t      updateBounds( bounds, lx1, ly1, lx2, ly2 );\n\t    }\n\t  }\n\t\n\t  return bounds;\n\t};\n\t\n\t// get the bounding box of the elements (in raw model position)\n\tvar boundingBoxImpl = function( ele, options ){\n\t  var cy = ele._private.cy;\n\t  var cy_p = cy._private;\n\t  var styleEnabled = cy_p.styleEnabled;\n\t\n\t  var bounds = {\n\t    x1: Infinity,\n\t    y1: Infinity,\n\t    x2: -Infinity,\n\t    y2: -Infinity\n\t  };\n\t\n\t  var _p = ele._private;\n\t  var display = styleEnabled ? ele.pstyle( 'display' ).value : 'element';\n\t  var isNode = ele.isNode();\n\t  var isEdge = ele.isEdge();\n\t  var ex1, ex2, ey1, ey2, x, y;\n\t  var displayed = display !== 'none';\n\t\n\t  if( displayed ){\n\t    var overlayOpacity = 0;\n\t    var overlayPadding = 0;\n\t\n\t    if( styleEnabled && options.includeOverlays ){\n\t      overlayOpacity = ele.pstyle( 'overlay-opacity' ).value;\n\t\n\t      if( overlayOpacity !== 0 ){\n\t        overlayPadding = ele.pstyle( 'overlay-padding' ).value;\n\t      }\n\t    }\n\t\n\t    var w = 0;\n\t    var wHalf = 0;\n\t\n\t    if( styleEnabled ){\n\t      w = ele.pstyle( 'width' ).pfValue;\n\t      wHalf = w / 2;\n\t    }\n\t\n\t    if( isNode && options.includeNodes ){\n\t      var pos = _p.position;\n\t      x = pos.x;\n\t      y = pos.y;\n\t      var w = ele.outerWidth();\n\t      var halfW = w / 2;\n\t      var h = ele.outerHeight();\n\t      var halfH = h / 2;\n\t\n\t      // handle node dimensions\n\t      /////////////////////////\n\t\n\t      ex1 = x - halfW - overlayPadding;\n\t      ex2 = x + halfW + overlayPadding;\n\t      ey1 = y - halfH - overlayPadding;\n\t      ey2 = y + halfH + overlayPadding;\n\t\n\t      updateBounds( bounds, ex1, ey1, ex2, ey2 );\n\t\n\t    } else if( isEdge && options.includeEdges ){\n\t      var rstyle = _p.rstyle || {};\n\t\n\t      // handle edge dimensions (rough box estimate)\n\t      //////////////////////////////////////////////\n\t      if( styleEnabled ){\n\t        ex1 = Math.min( rstyle.srcX, rstyle.midX, rstyle.tgtX );\n\t        ex2 = Math.max( rstyle.srcX, rstyle.midX, rstyle.tgtX );\n\t        ey1 = Math.min( rstyle.srcY, rstyle.midY, rstyle.tgtY );\n\t        ey2 = Math.max( rstyle.srcY, rstyle.midY, rstyle.tgtY );\n\t\n\t        // take into account edge width\n\t        ex1 -= wHalf;\n\t        ex2 += wHalf;\n\t        ey1 -= wHalf;\n\t        ey2 += wHalf;\n\t\n\t        updateBounds( bounds, ex1, ey1, ex2, ey2 );\n\t      }\n\t\n\t      // precise haystacks\n\t      ////////////////////\n\t      if( styleEnabled && ele.pstyle( 'curve-style' ).strValue === 'haystack' ){\n\t        var hpts = rstyle.haystackPts;\n\t\n\t        ex1 = hpts[0].x;\n\t        ey1 = hpts[0].y;\n\t        ex2 = hpts[1].x;\n\t        ey2 = hpts[1].y;\n\t\n\t        if( ex1 > ex2 ){\n\t          var temp = ex1;\n\t          ex1 = ex2;\n\t          ex2 = temp;\n\t        }\n\t\n\t        if( ey1 > ey2 ){\n\t          var temp = ey1;\n\t          ey1 = ey2;\n\t          ey2 = temp;\n\t        }\n\t\n\t        updateBounds( bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf );\n\t\n\t      // handle points along edge\n\t      ///////////////////////////\n\t      } else {\n\t        var pts = rstyle.bezierPts || rstyle.linePts || [];\n\t\n\t        for( var j = 0; j < pts.length; j++ ){\n\t          var pt = pts[ j ];\n\t\n\t          ex1 = pt.x - wHalf;\n\t          ex2 = pt.x + wHalf;\n\t          ey1 = pt.y - wHalf;\n\t          ey2 = pt.y + wHalf;\n\t\n\t          updateBounds( bounds, ex1, ey1, ex2, ey2 );\n\t        }\n\t\n\t        // fallback on source and target positions\n\t        //////////////////////////////////////////\n\t        if( pts.length === 0 ){\n\t          var n1 = _p.source;\n\t          var n1_p = n1._private;\n\t          var n1pos = n1_p.position;\n\t\n\t          var n2 = _p.target;\n\t          var n2_p = n2._private;\n\t          var n2pos = n2_p.position;\n\t\n\t          ex1 = n1pos.x;\n\t          ex2 = n2pos.x;\n\t          ey1 = n1pos.y;\n\t          ey2 = n2pos.y;\n\t\n\t          if( ex1 > ex2 ){\n\t            var temp = ex1;\n\t            ex1 = ex2;\n\t            ex2 = temp;\n\t          }\n\t\n\t          if( ey1 > ey2 ){\n\t            var temp = ey1;\n\t            ey1 = ey2;\n\t            ey2 = temp;\n\t          }\n\t\n\t          // take into account edge width\n\t          ex1 -= wHalf;\n\t          ex2 += wHalf;\n\t          ey1 -= wHalf;\n\t          ey2 += wHalf;\n\t\n\t          updateBounds( bounds, ex1, ey1, ex2, ey2 );\n\t        }\n\t      }\n\t\n\t    } // edges\n\t\n\t    // shadow and overlay\n\t    /////////////////////\n\t\n\t    if( styleEnabled ){\n\t\n\t      ex1 = bounds.x1;\n\t      ex2 = bounds.x2;\n\t      ey1 = bounds.y1;\n\t      ey2 = bounds.y2;\n\t\n\t      if( options.includeShadows && ele.pstyle('shadow-opacity').value > 0 ){\n\t        var r = ele.pstyle('shadow-blur').pfValue / 2;\n\t        var ox = ele.pstyle('shadow-offset-x').pfValue;\n\t        var oy = ele.pstyle('shadow-offset-y').pfValue;\n\t\n\t        updateBounds( bounds, ex1 - r + ox, ey1 - r + oy, ex2 + r + ox, ey2 + r + oy );\n\t      }\n\t\n\t      updateBounds( bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding );\n\t    }\n\t\n\t    // handle edge arrow size\n\t    /////////////////////////\n\t\n\t    if( styleEnabled && options.includeEdges && isEdge ){\n\t      updateBoundsFromArrow( bounds, ele, 'mid-source', options );\n\t      updateBoundsFromArrow( bounds, ele, 'mid-target', options );\n\t      updateBoundsFromArrow( bounds, ele, 'source', options );\n\t      updateBoundsFromArrow( bounds, ele, 'target', options );\n\t    }\n\t\n\t    // handle label dimensions\n\t    //////////////////////////\n\t\n\t    if( styleEnabled && options.includeLabels ){\n\t      updateBoundsFromLabel( bounds, ele, null, options );\n\t\n\t      if( isEdge ){\n\t        updateBoundsFromLabel( bounds, ele, 'source', options );\n\t        updateBoundsFromLabel( bounds, ele, 'target', options );\n\t      }\n\t    } // style enabled for labels\n\t  } // if displayed\n\t\n\t  bounds.x1 = noninf( bounds.x1 );\n\t  bounds.y1 = noninf( bounds.y1 );\n\t  bounds.x2 = noninf( bounds.x2 );\n\t  bounds.y2 = noninf( bounds.y2 );\n\t  bounds.w = noninf( bounds.x2 - bounds.x1 );\n\t  bounds.h = noninf( bounds.y2 - bounds.y1 );\n\t\n\t  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n\t  if( bounds.w > 0 && bounds.h > 0 && displayed ){\n\t    math.expandBoundingBox( bounds, 1 );\n\t  }\n\t\n\t  return bounds;\n\t};\n\t\n\tvar tf = function( val ){\n\t  if( val ){\n\t    return 't';\n\t  } else {\n\t    return 'f';\n\t  }\n\t};\n\t\n\tvar getKey = function( opts ){\n\t  var key = '';\n\t\n\t  key += tf( opts.incudeNodes );\n\t  key += tf( opts.includeEdges );\n\t  key += tf( opts.includeLabels );\n\t  key += tf( opts.includeShadows );\n\t  key += tf( opts.includeOverlays );\n\t\n\t  return key;\n\t};\n\t\n\tvar cachedBoundingBoxImpl = function( ele, opts ){\n\t  var _p = ele._private;\n\t  var bb;\n\t  var headless = ele.cy().headless();\n\t  var key = opts === defBbOpts ? defBbOptsKey : getKey( opts );\n\t\n\t  if( !opts.useCache || headless || !_p.bbCache || !_p.bbCache[key] ){\n\t    bb = boundingBoxImpl( ele, opts );\n\t\n\t    if( !headless ){\n\t      _p.bbCache = _p.bbCache || {};\n\t      _p.bbCache[key] = bb;\n\t    }\n\t  } else {\n\t    bb = _p.bbCache[key];\n\t  }\n\t\n\t  return bb;\n\t};\n\t\n\tvar defBbOpts = {\n\t  includeNodes: true,\n\t  includeEdges: true,\n\t  includeLabels: true,\n\t  includeShadows: true,\n\t  includeOverlays: true,\n\t  useCache: true\n\t};\n\t\n\tvar defBbOptsKey = getKey( defBbOpts );\n\t\n\telesfn.boundingBox = function( options ){\n\t  // the main usecase is ele.boundingBox() for a single element with no/def options\n\t  // specified s.t. the cache is used, so check for this case to make it faster by\n\t  // avoiding the overhead of the rest of the function\n\t  if( this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true) ){\n\t    if( options === undefined ){\n\t      options = defBbOpts;\n\t    }\n\t\n\t    return cachedBoundingBoxImpl( this[0], options );\n\t  }\n\t\n\t  var bounds = {\n\t    x1: Infinity,\n\t    y1: Infinity,\n\t    x2: -Infinity,\n\t    y2: -Infinity\n\t  };\n\t\n\t  options = options || util.staticEmptyObject();\n\t\n\t  var opts = {\n\t    includeNodes: util.default( options.includeNodes, defBbOpts.includeNodes ),\n\t    includeEdges: util.default( options.includeEdges, defBbOpts.includeEdges ),\n\t    includeLabels: util.default( options.includeLabels, defBbOpts.includeLabels ),\n\t    includeShadows: util.default( options.includeShadows, defBbOpts.includeShadows ),\n\t    includeOverlays: util.default( options.includeOverlays, defBbOpts.includeOverlays ),\n\t    useCache: util.default( options.useCache, defBbOpts.useCache )\n\t  };\n\t\n\t  var eles = this;\n\t  var cy = eles.cy();\n\t  var renderer = eles.cy().renderer();\n\t  var styleEnabled = cy.styleEnabled();\n\t\n\t  if( styleEnabled ){\n\t    renderer.recalculateRenderedStyle( eles, opts.useCache );\n\t  }\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[i];\n\t\n\t    if( styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' ){\n\t      renderer.recalculateRenderedStyle( ele.parallelEdges(), opts.useCache ); // n.b. ele.parallelEdges() single is cached\n\t    }\n\t\n\t    updateBoundsFromBox( bounds, cachedBoundingBoxImpl( ele, opts ) );\n\t  }\n\t\n\t  bounds.x1 = noninf( bounds.x1 );\n\t  bounds.y1 = noninf( bounds.y1 );\n\t  bounds.x2 = noninf( bounds.x2 );\n\t  bounds.y2 = noninf( bounds.y2 );\n\t  bounds.w = noninf( bounds.x2 - bounds.x1 );\n\t  bounds.h = noninf( bounds.y2 - bounds.y1 );\n\t\n\t  return bounds;\n\t};\n\t\n\tvar defineDimFns = function( opts ){\n\t  opts.uppercaseName = util.capitalize( opts.name );\n\t  opts.autoName = 'auto' + opts.uppercaseName;\n\t  opts.labelName = 'label' + opts.uppercaseName;\n\t  opts.outerName = 'outer' + opts.uppercaseName;\n\t  opts.uppercaseOuterName = util.capitalize( opts.outerName );\n\t\n\t  fn[ opts.name ] = function dimImpl(){\n\t    var ele = this[0];\n\t    var _p = ele._private;\n\t    var cy = _p.cy;\n\t    var styleEnabled = cy._private.styleEnabled;\n\t\n\t    if( ele ){\n\t      if( styleEnabled ){\n\t        var d = ele.pstyle( opts.name );\n\t\n\t        switch( d.strValue ){\n\t          case 'auto':\n\t            return _p[ opts.autoName ] || 0;\n\t          case 'label':\n\t            return _p.rstyle[ opts.labelName ] || 0;\n\t          default:\n\t            return d.pfValue;\n\t        }\n\t      } else {\n\t        return 1;\n\t      }\n\t    }\n\t  };\n\t\n\t  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){\n\t    var ele = this[0];\n\t    var _p = ele._private;\n\t    var cy = _p.cy;\n\t    var styleEnabled = cy._private.styleEnabled;\n\t\n\t    if( ele ){\n\t      if( styleEnabled ){\n\t        var dim = ele[ opts.name ]();\n\t        var border = ele.pstyle( 'border-width' ).pfValue;\n\t        var padding = ele.pstyle( opts.paddings[0] ).pfValue + ele.pstyle( opts.paddings[1] ).pfValue;\n\t\n\t        return dim + border + padding;\n\t      } else {\n\t        return 1;\n\t      }\n\t    }\n\t  };\n\t\n\t  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      var d = ele[ opts.name ]();\n\t      return d * this.cy().zoom();\n\t    }\n\t  };\n\t\n\t  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      var od = ele[ opts.outerName ]();\n\t      return od * this.cy().zoom();\n\t    }\n\t  };\n\t};\n\t\n\tdefineDimFns( {\n\t  name: 'width',\n\t  paddings: [ 'padding-left', 'padding-right' ]\n\t} );\n\t\n\tdefineDimFns( {\n\t  name: 'height',\n\t  paddings: [ 'padding-top', 'padding-bottom' ]\n\t} );\n\t\n\t// aliases\n\tfn.modelPosition = fn.point = fn.position;\n\tfn.modelPositions = fn.points = fn.positions;\n\tfn.renderedPoint = fn.renderedPosition;\n\tfn.relativePoint = fn.relativePosition;\n\tfn.boundingbox = fn.boundingBox;\n\tfn.renderedBoundingbox = fn.renderedBoundingBox;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar define = __webpack_require__( 56 );\n\t\n\tvar elesfn = ({\n\t  on: define.on(), // .on( events [, selector] [, data], handler)\n\t  one: define.on( { unbindSelfOnTrigger: true } ),\n\t  once: define.on( { unbindAllBindersOnTrigger: true } ),\n\t  off: define.off(), // .off( events [, selector] [, handler] )\n\t  trigger: define.trigger(), // .trigger( events [, extraParams] )\n\t\n\t  rtrigger: function( event, extraParams ){ // for internal use only\n\t    if( this.length === 0 ){ return; } // empty collections don't need to notify anything\n\t\n\t    // notify renderer\n\t    this.cy().notify( {\n\t      type: event,\n\t      eles: this\n\t    } );\n\t\n\t    this.trigger( event, extraParams );\n\t    return this;\n\t  }\n\t});\n\t\n\t// aliases:\n\tdefine.eventAliasesOn( elesfn );\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar Selector = __webpack_require__( 57 );\n\t\n\tvar elesfn = ({\n\t  nodes: function( selector ){\n\t    return this.filter( function( i, element ){\n\t      return element.isNode();\n\t    } ).filter( selector );\n\t  },\n\t\n\t  edges: function( selector ){\n\t    return this.filter( function( i, element ){\n\t      return element.isEdge();\n\t    } ).filter( selector );\n\t  },\n\t\n\t  filter: function( filter ){\n\t    if( filter === undefined ){ // check this first b/c it's the most common/performant case\n\t      return this;\n\t    } else if( is.string( filter ) || is.elementOrCollection( filter ) ){\n\t      return Selector( filter ).filter( this );\n\t    } else if( is.fn( filter ) ){\n\t      var elements = [];\n\t\n\t      for( var i = 0; i < this.length; i++ ){\n\t        var ele = this[ i ];\n\t\n\t        if( filter.apply( ele, [ i, ele ] ) ){\n\t          elements.push( ele );\n\t        }\n\t      }\n\t\n\t      return this.spawn( elements );\n\t    }\n\t\n\t    return this.spawn(); // if not handled by above, give 'em an empty collection\n\t  },\n\t\n\t  not: function( toRemove ){\n\t    if( !toRemove ){\n\t      return this;\n\t    } else {\n\t\n\t      if( is.string( toRemove ) ){\n\t        toRemove = this.filter( toRemove );\n\t      }\n\t\n\t      var elements = [];\n\t\n\t      for( var i = 0; i < this.length; i++ ){\n\t        var element = this[ i ];\n\t\n\t        var remove = toRemove._private.ids[ element.id() ];\n\t        if( !remove ){\n\t          elements.push( element );\n\t        }\n\t      }\n\t\n\t      return this.spawn( elements );\n\t    }\n\t\n\t  },\n\t\n\t  absoluteComplement: function(){\n\t    var cy = this._private.cy;\n\t\n\t    return cy.mutableElements().not( this );\n\t  },\n\t\n\t  intersect: function( other ){\n\t    // if a selector is specified, then filter by it instead\n\t    if( is.string( other ) ){\n\t      var selector = other;\n\t      return this.filter( selector );\n\t    }\n\t\n\t    var elements = [];\n\t    var col1 = this;\n\t    var col2 = other;\n\t    var col1Smaller = this.length < other.length;\n\t    // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;\n\t    var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;\n\t    var col = col1Smaller ? col1 : col2;\n\t\n\t    for( var i = 0; i < col.length; i++ ){\n\t      var id = col[ i ]._private.data.id;\n\t      var ele = ids2[ id ];\n\t\n\t      if( ele ){\n\t        elements.push( ele );\n\t      }\n\t    }\n\t\n\t    return this.spawn( elements );\n\t  },\n\t\n\t  xor: function( other ){\n\t    var cy = this._private.cy;\n\t\n\t    if( is.string( other ) ){\n\t      other = cy.$( other );\n\t    }\n\t\n\t    var elements = [];\n\t    var col1 = this;\n\t    var col2 = other;\n\t\n\t    var add = function( col, other ){\n\t\n\t      for( var i = 0; i < col.length; i++ ){\n\t        var ele = col[ i ];\n\t        var id = ele._private.data.id;\n\t        var inOther = other._private.ids[ id ];\n\t\n\t        if( !inOther ){\n\t          elements.push( ele );\n\t        }\n\t      }\n\t\n\t    };\n\t\n\t    add( col1, col2 );\n\t    add( col2, col1 );\n\t\n\t    return this.spawn( elements );\n\t  },\n\t\n\t  diff: function( other ){\n\t    var cy = this._private.cy;\n\t\n\t    if( is.string( other ) ){\n\t      other = cy.$( other );\n\t    }\n\t\n\t    var left = [];\n\t    var right = [];\n\t    var both = [];\n\t    var col1 = this;\n\t    var col2 = other;\n\t\n\t    var add = function( col, other, retEles ){\n\t\n\t      for( var i = 0; i < col.length; i++ ){\n\t        var ele = col[ i ];\n\t        var id = ele._private.data.id;\n\t        var inOther = other._private.ids[ id ];\n\t\n\t        if( inOther ){\n\t          both.push( ele );\n\t        } else {\n\t          retEles.push( ele );\n\t        }\n\t      }\n\t\n\t    };\n\t\n\t    add( col1, col2, left );\n\t    add( col2, col1, right );\n\t\n\t    return {\n\t      left: this.spawn( left, { unique: true } ),\n\t      right: this.spawn( right, { unique: true } ),\n\t      both: this.spawn( both, { unique: true } )\n\t    };\n\t  },\n\t\n\t  add: function( toAdd ){\n\t    var cy = this._private.cy;\n\t\n\t    if( !toAdd ){\n\t      return this;\n\t    }\n\t\n\t    if( is.string( toAdd ) ){\n\t      var selector = toAdd;\n\t      toAdd = cy.mutableElements().filter( selector );\n\t    }\n\t\n\t    var elements = [];\n\t\n\t    for( var i = 0; i < this.length; i++ ){\n\t      elements.push( this[ i ] );\n\t    }\n\t\n\t    for( var i = 0; i < toAdd.length; i++ ){\n\t\n\t      var add = !this._private.ids[ toAdd[ i ].id() ];\n\t      if( add ){\n\t        elements.push( toAdd[ i ] );\n\t      }\n\t    }\n\t\n\t    return this.spawn( elements );\n\t  },\n\t\n\t  // in place merge on calling collection\n\t  merge: function( toAdd ){\n\t    var _p = this._private;\n\t    var cy = _p.cy;\n\t\n\t    if( !toAdd ){\n\t      return this;\n\t    }\n\t\n\t    if( toAdd && is.string( toAdd ) ){\n\t      var selector = toAdd;\n\t      toAdd = cy.mutableElements().filter( selector );\n\t    }\n\t\n\t    for( var i = 0; i < toAdd.length; i++ ){\n\t      var toAddEle = toAdd[ i ];\n\t      var id = toAddEle._private.data.id;\n\t      var add = !_p.ids[ id ];\n\t\n\t      if( add ){\n\t        var index = this.length++;\n\t\n\t        this[ index ] = toAddEle;\n\t        _p.ids[ id ] = toAddEle;\n\t        _p.indexes[ id ] = index;\n\t      } else { // replace\n\t        var index = _p.indexes[ id ];\n\t\n\t        this[ index ] = toAddEle;\n\t        _p.ids[ id ] = toAddEle;\n\t      }\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  // remove single ele in place in calling collection\n\t  unmergeOne: function( ele ){\n\t    ele = ele[0];\n\t\n\t    var _p = this._private;\n\t    var id = ele._private.data.id;\n\t    var i = _p.indexes[ id ];\n\t\n\t    if( i == null ){\n\t      return this; // no need to remove\n\t    }\n\t\n\t    // remove ele\n\t    this[ i ] = undefined;\n\t    _p.ids[ id ] = undefined;\n\t    _p.indexes[ id ] = undefined;\n\t\n\t    var unmergedLastEle = i === this.length - 1;\n\t\n\t    // replace empty spot with last ele in collection\n\t    if( this.length > 1 && !unmergedLastEle ){\n\t      var lastEleI = this.length - 1;\n\t      var lastEle = this[ lastEleI ];\n\t      var lastEleId = lastEle._private.data.id;\n\t\n\t      this[ lastEleI ] = undefined;\n\t      this[ i ] = lastEle;\n\t      _p.indexes[ lastEleId ] = i;\n\t    }\n\t\n\t    // the collection is now 1 ele smaller\n\t    this.length--;\n\t\n\t    return this;\n\t  },\n\t\n\t  // remove eles in place on calling collection\n\t  unmerge: function( toRemove ){\n\t    var cy = this._private.cy;\n\t\n\t    if( !toRemove ){\n\t      return this;\n\t    }\n\t\n\t    if( toRemove && is.string( toRemove ) ){\n\t      var selector = toRemove;\n\t      toRemove = cy.mutableElements().filter( selector );\n\t    }\n\t\n\t    for( var i = 0; i < toRemove.length; i++ ){\n\t      this.unmergeOne( toRemove[ i ] );\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  map: function( mapFn, thisArg ){\n\t    var arr = [];\n\t    var eles = this;\n\t\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[ i ];\n\t      var ret = thisArg ? mapFn.apply( thisArg, [ ele, i, eles ] ) : mapFn( ele, i, eles );\n\t\n\t      arr.push( ret );\n\t    }\n\t\n\t    return arr;\n\t  },\n\t\n\t  stdFilter: function( fn, thisArg ){\n\t    var filterEles = [];\n\t    var eles = this;\n\t\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[ i ];\n\t      var include = thisArg ? fn.apply( thisArg, [ ele, i, eles ] ) : fn( ele, i, eles );\n\t\n\t      if( include ){\n\t        filterEles.push( ele );\n\t      }\n\t    }\n\t\n\t    return this.spawn( filterEles );\n\t  },\n\t\n\t  max: function( valFn, thisArg ){\n\t    var max = -Infinity;\n\t    var maxEle;\n\t    var eles = this;\n\t\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[ i ];\n\t      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );\n\t\n\t      if( val > max ){\n\t        max = val;\n\t        maxEle = ele;\n\t      }\n\t    }\n\t\n\t    return {\n\t      value: max,\n\t      ele: maxEle\n\t    };\n\t  },\n\t\n\t  min: function( valFn, thisArg ){\n\t    var min = Infinity;\n\t    var minEle;\n\t    var eles = this;\n\t\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[ i ];\n\t      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );\n\t\n\t      if( val < min ){\n\t        min = val;\n\t        minEle = ele;\n\t      }\n\t    }\n\t\n\t    return {\n\t      value: min,\n\t      ele: minEle\n\t    };\n\t  }\n\t});\n\t\n\t// aliases\n\tvar fn = elesfn;\n\tfn[ 'u' ] = fn[ '|' ] = fn[ '+' ] = fn.union = fn.or = fn.add;\n\tfn[ '\\\\' ] = fn[ '!' ] = fn[ '-' ] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;\n\tfn[ 'n' ] = fn[ '&' ] = fn[ '.' ] = fn.and = fn.intersection = fn.intersect;\n\tfn[ '^' ] = fn[ '(+)' ] = fn[ '(-)' ] = fn.symmetricDifference = fn.symdiff = fn.xor;\n\tfn.fnFilter = fn.filterFn = fn.stdFilter;\n\tfn.complement = fn.abscomp = fn.absoluteComplement;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar elesfn = ({\n\t  isNode: function(){\n\t    return this.group() === 'nodes';\n\t  },\n\t\n\t  isEdge: function(){\n\t    return this.group() === 'edges';\n\t  },\n\t\n\t  isLoop: function(){\n\t    return this.isEdge() && this.source().id() === this.target().id();\n\t  },\n\t\n\t  isSimple: function(){\n\t    return this.isEdge() && this.source().id() !== this.target().id();\n\t  },\n\t\n\t  group: function(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      return ele._private.group;\n\t    }\n\t  }\n\t});\n\t\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar zIndexSort = __webpack_require__( 72 );\n\t\n\tvar elesfn = ({\n\t  each: function( fn ){\n\t    if( is.fn( fn ) ){\n\t      for( var i = 0; i < this.length; i++ ){\n\t        var ele = this[ i ];\n\t        var ret = fn.apply( ele, [ i, ele ] );\n\t\n\t        if( ret === false ){ break; } // exit each early on return false\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t\n\t  forEach: function( fn, thisArg ){\n\t    if( is.fn( fn ) ){\n\t\n\t      for( var i = 0; i < this.length; i++ ){\n\t        var ele = this[ i ];\n\t        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );\n\t\n\t        if( ret === false ){ break; } // exit each early on return false\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  toArray: function(){\n\t    var array = [];\n\t\n\t    for( var i = 0; i < this.length; i++ ){\n\t      array.push( this[ i ] );\n\t    }\n\t\n\t    return array;\n\t  },\n\t\n\t  slice: function( start, end ){\n\t    var array = [];\n\t    var thisSize = this.length;\n\t\n\t    if( end == null ){\n\t      end = thisSize;\n\t    }\n\t\n\t    if( start == null ){\n\t      start = 0;\n\t    }\n\t\n\t    if( start < 0 ){\n\t      start = thisSize + start;\n\t    }\n\t\n\t    if( end < 0 ){\n\t      end = thisSize + end;\n\t    }\n\t\n\t    for( var i = start; i >= 0 && i < end && i < thisSize; i++ ){\n\t      array.push( this[ i ] );\n\t    }\n\t\n\t    return this.spawn( array );\n\t  },\n\t\n\t  size: function(){\n\t    return this.length;\n\t  },\n\t\n\t  eq: function( i ){\n\t    return this[ i ] || this.spawn();\n\t  },\n\t\n\t  first: function(){\n\t    return this[0] || this.spawn();\n\t  },\n\t\n\t  last: function(){\n\t    return this[ this.length - 1 ] || this.spawn();\n\t  },\n\t\n\t  empty: function(){\n\t    return this.length === 0;\n\t  },\n\t\n\t  nonempty: function(){\n\t    return !this.empty();\n\t  },\n\t\n\t  sort: function( sortFn ){\n\t    if( !is.fn( sortFn ) ){\n\t      return this;\n\t    }\n\t\n\t    var sorted = this.toArray().sort( sortFn );\n\t\n\t    return this.spawn( sorted );\n\t  },\n\t\n\t  sortByZIndex: function(){\n\t    return this.sort( zIndexSort );\n\t  },\n\t\n\t  zDepth: function(){\n\t    var ele = this[0];\n\t    if( !ele ){ return undefined; }\n\t\n\t    // var cy = ele.cy();\n\t    var _p = ele._private;\n\t    var group = _p.group;\n\t\n\t    if( group === 'nodes' ){\n\t      var depth = _p.data.parent ? ele.parents().size() : 0;\n\t\n\t      if( !ele.isParent() ){\n\t        return Number.MAX_VALUE; // childless nodes always on top\n\t      }\n\t\n\t      return depth;\n\t    } else {\n\t      var src = _p.source;\n\t      var tgt = _p.target;\n\t      var srcDepth = src.zDepth();\n\t      var tgtDepth = tgt.zDepth();\n\t\n\t      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent\n\t    }\n\t  }\n\t});\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar zIndexSort = function( a, b ){\n\t  var cy = a.cy();\n\t  var zDiff = a.pstyle( 'z-index' ).value - b.pstyle( 'z-index' ).value;\n\t  var depthA = 0;\n\t  var depthB = 0;\n\t  var hasCompoundNodes = cy.hasCompoundNodes();\n\t  var aIsNode = a.isNode();\n\t  var aIsEdge = !aIsNode;\n\t  var bIsNode = b.isNode();\n\t  var bIsEdge = !bIsNode;\n\t\n\t  // no need to calculate element depth if there is no compound node\n\t  if( hasCompoundNodes ){\n\t    depthA = a.zDepth();\n\t    depthB = b.zDepth();\n\t  }\n\t\n\t  var depthDiff = depthA - depthB;\n\t  var sameDepth = depthDiff === 0;\n\t\n\t  if( sameDepth ){\n\t\n\t    if( aIsNode && bIsEdge ){\n\t      return 1; // 'a' is a node, it should be drawn later\n\t\n\t    } else if( aIsEdge && bIsNode ){\n\t      return -1; // 'a' is an edge, it should be drawn first\n\t\n\t    } else { // both nodes or both edges\n\t      if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)\n\t        return a.poolIndex() - b.poolIndex();\n\t      } else {\n\t        return zDiff;\n\t      }\n\t    }\n\t\n\t  // elements on different level\n\t  } else {\n\t    return depthDiff; // deeper element should be drawn later\n\t  }\n\t\n\t};\n\t\n\tmodule.exports = zIndexSort;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\tvar Promise = __webpack_require__(58);\n\t\n\tvar elesfn = ({\n\t\n\t  // using standard layout options, apply position function (w/ or w/o animation)\n\t  layoutPositions: function( layout, options, fn ){\n\t    var nodes = this.nodes();\n\t    var cy = this.cy();\n\t\n\t    layout.trigger( { type: 'layoutstart', layout: layout } );\n\t\n\t    layout.animations = [];\n\t\n\t    if( options.animate ){\n\t      for( var i = 0; i < nodes.length; i++ ){\n\t        var node = nodes[ i ];\n\t        var lastNode = i === nodes.length - 1;\n\t\n\t        var newPos = fn.call( node, i, node );\n\t        var pos = node.position();\n\t\n\t        if( !is.number( pos.x ) || !is.number( pos.y ) ){\n\t          node.silentPosition( { x: 0, y: 0 } );\n\t        }\n\t\n\t        var ani = node.animation( {\n\t          position: newPos,\n\t          duration: options.animationDuration,\n\t          easing: options.animationEasing\n\t        } );\n\t\n\t        layout.animations.push( ani );\n\t\n\t        ani.play();\n\t      }\n\t\n\t      var onStep;\n\t      cy.on( 'step.*', ( onStep = function(){\n\t        if( options.fit ){\n\t          cy.fit( options.eles, options.padding );\n\t        }\n\t      }) );\n\t\n\t      layout.one('layoutstop', function(){\n\t        cy.off('step.*', onStep);\n\t      });\n\t\n\t      layout.one( 'layoutready', options.ready );\n\t      layout.trigger( { type: 'layoutready', layout: layout } );\n\t\n\t      Promise.all( layout.animations.map(function( ani ){\n\t        return ani.promise();\n\t      }) ).then(function(){\n\t        cy.off('step.*', onStep);\n\t\n\t        if( options.zoom != null ){\n\t          cy.zoom( options.zoom );\n\t        }\n\t\n\t        if( options.pan ){\n\t          cy.pan( options.pan );\n\t        }\n\t\n\t        if( options.fit ){\n\t          cy.fit( options.eles, options.padding );\n\t        }\n\t\n\t        layout.one( 'layoutstop', options.stop );\n\t        layout.trigger( { type: 'layoutstop', layout: layout } );\n\t      });\n\t    } else {\n\t      nodes.positions( fn );\n\t\n\t      if( options.fit ){\n\t        cy.fit( options.eles, options.padding );\n\t      }\n\t\n\t      if( options.zoom != null ){\n\t        cy.zoom( options.zoom );\n\t      }\n\t\n\t      if( options.pan ){\n\t        cy.pan( options.pan );\n\t      }\n\t\n\t      layout.one( 'layoutready', options.ready );\n\t      layout.trigger( { type: 'layoutready', layout: layout } );\n\t\n\t      layout.one( 'layoutstop', options.stop );\n\t      layout.trigger( { type: 'layoutstop', layout: layout } );\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  layout: function( options ){\n\t    var cy = this.cy();\n\t\n\t    cy.layout( util.extend( {}, options, {\n\t      eles: this\n\t    } ) );\n\t\n\t    return this;\n\t  },\n\t\n\t  makeLayout: function( options ){\n\t    var cy = this.cy();\n\t\n\t    return cy.makeLayout( util.extend( {}, options, {\n\t      eles: this\n\t    } ) );\n\t  }\n\t\n\t});\n\t\n\t// aliases:\n\telesfn.createLayout = elesfn.makeLayout;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar elesfn = ({\n\t\n\t  // fully updates (recalculates) the style for the elements\n\t  updateStyle: function( notifyRenderer ){\n\t    var cy = this._private.cy;\n\t\n\t    if( !cy.styleEnabled() ){ return this; }\n\t\n\t    if( cy._private.batchingStyle ){\n\t      var bEles = cy._private.batchStyleEles;\n\t\n\t      bEles.merge( this );\n\t\n\t      return this; // chaining and exit early when batching\n\t    }\n\t\n\t    var style = cy.style();\n\t    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\t\n\t    style.apply( this );\n\t\n\t    var updatedCompounds = this.updateCompoundBounds();\n\t    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\t\n\t    if( notifyRenderer ){\n\t      toNotify.rtrigger( 'style' ); // let renderer know we changed style\n\t    } else {\n\t      toNotify.trigger( 'style' ); // just fire the event\n\t    }\n\t    return this; // chaining\n\t  },\n\t\n\t  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()\n\t  updateMappers: function( notifyRenderer ){\n\t    var cy = this._private.cy;\n\t    var style = cy.style();\n\t    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\t\n\t    if( !cy.styleEnabled() ){ return this; }\n\t\n\t    style.updateMappers( this );\n\t\n\t    var updatedCompounds = this.updateCompoundBounds();\n\t    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\t\n\t    if( notifyRenderer ){\n\t      toNotify.rtrigger( 'style' ); // let renderer know we changed style\n\t    } else {\n\t      toNotify.trigger( 'style' ); // just fire the event\n\t    }\n\t    return this; // chaining\n\t  },\n\t\n\t  // get the internal parsed style object for the specified property\n\t  parsedStyle: function( property ){\n\t    var ele = this[0];\n\t    if( !ele.cy().styleEnabled() ){ return; }\n\t\n\t    if( ele ){\n\t      return ele._private.style[ property ] || ele.cy().style().getDefaultProperty( property );\n\t    }\n\t  },\n\t\n\t  // get the specified css property as a rendered value (i.e. on-screen value)\n\t  // or get the whole rendered style if no property specified (NB doesn't allow setting)\n\t  renderedStyle: function( property ){\n\t    var cy = this.cy();\n\t    if( !cy.styleEnabled() ){ return this; }\n\t\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      var renstyle = ele.cy().style().getRenderedStyle( ele );\n\t\n\t      if( property === undefined ){\n\t        return renstyle;\n\t      } else {\n\t        return renstyle[ property ];\n\t      }\n\t    }\n\t  },\n\t\n\t  // read the calculated css style of the element or override the style (via a bypass)\n\t  style: function( name, value ){\n\t    var cy = this.cy();\n\t\n\t    if( !cy.styleEnabled() ){ return this; }\n\t\n\t    var updateTransitions = false;\n\t    var style = cy.style();\n\t\n\t    if( is.plainObject( name ) ){ // then extend the bypass\n\t      var props = name;\n\t      style.applyBypass( this, props, updateTransitions );\n\t\n\t      var updatedCompounds = this.updateCompoundBounds();\n\t      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\t      toNotify.rtrigger( 'style' ); // let the renderer know we've updated style\n\t\n\t    } else if( is.string( name ) ){\n\t\n\t      if( value === undefined ){ // then get the property from the style\n\t        var ele = this[0];\n\t\n\t        if( ele ){\n\t          return style.getStylePropertyValue( ele, name );\n\t        } else { // empty collection => can't get any value\n\t          return;\n\t        }\n\t\n\t      } else { // then set the bypass with the property value\n\t        style.applyBypass( this, name, value, updateTransitions );\n\t\n\t        var updatedCompounds = this.updateCompoundBounds();\n\t        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\t        toNotify.rtrigger( 'style' ); // let the renderer know we've updated style\n\t      }\n\t\n\t    } else if( name === undefined ){\n\t      var ele = this[0];\n\t\n\t      if( ele ){\n\t        return style.getRawStyle( ele );\n\t      } else { // empty collection => can't get any value\n\t        return;\n\t      }\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  removeStyle: function( names ){\n\t    var cy = this.cy();\n\t\n\t    if( !cy.styleEnabled() ){ return this; }\n\t\n\t    var updateTransitions = false;\n\t    var style = cy.style();\n\t    var eles = this;\n\t\n\t    if( names === undefined ){\n\t      for( var i = 0; i < eles.length; i++ ){\n\t        var ele = eles[ i ];\n\t\n\t        style.removeAllBypasses( ele, updateTransitions );\n\t      }\n\t    } else {\n\t      names = names.split( /\\s+/ );\n\t\n\t      for( var i = 0; i < eles.length; i++ ){\n\t        var ele = eles[ i ];\n\t\n\t        style.removeBypasses( ele, names, updateTransitions );\n\t      }\n\t    }\n\t\n\t    var updatedCompounds = this.updateCompoundBounds();\n\t    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\t    toNotify.rtrigger( 'style' ); // let the renderer know we've updated style\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  show: function(){\n\t    this.css( 'display', 'element' );\n\t    return this; // chaining\n\t  },\n\t\n\t  hide: function(){\n\t    this.css( 'display', 'none' );\n\t    return this; // chaining\n\t  },\n\t\n\t  visible: function(){\n\t    var cy = this.cy();\n\t    if( !cy.styleEnabled() ){ return true; }\n\t\n\t    var ele = this[0];\n\t    var hasCompoundNodes = cy.hasCompoundNodes();\n\t\n\t    if( ele ){\n\t      if(\n\t        ele.pstyle( 'visibility' ).value !== 'visible'\n\t        || ele.pstyle( 'display' ).value !== 'element'\n\t      ){\n\t        return false;\n\t      }\n\t\n\t      if( ele._private.group === 'nodes' ){\n\t        if( !hasCompoundNodes ){ return true; }\n\t\n\t        var parents = ele._private.data.parent ? ele.parents() : null;\n\t\n\t        if( parents ){\n\t          for( var i = 0; i < parents.length; i++ ){\n\t            var parent = parents[ i ];\n\t            var pVis = parent.pstyle( 'visibility' ).value;\n\t            var pDis = parent.pstyle( 'display' ).value;\n\t\n\t            if( pVis !== 'visible' || pDis !== 'element' ){\n\t              return false;\n\t            }\n\t          }\n\t        }\n\t\n\t        return true;\n\t      } else {\n\t        var src = ele._private.source;\n\t        var tgt = ele._private.target;\n\t\n\t        return src.visible() && tgt.visible();\n\t      }\n\t\n\t    }\n\t  },\n\t\n\t  hidden: function(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      return !ele.visible();\n\t    }\n\t  },\n\t\n\t  effectiveOpacity: function(){\n\t    var cy = this.cy();\n\t    if( !cy.styleEnabled() ){ return 1; }\n\t\n\t    var hasCompoundNodes = cy.hasCompoundNodes();\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      var _p = ele._private;\n\t      var parentOpacity = ele.pstyle( 'opacity' ).value;\n\t\n\t      if( !hasCompoundNodes ){ return parentOpacity; }\n\t\n\t      var parents = !_p.data.parent ? null : ele.parents();\n\t\n\t      if( parents ){\n\t        for( var i = 0; i < parents.length; i++ ){\n\t          var parent = parents[ i ];\n\t          var opacity = parent.pstyle( 'opacity' ).value;\n\t\n\t          parentOpacity = opacity * parentOpacity;\n\t        }\n\t      }\n\t\n\t      return parentOpacity;\n\t    }\n\t  },\n\t\n\t  transparent: function(){\n\t    var cy = this.cy();\n\t    if( !cy.styleEnabled() ){ return false; }\n\t\n\t    var ele = this[0];\n\t    var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\t\n\t    if( ele ){\n\t      if( !hasCompoundNodes ){\n\t        return ele.pstyle( 'opacity' ).value === 0;\n\t      } else {\n\t        return ele.effectiveOpacity() === 0;\n\t      }\n\t    }\n\t  },\n\t\n\t  isFullAutoParent: function(){\n\t    var cy = this.cy();\n\t    if( !cy.styleEnabled() ){ return false; }\n\t\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      var autoW = ele.pstyle( 'width' ).value === 'auto';\n\t      var autoH = ele.pstyle( 'height' ).value === 'auto';\n\t\n\t      return ele.isParent() && autoW && autoH;\n\t    }\n\t  },\n\t\n\t  backgrounding: function(){\n\t    var cy = this.cy();\n\t    if( !cy.styleEnabled() ){ return false; }\n\t\n\t    var ele = this[0];\n\t\n\t    return ele._private.backgrounding ? true : false;\n\t  }\n\t\n\t});\n\t\n\t\n\telesfn.bypass = elesfn.css = elesfn.style;\n\telesfn.renderedCss = elesfn.renderedStyle;\n\telesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;\n\telesfn.pstyle = elesfn.parsedStyle;\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar elesfn = {};\n\t\n\tfunction defineSwitchFunction( params ){\n\t  return function(){\n\t    var args = arguments;\n\t    var changedEles = [];\n\t\n\t    // e.g. cy.nodes().select( data, handler )\n\t    if( args.length === 2 ){\n\t      var data = args[0];\n\t      var handler = args[1];\n\t      this.on( params.event, data, handler );\n\t    }\n\t\n\t    // e.g. cy.nodes().select( handler )\n\t    else if( args.length === 1 ){\n\t      var handler = args[0];\n\t      this.on( params.event, handler );\n\t    }\n\t\n\t    // e.g. cy.nodes().select()\n\t    else if( args.length === 0 ){\n\t      for( var i = 0; i < this.length; i++ ){\n\t        var ele = this[ i ];\n\t        var able = !params.ableField || ele._private[ params.ableField ];\n\t        var changed = ele._private[ params.field ] != params.value;\n\t\n\t        if( params.overrideAble ){\n\t          var overrideAble = params.overrideAble( ele );\n\t\n\t          if( overrideAble !== undefined ){\n\t            able = overrideAble;\n\t\n\t            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override\n\t          }\n\t        }\n\t\n\t        if( able ){\n\t          ele._private[ params.field ] = params.value;\n\t\n\t          if( changed ){\n\t            changedEles.push( ele );\n\t          }\n\t        }\n\t      }\n\t\n\t      var changedColl = this.spawn( changedEles );\n\t      changedColl.updateStyle(); // change of state => possible change of style\n\t      changedColl.trigger( params.event );\n\t    }\n\t\n\t    return this;\n\t  };\n\t}\n\t\n\tfunction defineSwitchSet( params ){\n\t  elesfn[ params.field ] = function(){\n\t    var ele = this[0];\n\t\n\t    if( ele ){\n\t      if( params.overrideField ){\n\t        var val = params.overrideField( ele );\n\t\n\t        if( val !== undefined ){\n\t          return val;\n\t        }\n\t      }\n\t\n\t      return ele._private[ params.field ];\n\t    }\n\t  };\n\t\n\t  elesfn[ params.on ] = defineSwitchFunction( {\n\t    event: params.on,\n\t    field: params.field,\n\t    ableField: params.ableField,\n\t    overrideAble: params.overrideAble,\n\t    value: true\n\t  } );\n\t\n\t  elesfn[ params.off ] = defineSwitchFunction( {\n\t    event: params.off,\n\t    field: params.field,\n\t    ableField: params.ableField,\n\t    overrideAble: params.overrideAble,\n\t    value: false\n\t  } );\n\t}\n\t\n\tdefineSwitchSet( {\n\t  field: 'locked',\n\t  overrideField: function( ele ){\n\t    return ele.cy().autolock() ? true : undefined;\n\t  },\n\t  on: 'lock',\n\t  off: 'unlock'\n\t} );\n\t\n\tdefineSwitchSet( {\n\t  field: 'grabbable',\n\t  overrideField: function( ele ){\n\t    return ele.cy().autoungrabify() ? false : undefined;\n\t  },\n\t  on: 'grabify',\n\t  off: 'ungrabify'\n\t} );\n\t\n\tdefineSwitchSet( {\n\t  field: 'selected',\n\t  ableField: 'selectable',\n\t  overrideAble: function( ele ){\n\t    return ele.cy().autounselectify() ? false : undefined;\n\t  },\n\t  on: 'select',\n\t  off: 'unselect'\n\t} );\n\t\n\tdefineSwitchSet( {\n\t  field: 'selectable',\n\t  overrideField: function( ele ){\n\t    return ele.cy().autounselectify() ? false : undefined;\n\t  },\n\t  on: 'selectify',\n\t  off: 'unselectify'\n\t} );\n\t\n\telesfn.deselect = elesfn.unselect;\n\t\n\telesfn.grabbed = function(){\n\t  var ele = this[0];\n\t  if( ele ){\n\t    return ele._private.grabbed;\n\t  }\n\t};\n\t\n\tdefineSwitchSet( {\n\t  field: 'active',\n\t  on: 'activate',\n\t  off: 'unactivate'\n\t} );\n\t\n\telesfn.inactive = function(){\n\t  var ele = this[0];\n\t  if( ele ){\n\t    return !ele._private.active;\n\t  }\n\t};\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar elesfn = {};\n\t\n\tvar cache = function( fn, name ){\n\t  return function traversalCache( arg1, arg2, arg3, arg4 ){\n\t    var selectorOrEles = arg1;\n\t    var eles = this;\n\t    var key;\n\t\n\t    if( selectorOrEles == null ){\n\t      key = 'null';\n\t    } else if( is.elementOrCollection( selectorOrEles ) && selectorOrEles.length === 1 ){\n\t      key = '#' + selectorOrEles.id();\n\t    }\n\t\n\t    if( eles.length === 1 && key ){\n\t      var _p = eles[0]._private;\n\t      var tch = _p.traversalCache = _p.traversalCache || {};\n\t      var ch = tch[ name ] = tch[ name ] || {};\n\t      var cacheHit = ch[ key ];\n\t\n\t      if( cacheHit ){\n\t        return cacheHit;\n\t      } else {\n\t        return ( ch[ key ] = fn.call( eles, arg1, arg2, arg3, arg4 ) );\n\t      }\n\t    } else {\n\t      return fn.call( eles, arg1, arg2, arg3, arg4 );\n\t    }\n\t  };\n\t};\n\t\n\t// DAG functions\n\t////////////////\n\t\n\tvar defineDagExtremity = function( params ){\n\t  return function dagExtremityImpl( selector ){\n\t    var eles = this;\n\t    var ret = [];\n\t\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[ i ];\n\t      if( !ele.isNode() ){\n\t        continue;\n\t      }\n\t\n\t      var disqualified = false;\n\t      var edges = ele.connectedEdges();\n\t\n\t      for( var j = 0; j < edges.length; j++ ){\n\t        var edge = edges[j];\n\t        var src = edge.source();\n\t        var tgt = edge.target();\n\t\n\t        if(\n\t             ( params.noIncomingEdges && tgt === ele && src !== ele )\n\t          || ( params.noOutgoingEdges && src === ele && tgt !== ele )\n\t        ){\n\t          disqualified = true;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if( !disqualified ){\n\t        ret.push( ele );\n\t      }\n\t    }\n\t\n\t    return this.spawn( ret, { unique: true } ).filter( selector );\n\t  };\n\t};\n\t\n\tvar defineDagOneHop = function( params ){\n\t  return function( selector ){\n\t    var eles = this;\n\t    var oEles = [];\n\t\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[ i ];\n\t\n\t      if( !ele.isNode() ){ continue; }\n\t\n\t      var edges = ele.connectedEdges();\n\t      for( var j = 0; j < edges.length; j++ ){\n\t        var edge = edges[ j ];\n\t        var src = edge.source();\n\t        var tgt = edge.target();\n\t\n\t        if( params.outgoing && src === ele ){\n\t          oEles.push( edge );\n\t          oEles.push( tgt );\n\t        } else if( params.incoming && tgt === ele ){\n\t          oEles.push( edge );\n\t          oEles.push( src );\n\t        }\n\t      }\n\t    }\n\t\n\t    return this.spawn( oEles, { unique: true } ).filter( selector );\n\t  };\n\t};\n\t\n\tvar defineDagAllHops = function( params ){\n\t  return function( selector ){\n\t    var eles = this;\n\t    var sEles = [];\n\t    var sElesIds = {};\n\t\n\t    for( ;; ){\n\t      var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\t\n\t      if( next.length === 0 ){ break; } // done if none left\n\t\n\t      var newNext = false;\n\t      for( var i = 0; i < next.length; i++ ){\n\t        var n = next[ i ];\n\t        var nid = n.id();\n\t\n\t        if( !sElesIds[ nid ] ){\n\t          sElesIds[ nid ] = true;\n\t          sEles.push( n );\n\t          newNext = true;\n\t        }\n\t      }\n\t\n\t      if( !newNext ){ break; } // done if touched all outgoers already\n\t\n\t      eles = next;\n\t    }\n\t\n\t    return this.spawn( sEles, { unique: true } ).filter( selector );\n\t  };\n\t};\n\t\n\tutil.extend( elesfn, {\n\t  // get the root nodes in the DAG\n\t  roots: defineDagExtremity({ noIncomingEdges: true }),\n\t\n\t  // get the leaf nodes in the DAG\n\t  leaves: defineDagExtremity({ noOutgoingEdges: true }),\n\t\n\t  // normally called children in graph theory\n\t  // these nodes =edges=> outgoing nodes\n\t  outgoers: cache( defineDagOneHop({ outgoing: true }) , 'outgoers' ),\n\t\n\t  // aka DAG descendants\n\t  successors: defineDagAllHops({ outgoing: true }),\n\t\n\t  // normally called parents in graph theory\n\t  // these nodes <=edges= incoming nodes\n\t  incomers: cache( defineDagOneHop({ incoming: true }), 'incomers' ),\n\t\n\t  // aka DAG ancestors\n\t  predecessors: defineDagAllHops({ incoming: true })\n\t} );\n\t\n\t\n\t// Neighbourhood functions\n\t//////////////////////////\n\t\n\tutil.extend( elesfn, {\n\t  neighborhood: cache(function( selector ){\n\t    var elements = [];\n\t    var nodes = this.nodes();\n\t\n\t    for( var i = 0; i < nodes.length; i++ ){ // for all nodes\n\t      var node = nodes[ i ];\n\t      var connectedEdges = node.connectedEdges();\n\t\n\t      // for each connected edge, add the edge and the other node\n\t      for( var j = 0; j < connectedEdges.length; j++ ){\n\t        var edge = connectedEdges[ j ];\n\t        var src = edge.source();\n\t        var tgt = edge.target();\n\t        var otherNode = node === src ? tgt : src;\n\t\n\t        // need check in case of loop\n\t        if( otherNode.length > 0 ){\n\t          elements.push( otherNode[0] ); // add node 1 hop away\n\t        }\n\t\n\t        // add connected edge\n\t        elements.push( edge[0] );\n\t      }\n\t\n\t    }\n\t\n\t    return ( this.spawn( elements, { unique: true } ) ).filter( selector );\n\t  }, 'neighborhood'),\n\t\n\t  closedNeighborhood: function( selector ){\n\t    return this.neighborhood().add( this ).filter( selector );\n\t  },\n\t\n\t  openNeighborhood: function( selector ){\n\t    return this.neighborhood( selector );\n\t  }\n\t} );\n\t\n\t// aliases\n\telesfn.neighbourhood = elesfn.neighborhood;\n\telesfn.closedNeighbourhood = elesfn.closedNeighborhood;\n\telesfn.openNeighbourhood = elesfn.openNeighborhood;\n\t\n\t// Edge functions\n\t/////////////////\n\t\n\tutil.extend( elesfn, {\n\t  source: cache(function sourceImpl( selector ){\n\t    var ele = this[0];\n\t    var src;\n\t\n\t    if( ele ){\n\t      src = ele._private.source || ele.cy().collection();\n\t    }\n\t\n\t    return src && selector ? src.filter( selector ) : src;\n\t  }, 'source'),\n\t\n\t  target: cache(function targetImpl( selector ){\n\t    var ele = this[0];\n\t    var tgt;\n\t\n\t    if( ele ){\n\t      tgt = ele._private.target || ele.cy().collection();\n\t    }\n\t\n\t    return tgt && selector ? tgt.filter( selector ) : tgt;\n\t  }, 'target'),\n\t\n\t  sources: defineSourceFunction( {\n\t    attr: 'source'\n\t  } ),\n\t\n\t  targets: defineSourceFunction( {\n\t    attr: 'target'\n\t  } )\n\t} );\n\t\n\tfunction defineSourceFunction( params ){\n\t  return function sourceImpl( selector ){\n\t    var sources = [];\n\t\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var ele = this[ i ];\n\t      var src = ele._private[ params.attr ];\n\t\n\t      if( src ){\n\t        sources.push( src );\n\t      }\n\t    }\n\t\n\t    return this.spawn( sources, { unique: true } ).filter( selector );\n\t  };\n\t}\n\t\n\tutil.extend( elesfn, {\n\t  edgesWith: cache( defineEdgesWithFunction(), 'edgesWith', true ),\n\t\n\t  edgesTo: cache( defineEdgesWithFunction( {\n\t    thisIsSrc: true\n\t  } ), 'edgesTo', true )\n\t} );\n\t\n\tfunction defineEdgesWithFunction( params ){\n\t\n\t  return function edgesWithImpl( otherNodes ){\n\t    var elements = [];\n\t    var cy = this._private.cy;\n\t    var p = params || {};\n\t\n\t    // get elements if a selector is specified\n\t    if( is.string( otherNodes ) ){\n\t      otherNodes = cy.$( otherNodes );\n\t    }\n\t\n\t    var thisIds = this._private.ids;\n\t    var otherIds = otherNodes._private.ids;\n\t\n\t    for( var h = 0; h < otherNodes.length; h++ ){\n\t      var edges = otherNodes[ h ]._private.edges;\n\t\n\t      for( var i = 0; i < edges.length; i++ ){\n\t        var edge = edges[ i ];\n\t        var edgeData = edge._private.data;\n\t        var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];\n\t        var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];\n\t        var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\t\n\t        if( !edgeConnectsThisAndOther ){ continue; }\n\t\n\t        if( p.thisIsSrc || p.thisIsTgt ){\n\t          if( p.thisIsSrc && !thisToOther ){ continue; }\n\t\n\t          if( p.thisIsTgt && !otherToThis ){ continue; }\n\t        }\n\t\n\t        elements.push( edge );\n\t      }\n\t    }\n\t\n\t    return this.spawn( elements, { unique: true } );\n\t  };\n\t}\n\t\n\tutil.extend( elesfn, {\n\t  connectedEdges: cache(function( selector ){\n\t    var retEles = [];\n\t\n\t    var eles = this;\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var node = eles[ i ];\n\t      if( !node.isNode() ){ continue; }\n\t\n\t      var edges = node._private.edges;\n\t\n\t      for( var j = 0; j < edges.length; j++ ){\n\t        var edge = edges[ j ];\n\t        retEles.push( edge );\n\t      }\n\t    }\n\t\n\t    return this.spawn( retEles, { unique: true } ).filter( selector );\n\t  }, 'connectedEdges'),\n\t\n\t  connectedNodes: cache(function( selector ){\n\t    var retEles = [];\n\t\n\t    var eles = this;\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var edge = eles[ i ];\n\t      if( !edge.isEdge() ){ continue; }\n\t\n\t      retEles.push( edge.source()[0] );\n\t      retEles.push( edge.target()[0] );\n\t    }\n\t\n\t    return this.spawn( retEles, { unique: true } ).filter( selector );\n\t  }, 'connectedNodes'),\n\t\n\t  parallelEdges: cache( defineParallelEdgesFunction(), 'parallelEdges' ),\n\t\n\t  codirectedEdges: cache( defineParallelEdgesFunction( {\n\t    codirected: true\n\t  } ), 'codirectedEdges' )\n\t} );\n\t\n\tfunction defineParallelEdgesFunction( params ){\n\t  var defaults = {\n\t    codirected: false\n\t  };\n\t  params = util.extend( {}, defaults, params );\n\t\n\t  return function parallelEdgesImpl( selector ){ // micro-optimised for renderer\n\t    var elements = [];\n\t    var edges = this.edges();\n\t    var p = params;\n\t\n\t    // look at all the edges in the collection\n\t    for( var i = 0; i < edges.length; i++ ){\n\t      var edge1 = edges[ i ];\n\t      var edge1_p = edge1._private;\n\t      var src1 = edge1_p.source;\n\t      var srcid1 = src1._private.data.id;\n\t      var tgtid1 = edge1_p.data.target;\n\t      var srcEdges1 = src1._private.edges;\n\t\n\t      // look at edges connected to the src node of this edge\n\t      for( var j = 0; j < srcEdges1.length; j++ ){\n\t        var edge2 = srcEdges1[ j ];\n\t        var edge2data = edge2._private.data;\n\t        var tgtid2 = edge2data.target;\n\t        var srcid2 = edge2data.source;\n\t\n\t        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n\t        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\t\n\t        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){\n\t          elements.push( edge2 );\n\t        }\n\t      }\n\t    }\n\t\n\t    return this.spawn( elements, { unique: true } ).filter( selector );\n\t  };\n\t\n\t}\n\t\n\t// Misc functions\n\t/////////////////\n\t\n\tutil.extend( elesfn, {\n\t  components: function(){\n\t    var self = this;\n\t    var cy = self.cy();\n\t    var visited = self.spawn();\n\t    var unvisited = self.nodes().spawnSelf();\n\t    var components = [];\n\t\n\t    var visitInComponent = function( node, component ){\n\t      visited.merge( node );\n\t      unvisited.unmerge( node );\n\t      component.merge( node );\n\t    };\n\t\n\t    if( unvisited.empty() ){ return self.spawn(); }\n\t\n\t    do {\n\t      var component = cy.collection();\n\t      components.push( component );\n\t\n\t      var root = unvisited[0];\n\t      visitInComponent( root, component );\n\t\n\t      self.bfs({\n\t        directed: false,\n\t        roots: root,\n\t        visit: function( i, depth, v, e, u ){\n\t          visitInComponent( v, component );\n\t        }\n\t      } );\n\t\n\t    } while( unvisited.length > 0 );\n\t\n\t    return components.map(function( component ){\n\t      var connectedEdges = component.connectedEdges().stdFilter(function( edge ){\n\t        return component.anySame( edge.source() ) && component.anySame( edge.target() );\n\t      });\n\t\n\t      return component.union( connectedEdges );\n\t    });\n\t  }\n\t} );\n\t\n\tmodule.exports = elesfn;\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\tvar Collection = __webpack_require__( 40 );\n\tvar Element = __webpack_require__( 41 );\n\t\n\tvar corefn = {\n\t  add: function( opts ){\n\t\n\t    var elements;\n\t    var cy = this;\n\t\n\t    // add the elements\n\t    if( is.elementOrCollection( opts ) ){\n\t      var eles = opts;\n\t\n\t      if( eles._private.cy === cy ){ // same instance => just restore\n\t        elements = eles.restore();\n\t\n\t      } else { // otherwise, copy from json\n\t        var jsons = [];\n\t\n\t        for( var i = 0; i < eles.length; i++ ){\n\t          var ele = eles[ i ];\n\t          jsons.push( ele.json() );\n\t        }\n\t\n\t        elements = new Collection( cy, jsons );\n\t      }\n\t    }\n\t\n\t    // specify an array of options\n\t    else if( is.array( opts ) ){\n\t      var jsons = opts;\n\t\n\t      elements = new Collection( cy, jsons );\n\t    }\n\t\n\t    // specify via opts.nodes and opts.edges\n\t    else if( is.plainObject( opts ) && (is.array( opts.nodes ) || is.array( opts.edges )) ){\n\t      var elesByGroup = opts;\n\t      var jsons = [];\n\t\n\t      var grs = [ 'nodes', 'edges' ];\n\t      for( var i = 0, il = grs.length; i < il; i++ ){\n\t        var group = grs[ i ];\n\t        var elesArray = elesByGroup[ group ];\n\t\n\t        if( is.array( elesArray ) ){\n\t\n\t          for( var j = 0, jl = elesArray.length; j < jl; j++ ){\n\t            var json = util.extend( { group: group }, elesArray[ j ] );\n\t\n\t            jsons.push( json );\n\t          }\n\t        }\n\t      }\n\t\n\t      elements = new Collection( cy, jsons );\n\t    }\n\t\n\t    // specify options for one element\n\t    else {\n\t      var json = opts;\n\t      elements = (new Element( cy, json )).collection();\n\t    }\n\t\n\t    return elements;\n\t  },\n\t\n\t  remove: function( collection ){\n\t    if( is.elementOrCollection( collection ) ){\n\t      collection = collection;\n\t    } else if( is.string( collection ) ){\n\t      var selector = collection;\n\t      collection = this.$( selector );\n\t    }\n\t\n\t    return collection.remove();\n\t  },\n\t\n\t  load: function( elements, onload, ondone ){\n\t    var cy = this;\n\t\n\t    cy.notifications( false );\n\t\n\t    // remove old elements\n\t    var oldEles = cy.mutableElements();\n\t    if( oldEles.length > 0 ){\n\t      oldEles.remove();\n\t    }\n\t\n\t    if( elements != null ){\n\t      if( is.plainObject( elements ) || is.array( elements ) ){\n\t        cy.add( elements );\n\t      }\n\t    }\n\t\n\t    cy.one( 'layoutready', function( e ){\n\t      cy.notifications( true );\n\t      cy.trigger( e ); // we missed this event by turning notifications off, so pass it on\n\t\n\t      cy.notify( {\n\t        type: 'load',\n\t        eles: cy.mutableElements()\n\t      } );\n\t\n\t      cy.one( 'load', onload );\n\t      cy.trigger( 'load' );\n\t    } ).one( 'layoutstop', function(){\n\t      cy.one( 'done', ondone );\n\t      cy.trigger( 'done' );\n\t    } );\n\t\n\t    var layoutOpts = util.extend( {}, cy._private.options.layout );\n\t    layoutOpts.eles = cy.elements();\n\t\n\t    cy.layout( layoutOpts );\n\t\n\t    return this;\n\t  }\n\t};\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar define = __webpack_require__( 56 );\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar corefn = ({\n\t\n\t  // pull in animation functions\n\t  animate: define.animate(),\n\t  animation: define.animation(),\n\t  animated: define.animated(),\n\t  clearQueue: define.clearQueue(),\n\t  delay: define.delay(),\n\t  delayAnimation: define.delayAnimation(),\n\t  stop: define.stop(),\n\t\n\t  addToAnimationPool: function( eles ){\n\t    var cy = this;\n\t\n\t    if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n\t\n\t    cy._private.aniEles.merge( eles );\n\t  },\n\t\n\t  stopAnimationLoop: function(){\n\t    this._private.animationsRunning = false;\n\t  },\n\t\n\t  startAnimationLoop: function(){\n\t    var cy = this;\n\t\n\t    cy._private.animationsRunning = true;\n\t\n\t    if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n\t\n\t    // NB the animation loop will exec in headless environments if style enabled\n\t    // and explicit cy.destroy() is necessary to stop the loop\n\t\n\t    function globalAnimationStep(){\n\t      if( !cy._private.animationsRunning ){ return; }\n\t\n\t      util.requestAnimationFrame( function animationStep( now ){\n\t        handleElements( now );\n\t        globalAnimationStep();\n\t      } );\n\t    }\n\t\n\t    var renderer = cy.renderer();\n\t\n\t    if( renderer && renderer.beforeRender ){ // let the renderer schedule animations\n\t      renderer.beforeRender( function rendererAnimationStep( willDraw, now ){\n\t        handleElements( now );\n\t      }, renderer.beforeRenderPriorities.animations );\n\t    } else { // manage the animation loop ourselves\n\t      globalAnimationStep(); // first call\n\t    }\n\t\n\t    function handleElements( now ){\n\t      var eles = cy._private.aniEles;\n\t      var doneEles = [];\n\t\n\t      function handleElement( ele, isCore ){\n\t        var _p = ele._private;\n\t        var current = _p.animation.current;\n\t        var queue = _p.animation.queue;\n\t        var ranAnis = false;\n\t\n\t        // if nothing currently animating, get something from the queue\n\t        if( current.length === 0 ){\n\t          var next = queue.shift();\n\t\n\t          if( next ){\n\t            current.push( next );\n\t          }\n\t        }\n\t\n\t        var callbacks = function( callbacks ){\n\t          for( var j = callbacks.length - 1; j >= 0; j-- ){\n\t            var cb = callbacks[ j ];\n\t\n\t            cb();\n\t          }\n\t\n\t          callbacks.splice( 0, callbacks.length );\n\t        };\n\t\n\t        // step and remove if done\n\t        for( var i = current.length - 1; i >= 0; i-- ){\n\t          var ani = current[ i ];\n\t          var ani_p = ani._private;\n\t\n\t          if( ani_p.stopped ){\n\t            current.splice( i, 1 );\n\t\n\t            ani_p.hooked = false;\n\t            ani_p.playing = false;\n\t            ani_p.started = false;\n\t\n\t            callbacks( ani_p.frames );\n\t\n\t            continue;\n\t          }\n\t\n\t          if( !ani_p.playing && !ani_p.applying ){ continue; }\n\t\n\t          // an apply() while playing shouldn't do anything\n\t          if( ani_p.playing && ani_p.applying ){\n\t            ani_p.applying = false;\n\t          }\n\t\n\t          if( !ani_p.started ){\n\t            startAnimation( ele, ani, now );\n\t          }\n\t\n\t          step( ele, ani, now, isCore );\n\t\n\t          if( is.fn( ani_p.step ) ){\n\t            ani_p.step.call( ele, now );\n\t          }\n\t\n\t          if( ani_p.applying ){\n\t            ani_p.applying = false;\n\t          }\n\t\n\t          callbacks( ani_p.frames );\n\t\n\t          if( ani.completed() ){\n\t            current.splice( i, 1 );\n\t\n\t            ani_p.hooked = false;\n\t            ani_p.playing = false;\n\t            ani_p.started = false;\n\t\n\t            callbacks( ani_p.completes );\n\t          }\n\t\n\t          ranAnis = true;\n\t        }\n\t\n\t        if( !isCore && current.length === 0 && queue.length === 0 ){\n\t          doneEles.push( ele );\n\t        }\n\t\n\t        return ranAnis;\n\t      } // handleElement\n\t\n\t      // handle all eles\n\t      var ranEleAni = false;\n\t      for( var e = 0; e < eles.length; e++ ){\n\t        var ele = eles[ e ];\n\t        var handledThisEle = handleElement( ele );\n\t\n\t        ranEleAni = ranEleAni || handledThisEle;\n\t      } // each element\n\t\n\t      var ranCoreAni = handleElement( cy, true );\n\t\n\t      // notify renderer\n\t      if( ranEleAni || ranCoreAni ){\n\t        if( eles.length > 0 ){\n\t          var updatedEles = eles.updateCompoundBounds().spawnSelf().merge( eles );\n\t\n\t          cy.notify({\n\t            type: 'draw',\n\t            eles: updatedEles\n\t          });\n\t        } else {\n\t          cy.notify({\n\t            type: 'draw'\n\t          });\n\t        }\n\t      }\n\t\n\t      // remove elements from list of currently animating if its queues are empty\n\t      eles.unmerge( doneEles );\n\t\n\t      cy.trigger('step');\n\t\n\t    } // handleElements\n\t\n\t    function startAnimation( self, ani, now ){\n\t      var isCore = is.core( self );\n\t      var isEles = !isCore;\n\t      var ele = self;\n\t      var style = cy._private.style;\n\t      var ani_p = ani._private;\n\t\n\t      if( isEles ){\n\t        var pos = ele._private.position;\n\t\n\t        ani_p.startPosition = ani_p.startPosition || {\n\t          x: pos.x,\n\t          y: pos.y\n\t        };\n\t\n\t        ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle( ele, ani_p.style );\n\t      }\n\t\n\t      if( isCore ){\n\t        var pan = cy._private.pan;\n\t\n\t        ani_p.startPan = ani_p.startPan || {\n\t          x: pan.x,\n\t          y: pan.y\n\t        };\n\t\n\t        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;\n\t      }\n\t\n\t      ani_p.started = true;\n\t      ani_p.startTime = now - ani_p.progress * ani_p.duration;\n\t    }\n\t\n\t    function step( self, ani, now, isCore ){\n\t      var style = cy._private.style;\n\t      var isEles = !isCore;\n\t      var _p = self._private;\n\t      var ani_p = ani._private;\n\t      var pEasing = ani_p.easing;\n\t      var startTime = ani_p.startTime;\n\t\n\t      if( !ani_p.easingImpl ){\n\t\n\t        if( pEasing == null ){ // use default\n\t          ani_p.easingImpl = easings[ 'linear' ];\n\t\n\t        } else { // then define w/ name\n\t          var easingVals;\n\t\n\t          if( is.string( pEasing ) ){\n\t            var easingProp = style.parse( 'transition-timing-function', pEasing );\n\t\n\t            easingVals = easingProp.value;\n\t\n\t          } else { // then assume preparsed array\n\t            easingVals = pEasing;\n\t          }\n\t\n\t          var name, args;\n\t\n\t          if( is.string( easingVals ) ){\n\t            name = easingVals;\n\t            args = [];\n\t          } else {\n\t            name = easingVals[1];\n\t            args = easingVals.slice( 2 ).map( function( n ){ return +n; } );\n\t          }\n\t\n\t          if( args.length > 0 ){ // create with args\n\t            if( name === 'spring' ){\n\t              args.push( ani_p.duration ); // need duration to generate spring\n\t            }\n\t\n\t            ani_p.easingImpl = easings[ name ].apply( null, args );\n\t          } else { // static impl by name\n\t            ani_p.easingImpl = easings[ name ];\n\t          }\n\t        }\n\t\n\t      }\n\t\n\t      var easing = ani_p.easingImpl;\n\t      var percent;\n\t\n\t      if( ani_p.duration === 0 ){\n\t        percent = 1;\n\t      } else {\n\t        percent = (now - startTime) / ani_p.duration;\n\t      }\n\t\n\t      if( ani_p.applying ){\n\t        percent = ani_p.progress;\n\t      }\n\t\n\t      if( percent < 0 ){\n\t        percent = 0;\n\t      } else if( percent > 1 ){\n\t        percent = 1;\n\t      }\n\t\n\t      if( ani_p.delay == null ){ // then update\n\t\n\t        var startPos = ani_p.startPosition;\n\t        var endPos = ani_p.position;\n\t        var pos = _p.position;\n\t        if( endPos && isEles ){\n\t          if( valid( startPos.x, endPos.x ) ){\n\t            pos.x = ease( startPos.x, endPos.x, percent, easing );\n\t          }\n\t\n\t          if( valid( startPos.y, endPos.y ) ){\n\t            pos.y = ease( startPos.y, endPos.y, percent, easing );\n\t          }\n\t\n\t          self.trigger('position');\n\t        }\n\t\n\t        var startPan = ani_p.startPan;\n\t        var endPan = ani_p.pan;\n\t        var pan = _p.pan;\n\t        var animatingPan = endPan != null && isCore;\n\t        if( animatingPan ){\n\t          if( valid( startPan.x, endPan.x ) ){\n\t            pan.x = ease( startPan.x, endPan.x, percent, easing );\n\t          }\n\t\n\t          if( valid( startPan.y, endPan.y ) ){\n\t            pan.y = ease( startPan.y, endPan.y, percent, easing );\n\t          }\n\t\n\t          self.trigger( 'pan' );\n\t        }\n\t\n\t        var startZoom = ani_p.startZoom;\n\t        var endZoom = ani_p.zoom;\n\t        var animatingZoom = endZoom != null && isCore;\n\t        if( animatingZoom ){\n\t          if( valid( startZoom, endZoom ) ){\n\t            _p.zoom = ease( startZoom, endZoom, percent, easing );\n\t          }\n\t\n\t          self.trigger( 'zoom' );\n\t        }\n\t\n\t        if( animatingPan || animatingZoom ){\n\t          self.trigger( 'viewport' );\n\t        }\n\t\n\t        var props = ani_p.style;\n\t        if( props && props.length > 0 && isEles ){\n\t          for( var i = 0; i < props.length; i++ ){\n\t            var prop = props[ i ];\n\t            var name = prop.name;\n\t            var end = prop;\n\t\n\t            var start = ani_p.startStyle[ name ];\n\t            var easedVal = ease( start, end, percent, easing );\n\t\n\t            style.overrideBypass( self, name, easedVal );\n\t          } // for props\n\t\n\t          self.trigger('style');\n\t\n\t        } // if\n\t\n\t      }\n\t\n\t      ani_p.progress = percent;\n\t\n\t      return percent;\n\t    }\n\t\n\t    function valid( start, end ){\n\t      if( start == null || end == null ){\n\t        return false;\n\t      }\n\t\n\t      if( is.number( start ) && is.number( end ) ){\n\t        return true;\n\t      } else if( (start) && (end) ){\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    }\n\t\n\t    // assumes p0 = 0, p3 = 1\n\t    function evalCubicBezier( p1, p2, t ){\n\t      var one_t = 1 - t;\n\t      var tsq = t * t;\n\t\n\t      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;\n\t    }\n\t\n\t    function cubicBezier( p1, p2 ){\n\t      return function( start, end, percent ){\n\t        return start + (end - start) * evalCubicBezier( p1, p2, percent );\n\t      };\n\t    }\n\t\n\t    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n\t    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n\t       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\n\t    var generateSpringRK4 = (function(){\n\t      function springAccelerationForState( state ){\n\t        return (-state.tension * state.x) - (state.friction * state.v);\n\t      }\n\t\n\t      function springEvaluateStateWithDerivative( initialState, dt, derivative ){\n\t        var state = {\n\t          x: initialState.x + derivative.dx * dt,\n\t          v: initialState.v + derivative.dv * dt,\n\t          tension: initialState.tension,\n\t          friction: initialState.friction\n\t        };\n\t\n\t        return { dx: state.v, dv: springAccelerationForState( state ) };\n\t      }\n\t\n\t      function springIntegrateState( state, dt ){\n\t        var a = {\n\t          dx: state.v,\n\t          dv: springAccelerationForState( state )\n\t        },\n\t        b = springEvaluateStateWithDerivative( state, dt * 0.5, a ),\n\t        c = springEvaluateStateWithDerivative( state, dt * 0.5, b ),\n\t        d = springEvaluateStateWithDerivative( state, dt, c ),\n\t        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n\t        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n\t\n\t        state.x = state.x + dxdt * dt;\n\t        state.v = state.v + dvdt * dt;\n\t\n\t        return state;\n\t      }\n\t\n\t      return function springRK4Factory( tension, friction, duration ){\n\t\n\t        var initState = {\n\t          x: -1,\n\t          v: 0,\n\t          tension: null,\n\t          friction: null\n\t        },\n\t        path = [0],\n\t        time_lapsed = 0,\n\t        tolerance = 1 / 10000,\n\t        DT = 16 / 1000,\n\t        have_duration, dt, last_state;\n\t\n\t        tension = parseFloat( tension ) || 500;\n\t        friction = parseFloat( friction ) || 20;\n\t        duration = duration || null;\n\t\n\t        initState.tension = tension;\n\t        initState.friction = friction;\n\t\n\t        have_duration = duration !== null;\n\t\n\t        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n\t        if( have_duration ){\n\t          /* Run the simulation without a duration. */\n\t          time_lapsed = springRK4Factory( tension, friction );\n\t          /* Compute the adjusted time delta. */\n\t          dt = time_lapsed / duration * DT;\n\t        } else {\n\t          dt = DT;\n\t        }\n\t\n\t        while( true ){\n\t          /* Next/step function .*/\n\t          last_state = springIntegrateState( last_state || initState, dt );\n\t          /* Store the position. */\n\t          path.push( 1 + last_state.x );\n\t          time_lapsed += 16;\n\t          /* If the change threshold is reached, break. */\n\t          if( !(Math.abs( last_state.x ) > tolerance && Math.abs( last_state.v ) > tolerance) ){\n\t            break;\n\t          }\n\t        }\n\t\n\t        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n\t           computed path and returns a snapshot of the position according to a given percentComplete. */\n\t        return !have_duration ? time_lapsed : function( percentComplete ){ return path[ (percentComplete * (path.length - 1)) | 0 ]; };\n\t      };\n\t    }());\n\t\n\t    var easings = {\n\t      'linear': function( start, end, percent ){\n\t        return start + (end - start) * percent;\n\t      },\n\t\n\t      // default easings\n\t      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),\n\t      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),\n\t      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),\n\t      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),\n\t\n\t      // sine\n\t      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),\n\t      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),\n\t      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),\n\t\n\t      // quad\n\t      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),\n\t      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),\n\t      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),\n\t\n\t      // cubic\n\t      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),\n\t      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),\n\t      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),\n\t\n\t      // quart\n\t      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),\n\t      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),\n\t      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),\n\t\n\t      // quint\n\t      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),\n\t      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),\n\t      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),\n\t\n\t      // expo\n\t      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),\n\t      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),\n\t      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),\n\t\n\t      // circ\n\t      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),\n\t      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),\n\t      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),\n\t\n\t\n\t      // user param easings...\n\t\n\t      'spring': function( tension, friction, duration ){\n\t        if( duration === 0 ){ // can't get a spring w/ duration 0\n\t          return easings.linear; // duration 0 => jump to end so impl doesn't matter\n\t        }\n\t\n\t        var spring = generateSpringRK4( tension, friction, duration );\n\t\n\t        return function( start, end, percent ){\n\t          return start + (end - start) * spring( percent );\n\t        };\n\t      },\n\t\n\t      'cubic-bezier': function( x1, y1, x2, y2 ){\n\t        return cubicBezier( x1, y1, x2, y2 );\n\t      }\n\t    };\n\t\n\t    function ease( startProp, endProp, percent, easingFn ){\n\t      if( percent < 0 ){\n\t        percent = 0;\n\t      } else if( percent > 1 ){\n\t        percent = 1;\n\t      }\n\t\n\t      var start, end;\n\t\n\t      if( startProp.pfValue != null || startProp.value != null ){\n\t        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;\n\t      } else {\n\t        start = startProp;\n\t      }\n\t\n\t      if( endProp.pfValue != null || endProp.value != null ){\n\t        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;\n\t      } else {\n\t        end = endProp;\n\t      }\n\t\n\t      if( is.number( start ) && is.number( end ) ){\n\t        return easingFn( start, end, percent );\n\t\n\t      } else if( is.array( start ) && is.array( end ) ){\n\t        var easedArr = [];\n\t\n\t        for( var i = 0; i < end.length; i++ ){\n\t          var si = start[ i ];\n\t          var ei = end[ i ];\n\t\n\t          if( si != null && ei != null ){\n\t            var val = easingFn( si, ei, percent );\n\t\n\t            if( startProp.roundValue ){ val = Math.round( val ); }\n\t\n\t            easedArr.push( val );\n\t          } else {\n\t            easedArr.push( ei );\n\t          }\n\t        }\n\t\n\t        return easedArr;\n\t      }\n\t\n\t      return undefined;\n\t    }\n\t\n\t  }\n\t\n\t});\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar define = __webpack_require__( 56 );\n\t\n\tvar corefn = ({\n\t  on: define.on(), // .on( events [, selector] [, data], handler)\n\t  one: define.on( { unbindSelfOnTrigger: true } ),\n\t  once: define.on( { unbindAllBindersOnTrigger: true } ),\n\t  off: define.off(), // .off( events [, selector] [, handler] )\n\t  trigger: define.trigger() // .trigger( events [, extraParams] )\n\t});\n\t\n\tdefine.eventAliasesOn( corefn );\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar corefn = ({\n\t\n\t  png: function( options ){\n\t    var renderer = this._private.renderer;\n\t    options = options || {};\n\t\n\t    return renderer.png( options );\n\t  },\n\t\n\t  jpg: function( options ){\n\t    var renderer = this._private.renderer;\n\t    options = options || {};\n\t\n\t    options.bg = options.bg || '#fff';\n\t\n\t    return renderer.jpg( options );\n\t  }\n\t\n\t});\n\t\n\tcorefn.jpeg = corefn.jpg;\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar corefn = ({\n\t\n\t  layout: function( params ){\n\t    var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.makeLayout( params ) );\n\t\n\t    layout.run();\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  makeLayout: function( options ){\n\t    var cy = this;\n\t\n\t    if( options == null ){\n\t      util.error( 'Layout options must be specified to make a layout' );\n\t      return;\n\t    }\n\t\n\t    if( options.name == null ){\n\t      util.error( 'A `name` must be specified to make a layout' );\n\t      return;\n\t    }\n\t\n\t    var name = options.name;\n\t    var Layout = cy.extension( 'layout', name );\n\t\n\t    if( Layout == null ){\n\t      util.error( 'Can not apply layout: No such layout `' + name + '` found; did you include its JS file?' );\n\t      return;\n\t    }\n\t\n\t    var eles;\n\t    if( is.string( options.eles ) ){\n\t      eles = cy.$( options.eles );\n\t    } else {\n\t      eles = options.eles != null ? options.eles : cy.$();\n\t    }\n\t\n\t    var layout = new Layout( util.extend( {}, options, {\n\t      cy: cy,\n\t      eles: eles\n\t    } ) );\n\t\n\t    return layout;\n\t  }\n\t\n\t});\n\t\n\tcorefn.createLayout = corefn.makeLayout;\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar corefn = ({\n\t  notify: function( params ){\n\t    var _p = this._private;\n\t\n\t    if( _p.batchingNotify ){\n\t      var bEles = _p.batchNotifyEles;\n\t      var bTypes = _p.batchNotifyTypes;\n\t\n\t      if( params.eles ){\n\t        bEles.merge( params.eles );\n\t      }\n\t\n\t      if( !bTypes.ids[ params.type ] ){\n\t        bTypes.push( params.type );\n\t        bTypes.ids[ params.type ] = true;\n\t      }\n\t\n\t      return; // notifications are disabled during batching\n\t    }\n\t\n\t    if( !_p.notificationsEnabled ){ return; } // exit on disabled\n\t\n\t    var renderer = this.renderer();\n\t\n\t    renderer.notify( params );\n\t  },\n\t\n\t  notifications: function( bool ){\n\t    var p = this._private;\n\t\n\t    if( bool === undefined ){\n\t      return p.notificationsEnabled;\n\t    } else {\n\t      p.notificationsEnabled = bool ? true : false;\n\t    }\n\t  },\n\t\n\t  noNotifications: function( callback ){\n\t    this.notifications( false );\n\t    callback();\n\t    this.notifications( true );\n\t  },\n\t\n\t  startBatch: function(){\n\t    var _p = this._private;\n\t\n\t    if( _p.batchCount == null ){\n\t      _p.batchCount = 0;\n\t    }\n\t\n\t    if( _p.batchCount === 0 ){\n\t      _p.batchingStyle = _p.batchingNotify = true;\n\t      _p.batchStyleEles = this.collection();\n\t      _p.batchNotifyEles = this.collection();\n\t      _p.batchNotifyTypes = [];\n\t      _p.batchNotifyTypes.ids = {};\n\t    }\n\t\n\t    _p.batchCount++;\n\t\n\t    return this;\n\t  },\n\t\n\t  endBatch: function(){\n\t    var _p = this._private;\n\t\n\t    _p.batchCount--;\n\t\n\t    if( _p.batchCount === 0 ){\n\t      // update style for dirty eles\n\t      _p.batchingStyle = false;\n\t      _p.batchStyleEles.updateStyle();\n\t\n\t      // notify the renderer of queued eles and event types\n\t      _p.batchingNotify = false;\n\t      this.notify( {\n\t        type: _p.batchNotifyTypes,\n\t        eles: _p.batchNotifyEles\n\t      } );\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  batch: function( callback ){\n\t    this.startBatch();\n\t    callback();\n\t    this.endBatch();\n\t\n\t    return this;\n\t  },\n\t\n\t  // for backwards compatibility\n\t  batchData: function( map ){\n\t    var cy = this;\n\t\n\t    return this.batch( function(){\n\t      var ids = Object.keys( map );\n\t\n\t      for( var i = 0; i < ids.length; i++ ){\n\t        var ids = id[i];\n\t        var data = map[ id ];\n\t        var ele = cy.getElementById( id );\n\t\n\t        ele.data( data );\n\t      }\n\t    } );\n\t  }\n\t});\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar corefn = ({\n\t\n\t  renderTo: function( context, zoom, pan, pxRatio ){\n\t    var r = this._private.renderer;\n\t\n\t    r.renderTo( context, zoom, pan, pxRatio );\n\t    return this;\n\t  },\n\t\n\t  renderer: function(){\n\t    return this._private.renderer;\n\t  },\n\t\n\t  forceRender: function(){\n\t    this.notify( {\n\t      type: 'draw'\n\t    } );\n\t\n\t    return this;\n\t  },\n\t\n\t  resize: function(){\n\t    this.invalidateSize();\n\t\n\t    this.notify( {\n\t      type: 'resize'\n\t    } );\n\t\n\t    this.trigger( 'resize' );\n\t\n\t    return this;\n\t  },\n\t\n\t  initRenderer: function( options ){\n\t    var cy = this;\n\t\n\t    var RendererProto = cy.extension( 'renderer', options.name );\n\t    if( RendererProto == null ){\n\t      util.error( 'Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name );\n\t      return;\n\t    }\n\t\n\t    var rOpts = util.extend( {}, options, {\n\t      cy: cy\n\t    } );\n\t\n\t    cy._private.renderer = new RendererProto( rOpts );\n\t  },\n\t\n\t  onRender: function( fn ){\n\t    return this.on('render', fn);\n\t  },\n\t\n\t  offRender: function( fn ){\n\t    return this.off('render', fn);\n\t  }\n\t\n\t});\n\t\n\tcorefn.invalidateDimensions = corefn.resize;\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar Collection = __webpack_require__( 40 );\n\t\n\tvar corefn = ({\n\t\n\t  // get a collection\n\t  // - empty collection on no args\n\t  // - collection of elements in the graph on selector arg\n\t  // - guarantee a returned collection when elements or collection specified\n\t  collection: function( eles, opts ){\n\t\n\t    if( is.string( eles ) ){\n\t      return this.$( eles );\n\t\n\t    } else if( is.elementOrCollection( eles ) ){\n\t      return eles.collection();\n\t\n\t    } else if( is.array( eles ) ){\n\t      return new Collection( this, eles, opts );\n\t    }\n\t\n\t    return new Collection( this );\n\t  },\n\t\n\t  nodes: function( selector ){\n\t    var nodes = this.$( function(){\n\t      return this.isNode();\n\t    } );\n\t\n\t    if( selector ){\n\t      return nodes.filter( selector );\n\t    }\n\t\n\t    return nodes;\n\t  },\n\t\n\t  edges: function( selector ){\n\t    var edges = this.$( function(){\n\t      return this.isEdge();\n\t    } );\n\t\n\t    if( selector ){\n\t      return edges.filter( selector );\n\t    }\n\t\n\t    return edges;\n\t  },\n\t\n\t  // search the graph like jQuery\n\t  $: function( selector ){\n\t    var eles = this._private.elements;\n\t\n\t    if( selector ){\n\t      return eles.filter( selector );\n\t    } else {\n\t      return eles.spawnSelf();\n\t    }\n\t  },\n\t\n\t  mutableElements: function(){\n\t    return this._private.elements;\n\t  }\n\t\n\t});\n\t\n\t// aliases\n\tcorefn.elements = corefn.filter = corefn.$;\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar Style = __webpack_require__( 86 );\n\t\n\tvar corefn = ({\n\t\n\t  style: function( newStyle ){\n\t    if( newStyle ){\n\t      var s = this.setStyle( newStyle );\n\t\n\t      s.update();\n\t    }\n\t\n\t    return this._private.style;\n\t  },\n\t\n\t  setStyle: function( style ){\n\t    var _p = this._private;\n\t\n\t    if( is.stylesheet( style ) ){\n\t      _p.style = style.generateStyle( this );\n\t\n\t    } else if( is.array( style ) ){\n\t      _p.style = Style.fromJson( this, style );\n\t\n\t    } else if( is.string( style ) ){\n\t      _p.style = Style.fromString( this, style );\n\t\n\t    } else {\n\t      _p.style = Style( this );\n\t    }\n\t\n\t    return _p.style;\n\t  }\n\t});\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\tvar Selector = __webpack_require__( 57 );\n\t\n\tvar Style = function( cy ){\n\t\n\t  if( !(this instanceof Style) ){\n\t    return new Style( cy );\n\t  }\n\t\n\t  if( !is.core( cy ) ){\n\t    util.error( 'A style must have a core reference' );\n\t    return;\n\t  }\n\t\n\t  this._private = {\n\t    cy: cy,\n\t    coreStyle: {}\n\t  };\n\t\n\t  this.length = 0;\n\t\n\t  this.resetToDefault();\n\t};\n\t\n\tvar styfn = Style.prototype;\n\t\n\tstyfn.instanceString = function(){\n\t  return 'style';\n\t};\n\t\n\t// remove all contexts\n\tstyfn.clear = function(){\n\t  for( var i = 0; i < this.length; i++ ){\n\t    this[ i ] = undefined;\n\t  }\n\t  this.length = 0;\n\t\n\t  var _p = this._private;\n\t\n\t  _p.newStyle = true;\n\t\n\t  return this; // chaining\n\t};\n\t\n\tstyfn.resetToDefault = function(){\n\t  this.clear();\n\t  this.addDefaultStylesheet();\n\t\n\t  return this;\n\t};\n\t\n\t// builds a style object for the 'core' selector\n\tstyfn.core = function(){\n\t  return this._private.coreStyle;\n\t};\n\t\n\t// create a new context from the specified selector string and switch to that context\n\tstyfn.selector = function( selectorStr ){\n\t  // 'core' is a special case and does not need a selector\n\t  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );\n\t\n\t  var i = this.length++; // new context means new index\n\t  this[ i ] = {\n\t    selector: selector,\n\t    properties: [],\n\t    mappedProperties: [],\n\t    index: i\n\t  };\n\t\n\t  return this; // chaining\n\t};\n\t\n\t// add one or many css rules to the current context\n\tstyfn.css = function(){\n\t  var self = this;\n\t  var args = arguments;\n\t\n\t  switch( args.length ){\n\t  case 1:\n\t    var map = args[0];\n\t\n\t    for( var i = 0; i < self.properties.length; i++ ){\n\t      var prop = self.properties[ i ];\n\t      var mapVal = map[ prop.name ];\n\t\n\t      if( mapVal === undefined ){\n\t        mapVal = map[ util.dash2camel( prop.name ) ];\n\t      }\n\t\n\t      if( mapVal !== undefined ){\n\t        this.cssRule( prop.name, mapVal );\n\t      }\n\t    }\n\t\n\t    break;\n\t\n\t  case 2:\n\t    this.cssRule( args[0], args[1] );\n\t    break;\n\t\n\t  default:\n\t    break; // do nothing if args are invalid\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\tstyfn.style = styfn.css;\n\t\n\t// add a single css rule to the current context\n\tstyfn.cssRule = function( name, value ){\n\t  // name-value pair\n\t  var property = this.parse( name, value );\n\t\n\t  // add property to current context if valid\n\t  if( property ){\n\t    var i = this.length - 1;\n\t    this[ i ].properties.push( property );\n\t    this[ i ].properties[ property.name ] = property; // allow access by name as well\n\t\n\t    if( property.name.match( /pie-(\\d+)-background-size/ ) && property.value ){\n\t      this._private.hasPie = true;\n\t    }\n\t\n\t    if( property.mapped ){\n\t      this[ i ].mappedProperties.push( property );\n\t    }\n\t\n\t    // add to core style if necessary\n\t    var currentSelectorIsCore = !this[ i ].selector;\n\t    if( currentSelectorIsCore ){\n\t      this._private.coreStyle[ property.name ] = property;\n\t    }\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\t\n\t// static function\n\tStyle.fromJson = function( cy, json ){\n\t  var style = new Style( cy );\n\t\n\t  style.fromJson( json );\n\t\n\t  return style;\n\t};\n\t\n\tStyle.fromString = function( cy, string ){\n\t  return new Style( cy ).fromString( string );\n\t};\n\t\n\t[\n\t  __webpack_require__( 87 ),\n\t  __webpack_require__( 88 ),\n\t  __webpack_require__( 89 ),\n\t  __webpack_require__( 90 ),\n\t  __webpack_require__( 91 ),\n\t  __webpack_require__( 92 ),\n\t  __webpack_require__( 93 ),\n\t  __webpack_require__( 94 )\n\t].forEach( function( props ){\n\t  util.extend( styfn, props );\n\t} );\n\t\n\t\n\tStyle.types = styfn.types;\n\tStyle.properties = styfn.properties;\n\t\n\tmodule.exports = Style;\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar styfn = {};\n\t\n\t// (potentially expensive calculation)\n\t// apply the style to the element based on\n\t// - its bypass\n\t// - what selectors match it\n\tstyfn.apply = function( eles ){\n\t  var self = this;\n\t  var _p = self._private;\n\t\n\t  if( _p.newStyle ){ // clear style caches\n\t    _p.contextStyles = {};\n\t    _p.propDiffs = {};\n\t\n\t    self.cleanElements( eles, true );\n\t  }\n\t\n\t  for( var ie = 0; ie < eles.length; ie++ ){\n\t    var ele = eles[ ie ];\n\t\n\t    var cxtMeta = self.getContextMeta( ele );\n\t    var cxtStyle = self.getContextStyle( cxtMeta );\n\t    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );\n\t\n\t    self.enforceCompoundSizing( ele );\n\t    self.updateTransitions( ele, app.diffProps );\n\t    self.updateStyleHints( ele );\n\t\n\t  } // for elements\n\t\n\t  _p.newStyle = false;\n\t};\n\t\n\tstyfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){\n\t  var self = this;\n\t  var cache = self._private.propDiffs = self._private.propDiffs || {};\n\t  var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n\t  var cachedVal = cache[ dualCxtKey ];\n\t\n\t  if( cachedVal ){\n\t    return cachedVal;\n\t  }\n\t\n\t  var diffProps = [];\n\t  var addedProp = {};\n\t\n\t  for( var i = 0; i < self.length; i++ ){\n\t    var cxt = self[ i ];\n\t    var oldHasCxt = oldCxtKey[ i ] === 't';\n\t    var newHasCxt = newCxtKey[ i ] === 't';\n\t    var cxtHasDiffed = oldHasCxt !== newHasCxt;\n\t    var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\t\n\t    if( cxtHasDiffed || cxtHasMappedProps ){\n\t      var props;\n\t\n\t      if( cxtHasDiffed && cxtHasMappedProps ){\n\t        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n\t      } else if( cxtHasDiffed ){\n\t        props = cxt.properties; // need to check them all\n\t      } else if( cxtHasMappedProps ){\n\t        props = cxt.mappedProperties; // only need to check mapped\n\t      }\n\t\n\t      for( var j = 0; j < props.length; j++ ){\n\t        var prop = props[ j ];\n\t        var name = prop.name;\n\t\n\t        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n\t        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n\t        // is cached)\n\t        var laterCxtOverrides = false;\n\t        for( var k = i + 1; k < self.length; k++ ){\n\t          var laterCxt = self[ k ];\n\t          var hasLaterCxt = newCxtKey[ k ] === 't';\n\t\n\t          if( !hasLaterCxt ){ continue; } // can't override unless the context is active\n\t\n\t          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;\n\t\n\t          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides\n\t        }\n\t\n\t        if( !addedProp[ name ] && !laterCxtOverrides ){\n\t          addedProp[ name ] = true;\n\t          diffProps.push( name );\n\t        }\n\t      } // for props\n\t    } // if\n\t\n\t  } // for contexts\n\t\n\t  cache[ dualCxtKey ] = diffProps;\n\t  return diffProps;\n\t};\n\t\n\tstyfn.getContextMeta = function( ele ){\n\t  var self = this;\n\t  var cxtKey = '';\n\t  var diffProps;\n\t  var prevKey = ele._private.styleCxtKey || '';\n\t\n\t  if( self._private.newStyle ){\n\t    prevKey = ''; // since we need to apply all style if a fresh stylesheet\n\t  }\n\t\n\t  // get the cxt key\n\t  for( var i = 0; i < self.length; i++ ){\n\t    var context = self[ i ];\n\t    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'\n\t\n\t    if( contextSelectorMatches ){\n\t      cxtKey += 't';\n\t    } else {\n\t      cxtKey += 'f';\n\t    }\n\t  } // for context\n\t\n\t  diffProps = self.getPropertiesDiff( prevKey, cxtKey );\n\t\n\t  ele._private.styleCxtKey = cxtKey;\n\t\n\t  return {\n\t    key: cxtKey,\n\t    diffPropNames: diffProps\n\t  };\n\t};\n\t\n\t// gets a computed ele style object based on matched contexts\n\tstyfn.getContextStyle = function( cxtMeta ){\n\t  var cxtKey = cxtMeta.key;\n\t  var self = this;\n\t  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n\t\n\t  // if already computed style, returned cached copy\n\t  if( cxtStyles[ cxtKey ] ){ return cxtStyles[ cxtKey ]; }\n\t\n\t  var style = {\n\t    _private: {\n\t      key: cxtKey\n\t    }\n\t  };\n\t\n\t  for( var i = 0; i < self.length; i++ ){\n\t    var cxt = self[ i ];\n\t    var hasCxt = cxtKey[ i ] === 't';\n\t\n\t    if( !hasCxt ){ continue; }\n\t\n\t    for( var j = 0; j < cxt.properties.length; j++ ){\n\t      var prop = cxt.properties[ j ];\n\t      var styProp = style[ prop.name ] = prop;\n\t\n\t      styProp.context = cxt;\n\t    }\n\t  }\n\t\n\t  cxtStyles[ cxtKey ] = style;\n\t  return style;\n\t};\n\t\n\tstyfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){\n\t  var self = this;\n\t  var diffProps = cxtMeta.diffPropNames;\n\t  var retDiffProps = {};\n\t\n\t  for( var i = 0; i < diffProps.length; i++ ){\n\t    var diffPropName = diffProps[ i ];\n\t    var cxtProp = cxtStyle[ diffPropName ];\n\t    var eleProp = ele.pstyle( diffPropName );\n\t\n\t    if( !cxtProp ){ // no context prop means delete\n\t      if( eleProp.bypass ){\n\t        cxtProp = { name: diffPropName, deleteBypassed: true };\n\t      } else {\n\t        cxtProp = { name: diffPropName, delete: true };\n\t      }\n\t    }\n\t\n\t    // save cycles when the context prop doesn't need to be applied\n\t    if( eleProp === cxtProp ){ continue; }\n\t\n\t    var retDiffProp = retDiffProps[ diffPropName ] = {\n\t      prev: eleProp\n\t    };\n\t\n\t    self.applyParsedProperty( ele, cxtProp );\n\t\n\t    retDiffProp.next = ele.pstyle( diffPropName );\n\t\n\t    if( retDiffProp.next && retDiffProp.next.bypass ){\n\t      retDiffProp.next = retDiffProp.next.bypassed;\n\t    }\n\t  }\n\t\n\t  return {\n\t    diffProps: retDiffProps\n\t  };\n\t};\n\t\n\t// because a node can become and unbecome a parent, it's safer to enforce auto sizing manually\n\t// (i.e. the style context diff could be empty, meaning the autosizing is stale)\n\tstyfn.enforceCompoundSizing = function(ele){\n\t  var self = this;\n\t\n\t  if( ele.isParent() ){\n\t    self.applyParsedProperty( ele, self.parse('width', 'auto') );\n\t    self.applyParsedProperty( ele, self.parse('height', 'auto') );\n\t  }\n\t};\n\t\n\tstyfn.updateStyleHints = function(ele){\n\t  var _p = ele._private;\n\t  var self = this;\n\t\n\t  if( ele.removed() ){ return; }\n\t\n\t  // set whether has pie or not; for greater efficiency\n\t  var hasPie = false;\n\t  if( _p.group === 'nodes' ){\n\t    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N\n\t      var size = ele.pstyle( 'pie-' + i + '-background-size' ).value;\n\t\n\t      if( size > 0 ){\n\t        hasPie = true;\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  _p.hasPie = hasPie;\n\t\n\t  var transform = ele.pstyle( 'text-transform' ).strValue;\n\t  var content = ele.pstyle( 'label' ).strValue;\n\t  var srcContent = ele.pstyle( 'source-label' ).strValue;\n\t  var tgtContent = ele.pstyle( 'target-label' ).strValue;\n\t  var fStyle = ele.pstyle( 'font-style' ).strValue;\n\t  var size = ele.pstyle( 'font-size' ).pfValue + 'px';\n\t  var family = ele.pstyle( 'font-family' ).strValue;\n\t  // var variant = style['font-variant'].strValue;\n\t  var weight = ele.pstyle( 'font-weight' ).strValue;\n\t  var valign = ele.pstyle( 'text-valign' ).strValue;\n\t  var halign = ele.pstyle( 'text-valign' ).strValue;\n\t  var oWidth = ele.pstyle( 'text-outline-width' ).pfValue;\n\t  var wrap = ele.pstyle( 'text-wrap' ).strValue;\n\t  var wrapW = ele.pstyle( 'text-max-width' ).pfValue;\n\t  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;\n\t  _p.labelStyleKey = labelStyleKey;\n\t  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;\n\t  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;\n\t  _p.labelKey = labelStyleKey + '$' + content;\n\t  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;\n\t\n\t  _p.styleKey = Date.now();\n\t};\n\t\n\t// apply a property to the style (for internal use)\n\t// returns whether application was successful\n\t//\n\t// now, this function flattens the property, and here's how:\n\t//\n\t// for parsedProp:{ bypass: true, deleteBypass: true }\n\t// no property is generated, instead the bypass property in the\n\t// element's style is replaced by what's pointed to by the `bypassed`\n\t// field in the bypass property (i.e. restoring the property the\n\t// bypass was overriding)\n\t//\n\t// for parsedProp:{ mapped: truthy }\n\t// the generated flattenedProp:{ mapping: prop }\n\t//\n\t// for parsedProp:{ bypass: true }\n\t// the generated flattenedProp:{ bypassed: parsedProp }\n\tstyfn.applyParsedProperty = function( ele, parsedProp ){\n\t  var self = this;\n\t  var prop = parsedProp;\n\t  var style = ele._private.style;\n\t  var fieldVal, flatProp;\n\t  var types = self.types;\n\t  var type = self.properties[ prop.name ].type;\n\t  var propIsBypass = prop.bypass;\n\t  var origProp = style[ prop.name ];\n\t  var origPropIsBypass = origProp && origProp.bypass;\n\t  var _p = ele._private;\n\t\n\t  // can't apply auto to width or height unless it's a parent node\n\t  if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){\n\t    if( parsedProp.value === 'auto' && !ele.isParent() ){\n\t      return false;\n\t    } else if( parsedProp.value !== 'auto' && ele.isParent() ){\n\t      prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );\n\t    }\n\t  }\n\t\n\t  // edges connected to compound nodes can not be haystacks\n\t  if(\n\t    parsedProp.name === 'curve-style'\n\t    && parsedProp.value === 'haystack'\n\t    && ele.isEdge()\n\t    && ( ele.isLoop() || ele.source().isParent() || ele.target().isParent() )\n\t  ){\n\t    prop = parsedProp = this.parse( parsedProp.name, 'bezier', propIsBypass );\n\t  }\n\t\n\t  if( prop.delete ){ // delete the property and use the default value on falsey value\n\t    style[ prop.name ] = undefined;\n\t\n\t    return true;\n\t  }\n\t\n\t  if( prop.deleteBypassed ){ // delete the property that the\n\t    if( !origProp ){\n\t      return true; // can't delete if no prop\n\t\n\t    } else if( origProp.bypass ){ // delete bypassed\n\t      origProp.bypassed = undefined;\n\t      return true;\n\t\n\t    } else {\n\t      return false; // we're unsuccessful deleting the bypassed\n\t    }\n\t  }\n\t\n\t  // check if we need to delete the current bypass\n\t  if( prop.deleteBypass ){ // then this property is just here to indicate we need to delete\n\t    if( !origProp ){\n\t      return true; // property is already not defined\n\t\n\t    } else if( origProp.bypass ){ // then replace the bypass property with the original\n\t      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n\t      style[ prop.name ] = origProp.bypassed;\n\t      return true;\n\t\n\t    } else {\n\t      return false; // we're unsuccessful deleting the bypass\n\t    }\n\t  }\n\t\n\t  var printMappingErr = function(){\n\t    util.error( 'Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined' );\n\t  };\n\t\n\t  // put the property in the style objects\n\t  switch( prop.mapped ){ // flatten the property if mapped\n\t  case types.mapData:\n\t  case types.mapLayoutData:\n\t  case types.mapScratch:\n\t\n\t    var isLayout = prop.mapped === types.mapLayoutData;\n\t    var isScratch = prop.mapped === types.mapScratch;\n\t\n\t    // flatten the field (e.g. data.foo.bar)\n\t    var fields = prop.field.split( '.' );\n\t    var fieldVal;\n\t\n\t    if( isScratch || isLayout ){\n\t      fieldVal = _p.scratch;\n\t    } else {\n\t      fieldVal = _p.data;\n\t    }\n\t\n\t    for( var i = 0; i < fields.length && fieldVal; i++ ){\n\t      var field = fields[ i ];\n\t      fieldVal = fieldVal[ field ];\n\t    }\n\t\n\t    var percent;\n\t    if( !is.number( fieldVal ) ){ // then keep the mapping but assume 0% for now\n\t      percent = 0;\n\t    } else {\n\t      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);\n\t    }\n\t\n\t    // make sure to bound percent value\n\t    if( percent < 0 ){\n\t      percent = 0;\n\t    } else if( percent > 1 ){\n\t      percent = 1;\n\t    }\n\t\n\t    if( type.color ){\n\t      var r1 = prop.valueMin[0];\n\t      var r2 = prop.valueMax[0];\n\t      var g1 = prop.valueMin[1];\n\t      var g2 = prop.valueMax[1];\n\t      var b1 = prop.valueMin[2];\n\t      var b2 = prop.valueMax[2];\n\t      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n\t      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n\t\n\t      var clr = [\n\t        Math.round( r1 + (r2 - r1) * percent ),\n\t        Math.round( g1 + (g2 - g1) * percent ),\n\t        Math.round( b1 + (b2 - b1) * percent ),\n\t        Math.round( a1 + (a2 - a1) * percent )\n\t      ];\n\t\n\t      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing\n\t        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass\n\t        name: prop.name,\n\t        value: clr,\n\t        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n\t      };\n\t\n\t    } else if( type.number ){\n\t      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n\t      flatProp = this.parse( prop.name, calcValue, prop.bypass, true );\n\t\n\t    } else {\n\t      return false; // can only map to colours and numbers\n\t    }\n\t\n\t    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n\t      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );\n\t    }\n\t\n\t    if( !flatProp ){ printMappingErr(); }\n\t    flatProp.mapping = prop; // keep a reference to the mapping\n\t    prop = flatProp; // the flattened (mapped) property is the one we want\n\t\n\t    break;\n\t\n\t  // direct mapping\n\t  case types.data:\n\t  case types.layoutData:\n\t  case types.scratch:\n\t    var isLayout = prop.mapped === types.layoutData;\n\t    var isScratch = prop.mapped === types.scratch;\n\t\n\t    // flatten the field (e.g. data.foo.bar)\n\t    var fields = prop.field.split( '.' );\n\t    var fieldVal;\n\t\n\t    if( isScratch || isLayout ){\n\t      fieldVal = _p.scratch;\n\t    } else {\n\t      fieldVal = _p.data;\n\t    }\n\t\n\t    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){\n\t      var field = fields[ i ];\n\t      fieldVal = fieldVal[ field ];\n\t    } }\n\t\n\t    flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );\n\t\n\t    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n\t      var flatPropVal = origProp ? origProp.strValue : '';\n\t\n\t      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );\n\t    }\n\t\n\t    if( !flatProp ){ printMappingErr(); }\n\t    flatProp.mapping = prop; // keep a reference to the mapping\n\t    prop = flatProp; // the flattened (mapped) property is the one we want\n\t\n\t    break;\n\t\n\t  case types.fn:\n\t    var fn = prop.value;\n\t    var fnRetVal = fn( ele );\n\t\n\t    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );\n\t    flatProp.mapping = prop; // keep a reference to the mapping\n\t    prop = flatProp; // the flattened (mapped) property is the one we want\n\t\n\t    break;\n\t\n\t  case undefined:\n\t    break; // just set the property\n\t\n\t  default:\n\t    return false; // not a valid mapping\n\t  }\n\t\n\t  // if the property is a bypass property, then link the resultant property to the original one\n\t  if( propIsBypass ){\n\t    if( origPropIsBypass ){ // then this bypass overrides the existing one\n\t      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n\t    } else { // then link the orig prop to the new bypass\n\t      prop.bypassed = origProp;\n\t    }\n\t\n\t    style[ prop.name ] = prop; // and set\n\t\n\t  } else { // prop is not bypass\n\t    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop\n\t      origProp.bypassed = prop;\n\t    } else { // then just replace the old prop with the new one\n\t      style[ prop.name ] = prop;\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tstyfn.cleanElements = function( eles, keepBypasses ){\n\t  var self = this;\n\t  var props = self.properties;\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[i];\n\t\n\t    if( !keepBypasses ){\n\t      ele._private.style = {};\n\t    } else {\n\t      var style = ele._private.style;\n\t\n\t      for( var j = 0; j < props.length; j++ ){\n\t        var prop = props[j];\n\t        var eleProp = style[ prop.name ];\n\t\n\t        if( eleProp ){\n\t          if( eleProp.bypass ){\n\t            eleProp.bypassed = null;\n\t          } else {\n\t            style[ prop.name ] = null;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t// updates the visual style for all elements (useful for manual style modification after init)\n\tstyfn.update = function(){\n\t  var cy = this._private.cy;\n\t  var eles = cy.mutableElements();\n\t\n\t  eles.updateStyle();\n\t};\n\t\n\t// just update the functional properties (i.e. mappings) in the elements'\n\t// styles (less expensive than recalculation)\n\tstyfn.updateMappers = function( eles ){\n\t  var self = this;\n\t\n\t  for( var i = 0; i < eles.length; i++ ){ // for each ele\n\t    var ele = eles[ i ];\n\t    var style = ele._private.style;\n\t\n\t    for( var j = 0; j < self.properties.length; j++ ){ // for each prop\n\t      var prop = self.properties[ j ];\n\t      var propInStyle = style[ prop.name ];\n\t\n\t      if( propInStyle && propInStyle.mapping ){\n\t        var mapping = propInStyle.mapping;\n\t        this.applyParsedProperty( ele, mapping ); // reapply the mapping property\n\t      }\n\t    }\n\t\n\t    this.updateStyleHints( ele );\n\t  }\n\t};\n\t\n\t// diffProps : { name => { prev, next } }\n\tstyfn.updateTransitions = function( ele, diffProps, isBypass ){\n\t  var self = this;\n\t  var _p = ele._private;\n\t  var props = ele.pstyle( 'transition-property' ).value;\n\t  var duration = ele.pstyle( 'transition-duration' ).pfValue;\n\t  var delay = ele.pstyle( 'transition-delay' ).pfValue;\n\t\n\t  if( props.length > 0 && duration > 0 ){\n\t\n\t    var css = {};\n\t\n\t    // build up the style to animate towards\n\t    var anyPrev = false;\n\t    for( var i = 0; i < props.length; i++ ){\n\t      var prop = props[ i ];\n\t      var styProp = ele.pstyle( prop );\n\t      var diffProp = diffProps[ prop ];\n\t\n\t      if( !diffProp ){ continue; }\n\t\n\t      var prevProp = diffProp.prev;\n\t      var fromProp = prevProp;\n\t      var toProp = diffProp.next != null ? diffProp.next : styProp;\n\t      var diff = false;\n\t      var initVal;\n\t      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\t\n\t      if( !fromProp ){ continue; }\n\t\n\t      // consider px values\n\t      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){\n\t        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n\t        initVal = fromProp.pfValue + initDt * diff;\n\t\n\t      // consider numerical values\n\t      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){\n\t        diff = toProp.value - fromProp.value; // nonzero is truthy\n\t        initVal = fromProp.value + initDt * diff;\n\t\n\t      // consider colour values\n\t      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){\n\t        diff = fromProp.value[0] !== toProp.value[0]\n\t          || fromProp.value[1] !== toProp.value[1]\n\t          || fromProp.value[2] !== toProp.value[2]\n\t        ;\n\t\n\t        initVal = fromProp.strValue;\n\t      }\n\t\n\t      // the previous value is good for an animation only if it's different\n\t      if( diff ){\n\t        css[ prop ] = toProp.strValue; // to val\n\t        this.applyBypass( ele, prop, initVal ); // from val\n\t        anyPrev = true;\n\t      }\n\t\n\t    } // end if props allow ani\n\t\n\t    // can't transition if there's nothing previous to transition from\n\t    if( !anyPrev ){ return; }\n\t\n\t    _p.transitioning = true;\n\t\n\t    ele.stop();\n\t\n\t    if( delay > 0 ){\n\t      ele.delay( delay );\n\t    }\n\t\n\t    ele.animate( {\n\t      css: css\n\t    }, {\n\t      duration: duration,\n\t      easing: ele.pstyle( 'transition-timing-function' ).value,\n\t      queue: false,\n\t      complete: function(){\n\t        if( !isBypass ){\n\t          self.removeBypasses( ele, props );\n\t        }\n\t\n\t        _p.transitioning = false;\n\t      }\n\t    } );\n\t\n\t  } else if( _p.transitioning ){\n\t    ele.stop();\n\t\n\t    this.removeBypasses( ele, props );\n\t\n\t    _p.transitioning = false;\n\t  }\n\t};\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar styfn = {};\n\t\n\t// bypasses are applied to an existing style on an element, and just tacked on temporarily\n\t// returns true iff application was successful for at least 1 specified property\n\tstyfn.applyBypass = function( eles, name, value, updateTransitions ){\n\t  var self = this;\n\t  var props = [];\n\t  var isBypass = true;\n\t\n\t  // put all the properties (can specify one or many) in an array after parsing them\n\t  if( name === '*' || name === '**' ){ // apply to all property names\n\t\n\t    if( value !== undefined ){\n\t      for( var i = 0; i < self.properties.length; i++ ){\n\t        var prop = self.properties[ i ];\n\t        var name = prop.name;\n\t\n\t        var parsedProp = this.parse( name, value, true );\n\t\n\t        if( parsedProp ){\n\t          props.push( parsedProp );\n\t        }\n\t      }\n\t    }\n\t\n\t  } else if( is.string( name ) ){ // then parse the single property\n\t    var parsedProp = this.parse( name, value, true );\n\t\n\t    if( parsedProp ){\n\t      props.push( parsedProp );\n\t    }\n\t  } else if( is.plainObject( name ) ){ // then parse each property\n\t    var specifiedProps = name;\n\t    updateTransitions = value;\n\t\n\t    for( var i = 0; i < self.properties.length; i++ ){\n\t      var prop = self.properties[ i ];\n\t      var name = prop.name;\n\t      var value = specifiedProps[ name ];\n\t\n\t      if( value === undefined ){ // try camel case name too\n\t        value = specifiedProps[ util.dash2camel( name ) ];\n\t      }\n\t\n\t      if( value !== undefined ){\n\t        var parsedProp = this.parse( name, value, true );\n\t\n\t        if( parsedProp ){\n\t          props.push( parsedProp );\n\t        }\n\t      }\n\t    }\n\t  } else { // can't do anything without well defined properties\n\t    return false;\n\t  }\n\t\n\t  // we've failed if there are no valid properties\n\t  if( props.length === 0 ){ return false; }\n\t\n\t  // now, apply the bypass properties on the elements\n\t  var ret = false; // return true if at least one succesful bypass applied\n\t  for( var i = 0; i < eles.length; i++ ){ // for each ele\n\t    var ele = eles[ i ];\n\t    var diffProps = {};\n\t    var diffProp;\n\t\n\t    for( var j = 0; j < props.length; j++ ){ // for each prop\n\t      var prop = props[ j ];\n\t\n\t      if( updateTransitions ){\n\t        var prevProp = ele.pstyle( prop.name );\n\t        diffProp = diffProps[ prop.name ] = { prev: prevProp };\n\t      }\n\t\n\t      ret = this.applyParsedProperty( ele, prop ) || ret;\n\t\n\t      if( updateTransitions ){\n\t        diffProp.next = ele.pstyle( prop.name );\n\t      }\n\t\n\t    } // for props\n\t\n\t    if( ret ){\n\t      this.updateStyleHints( ele );\n\t    }\n\t\n\t    if( updateTransitions ){\n\t      this.updateTransitions( ele, diffProps, isBypass );\n\t    }\n\t  } // for eles\n\t\n\t  return ret;\n\t};\n\t\n\t// only useful in specific cases like animation\n\tstyfn.overrideBypass = function( eles, name, value ){\n\t  name = util.camel2dash( name );\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[ i ];\n\t    var prop = ele._private.style[ name ];\n\t    var type = this.properties[ name ].type;\n\t    var isColor = type.color;\n\t    var isMulti = type.mutiple;\n\t\n\t    if( !prop || !prop.bypass ){ // need a bypass if one doesn't exist\n\t      this.applyBypass( ele, name, value );\n\t      continue;\n\t    }\n\t\n\t    prop.value = value;\n\t\n\t    if( prop.pfValue != null ){\n\t      prop.pfValue = value;\n\t    }\n\t\n\t    if( isColor ){\n\t      prop.strValue = 'rgb(' + value.join( ',' ) + ')';\n\t    } else if( isMulti ){\n\t      prop.strValue = value.join( ' ' );\n\t    } else {\n\t      prop.strValue = '' + value;\n\t    }\n\t  }\n\t};\n\t\n\tstyfn.removeAllBypasses = function( eles, updateTransitions ){\n\t  return this.removeBypasses( eles, this.propertyNames, updateTransitions );\n\t};\n\t\n\tstyfn.removeBypasses = function( eles, props, updateTransitions ){\n\t  var isBypass = true;\n\t\n\t  for( var j = 0; j < eles.length; j++ ){\n\t    var ele = eles[ j ];\n\t    var diffProps = {};\n\t\n\t    for( var i = 0; i < props.length; i++ ){\n\t      var name = props[ i ];\n\t      var prop = this.properties[ name ];\n\t      var prevProp = ele.pstyle( prop.name );\n\t\n\t      if( !prevProp || !prevProp.bypass ){\n\t        // if a bypass doesn't exist for the prop, nothing needs to be removed\n\t        continue;\n\t      }\n\t\n\t      var value = ''; // empty => remove bypass\n\t      var parsedProp = this.parse( name, value, true );\n\t      var diffProp = diffProps[ prop.name ] = { prev: prevProp };\n\t\n\t      this.applyParsedProperty( ele, parsedProp );\n\t\n\t      diffProp.next = ele.pstyle( prop.name );\n\t    } // for props\n\t\n\t    this.updateStyleHints( ele );\n\t\n\t    if( updateTransitions ){\n\t      this.updateTransitions( ele, diffProps, isBypass );\n\t    }\n\t  } // for eles\n\t};\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar window = __webpack_require__( 29 );\n\t\n\tvar styfn = {};\n\t\n\t// gets what an em size corresponds to in pixels relative to a dom element\n\tstyfn.getEmSizeInPixels = function(){\n\t  var px = this.containerCss( 'font-size' );\n\t\n\t  if( px != null ){\n\t    return parseFloat( px );\n\t  } else {\n\t    return 1; // for headless\n\t  }\n\t};\n\t\n\t// gets css property from the core container\n\tstyfn.containerCss = function( propName ){\n\t  var cy = this._private.cy;\n\t  var domElement = cy.container();\n\t\n\t  if( window && domElement && window.getComputedStyle ){\n\t    return window.getComputedStyle( domElement ).getPropertyValue( propName );\n\t  }\n\t};\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar styfn = {};\n\t\n\t// gets the rendered style for an element\n\tstyfn.getRenderedStyle = function( ele ){\n\t  return this.getRawStyle( ele, true );\n\t};\n\t\n\t// gets the raw style for an element\n\tstyfn.getRawStyle = function( ele, isRenderedVal ){\n\t  var self = this;\n\t  var ele = ele[0]; // insure it's an element\n\t\n\t  if( ele ){\n\t    var rstyle = {};\n\t\n\t    for( var i = 0; i < self.properties.length; i++ ){\n\t      var prop = self.properties[ i ];\n\t      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );\n\t\n\t      if( val ){\n\t        rstyle[ prop.name ] = val;\n\t        rstyle[ util.dash2camel( prop.name ) ] = val;\n\t      }\n\t    }\n\t\n\t    return rstyle;\n\t  }\n\t};\n\t\n\tstyfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){\n\t  var self = this;\n\t  var ele = ele[0]; // insure it's an element\n\t\n\t  if( ele ){\n\t    var prop = self.properties[ propName ];\n\t    var type = prop.type;\n\t    var styleProp = ele.pstyle( prop.name );\n\t    var zoom = ele.cy().zoom();\n\t\n\t    if( styleProp ){\n\t      var units = styleProp.units ? type.implicitUnits || 'px' : null;\n\t      var val = units ? [].concat( styleProp.pfValue ).map( function( pfValue ){\n\t        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;\n\t      } ).join( ' ' ) : styleProp.strValue;\n\t\n\t      return val;\n\t    }\n\t  }\n\t};\n\t\n\tstyfn.getAnimationStartStyle = function( ele, aniProps ){\n\t  var rstyle = {};\n\t\n\t  for( var i = 0; i < aniProps.length; i++ ){\n\t    var aniProp = aniProps[ i ];\n\t    var name = aniProp.name;\n\t\n\t    var styleProp = ele.pstyle( name );\n\t\n\t    if( styleProp !== undefined ){ // then make a prop of it\n\t      if( is.plainObject( styleProp ) ){\n\t        styleProp = this.parse( name, styleProp.strValue );\n\t      } else {\n\t        styleProp = this.parse( name, styleProp );\n\t      }\n\t    }\n\t\n\t    if( styleProp ){\n\t      rstyle[ name ] = styleProp;\n\t    }\n\t  }\n\t\n\t  return rstyle;\n\t};\n\t\n\tstyfn.getPropsList = function( propsObj ){\n\t  var self = this;\n\t  var rstyle = [];\n\t  var style = propsObj;\n\t  var props = self.properties;\n\t\n\t  if( style ){\n\t    var names = Object.keys( style );\n\t\n\t    for( var i = 0; i < names.length; i++ ){\n\t      var name = names[i];\n\t      var val = style[ name ];\n\t      var prop = props[ name ] || props[ util.camel2dash( name ) ];\n\t      var styleProp = this.parse( prop.name, val );\n\t\n\t      rstyle.push( styleProp );\n\t    }\n\t  }\n\t\n\t  return rstyle;\n\t};\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar styfn = {};\n\t\n\tstyfn.applyFromJson = function( json ){\n\t  var style = this;\n\t\n\t  for( var i = 0; i < json.length; i++ ){\n\t    var context = json[ i ];\n\t    var selector = context.selector;\n\t    var props = context.style || context.css;\n\t    var names = Object.keys( props );\n\t\n\t    style.selector( selector ); // apply selector\n\t\n\t    for( var j = 0; j < names.length; j++ ){\n\t      var name = names[j];\n\t      var value = props[ name ];\n\t\n\t      style.css( name, value ); // apply property\n\t    }\n\t  }\n\t\n\t  return style;\n\t};\n\t\n\t// accessible cy.style() function\n\tstyfn.fromJson = function( json ){\n\t  var style = this;\n\t\n\t  style.resetToDefault();\n\t  style.applyFromJson( json );\n\t\n\t  return style;\n\t};\n\t\n\t// get json from cy.style() api\n\tstyfn.json = function(){\n\t  var json = [];\n\t\n\t  for( var i = this.defaultLength; i < this.length; i++ ){\n\t    var cxt = this[ i ];\n\t    var selector = cxt.selector;\n\t    var props = cxt.properties;\n\t    var css = {};\n\t\n\t    for( var j = 0; j < props.length; j++ ){\n\t      var prop = props[ j ];\n\t      css[ prop.name ] = prop.strValue;\n\t    }\n\t\n\t    json.push( {\n\t      selector: !selector ? 'core' : selector.toString(),\n\t      style: css\n\t    } );\n\t  }\n\t\n\t  return json;\n\t};\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar Selector = __webpack_require__( 57 );\n\t\n\tvar styfn = {};\n\t\n\tstyfn.applyFromString = function( string ){\n\t  var self = this;\n\t  var style = this;\n\t  var remaining = '' + string;\n\t  var selAndBlockStr;\n\t  var blockRem;\n\t  var propAndValStr;\n\t\n\t  // remove comments from the style string\n\t  remaining = remaining.replace( /[/][*](\\s|.)+?[*][/]/g, '' );\n\t\n\t  function removeSelAndBlockFromRemaining(){\n\t    // remove the parsed selector and block from the remaining text to parse\n\t    if( remaining.length > selAndBlockStr.length ){\n\t      remaining = remaining.substr( selAndBlockStr.length );\n\t    } else {\n\t      remaining = '';\n\t    }\n\t  }\n\t\n\t  function removePropAndValFromRem(){\n\t    // remove the parsed property and value from the remaining block text to parse\n\t    if( blockRem.length > propAndValStr.length ){\n\t      blockRem = blockRem.substr( propAndValStr.length );\n\t    } else {\n\t      blockRem = '';\n\t    }\n\t  }\n\t\n\t  while( true ){\n\t    var nothingLeftToParse = remaining.match( /^\\s*$/ );\n\t    if( nothingLeftToParse ){ break; }\n\t\n\t    var selAndBlock = remaining.match( /^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/ );\n\t\n\t    if( !selAndBlock ){\n\t      util.error( 'Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining );\n\t      break;\n\t    }\n\t\n\t    selAndBlockStr = selAndBlock[0];\n\t\n\t    // parse the selector\n\t    var selectorStr = selAndBlock[1];\n\t    if( selectorStr !== 'core' ){\n\t      var selector = new Selector( selectorStr );\n\t      if( selector._private.invalid ){\n\t        util.error( 'Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr );\n\t\n\t        // skip this selector and block\n\t        removeSelAndBlockFromRemaining();\n\t        continue;\n\t      }\n\t    }\n\t\n\t    // parse the block of properties and values\n\t    var blockStr = selAndBlock[2];\n\t    var invalidBlock = false;\n\t    blockRem = blockStr;\n\t    var props = [];\n\t\n\t    while( true ){\n\t      var nothingLeftToParse = blockRem.match( /^\\s*$/ );\n\t      if( nothingLeftToParse ){ break; }\n\t\n\t      var propAndVal = blockRem.match( /^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/ );\n\t\n\t      if( !propAndVal ){\n\t        util.error( 'Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr );\n\t        invalidBlock = true;\n\t        break;\n\t      }\n\t\n\t      propAndValStr = propAndVal[0];\n\t      var propStr = propAndVal[1];\n\t      var valStr = propAndVal[2];\n\t\n\t      var prop = self.properties[ propStr ];\n\t      if( !prop ){\n\t        util.error( 'Skipping property: Invalid property name in: ' + propAndValStr );\n\t\n\t        // skip this property in the block\n\t        removePropAndValFromRem();\n\t        continue;\n\t      }\n\t\n\t      var parsedProp = style.parse( propStr, valStr );\n\t\n\t      if( !parsedProp ){\n\t        util.error( 'Skipping property: Invalid property definition in: ' + propAndValStr );\n\t\n\t        // skip this property in the block\n\t        removePropAndValFromRem();\n\t        continue;\n\t      }\n\t\n\t      props.push( {\n\t        name: propStr,\n\t        val: valStr\n\t      } );\n\t      removePropAndValFromRem();\n\t    }\n\t\n\t    if( invalidBlock ){\n\t      removeSelAndBlockFromRemaining();\n\t      break;\n\t    }\n\t\n\t    // put the parsed block in the style\n\t    style.selector( selectorStr );\n\t    for( var i = 0; i < props.length; i++ ){\n\t      var prop = props[ i ];\n\t      style.css( prop.name, prop.val );\n\t    }\n\t\n\t    removeSelAndBlockFromRemaining();\n\t  }\n\t\n\t  return style;\n\t};\n\t\n\tstyfn.fromString = function( string ){\n\t  var style = this;\n\t\n\t  style.resetToDefault();\n\t  style.applyFromString( string );\n\t\n\t  return style;\n\t};\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar styfn = {};\n\t\n\t(function(){\n\t  var number = util.regex.number;\n\t  var rgba = util.regex.rgbaNoBackRefs;\n\t  var hsla = util.regex.hslaNoBackRefs;\n\t  var hex3 = util.regex.hex3;\n\t  var hex6 = util.regex.hex6;\n\t  var data = function( prefix ){ return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$'; };\n\t  var mapData = function( prefix ){\n\t    var mapArg = number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;\n\t    return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n\t  };\n\t\n\t  // each visual style property has a type and needs to be validated according to it\n\t  styfn.types = {\n\t    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },\n\t    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },\n\t    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },\n\t    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },\n\t    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },\n\t    position: { enums: [ 'parent', 'origin' ] },\n\t    nodeSize: { number: true, min: 0, enums: [ 'auto', 'label' ] },\n\t    number: { number: true, unitless: true },\n\t    numbers: { number: true, unitless: true, multiple: true },\n\t    size: { number: true, min: 0 },\n\t    bidirectionalSize: { number: true }, // allows negative\n\t    bidirectionalSizes: { number: true, multiple: true }, // allows negative\n\t    bgSize: { number: true, min: 0, allowPercent: true },\n\t    bgWH: { number: true, min: 0, allowPercent: true, enums: [ 'auto' ] },\n\t    bgPos: { number: true, allowPercent: true },\n\t    bgRepeat: { enums: [ 'repeat', 'repeat-x', 'repeat-y', 'no-repeat' ] },\n\t    bgFit: { enums: [ 'none', 'contain', 'cover' ] },\n\t    bgClip: { enums: [ 'none', 'node' ] },\n\t    color: { color: true },\n\t    bool: { enums: [ 'yes', 'no' ] },\n\t    lineStyle: { enums: [ 'solid', 'dotted', 'dashed' ] },\n\t    borderStyle: { enums: [ 'solid', 'dotted', 'dashed', 'double' ] },\n\t    curveStyle: { enums: [ 'bezier', 'unbundled-bezier', 'haystack', 'segments' ] },\n\t    fontFamily: { regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$' },\n\t    fontVariant: { enums: [ 'small-caps', 'normal' ] },\n\t    fontStyle: { enums: [ 'italic', 'normal', 'oblique' ] },\n\t    fontWeight: { enums: [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900 ] },\n\t    textDecoration: { enums: [ 'none', 'underline', 'overline', 'line-through' ] },\n\t    textTransform: { enums: [ 'none', 'uppercase', 'lowercase' ] },\n\t    textWrap: { enums: [ 'none', 'wrap' ] },\n\t    textBackgroundShape: { enums: [ 'rectangle', 'roundrectangle' ]},\n\t    nodeShape: { enums: [ 'rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon' ] },\n\t    compoundIncludeLabels: { enums: [ 'include', 'exclude' ] },\n\t    arrowShape: { enums: [ 'tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none' ] },\n\t    arrowFill: { enums: [ 'filled', 'hollow' ] },\n\t    display: { enums: [ 'element', 'none' ] },\n\t    visibility: { enums: [ 'hidden', 'visible' ] },\n\t    valign: { enums: [ 'top', 'center', 'bottom' ] },\n\t    halign: { enums: [ 'left', 'center', 'right' ] },\n\t    text: { string: true },\n\t    data: { mapping: true, regex: data( 'data' ) },\n\t    layoutData: { mapping: true, regex: data( 'layoutData' ) },\n\t    scratch: { mapping: true, regex: data( 'scratch' ) },\n\t    mapData: { mapping: true, regex: mapData( 'mapData' ) },\n\t    mapLayoutData: { mapping: true, regex: mapData( 'mapLayoutData' ) },\n\t    mapScratch: { mapping: true, regex: mapData( 'mapScratch' ) },\n\t    fn: { mapping: true, fn: true },\n\t    url: { regex: '^url\\\\s*\\\\(\\\\s*([^\\\\s]+)\\\\s*\\\\s*\\\\)|none|(.+)$' },\n\t    propList: { propList: true },\n\t    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },\n\t    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: [ 'none', 'autorotate' ] },\n\t    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },\n\t    edgeDistances: { enums: ['intersection', 'node-position'] },\n\t    easing: {\n\t      regexes: [\n\t        '^(spring)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$',\n\t        '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$'\n\t      ],\n\t      enums: [\n\t        'linear',\n\t        'ease', 'ease-in', 'ease-out', 'ease-in-out',\n\t        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',\n\t        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',\n\t        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',\n\t        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',\n\t        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',\n\t        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',\n\t        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'\n\t      ]\n\t    }\n\t  };\n\t\n\t  // define visual style properties\n\t  var t = styfn.types;\n\t  var props = styfn.properties = [\n\t    // main label\n\t    { name: 'label', type: t.text },\n\t    { name: 'text-rotation', type: t.textRotation },\n\t    { name: 'text-margin-x', type: t.bidirectionalSize },\n\t    { name: 'text-margin-y', type: t.bidirectionalSize },\n\t\n\t    // source label\n\t    { name: 'source-label', type: t.text },\n\t    { name: 'source-text-rotation', type: t.textRotation },\n\t    { name: 'source-text-margin-x', type: t.bidirectionalSize },\n\t    { name: 'source-text-margin-y', type: t.bidirectionalSize },\n\t    { name: 'source-text-offset', type: t.size },\n\t\n\t    // target label\n\t    { name: 'target-label', type: t.text },\n\t    { name: 'target-text-rotation', type: t.textRotation },\n\t    { name: 'target-text-margin-x', type: t.bidirectionalSize },\n\t    { name: 'target-text-margin-y', type: t.bidirectionalSize },\n\t    { name: 'target-text-offset', type: t.size },\n\t\n\t    // common label style\n\t    { name: 'text-valign', type: t.valign },\n\t    { name: 'text-halign', type: t.halign },\n\t    { name: 'color', type: t.color },\n\t    { name: 'text-outline-color', type: t.color },\n\t    { name: 'text-outline-width', type: t.size },\n\t    { name: 'text-outline-opacity', type: t.zeroOneNumber },\n\t    { name: 'text-opacity', type: t.zeroOneNumber },\n\t    { name: 'text-background-color', type: t.color },\n\t    { name: 'text-background-margin', type: t.size },\n\t    { name: 'text-background-opacity', type: t.zeroOneNumber },\n\t    { name: 'text-border-opacity', type: t.zeroOneNumber },\n\t    { name: 'text-border-color', type: t.color },\n\t    { name: 'text-border-width', type: t.size },\n\t    { name: 'text-border-style', type: t.borderStyle },\n\t    { name: 'text-background-shape', type: t.textBackgroundShape},\n\t    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas\n\t    { name: 'text-transform', type: t.textTransform },\n\t    { name: 'text-wrap', type: t.textWrap },\n\t    { name: 'text-max-width', type: t.size },\n\t    { name: 'text-events', type: t.bool },\n\t    { name: 'font-family', type: t.fontFamily },\n\t    { name: 'font-style', type: t.fontStyle },\n\t    // { name: 'font-variant', type: t.fontVariant }, // not useful\n\t    { name: 'font-weight', type: t.fontWeight },\n\t    { name: 'font-size', type: t.size },\n\t    { name: 'min-zoomed-font-size', type: t.size },\n\t\n\t    // behaviour\n\t    { name: 'events', type: t.bool },\n\t\n\t    // visibility\n\t    { name: 'display', type: t.display },\n\t    { name: 'visibility', type: t.visibility },\n\t    { name: 'opacity', type: t.zeroOneNumber },\n\t    { name: 'z-index', type: t.nonNegativeInt },\n\t\n\t    // overlays\n\t    { name: 'overlay-padding', type: t.size },\n\t    { name: 'overlay-color', type: t.color },\n\t    { name: 'overlay-opacity', type: t.zeroOneNumber },\n\t\n\t    // shadows\n\t    { name: 'shadow-blur', type: t.size },\n\t    { name: 'shadow-color', type: t.color },\n\t    { name: 'shadow-opacity', type: t.zeroOneNumber },\n\t    { name: 'shadow-offset-x', type: t.bidirectionalSize },\n\t    { name: 'shadow-offset-y', type: t.bidirectionalSize },\n\t\n\t    // label shadows\n\t    { name: 'text-shadow-blur', type: t.size },\n\t    { name: 'text-shadow-color', type: t.color },\n\t    { name: 'text-shadow-opacity', type: t.zeroOneNumber },\n\t    { name: 'text-shadow-offset-x', type: t.bidirectionalSize },\n\t    { name: 'text-shadow-offset-y', type: t.bidirectionalSize },\n\t\n\t    // transition anis\n\t    { name: 'transition-property', type: t.propList },\n\t    { name: 'transition-duration', type: t.time },\n\t    { name: 'transition-delay', type: t.time },\n\t    { name: 'transition-timing-function', type: t.easing },\n\t\n\t    // node body\n\t    { name: 'height', type: t.nodeSize },\n\t    { name: 'width', type: t.nodeSize },\n\t    { name: 'shape', type: t.nodeShape },\n\t    { name: 'shape-polygon-points', type: t.polygonPointList },\n\t    { name: 'background-color', type: t.color },\n\t    { name: 'background-opacity', type: t.zeroOneNumber },\n\t    { name: 'background-blacken', type: t.nOneOneNumber },\n\t    { name: 'padding-left', type: t.size },\n\t    { name: 'padding-right', type: t.size },\n\t    { name: 'padding-top', type: t.size },\n\t    { name: 'padding-bottom', type: t.size },\n\t\n\t    // node border\n\t    { name: 'border-color', type: t.color },\n\t    { name: 'border-opacity', type: t.zeroOneNumber },\n\t    { name: 'border-width', type: t.size },\n\t    { name: 'border-style', type: t.borderStyle },\n\t\n\t    // node background images\n\t    { name: 'background-image', type: t.url },\n\t    { name: 'background-image-opacity', type: t.zeroOneNumber },\n\t    { name: 'background-position-x', type: t.bgPos },\n\t    { name: 'background-position-y', type: t.bgPos },\n\t    { name: 'background-repeat', type: t.bgRepeat },\n\t    { name: 'background-fit', type: t.bgFit },\n\t    { name: 'background-clip', type: t.bgClip },\n\t    { name: 'background-width', type: t.bgWH },\n\t    { name: 'background-height', type: t.bgWH },\n\t\n\t    // compound props\n\t    { name: 'position', type: t.position },\n\t    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },\n\t\n\t    // edge line\n\t    { name: 'line-style', type: t.lineStyle },\n\t    { name: 'line-color', type: t.color },\n\t    { name: 'curve-style', type: t.curveStyle },\n\t    { name: 'haystack-radius', type: t.zeroOneNumber },\n\t    { name: 'control-point-step-size', type: t.size },\n\t    { name: 'control-point-distances', type: t.bidirectionalSizes },\n\t    { name: 'control-point-weights', type: t.numbers },\n\t    { name: 'segment-distances', type: t.bidirectionalSizes },\n\t    { name: 'segment-weights', type: t.numbers },\n\t    { name: 'edge-distances', type: t.edgeDistances },\n\t\n\t    // these are just for the core\n\t    { name: 'selection-box-color', type: t.color },\n\t    { name: 'selection-box-opacity', type: t.zeroOneNumber },\n\t    { name: 'selection-box-border-color', type: t.color },\n\t    { name: 'selection-box-border-width', type: t.size },\n\t    { name: 'active-bg-color', type: t.color },\n\t    { name: 'active-bg-opacity', type: t.zeroOneNumber },\n\t    { name: 'active-bg-size', type: t.size },\n\t    { name: 'outside-texture-bg-color', type: t.color },\n\t    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }\n\t  ];\n\t\n\t  // define aliases\n\t  var aliases = styfn.aliases = [\n\t    { name: 'content', pointsTo: 'label' },\n\t    { name: 'control-point-distance', pointsTo: 'control-point-distances' },\n\t    { name: 'control-point-weight', pointsTo: 'control-point-weights' },\n\t    { name: 'edge-text-rotation', pointsTo: 'text-rotation' }\n\t  ];\n\t\n\t  // pie backgrounds for nodes\n\t  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n\t  props.push( { name: 'pie-size', type: t.bgSize } );\n\t  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){\n\t    props.push( { name: 'pie-' + i + '-background-color', type: t.color } );\n\t    props.push( { name: 'pie-' + i + '-background-size', type: t.percent } );\n\t    props.push( { name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber } );\n\t  }\n\t\n\t  // edge arrows\n\t  var arrowPrefixes = styfn.arrowPrefixes = [ 'source', 'mid-source', 'target', 'mid-target' ];\n\t  [\n\t    { name: 'arrow-shape', type: t.arrowShape },\n\t    { name: 'arrow-color', type: t.color },\n\t    { name: 'arrow-fill', type: t.arrowFill }\n\t  ].forEach( function( prop ){\n\t    arrowPrefixes.forEach( function( prefix ){\n\t      var name = prefix + '-' + prop.name;\n\t      var type = prop.type;\n\t\n\t      props.push( { name: name, type: type } );\n\t    } );\n\t  }, {} );\n\t\n\t  // list of property names\n\t  styfn.propertyNames = props.map( function( p ){ return p.name; } );\n\t\n\t  // allow access of properties by name ( e.g. style.properties.height )\n\t  for( var i = 0; i < props.length; i++ ){\n\t    var prop = props[ i ];\n\t\n\t    props[ prop.name ] = prop; // allow lookup by name\n\t  }\n\t\n\t  // map aliases\n\t  for( var i = 0; i < aliases.length; i++ ){\n\t    var alias = aliases[ i ];\n\t    var pointsToProp = props[ alias.pointsTo ];\n\t    var aliasProp = {\n\t      name: alias.name,\n\t      alias: true,\n\t      pointsTo: pointsToProp\n\t    };\n\t\n\t    // add alias prop for parsing\n\t    props.push( aliasProp );\n\t\n\t    props[ alias.name ] = aliasProp; // allow lookup by name\n\t  }\n\t})();\n\t\n\tstyfn.getDefaultProperty = function( name ){\n\t  return this.getDefaultProperties()[ name ];\n\t};\n\t\n\tstyfn.getDefaultProperties = util.memoize( function(){\n\t  var rawProps = util.extend( {\n\t    'events': 'yes',\n\t    'text-events': 'no',\n\t    'text-valign': 'top',\n\t    'text-halign': 'center',\n\t    'color': '#000',\n\t    'text-outline-color': '#000',\n\t    'text-outline-width': 0,\n\t    'text-outline-opacity': 1,\n\t    'text-opacity': 1,\n\t    'text-decoration': 'none',\n\t    'text-transform': 'none',\n\t    'text-wrap': 'none',\n\t    'text-max-width': 9999,\n\t    'text-background-color': '#000',\n\t    'text-background-opacity': 0,\n\t    'text-background-margin': 0,\n\t    'text-border-opacity': 0,\n\t    'text-border-width': 0,\n\t    'text-border-style': 'solid',\n\t    'text-border-color': '#000',\n\t    'text-background-shape': 'rectangle',\n\t    'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n\t    'font-style': 'normal',\n\t    // 'font-variant': fontVariant,\n\t    'font-weight': 'normal',\n\t    'font-size': 16,\n\t    'min-zoomed-font-size': 0,\n\t    'text-rotation': 'none',\n\t    'source-text-rotation': 'none',\n\t    'target-text-rotation': 'none',\n\t    'visibility': 'visible',\n\t    'display': 'element',\n\t    'opacity': 1,\n\t    'z-index': 0,\n\t    'label': '',\n\t    'text-margin-x': 0,\n\t    'text-margin-y': 0,\n\t    'source-label': '',\n\t    'source-text-offset': 0,\n\t    'source-text-margin-x': 0,\n\t    'source-text-margin-y': 0,\n\t    'target-label': '',\n\t    'target-text-offset': 0,\n\t    'target-text-margin-x': 0,\n\t    'target-text-margin-y': 0,\n\t    'overlay-opacity': 0,\n\t    'overlay-color': '#000',\n\t    'overlay-padding': 10,\n\t    'shadow-opacity': 0,\n\t    'shadow-color': '#000',\n\t    'shadow-blur': 10,\n\t    'shadow-offset-x': 0,\n\t    'shadow-offset-y': 0,\n\t    'text-shadow-opacity': 0,\n\t    'text-shadow-color': '#000',\n\t    'text-shadow-blur': 5,\n\t    'text-shadow-offset-x': 0,\n\t    'text-shadow-offset-y': 0,\n\t    'transition-property': 'none',\n\t    'transition-duration': 0,\n\t    'transition-delay': 0,\n\t    'transition-timing-function': 'linear',\n\t\n\t    // node props\n\t    'background-blacken': 0,\n\t    'background-color': '#999',\n\t    'background-opacity': 1,\n\t    'background-image': 'none',\n\t    'background-image-opacity': 1,\n\t    'background-position-x': '50%',\n\t    'background-position-y': '50%',\n\t    'background-repeat': 'no-repeat',\n\t    'background-fit': 'none',\n\t    'background-clip': 'node',\n\t    'background-width': 'auto',\n\t    'background-height': 'auto',\n\t    'border-color': '#000',\n\t    'border-opacity': 1,\n\t    'border-width': 0,\n\t    'border-style': 'solid',\n\t    'height': 30,\n\t    'width': 30,\n\t    'shape': 'ellipse',\n\t    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n\t\n\t    // compound props\n\t    'padding-top': 0,\n\t    'padding-bottom': 0,\n\t    'padding-left': 0,\n\t    'padding-right': 0,\n\t    'position': 'origin',\n\t    'compound-sizing-wrt-labels': 'include'\n\t  }, {\n\t    // node pie bg\n\t    'pie-size': '100%'\n\t  }, [\n\t    { name: 'pie-{{i}}-background-color', value: 'black' },\n\t    { name: 'pie-{{i}}-background-size', value: '0%' },\n\t    { name: 'pie-{{i}}-background-opacity', value: 1 }\n\t  ].reduce( function( css, prop ){\n\t    for( var i = 1; i <= styfn.pieBackgroundN; i++ ){\n\t      var name = prop.name.replace( '{{i}}', i );\n\t      var val = prop.value;\n\t\n\t      css[ name ] = val;\n\t    }\n\t\n\t    return css;\n\t  }, {} ), {\n\t    // edge props\n\t    'line-style': 'solid',\n\t    'line-color': '#999',\n\t    'control-point-step-size': 40,\n\t    'control-point-weights': 0.5,\n\t    'segment-weights': 0.5,\n\t    'segment-distances': 20,\n\t    'edge-distances': 'intersection',\n\t    'curve-style': 'bezier',\n\t    'haystack-radius': 0\n\t  }, [\n\t    { name: 'arrow-shape', value: 'none' },\n\t    { name: 'arrow-color', value: '#999' },\n\t    { name: 'arrow-fill', value: 'filled' }\n\t  ].reduce( function( css, prop ){\n\t    styfn.arrowPrefixes.forEach( function( prefix ){\n\t      var name = prefix + '-' + prop.name;\n\t      var val = prop.value;\n\t\n\t      css[ name ] = val;\n\t    } );\n\t\n\t    return css;\n\t  }, {} ) );\n\t\n\t  var parsedProps = {};\n\t\n\t  for( var i = 0; i < this.properties.length; i++ ){\n\t    var prop = this.properties[i];\n\t\n\t    if( prop.pointsTo ){ continue; }\n\t\n\t    var name = prop.name;\n\t    var val = rawProps[ name ];\n\t    var parsedProp = this.parse( name, val );\n\t\n\t    parsedProps[ name ] = parsedProp;\n\t  }\n\t\n\t  return parsedProps;\n\t} );\n\t\n\tstyfn.addDefaultStylesheet = function(){\n\t  this\n\t    .selector( '$node > node' ) // compound (parent) node properties\n\t      .css( {\n\t        'width': 'auto',\n\t        'height': 'auto',\n\t        'shape': 'rectangle',\n\t        'padding-top': 10,\n\t        'padding-right': 10,\n\t        'padding-left': 10,\n\t        'padding-bottom': 10,\n\t        'background-color': '#eee',\n\t        'border-color': '#ccc',\n\t        'border-width': 1\n\t      } )\n\t    .selector( 'edge' ) // just edge properties\n\t      .css( {\n\t        'width': 3,\n\t        'curve-style': 'haystack'\n\t      } )\n\t    .selector( ':selected' )\n\t      .css( {\n\t        'background-color': '#0169D9',\n\t        'line-color': '#0169D9',\n\t        'source-arrow-color': '#0169D9',\n\t        'target-arrow-color': '#0169D9',\n\t        'mid-source-arrow-color': '#0169D9',\n\t        'mid-target-arrow-color': '#0169D9'\n\t      } )\n\t    .selector( 'node:parent:selected' )\n\t      .css( {\n\t        'background-color': '#CCE1F9',\n\t        'border-color': '#aec8e5'\n\t      } )\n\t    .selector( ':active' )\n\t      .css( {\n\t        'overlay-color': 'black',\n\t        'overlay-padding': 10,\n\t        'overlay-opacity': 0.25\n\t      } )\n\t    .selector( 'core' ) // just core properties\n\t      .css( {\n\t        'selection-box-color': '#ddd',\n\t        'selection-box-opacity': 0.65,\n\t        'selection-box-border-color': '#aaa',\n\t        'selection-box-border-width': 1,\n\t        'active-bg-color': 'black',\n\t        'active-bg-opacity': 0.15,\n\t        'active-bg-size': 30,\n\t        'outside-texture-bg-color': '#000',\n\t        'outside-texture-bg-opacity': 0.125\n\t      } )\n\t  ;\n\t\n\t  this.defaultLength = this.length;\n\t};\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar styfn = {};\n\t\n\t// a caching layer for property parsing\n\tstyfn.parse = function( name, value, propIsBypass, propIsFlat ){\n\t  var self = this;\n\t\n\t  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n\t  if( is.fn( value ) ){\n\t    return self.parseImpl( name, value, propIsBypass, propIsFlat );\n\t  }\n\t\n\t  var argHash = [ name, value, propIsBypass, propIsFlat ].join( '$' );\n\t  var propCache = self.propCache = self.propCache || {};\n\t  var ret;\n\t\n\t  if( !(ret = propCache[ argHash ]) ){\n\t    ret = propCache[ argHash ] = self.parseImpl( name, value, propIsBypass, propIsFlat );\n\t  }\n\t\n\t  // always need a copy since props are mutated later in their lifecycles\n\t  ret = util.copy( ret );\n\t\n\t  if( ret ){\n\t    ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour\n\t  }\n\t\n\t  return ret;\n\t};\n\t\n\t// parse a property; return null on invalid; return parsed property otherwise\n\t// fields :\n\t// - name : the name of the property\n\t// - value : the parsed, native-typed value of the property\n\t// - strValue : a string value that represents the property value in valid css\n\t// - bypass : true iff the property is a bypass property\n\tvar parseImpl = function( name, value, propIsBypass, propIsFlat ){\n\t  var self = this;\n\t\n\t  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\t\n\t  var property = self.properties[ name ];\n\t  var passedValue = value;\n\t  var types = self.types;\n\t\n\t  if( !property ){ return null; } // return null on property of unknown name\n\t  if( value === undefined || value === null ){ return null; } // can't assign null\n\t\n\t  // the property may be an alias\n\t  if( property.alias ){\n\t    property = property.pointsTo;\n\t    name = property.name;\n\t  }\n\t\n\t  var valueIsString = is.string( value );\n\t  if( valueIsString ){ // trim the value to make parsing easier\n\t    value = value.trim();\n\t  }\n\t\n\t  var type = property.type;\n\t  if( !type ){ return null; } // no type, no luck\n\t\n\t  // check if bypass is null or empty string (i.e. indication to delete bypass property)\n\t  if( propIsBypass && (value === '' || value === null) ){\n\t    return {\n\t      name: name,\n\t      value: value,\n\t      bypass: true,\n\t      deleteBypass: true\n\t    };\n\t  }\n\t\n\t  // check if value is a function used as a mapper\n\t  if( is.fn( value ) ){\n\t    return {\n\t      name: name,\n\t      value: value,\n\t      strValue: 'fn',\n\t      mapped: types.fn,\n\t      bypass: propIsBypass\n\t    };\n\t  }\n\t\n\t  // check if value is mapped\n\t  var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;\n\t  if( !valueIsString || propIsFlat ){\n\t    // then don't bother to do the expensive regex checks\n\t\n\t  } else if(\n\t    ( data = new RegExp( types.data.regex ).exec( value ) ) ||\n\t    ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||\n\t    ( scratch = new RegExp( types.scratch.regex ).exec( value ) )\n\t  ){\n\t    if( propIsBypass ){ return false; } // mappers not allowed in bypass\n\t\n\t    var mapped;\n\t    if( data ){\n\t      mapped = types.data;\n\t    } else if( layoutData ){\n\t      mapped = types.layoutData;\n\t    } else {\n\t      mapped = types.scratch;\n\t    }\n\t\n\t    data = data || layoutData || scratch;\n\t\n\t    return {\n\t      name: name,\n\t      value: data,\n\t      strValue: '' + value,\n\t      mapped: mapped,\n\t      field: data[1],\n\t      bypass: propIsBypass\n\t    };\n\t\n\t  } else if(\n\t    ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||\n\t    ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||\n\t    ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )\n\t  ){\n\t    if( propIsBypass ){ return false; } // mappers not allowed in bypass\n\t    if( type.multiple ){ return false; } // impossible to map to num\n\t\n\t    var mapped;\n\t    if( mapData ){\n\t      mapped = types.mapData;\n\t    } else if( mapLayoutData ){\n\t      mapped = types.mapLayoutData;\n\t    } else {\n\t      mapped = types.mapScratch;\n\t    }\n\t\n\t    mapData = mapData || mapLayoutData || mapScratch;\n\t\n\t    // we can map only if the type is a colour or a number\n\t    if( !(type.color || type.number) ){ return false; }\n\t\n\t    var valueMin = this.parse( name, mapData[4] ); // parse to validate\n\t    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped\n\t\n\t    var valueMax = this.parse( name, mapData[5] ); // parse to validate\n\t    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped\n\t\n\t    // check if valueMin and valueMax are the same\n\t    if( valueMin.value === valueMax.value ){\n\t      return false; // can't make much of a mapper without a range\n\t\n\t    } else if( type.color ){\n\t      var c1 = valueMin.value;\n\t      var c2 = valueMax.value;\n\t\n\t      var same = c1[0] === c2[0] // red\n\t        && c1[1] === c2[1] // green\n\t        && c1[2] === c2[2] // blue\n\t        && ( // optional alpha\n\t          c1[3] === c2[3] // same alpha outright\n\t          || (\n\t            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?\n\t            &&\n\t            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n\t          )\n\t        )\n\t      ;\n\t\n\t      if( same ){ return false; } // can't make a mapper without a range\n\t    }\n\t\n\t    return {\n\t      name: name,\n\t      value: mapData,\n\t      strValue: '' + value,\n\t      mapped: mapped,\n\t      field: mapData[1],\n\t      fieldMin: parseFloat( mapData[2] ), // min & max are numeric\n\t      fieldMax: parseFloat( mapData[3] ),\n\t      valueMin: valueMin.value,\n\t      valueMax: valueMax.value,\n\t      bypass: propIsBypass\n\t    };\n\t  }\n\t\n\t  if( type.multiple && propIsFlat !== 'multiple' ){\n\t    var vals;\n\t\n\t    if( valueIsString ){\n\t      vals = value.split( /\\s+/ );\n\t    } else if( is.array( value ) ){\n\t      vals = value;\n\t    } else {\n\t      vals = [ value ];\n\t    }\n\t\n\t    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }\n\t\n\t    var valArr = vals.map( function( v ){\n\t      var p = self.parse( name, v, propIsBypass, 'multiple' );\n\t\n\t      if( p.pfValue != null ){\n\t        return p.pfValue;\n\t      } else {\n\t        return p.value;\n\t      }\n\t    } );\n\t\n\t    return {\n\t      name: name,\n\t      value: valArr,\n\t      pfValue: valArr,\n\t      strValue: valArr.join( ' ' ),\n\t      bypass: propIsBypass,\n\t      units: type.number && !type.unitless ? type.implicitUnits || 'px' : undefined\n\t    };\n\t  }\n\t\n\t  // several types also allow enums\n\t  var checkEnums = function(){\n\t    for( var i = 0; i < type.enums.length; i++ ){\n\t      var en = type.enums[ i ];\n\t\n\t      if( en === value ){\n\t        return {\n\t          name: name,\n\t          value: value,\n\t          strValue: '' + value,\n\t          bypass: propIsBypass\n\t        };\n\t      }\n\t    }\n\t\n\t    return null;\n\t  };\n\t\n\t  // check the type and return the appropriate object\n\t  if( type.number ){\n\t    var units;\n\t    var implicitUnits = 'px'; // not set => px\n\t\n\t    if( type.units ){ // use specified units if set\n\t      units = type.units;\n\t    }\n\t\n\t    if( type.implicitUnits ){\n\t      implicitUnits = type.implicitUnits;\n\t    }\n\t\n\t    if( !type.unitless ){\n\t      if( valueIsString ){\n\t        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n\t        if( units ){ unitsRegex = units; } // only allow explicit units if so set\n\t        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );\n\t\n\t        if( match ){\n\t          value = match[1];\n\t          units = match[2] || implicitUnits;\n\t        }\n\t\n\t      } else if( !units || type.implicitUnits ){\n\t        units = implicitUnits; // implicitly px if unspecified\n\t      }\n\t    }\n\t\n\t    value = parseFloat( value );\n\t\n\t    // if not a number and enums not allowed, then the value is invalid\n\t    if( isNaN( value ) && type.enums === undefined ){\n\t      return null;\n\t    }\n\t\n\t    // check if this number type also accepts special keywords in place of numbers\n\t    // (i.e. `left`, `auto`, etc)\n\t    if( isNaN( value ) && type.enums !== undefined ){\n\t      value = passedValue;\n\t\n\t      return checkEnums();\n\t    }\n\t\n\t    // check if value must be an integer\n\t    if( type.integer && !is.integer( value ) ){\n\t      return null;\n\t    }\n\t\n\t    // check value is within range\n\t    if( (type.min !== undefined && value < type.min)\n\t    || (type.max !== undefined && value > type.max)\n\t    ){\n\t      return null;\n\t    }\n\t\n\t    var ret = {\n\t      name: name,\n\t      value: value,\n\t      strValue: '' + value + (units ? units : ''),\n\t      units: units,\n\t      bypass: propIsBypass\n\t    };\n\t\n\t    // normalise value in pixels\n\t    if( type.unitless || (units !== 'px' && units !== 'em') ){\n\t      ret.pfValue = value;\n\t    } else {\n\t      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );\n\t    }\n\t\n\t    // normalise value in ms\n\t    if( units === 'ms' || units === 's' ){\n\t      ret.pfValue = units === 'ms' ? value : 1000 * value;\n\t    }\n\t\n\t    // normalise value in rad\n\t    if( units === 'deg' || units === 'rad' ){\n\t      ret.pfValue = units === 'rad' ? value : math.deg2rad( value );\n\t    }\n\t\n\t    return ret;\n\t\n\t  } else if( type.propList ){\n\t\n\t    var props = [];\n\t    var propsStr = '' + value;\n\t\n\t    if( propsStr === 'none' ){\n\t      // leave empty\n\t\n\t    } else { // go over each prop\n\t\n\t      var propsSplit = propsStr.split( ',' );\n\t      for( var i = 0; i < propsSplit.length; i++ ){\n\t        var propName = propsSplit[ i ].trim();\n\t\n\t        if( self.properties[ propName ] ){\n\t          props.push( propName );\n\t        }\n\t      }\n\t\n\t      if( props.length === 0 ){ return null; }\n\t    }\n\t\n\t    return {\n\t      name: name,\n\t      value: props,\n\t      strValue: props.length === 0 ? 'none' : props.join( ', ' ),\n\t      bypass: propIsBypass\n\t    };\n\t\n\t  } else if( type.color ){\n\t    var tuple = util.color2tuple( value );\n\t\n\t    if( !tuple ){ return null; }\n\t\n\t    return {\n\t      name: name,\n\t      value: tuple,\n\t      strValue: '' + value,\n\t      bypass: propIsBypass,\n\t      roundValue: true\n\t    };\n\t\n\t  } else if( type.regex || type.regexes ){\n\t\n\t    // first check enums\n\t    if( type.enums ){\n\t      var enumProp = checkEnums();\n\t\n\t      if( enumProp ){ return enumProp; }\n\t    }\n\t\n\t    var regexes = type.regexes ? type.regexes : [ type.regex ];\n\t\n\t    for( var i = 0; i < regexes.length; i++ ){\n\t      var regex = new RegExp( regexes[ i ] ); // make a regex from the type string\n\t      var m = regex.exec( value );\n\t\n\t      if( m ){ // regex matches\n\t        return {\n\t          name: name,\n\t          value: m,\n\t          strValue: '' + value,\n\t          bypass: propIsBypass\n\t        };\n\t\n\t      }\n\t    }\n\t\n\t    return null; // didn't match any\n\t\n\t  } else if( type.string ){\n\t    // just return\n\t    return {\n\t      name: name,\n\t      value: value,\n\t      strValue: '' + value,\n\t      bypass: propIsBypass\n\t    };\n\t\n\t  } else if( type.enums ){ // check enums last because it's a combo type in others\n\t    return checkEnums();\n\t\n\t  } else {\n\t    return null; // not a type we can handle\n\t  }\n\t\n\t};\n\tstyfn.parseImpl = parseImpl;\n\t\n\tmodule.exports = styfn;\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar corefn = ({\n\t\n\t  autolock: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.autolock = bool ? true : false;\n\t    } else {\n\t      return this._private.autolock;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  autoungrabify: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.autoungrabify = bool ? true : false;\n\t    } else {\n\t      return this._private.autoungrabify;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  autounselectify: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.autounselectify = bool ? true : false;\n\t    } else {\n\t      return this._private.autounselectify;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  panningEnabled: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.panningEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.panningEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  userPanningEnabled: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.userPanningEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.userPanningEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  zoomingEnabled: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.zoomingEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.zoomingEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  userZoomingEnabled: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.userZoomingEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.userZoomingEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  boxSelectionEnabled: function( bool ){\n\t    if( bool !== undefined ){\n\t      this._private.boxSelectionEnabled = bool ? true : false;\n\t    } else {\n\t      return this._private.boxSelectionEnabled;\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  pan: function(){\n\t    var args = arguments;\n\t    var pan = this._private.pan;\n\t    var dim, val, dims, x, y;\n\t\n\t    switch( args.length ){\n\t    case 0: // .pan()\n\t      return pan;\n\t\n\t    case 1:\n\t\n\t      if( is.string( args[0] ) ){ // .pan('x')\n\t        dim = args[0];\n\t        return pan[ dim ];\n\t\n\t      } else if( is.plainObject( args[0] ) ){ // .pan({ x: 0, y: 100 })\n\t        if( !this._private.panningEnabled ){\n\t          return this;\n\t        }\n\t\n\t        dims = args[0];\n\t        x = dims.x;\n\t        y = dims.y;\n\t\n\t        if( is.number( x ) ){\n\t          pan.x = x;\n\t        }\n\t\n\t        if( is.number( y ) ){\n\t          pan.y = y;\n\t        }\n\t\n\t        this.trigger( 'pan viewport' );\n\t      }\n\t      break;\n\t\n\t    case 2: // .pan('x', 100)\n\t      if( !this._private.panningEnabled ){\n\t        return this;\n\t      }\n\t\n\t      dim = args[0];\n\t      val = args[1];\n\t\n\t      if( (dim === 'x' || dim === 'y') && is.number( val ) ){\n\t        pan[ dim ] = val;\n\t      }\n\t\n\t      this.trigger( 'pan viewport' );\n\t      break;\n\t\n\t    default:\n\t      break; // invalid\n\t    }\n\t\n\t    this.notify( { // notify the renderer that the viewport changed\n\t      type: 'viewport'\n\t    } );\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  panBy: function( params ){\n\t    var args = arguments;\n\t    var pan = this._private.pan;\n\t    var dim, val, dims, x, y;\n\t\n\t    if( !this._private.panningEnabled ){\n\t      return this;\n\t    }\n\t\n\t    switch( args.length ){\n\t    case 1:\n\t\n\t      if( is.plainObject( args[0] ) ){ // .panBy({ x: 0, y: 100 })\n\t        dims = args[0];\n\t        x = dims.x;\n\t        y = dims.y;\n\t\n\t        if( is.number( x ) ){\n\t          pan.x += x;\n\t        }\n\t\n\t        if( is.number( y ) ){\n\t          pan.y += y;\n\t        }\n\t\n\t        this.trigger( 'pan viewport' );\n\t      }\n\t      break;\n\t\n\t    case 2: // .panBy('x', 100)\n\t      dim = args[0];\n\t      val = args[1];\n\t\n\t      if( (dim === 'x' || dim === 'y') && is.number( val ) ){\n\t        pan[ dim ] += val;\n\t      }\n\t\n\t      this.trigger( 'pan viewport' );\n\t      break;\n\t\n\t    default:\n\t      break; // invalid\n\t    }\n\t\n\t    this.notify( { // notify the renderer that the viewport changed\n\t      type: 'viewport'\n\t    } );\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  fit: function( elements, padding ){\n\t    var viewportState = this.getFitViewport( elements, padding );\n\t\n\t    if( viewportState ){\n\t      var _p = this._private;\n\t      _p.zoom = viewportState.zoom;\n\t      _p.pan = viewportState.pan;\n\t\n\t      this.trigger( 'pan zoom viewport' );\n\t\n\t      this.notify( { // notify the renderer that the viewport changed\n\t        type: 'viewport'\n\t      } );\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  getFitViewport: function( elements, padding ){\n\t    if( is.number( elements ) && padding === undefined ){ // elements is optional\n\t      padding = elements;\n\t      elements = undefined;\n\t    }\n\t\n\t    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n\t      return;\n\t    }\n\t\n\t    var bb;\n\t\n\t    if( is.string( elements ) ){\n\t      var sel = elements;\n\t      elements = this.$( sel );\n\t\n\t    } else if( is.boundingBox( elements ) ){ // assume bb\n\t      var bbe = elements;\n\t      bb = {\n\t        x1: bbe.x1,\n\t        y1: bbe.y1,\n\t        x2: bbe.x2,\n\t        y2: bbe.y2\n\t      };\n\t\n\t      bb.w = bb.x2 - bb.x1;\n\t      bb.h = bb.y2 - bb.y1;\n\t\n\t    } else if( !is.elementOrCollection( elements ) ){\n\t      elements = this.mutableElements();\n\t    }\n\t\n\t    bb = bb || elements.boundingBox();\n\t\n\t    var w = this.width();\n\t    var h = this.height();\n\t    var zoom;\n\t    padding = is.number( padding ) ? padding : 0;\n\t\n\t    if( !isNaN( w ) && !isNaN( h ) && w > 0 && h > 0 && !isNaN( bb.w ) && !isNaN( bb.h ) &&  bb.w > 0 && bb.h > 0 ){\n\t      zoom = Math.min( (w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h );\n\t\n\t      // crop zoom\n\t      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n\t      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\t\n\t      var pan = { // now pan to middle\n\t        x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,\n\t        y: (h - zoom * ( bb.y1 + bb.y2 )) / 2\n\t      };\n\t\n\t      return {\n\t        zoom: zoom,\n\t        pan: pan\n\t      };\n\t    }\n\t\n\t    return;\n\t  },\n\t\n\t  minZoom: function( zoom ){\n\t    if( zoom === undefined ){\n\t      return this._private.minZoom;\n\t    } else if( is.number( zoom ) ){\n\t      this._private.minZoom = zoom;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  maxZoom: function( zoom ){\n\t    if( zoom === undefined ){\n\t      return this._private.maxZoom;\n\t    } else if( is.number( zoom ) ){\n\t      this._private.maxZoom = zoom;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  zoom: function( params ){\n\t    var pos; // in rendered px\n\t    var zoom;\n\t\n\t    if( params === undefined ){ // then get the zoom\n\t      return this._private.zoom;\n\t\n\t    } else if( is.number( params ) ){ // then set the zoom\n\t      zoom = params;\n\t\n\t    } else if( is.plainObject( params ) ){ // then zoom about a point\n\t      zoom = params.level;\n\t\n\t      if( params.position ){\n\t        var p = params.position;\n\t        var pan = this._private.pan;\n\t        var z = this._private.zoom;\n\t\n\t        pos = { // convert to rendered px\n\t          x: p.x * z + pan.x,\n\t          y: p.y * z + pan.y\n\t        };\n\t      } else if( params.renderedPosition ){\n\t        pos = params.renderedPosition;\n\t      }\n\t\n\t      if( pos && !this._private.panningEnabled ){\n\t        return this; // panning disabled\n\t      }\n\t    }\n\t\n\t    if( !this._private.zoomingEnabled ){\n\t      return this; // zooming disabled\n\t    }\n\t\n\t    if( !is.number( zoom ) || ( pos && (!is.number( pos.x ) || !is.number( pos.y )) ) ){\n\t      return this; // can't zoom with invalid params\n\t    }\n\t\n\t    // crop zoom\n\t    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n\t    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\t\n\t    if( pos ){ // set zoom about position\n\t      var pan1 = this._private.pan;\n\t      var zoom1 = this._private.zoom;\n\t      var zoom2 = zoom;\n\t\n\t      var pan2 = {\n\t        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n\t        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n\t      };\n\t\n\t      this._private.zoom = zoom;\n\t      this._private.pan = pan2;\n\t\n\t      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;\n\t      this.trigger( ' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );\n\t\n\t    } else { // just set the zoom\n\t      this._private.zoom = zoom;\n\t      this.trigger( 'zoom viewport' );\n\t    }\n\t\n\t    this.notify( { // notify the renderer that the viewport changed\n\t      type: 'viewport'\n\t    } );\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  viewport: function( opts ){\n\t    var _p = this._private;\n\t    var zoomDefd = true;\n\t    var panDefd = true;\n\t    var events = []; // to trigger\n\t    var zoomFailed = false;\n\t    var panFailed = false;\n\t\n\t    if( !opts ){ return this; }\n\t    if( !is.number( opts.zoom ) ){ zoomDefd = false; }\n\t    if( !is.plainObject( opts.pan ) ){ panDefd = false; }\n\t    if( !zoomDefd && !panDefd ){ return this; }\n\t\n\t    if( zoomDefd ){\n\t      var z = opts.zoom;\n\t\n\t      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){\n\t        zoomFailed = true;\n\t\n\t      } else {\n\t        _p.zoom = z;\n\t\n\t        events.push( 'zoom' );\n\t      }\n\t    }\n\t\n\t    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){\n\t      var p = opts.pan;\n\t\n\t      if( is.number( p.x ) ){\n\t        _p.pan.x = p.x;\n\t        panFailed = false;\n\t      }\n\t\n\t      if( is.number( p.y ) ){\n\t        _p.pan.y = p.y;\n\t        panFailed = false;\n\t      }\n\t\n\t      if( !panFailed ){\n\t        events.push( 'pan' );\n\t      }\n\t    }\n\t\n\t    if( events.length > 0 ){\n\t      events.push( 'viewport' );\n\t      this.trigger( events.join( ' ' ) );\n\t\n\t      this.notify( {\n\t        type: 'viewport'\n\t      } );\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  center: function( elements ){\n\t    var pan = this.getCenterPan( elements );\n\t\n\t    if( pan ){\n\t      this._private.pan = pan;\n\t\n\t      this.trigger( 'pan viewport' );\n\t\n\t      this.notify( { // notify the renderer that the viewport changed\n\t        type: 'viewport'\n\t      } );\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  getCenterPan: function( elements, zoom ){\n\t    if( !this._private.panningEnabled ){\n\t      return;\n\t    }\n\t\n\t    if( is.string( elements ) ){\n\t      var selector = elements;\n\t      elements = this.mutableElements().filter( selector );\n\t    } else if( !is.elementOrCollection( elements ) ){\n\t      elements = this.mutableElements();\n\t    }\n\t\n\t    var bb = elements.boundingBox();\n\t    var w = this.width();\n\t    var h = this.height();\n\t    zoom = zoom === undefined ? this._private.zoom : zoom;\n\t\n\t    var pan = { // middle\n\t      x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,\n\t      y: (h - zoom * ( bb.y1 + bb.y2 )) / 2\n\t    };\n\t\n\t    return pan;\n\t  },\n\t\n\t  reset: function(){\n\t    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n\t      return this;\n\t    }\n\t\n\t    this.viewport( {\n\t      pan: { x: 0, y: 0 },\n\t      zoom: 1\n\t    } );\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  invalidateSize: function(){\n\t    this._private.sizeCache = null;\n\t  },\n\t\n\t  size: function(){\n\t    var _p = this._private;\n\t    var container = _p.container;\n\t\n\t    return ( _p.sizeCache = _p.sizeCache || ( container ? {\n\t      width: container.clientWidth,\n\t      height: container.clientHeight\n\t    } : { // fallback if no container (not 0 b/c can be used for dividing etc)\n\t      width: 1,\n\t      height: 1\n\t    } ) );\n\t  },\n\t\n\t  width: function(){\n\t    return this.size().width;\n\t  },\n\t\n\t  height: function(){\n\t    return this.size().height;\n\t  },\n\t\n\t  extent: function(){\n\t    var pan = this._private.pan;\n\t    var zoom = this._private.zoom;\n\t    var rb = this.renderedExtent();\n\t\n\t    var b = {\n\t      x1: ( rb.x1 - pan.x ) / zoom,\n\t      x2: ( rb.x2 - pan.x ) / zoom,\n\t      y1: ( rb.y1 - pan.y ) / zoom,\n\t      y2: ( rb.y2 - pan.y ) / zoom\n\t    };\n\t\n\t    b.w = b.x2 - b.x1;\n\t    b.h = b.y2 - b.y1;\n\t\n\t    return b;\n\t  },\n\t\n\t  renderedExtent: function(){\n\t    var width = this.width();\n\t    var height = this.height();\n\t\n\t    return {\n\t      x1: 0,\n\t      y1: 0,\n\t      x2: width,\n\t      y2: height,\n\t      w: width,\n\t      h: height\n\t    };\n\t  }\n\t});\n\t\n\t// aliases\n\tcorefn.centre = corefn.center;\n\t\n\t// backwards compatibility\n\tcorefn.autolockNodes = corefn.autolock;\n\tcorefn.autoungrabifyNodes = corefn.autoungrabify;\n\t\n\tmodule.exports = corefn;\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar define = __webpack_require__( 56 );\n\tvar Collection = __webpack_require__( 40 );\n\tvar Core = __webpack_require__( 31 );\n\tvar incExts = __webpack_require__( 97 );\n\tvar is = __webpack_require__( 30 );\n\t\n\t// registered extensions to cytoscape, indexed by name\n\tvar extensions = {};\n\t\n\t// registered modules for extensions, indexed by name\n\tvar modules = {};\n\t\n\tfunction setExtension( type, name, registrant ){\n\t\n\t  var ext = registrant;\n\t\n\t  var overrideErr = function( field ){\n\t    util.error( 'Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden' );\n\t  };\n\t\n\t  if( type === 'core' ){\n\t    if( Core.prototype[ name ] ){\n\t      return overrideErr( name );\n\t    } else {\n\t      Core.prototype[ name ] = registrant;\n\t    }\n\t\n\t  } else if( type === 'collection' ){\n\t    if( Collection.prototype[ name ] ){\n\t      return overrideErr( name );\n\t    } else {\n\t      Collection.prototype[ name ] = registrant;\n\t    }\n\t\n\t  } else if( type === 'layout' ){\n\t    // fill in missing layout functions in the prototype\n\t\n\t    var Layout = function( options ){\n\t      this.options = options;\n\t\n\t      registrant.call( this, options );\n\t\n\t      // make sure layout has _private for use w/ std apis like .on()\n\t      if( !is.plainObject( this._private ) ){\n\t        this._private = {};\n\t      }\n\t\n\t      this._private.cy = options.cy;\n\t      this._private.listeners = [];\n\t    };\n\t\n\t    var layoutProto = Layout.prototype = Object.create( registrant.prototype );\n\t\n\t    var optLayoutFns = [];\n\t\n\t    for( var i = 0; i < optLayoutFns.length; i++ ){\n\t      var fnName = optLayoutFns[ i ];\n\t\n\t      layoutProto[ fnName ] = layoutProto[ fnName ] || function(){ return this; };\n\t    }\n\t\n\t    // either .start() or .run() is defined, so autogen the other\n\t    if( layoutProto.start && !layoutProto.run ){\n\t      layoutProto.run = function(){ this.start(); return this; };\n\t    } else if( !layoutProto.start && layoutProto.run ){\n\t      layoutProto.start = function(){ this.run(); return this; };\n\t    }\n\t\n\t    if( !layoutProto.stop ){\n\t      layoutProto.stop = function(){\n\t        var opts = this.options;\n\t\n\t        if( opts && opts.animate ){\n\t          var anis = this.animations;\n\t          for( var i = 0; i < anis.length; i++ ){\n\t            anis[ i ].stop();\n\t          }\n\t        }\n\t\n\t        this.trigger( 'layoutstop' );\n\t\n\t        return this;\n\t      };\n\t    }\n\t\n\t    if( !layoutProto.destroy ){\n\t      layoutProto.destroy = function(){\n\t        return this;\n\t      };\n\t    }\n\t\n\t    layoutProto.on = define.on( { layout: true } );\n\t    layoutProto.one = define.on( { layout: true, unbindSelfOnTrigger: true } );\n\t    layoutProto.once = define.on( { layout: true, unbindAllBindersOnTrigger: true } );\n\t    layoutProto.off = define.off( { layout: true } );\n\t    layoutProto.trigger = define.trigger( { layout: true } );\n\t\n\t    define.eventAliasesOn( layoutProto );\n\t\n\t    ext = Layout; // replace with our wrapped layout\n\t\n\t  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){\n\t    // user registered renderers inherit from base\n\t\n\t    var BaseRenderer = getExtension( 'renderer', 'base' );\n\t    var bProto = BaseRenderer.prototype;\n\t    var RegistrantRenderer = registrant;\n\t    var rProto = registrant.prototype;\n\t\n\t    var Renderer = function(){\n\t      BaseRenderer.apply( this, arguments );\n\t      RegistrantRenderer.apply( this, arguments );\n\t    };\n\t\n\t    var proto = Renderer.prototype;\n\t\n\t    for( var pName in bProto ){\n\t      var pVal = bProto[ pName ];\n\t      var existsInR = rProto[ pName ] != null;\n\t\n\t      if( existsInR ){\n\t        return overrideErr( pName );\n\t      }\n\t\n\t      proto[ pName ] = pVal; // take impl from base\n\t    }\n\t\n\t    for( var pName in rProto ){\n\t      proto[ pName ] = rProto[ pName ]; // take impl from registrant\n\t    }\n\t\n\t    bProto.clientFunctions.forEach( function( name ){\n\t      proto[ name ] = proto[ name ] || function(){\n\t        util.error( 'Renderer does not implement `renderer.' + name + '()` on its prototype' );\n\t      };\n\t    } );\n\t\n\t    ext = Renderer;\n\t\n\t  }\n\t\n\t  return util.setMap( {\n\t    map: extensions,\n\t    keys: [ type, name ],\n\t    value: ext\n\t  } );\n\t}\n\t\n\tfunction getExtension( type, name ){\n\t  return util.getMap( {\n\t    map: extensions,\n\t    keys: [ type, name ]\n\t  } );\n\t}\n\t\n\tfunction setModule( type, name, moduleType, moduleName, registrant ){\n\t  return util.setMap( {\n\t    map: modules,\n\t    keys: [ type, name, moduleType, moduleName ],\n\t    value: registrant\n\t  } );\n\t}\n\t\n\tfunction getModule( type, name, moduleType, moduleName ){\n\t  return util.getMap( {\n\t    map: modules,\n\t    keys: [ type, name, moduleType, moduleName ]\n\t  } );\n\t}\n\t\n\tvar extension = function(){\n\t  // e.g. extension('renderer', 'svg')\n\t  if( arguments.length === 2 ){\n\t    return getExtension.apply( null, arguments );\n\t  }\n\t\n\t  // e.g. extension('renderer', 'svg', { ... })\n\t  else if( arguments.length === 3 ){\n\t    return setExtension.apply( null, arguments );\n\t  }\n\t\n\t  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n\t  else if( arguments.length === 4 ){\n\t    return getModule.apply( null, arguments );\n\t  }\n\t\n\t  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n\t  else if( arguments.length === 5 ){\n\t    return setModule.apply( null, arguments );\n\t  }\n\t\n\t  else {\n\t    util.error( 'Invalid extension access syntax' );\n\t  }\n\t\n\t};\n\t\n\t// allows a core instance to access extensions internally\n\tCore.prototype.extension = extension;\n\t\n\t// included extensions\n\tincExts.forEach( function( group ){\n\t  group.extensions.forEach( function( ext ){\n\t    setExtension( group.type, ext.name, ext.impl );\n\t  } );\n\t} );\n\t\n\tmodule.exports = extension;\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = [\n\t  {\n\t    type: 'layout',\n\t    extensions: __webpack_require__( 98 )\n\t  },\n\t\n\t  {\n\t    type: 'renderer',\n\t    extensions: __webpack_require__( 110 )\n\t  }\n\t];\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = [\n\t  { name: 'breadthfirst', impl: __webpack_require__( 99 ) },\n\t  { name: 'circle', impl: __webpack_require__( 100 ) },\n\t  { name: 'concentric',impl: __webpack_require__( 101 ) },\n\t  { name: 'cose', impl: __webpack_require__( 102 ) },\n\t  { name: 'grid', impl: __webpack_require__( 106 ) },\n\t  { name: 'null', impl: __webpack_require__( 107 ) },\n\t  { name: 'preset', impl: __webpack_require__( 108 ) },\n\t  { name: 'random', impl: __webpack_require__( 109 ) }\n\t];\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)\n\t  padding: 30, // padding on fit\n\t  circle: false, // put depths in concentric circles if true, put depths top down if false\n\t  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n\t  roots: undefined, // the roots of the trees\n\t  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined // callback on layoutstop\n\t};\n\t\n\tfunction BreadthFirstLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t}\n\t\n\tBreadthFirstLayout.prototype.run = function(){\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var cy = params.cy;\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not( ':parent' );\n\t  var graph = eles;\n\t\n\t  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  } );\n\t\n\t  var roots;\n\t  if( is.elementOrCollection( options.roots ) ){\n\t    roots = options.roots;\n\t  } else if( is.array( options.roots ) ){\n\t    var rootsArray = [];\n\t\n\t    for( var i = 0; i < options.roots.length; i++ ){\n\t      var id = options.roots[ i ];\n\t      var ele = cy.getElementById( id );\n\t      rootsArray.push( ele );\n\t    }\n\t\n\t    roots = cy.collection( rootsArray );\n\t  } else if( is.string( options.roots ) ){\n\t    roots = cy.$( options.roots );\n\t\n\t  } else {\n\t    if( options.directed ){\n\t      roots = nodes.roots();\n\t    } else {\n\t      var components = [];\n\t      var unhandledNodes = nodes;\n\t\n\t      while( unhandledNodes.length > 0 ){\n\t        var currComp = cy.collection();\n\t\n\t        eles.bfs( {\n\t          roots: unhandledNodes[0],\n\t          visit: function( i, depth, node, edge, pNode ){\n\t            currComp = currComp.add( node );\n\t          },\n\t          directed: false\n\t        } );\n\t\n\t        unhandledNodes = unhandledNodes.not( currComp );\n\t        components.push( currComp );\n\t      }\n\t\n\t      roots = cy.collection();\n\t      for( var i = 0; i < components.length; i++ ){\n\t        var comp = components[ i ];\n\t        var maxDegree = comp.maxDegree( false );\n\t        var compRoots = comp.filter( function(){\n\t          return this.degree( false ) === maxDegree;\n\t        } );\n\t\n\t        roots = roots.add( compRoots );\n\t      }\n\t\n\t    }\n\t  }\n\t\n\t\n\t  var depths = [];\n\t  var foundByBfs = {};\n\t  var id2depth = {};\n\t  var prevNode = {};\n\t  var prevEdge = {};\n\t  var successors = {};\n\t\n\t  // find the depths of the nodes\n\t  graph.bfs( {\n\t    roots: roots,\n\t    directed: options.directed,\n\t    visit: function( i, depth, node, edge, pNode ){\n\t      var ele = this[0];\n\t      var id = ele.id();\n\t\n\t      if( !depths[ depth ] ){\n\t        depths[ depth ] = [];\n\t      }\n\t\n\t      depths[ depth ].push( ele );\n\t      foundByBfs[ id ] = true;\n\t      id2depth[ id ] = depth;\n\t      prevNode[ id ] = pNode;\n\t      prevEdge[ id ] = edge;\n\t\n\t      if( pNode ){\n\t        var prevId = pNode.id();\n\t        var succ = successors[ prevId ] = successors[ prevId ] || [];\n\t\n\t        succ.push( node );\n\t      }\n\t    }\n\t  } );\n\t\n\t  // check for nodes not found by bfs\n\t  var orphanNodes = [];\n\t  for( var i = 0; i < nodes.length; i++ ){\n\t    var ele = nodes[ i ];\n\t\n\t    if( foundByBfs[ ele.id() ] ){\n\t      continue;\n\t    } else {\n\t      orphanNodes.push( ele );\n\t    }\n\t  }\n\t\n\t  // assign orphan nodes a depth from their neighborhood\n\t  var maxChecks = orphanNodes.length * 3;\n\t  var checks = 0;\n\t  while( orphanNodes.length !== 0 && checks < maxChecks ){\n\t    var node = orphanNodes.shift();\n\t    var neighbors = node.neighborhood().nodes();\n\t    var assignedDepth = false;\n\t\n\t    for( var i = 0; i < neighbors.length; i++ ){\n\t      var depth = id2depth[ neighbors[ i ].id() ];\n\t\n\t      if( depth !== undefined ){\n\t        depths[ depth ].push( node );\n\t        assignedDepth = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if( !assignedDepth ){\n\t      orphanNodes.push( node );\n\t    }\n\t\n\t    checks++;\n\t  }\n\t\n\t  // assign orphan nodes that are still left to the depth of their subgraph\n\t  while( orphanNodes.length !== 0 ){\n\t    var node = orphanNodes.shift();\n\t    //var subgraph = graph.bfs( node ).path;\n\t    var assignedDepth = false;\n\t\n\t    // for( var i = 0; i < subgraph.length; i++ ){\n\t    //   var depth = id2depth[ subgraph[i].id() ];\n\t\n\t    //   if( depth !== undefined ){\n\t    //     depths[depth].push( node );\n\t    //     assignedDepth = true;\n\t    //     break;\n\t    //   }\n\t    // }\n\t\n\t    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0\n\t      if( depths.length === 0 ){\n\t        depths.push( [] );\n\t      }\n\t\n\t      depths[0].push( node );\n\t    }\n\t  }\n\t\n\t  // assign the nodes a depth and index\n\t  var assignDepthsToEles = function(){\n\t    for( var i = 0; i < depths.length; i++ ){\n\t      var eles = depths[ i ];\n\t\n\t      for( var j = 0; j < eles.length; j++ ){\n\t        var ele = eles[ j ];\n\t\n\t        ele._private.scratch.breadthfirst = {\n\t          depth: i,\n\t          index: j\n\t        };\n\t      }\n\t    }\n\t  };\n\t  assignDepthsToEles();\n\t\n\t\n\t  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth\n\t    var edges = node.connectedEdges( function(){\n\t      return this.data( 'target' ) === node.id();\n\t    } );\n\t    var thisInfo = node._private.scratch.breadthfirst;\n\t    var highestDepthOfOther = 0;\n\t    var highestOther;\n\t    for( var i = 0; i < edges.length; i++ ){\n\t      var edge = edges[ i ];\n\t      var otherNode = edge.source()[0];\n\t      var otherInfo = otherNode._private.scratch.breadthfirst;\n\t\n\t      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){\n\t        highestDepthOfOther = otherInfo.depth;\n\t        highestOther = otherNode;\n\t      }\n\t    }\n\t\n\t    return highestOther;\n\t  };\n\t\n\t  // make maximal if so set by adjusting depths\n\t  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){\n\t\n\t    var nDepths = depths.length;\n\t    var elesToMove = [];\n\t    for( var i = 0; i < nDepths; i++ ){\n\t      var depth = depths[ i ];\n\t\n\t      var nDepth = depth.length;\n\t      for( var j = 0; j < nDepth; j++ ){\n\t        var ele = depth[ j ];\n\t        var info = ele._private.scratch.breadthfirst;\n\t        var intEle = intersectsDepth( ele );\n\t\n\t        if( intEle ){\n\t          info.intEle = intEle;\n\t          elesToMove.push( ele );\n\t        }\n\t      }\n\t    }\n\t\n\t    for( var i = 0; i < elesToMove.length; i++ ){\n\t      var ele = elesToMove[ i ];\n\t      var info = ele._private.scratch.breadthfirst;\n\t      var intEle = info.intEle;\n\t      var intInfo = intEle._private.scratch.breadthfirst;\n\t\n\t      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index\n\t\n\t      // add to end of new depth\n\t      var newDepth = intInfo.depth + 1;\n\t      while( newDepth > depths.length - 1 ){\n\t        depths.push( [] );\n\t      }\n\t      depths[ newDepth ].push( ele );\n\t\n\t      info.depth = newDepth;\n\t      info.index = depths[ newDepth ].length - 1;\n\t    }\n\t\n\t    assignDepthsToEles();\n\t  }\n\t\n\t  // find min distance we need to leave between nodes\n\t  var minDistance = 0;\n\t  if( options.avoidOverlap ){\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      var n = nodes[ i ];\n\t      var nbb = n.boundingBox();\n\t      var w = nbb.w;\n\t      var h = nbb.h;\n\t\n\t      minDistance = Math.max( minDistance, w, h );\n\t    }\n\t    minDistance *= options.spacingFactor; // just to have some nice spacing\n\t  }\n\t\n\t  // get the weighted percent for an element based on its connectivity to other levels\n\t  var cachedWeightedPercent = {};\n\t  var getWeightedPercent = function( ele ){\n\t    if( cachedWeightedPercent[ ele.id() ] ){\n\t      return cachedWeightedPercent[ ele.id() ];\n\t    }\n\t\n\t    var eleDepth = ele._private.scratch.breadthfirst.depth;\n\t    var neighbors = ele.neighborhood().nodes().not( ':parent' );\n\t    var percent = 0;\n\t    var samples = 0;\n\t\n\t    for( var i = 0; i < neighbors.length; i++ ){\n\t      var neighbor = neighbors[ i ];\n\t      var bf = neighbor._private.scratch.breadthfirst;\n\t      var index = bf.index;\n\t      var depth = bf.depth;\n\t      var nDepth = depths[ depth ].length;\n\t\n\t      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above\n\t        percent += index / nDepth;\n\t        samples++;\n\t      }\n\t    }\n\t\n\t    samples = Math.max( 1, samples );\n\t    percent = percent / samples;\n\t\n\t    if( samples === 0 ){ // so lone nodes have a \"don't care\" state in sorting\n\t      percent = undefined;\n\t    }\n\t\n\t    cachedWeightedPercent[ ele.id() ] = percent;\n\t    return percent;\n\t  };\n\t\n\t\n\t  // rearrange the indices in each depth level based on connectivity\n\t\n\t  var sortFn = function( a, b ){\n\t    var apct = getWeightedPercent( a );\n\t    var bpct = getWeightedPercent( b );\n\t\n\t    return apct - bpct;\n\t  };\n\t\n\t  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result\n\t\n\t    for( var i = 0; i < depths.length; i++ ){\n\t      depths[ i ] = depths[ i ].sort( sortFn );\n\t    }\n\t    assignDepthsToEles(); // and update\n\t\n\t  }\n\t\n\t  var biggestDepthSize = 0;\n\t  for( var i = 0; i < depths.length; i++ ){\n\t    biggestDepthSize = Math.max( depths[ i ].length, biggestDepthSize );\n\t  }\n\t\n\t  var center = {\n\t    x: bb.x1 + bb.w / 2,\n\t    y: bb.x1 + bb.h / 2\n\t  };\n\t\n\t  var getPosition = function( ele, isBottomDepth ){\n\t    var info = ele._private.scratch.breadthfirst;\n\t    var depth = info.depth;\n\t    var index = info.index;\n\t    var depthSize = depths[ depth ].length;\n\t\n\t    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );\n\t    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );\n\t    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );\n\t    radiusStepSize = Math.max( radiusStepSize, minDistance );\n\t\n\t    if( !options.circle ){\n\t\n\t      var epos = {\n\t        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n\t        y: (depth + 1) * distanceY\n\t      };\n\t\n\t      if( isBottomDepth ){\n\t        return epos;\n\t      }\n\t\n\t      // var succs = successors[ ele.id() ];\n\t      // if( succs ){\n\t      //   epos.x = 0;\n\t      //\n\t      //   for( var i = 0 ; i < succs.length; i++ ){\n\t      //     var spos = pos[ succs[i].id() ];\n\t      //\n\t      //     epos.x += spos.x;\n\t      //   }\n\t      //\n\t      //   epos.x /= succs.length;\n\t      // } else {\n\t      //   //debugger;\n\t      // }\n\t\n\t      return epos;\n\t\n\t    } else {\n\t      if( options.circle ){\n\t        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n\t        var theta = 2 * Math.PI / depths[ depth ].length * index;\n\t\n\t        if( depth === 0 && depths[0].length === 1 ){\n\t          radius = 1;\n\t        }\n\t\n\t        return {\n\t          x: center.x + radius * Math.cos( theta ),\n\t          y: center.y + radius * Math.sin( theta )\n\t        };\n\t\n\t      } else {\n\t        return {\n\t          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n\t          y: (depth + 1) * distanceY\n\t        };\n\t      }\n\t    }\n\t\n\t  };\n\t\n\t  // get positions in reverse depth order\n\t  var pos = {};\n\t  for( var i = depths.length - 1; i >= 0; i-- ){\n\t    var depth = depths[ i ];\n\t\n\t    for( var j = 0; j < depth.length; j++ ){\n\t      var node = depth[ j ];\n\t\n\t      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );\n\t    }\n\t  }\n\t\n\t  nodes.layoutPositions( this, options, function(){\n\t    return pos[ this.id() ];\n\t  } );\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = BreadthFirstLayout;\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  padding: 30, // the padding on fit\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space\n\t  radius: undefined, // the radius of the circle\n\t  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n\t  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n\t  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n\t  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined // callback on layoutstop\n\t};\n\t\n\tfunction CircleLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t}\n\t\n\tCircleLayout.prototype.run = function(){\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var cy = params.cy;\n\t  var eles = options.eles;\n\t\n\t  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\t\n\t  var nodes = eles.nodes().not( ':parent' );\n\t\n\t  if( options.sort ){\n\t    nodes = nodes.sort( options.sort );\n\t  }\n\t\n\t  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  } );\n\t\n\t  var center = {\n\t    x: bb.x1 + bb.w / 2,\n\t    y: bb.y1 + bb.h / 2\n\t  };\n\t\n\t  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n\t\n\t  var dTheta = sweep / ( Math.max( 1, nodes.length - 1 ) );\n\t  var r;\n\t\n\t  var minDistance = 0;\n\t  for( var i = 0; i < nodes.length; i++ ){\n\t    var n = nodes[ i ];\n\t    var nbb = n.boundingBox();\n\t    var w = nbb.w;\n\t    var h = nbb.h;\n\t\n\t    minDistance = Math.max( minDistance, w, h );\n\t  }\n\t\n\t  if( is.number( options.radius ) ){\n\t    r = options.radius;\n\t  } else if( nodes.length <= 1 ){\n\t    r = 0;\n\t  } else {\n\t    r = Math.min( bb.h, bb.w ) / 2 - minDistance;\n\t  }\n\t\n\t  // calculate the radius\n\t  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n\t    minDistance *= 1.75; // just to have some nice spacing\n\t\n\t    var dcos = Math.cos( dTheta ) - Math.cos( 0 );\n\t    var dsin = Math.sin( dTheta ) - Math.sin( 0 );\n\t    var rMin = Math.sqrt( minDistance * minDistance / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping\n\t    r = Math.max( rMin, r );\n\t  }\n\t\n\t  var getPos = function( i, ele ){\n\t    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );\n\t\n\t    var rx = r * Math.cos( theta );\n\t    var ry = r * Math.sin( theta );\n\t    var pos = {\n\t      x: center.x + rx,\n\t      y: center.y + ry\n\t    };\n\t\n\t    return pos;\n\t  };\n\t\n\t  nodes.layoutPositions( this, options, getPos );\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = CircleLayout;\n\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  padding: 30, // the padding on fit\n\t  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n\t  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n\t  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n\t  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n\t  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n\t  height: undefined, // height of layout area (overrides container height)\n\t  width: undefined, // width of layout area (overrides container width)\n\t  concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre\n\t    return node.degree();\n\t  },\n\t  levelWidth: function( nodes ){ // the variation of concentric values in each level\n\t    return nodes.maxDegree() / 4;\n\t  },\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined // callback on layoutstop\n\t};\n\t\n\tfunction ConcentricLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t}\n\t\n\tConcentricLayout.prototype.run = function(){\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\t\n\t  var cy = params.cy;\n\t\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not( ':parent' );\n\t\n\t  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  } );\n\t\n\t  var center = {\n\t    x: bb.x1 + bb.w / 2,\n\t    y: bb.y1 + bb.h / 2\n\t  };\n\t\n\t  var nodeValues = []; // { node, value }\n\t  var theta = options.startAngle;\n\t  var maxNodeSize = 0;\n\t\n\t  for( var i = 0; i < nodes.length; i++ ){\n\t    var node = nodes[ i ];\n\t    var value;\n\t\n\t    // calculate the node value\n\t    value = options.concentric.apply( node, [ node ] );\n\t    nodeValues.push( {\n\t      value: value,\n\t      node: node\n\t    } );\n\t\n\t    // for style mapping\n\t    node._private.scratch.concentric = value;\n\t  }\n\t\n\t  // in case we used the `concentric` in style\n\t  nodes.updateStyle();\n\t\n\t  // calculate max size now based on potentially updated mappers\n\t  for( var i = 0; i < nodes.length; i++ ){\n\t    var node = nodes[ i ];\n\t    var nbb = node.boundingBox();\n\t\n\t    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );\n\t  }\n\t\n\t  // sort node values in descreasing order\n\t  nodeValues.sort( function( a, b ){\n\t    return b.value - a.value;\n\t  } );\n\t\n\t  var levelWidth = options.levelWidth( nodes );\n\t\n\t  // put the values into levels\n\t  var levels = [ [] ];\n\t  var currentLevel = levels[0];\n\t  for( var i = 0; i < nodeValues.length; i++ ){\n\t    var val = nodeValues[ i ];\n\t\n\t    if( currentLevel.length > 0 ){\n\t      var diff = Math.abs( currentLevel[0].value - val.value );\n\t\n\t      if( diff >= levelWidth ){\n\t        currentLevel = [];\n\t        levels.push( currentLevel );\n\t      }\n\t    }\n\t\n\t    currentLevel.push( val );\n\t  }\n\t\n\t  // create positions from levels\n\t\n\t  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\t\n\t  if( !options.avoidOverlap ){ // then strictly constrain to bb\n\t    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n\t    var maxR = ( Math.min( bb.w, bb.h ) / 2 - minDist );\n\t    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );\n\t\n\t    minDist = Math.min( minDist, rStep );\n\t  }\n\t\n\t  // find the metrics for each level\n\t  var r = 0;\n\t  for( var i = 0; i < levels.length; i++ ){\n\t    var level = levels[ i ];\n\t    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n\t    var dTheta = level.dTheta = sweep / ( Math.max( 1, level.length - 1 ) );\n\t\n\t    // calculate the radius\n\t    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n\t      var dcos = Math.cos( dTheta ) - Math.cos( 0 );\n\t      var dsin = Math.sin( dTheta ) - Math.sin( 0 );\n\t      var rMin = Math.sqrt( minDist * minDist / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping\n\t\n\t      r = Math.max( rMin, r );\n\t    }\n\t\n\t    level.r = r;\n\t\n\t    r += minDist;\n\t  }\n\t\n\t  if( options.equidistant ){\n\t    var rDeltaMax = 0;\n\t    var r = 0;\n\t\n\t    for( var i = 0; i < levels.length; i++ ){\n\t      var level = levels[ i ];\n\t      var rDelta = level.r - r;\n\t\n\t      rDeltaMax = Math.max( rDeltaMax, rDelta );\n\t    }\n\t\n\t    r = 0;\n\t    for( var i = 0; i < levels.length; i++ ){\n\t      var level = levels[ i ];\n\t\n\t      if( i === 0 ){\n\t        r = level.r;\n\t      }\n\t\n\t      level.r = r;\n\t\n\t      r += rDeltaMax;\n\t    }\n\t  }\n\t\n\t  // calculate the node positions\n\t  var pos = {}; // id => position\n\t  for( var i = 0; i < levels.length; i++ ){\n\t    var level = levels[ i ];\n\t    var dTheta = level.dTheta;\n\t    var r = level.r;\n\t\n\t    for( var j = 0; j < level.length; j++ ){\n\t      var val = level[ j ];\n\t      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;\n\t\n\t      var p = {\n\t        x: center.x + r * Math.cos( theta ),\n\t        y: center.y + r * Math.sin( theta )\n\t      };\n\t\n\t      pos[ val.node.id() ] = p;\n\t    }\n\t  }\n\t\n\t  // position the nodes\n\t  nodes.layoutPositions( this, options, function(){\n\t    var id = this.id();\n\t\n\t    return pos[ id ];\n\t  } );\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = ConcentricLayout;\n\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\tThe CoSE layout was written by Gerardo Huck.\n\thttps://www.linkedin.com/in/gerardohuck/\n\t\n\tBased on the following article:\n\thttp://dl.acm.org/citation.cfm?id=1498047\n\t\n\tModifications tracked on Github.\n\t*/\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\tvar Thread = __webpack_require__( 103 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar DEBUG;\n\t\n\t/**\n\t * @brief :  default layout options\n\t */\n\tvar defaults = {\n\t  // Called on `layoutready`\n\t  ready: function(){},\n\t\n\t  // Called on `layoutstop`\n\t  stop: function(){},\n\t\n\t  // Whether to animate while running the layout\n\t  animate: true,\n\t\n\t  // The layout animates only after this many milliseconds\n\t  // (prevents flashing on fast runs)\n\t  animationThreshold: 250,\n\t\n\t  // Number of iterations between consecutive screen positions update\n\t  // (0 -> only updated on the end)\n\t  refresh: 20,\n\t\n\t  // Whether to fit the network view after when done\n\t  fit: true,\n\t\n\t  // Padding on fit\n\t  padding: 30,\n\t\n\t  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  boundingBox: undefined,\n\t\n\t  // Extra spacing between components in non-compound graphs\n\t  componentSpacing: 100,\n\t\n\t  // Node repulsion (non overlapping) multiplier\n\t  nodeRepulsion: function( node ){ return 400000; },\n\t\n\t  // Node repulsion (overlapping) multiplier\n\t  nodeOverlap: 10,\n\t\n\t  // Ideal edge (non nested) length\n\t  idealEdgeLength: function( edge ){ return 10; },\n\t\n\t  // Divisor to compute edge forces\n\t  edgeElasticity: function( edge ){ return 100; },\n\t\n\t  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n\t  nestingFactor: 5,\n\t\n\t  // Gravity force (constant)\n\t  gravity: 80,\n\t\n\t  // Maximum number of iterations to perform\n\t  numIter: 1000,\n\t\n\t  // Initial temperature (maximum node displacement)\n\t  initialTemp: 200,\n\t\n\t  // Cooling factor (how the temperature is reduced between consecutive iterations\n\t  coolingFactor: 0.95,\n\t\n\t  // Lower temperature threshold (below this point the layout will end)\n\t  minTemp: 1.0,\n\t\n\t  // Whether to use threading to speed up the layout\n\t  useMultitasking: true\n\t};\n\t\n\t\n\t/**\n\t * @brief       : constructor\n\t * @arg options : object containing layout options\n\t */\n\tfunction CoseLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t\n\t  this.options.layout = this;\n\t}\n\t\n\t\n\t/**\n\t * @brief : runs the layout\n\t */\n\tCoseLayout.prototype.run = function(){\n\t  var options = this.options;\n\t  var cy      = options.cy;\n\t  var layout  = this;\n\t  var thread  = this.thread;\n\t\n\t  if( !thread || thread.stopped() ){\n\t    thread = this.thread = Thread( { disabled: !options.useMultitasking } );\n\t  }\n\t\n\t  layout.stopped = false;\n\t\n\t  layout.trigger( { type: 'layoutstart', layout: layout } );\n\t\n\t  // Set DEBUG - Global variable\n\t  if( true === options.debug ){\n\t    DEBUG = true;\n\t  } else {\n\t    DEBUG = false;\n\t  }\n\t\n\t  // Initialize layout info\n\t  var layoutInfo = createLayoutInfo( cy, layout, options );\n\t\n\t  // Show LayoutInfo contents if debugging\n\t  if( DEBUG ){\n\t    printLayoutInfo( layoutInfo );\n\t  }\n\t\n\t  // If required, randomize node positions\n\t  // if (true === options.randomize) {\n\t  randomizePositions( layoutInfo, cy );\n\t  // }\n\t\n\t  var startTime = Date.now();\n\t  var refreshRequested = false;\n\t  var refresh = function( rOpts ){\n\t    rOpts = rOpts || {};\n\t\n\t    if( refreshRequested && !rOpts.next ){\n\t      return;\n\t    }\n\t\n\t    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){\n\t      return;\n\t    }\n\t\n\t    refreshRequested = true;\n\t\n\t    util.requestAnimationFrame( function(){\n\t      refreshPositions( layoutInfo, cy, options );\n\t\n\t      // Fit the graph if necessary\n\t      if( true === options.fit ){\n\t        cy.fit( options.padding );\n\t      }\n\t\n\t      refreshRequested = false;\n\t\n\t      if( rOpts.next ){ rOpts.next(); }\n\t    });\n\t  };\n\t\n\t  thread.on( 'message', function( e ){\n\t    var layoutNodes = e.message;\n\t\n\t    layoutInfo.layoutNodes = layoutNodes;\n\t    refresh();\n\t  } );\n\t\n\t  thread.pass( {\n\t    layoutInfo: layoutInfo,\n\t    options: {\n\t      animate: options.animate,\n\t      refresh: options.refresh,\n\t      componentSpacing: options.componentSpacing,\n\t      nodeOverlap: options.nodeOverlap,\n\t      nestingFactor: options.nestingFactor,\n\t      gravity: options.gravity,\n\t      numIter: options.numIter,\n\t      initialTemp: options.initialTemp,\n\t      coolingFactor: options.coolingFactor,\n\t      minTemp: options.minTemp\n\t    }\n\t  } ).run( function( pass ){\n\t    var layoutInfo = pass.layoutInfo;\n\t    var options = pass.options;\n\t    var stopped = false;\n\t\n\t    /**\n\t     * @brief          : Performs one iteration of the physical simulation\n\t     * @arg layoutInfo : LayoutInfo object already initialized\n\t     * @arg cy         : Cytoscape object\n\t     * @arg options    : Layout options\n\t     */\n\t    var step = function( layoutInfo, options, step ){\n\t      // var s = \"\\n\\n###############################\";\n\t      // s += \"\\nSTEP: \" + step;\n\t      // s += \"\\n###############################\\n\";\n\t      // logDebug(s);\n\t\n\t      // Calculate node repulsions\n\t      calculateNodeForces( layoutInfo, options );\n\t      // Calculate edge forces\n\t      calculateEdgeForces( layoutInfo, options );\n\t      // Calculate gravity forces\n\t      calculateGravityForces( layoutInfo, options );\n\t      // Propagate forces from parent to child\n\t      propagateForces( layoutInfo, options );\n\t      // Update positions based on calculated forces\n\t      updatePositions( layoutInfo, options );\n\t    };\n\t\n\t    /**\n\t     * @brief : Computes the node repulsion forces\n\t     */\n\t    var calculateNodeForces = function( layoutInfo, options ){\n\t      // Go through each of the graphs in graphSet\n\t      // Nodes only repel each other if they belong to the same graph\n\t      // var s = 'calculateNodeForces';\n\t      // logDebug(s);\n\t      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){\n\t        var graph    = layoutInfo.graphSet[ i ];\n\t        var numNodes = graph.length;\n\t\n\t        // s = \"Set: \" + graph.toString();\n\t        // logDebug(s);\n\t\n\t        // Now get all the pairs of nodes\n\t        // Only get each pair once, (A, B) = (B, A)\n\t        for( var j = 0; j < numNodes; j++ ){\n\t          var node1 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];\n\t\n\t          for( var k = j + 1; k < numNodes; k++ ){\n\t            var node2 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ k ] ] ];\n\t\n\t            nodeRepulsion( node1, node2, layoutInfo, options );\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Compute the node repulsion forces between a pair of nodes\n\t     */\n\t    var nodeRepulsion = function( node1, node2, layoutInfo, options ){\n\t      // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n\t\n\t      var cmptId1 = node1.cmptId;\n\t      var cmptId2 = node2.cmptId;\n\t\n\t      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }\n\t\n\t      // Get direction of line connecting both node centers\n\t      var directionX = node2.positionX - node1.positionX;\n\t      var directionY = node2.positionY - node1.positionY;\n\t      // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n\t\n\t      // If both centers are the same, apply a random force\n\t      if( 0 === directionX && 0 === directionY ){\n\t        // s += \"\\nNodes have the same position.\";\n\t        return; // TODO could be improved with random force\n\t      }\n\t\n\t      var overlap = nodesOverlap( node1, node2, directionX, directionY );\n\t\n\t      if( overlap > 0 ){\n\t        // s += \"\\nNodes DO overlap.\";\n\t        // s += \"\\nOverlap: \" + overlap;\n\t        // If nodes overlap, repulsion force is proportional\n\t        // to the overlap\n\t        var force    = options.nodeOverlap * overlap;\n\t\n\t        // Compute the module and components of the force vector\n\t        var distance = Math.sqrt( directionX * directionX + directionY * directionY );\n\t        // s += \"\\nDistance: \" + distance;\n\t        var forceX   = force * directionX / distance;\n\t        var forceY   = force * directionY / distance;\n\t\n\t      } else {\n\t        // s += \"\\nNodes do NOT overlap.\";\n\t        // If there's no overlap, force is inversely proportional\n\t        // to squared distance\n\t\n\t        // Get clipping points for both nodes\n\t        var point1 = findClippingPoint( node1, directionX, directionY );\n\t        var point2 = findClippingPoint( node2, -1 * directionX, -1 * directionY );\n\t\n\t        // Use clipping points to compute distance\n\t        var distanceX   = point2.x - point1.x;\n\t        var distanceY   = point2.y - point1.y;\n\t        var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n\t        var distance    = Math.sqrt( distanceSqr );\n\t        // s += \"\\nDistance: \" + distance;\n\t\n\t        // Compute the module and components of the force vector\n\t        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;\n\t        var forceX = force * distanceX / distance;\n\t        var forceY = force * distanceY / distance;\n\t      }\n\t\n\t      // Apply force\n\t      if( !node1.isLocked ){\n\t        node1.offsetX -= forceX;\n\t        node1.offsetY -= forceY;\n\t      }\n\t\n\t      if( !node2.isLocked ){\n\t        node2.offsetX += forceX;\n\t        node2.offsetY += forceY;\n\t      }\n\t\n\t      // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n\t      // logDebug(s);\n\t\n\t      return;\n\t    };\n\t\n\t    /**\n\t     * @brief  : Determines whether two nodes overlap or not\n\t     * @return : Amount of overlapping (0 => no overlap)\n\t     */\n\t    var nodesOverlap = function( node1, node2, dX, dY ){\n\t\n\t      if( dX > 0 ){\n\t        var overlapX = node1.maxX - node2.minX;\n\t      } else {\n\t        var overlapX = node2.maxX - node1.minX;\n\t      }\n\t\n\t      if( dY > 0 ){\n\t        var overlapY = node1.maxY - node2.minY;\n\t      } else {\n\t        var overlapY = node2.maxY - node1.minY;\n\t      }\n\t\n\t      if( overlapX >= 0 && overlapY >= 0 ){\n\t        return Math.sqrt( overlapX * overlapX + overlapY * overlapY );\n\t      } else {\n\t        return 0;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Finds the point in which an edge (direction dX, dY) intersects\n\t     *          the rectangular bounding box of it's source/target node\n\t     */\n\t    var findClippingPoint = function( node, dX, dY ){\n\t\n\t      // Shorcuts\n\t      var X = node.positionX;\n\t      var Y = node.positionY;\n\t      var H = node.height || 1;\n\t      var W = node.width || 1;\n\t      var dirSlope     = dY / dX;\n\t      var nodeSlope    = H / W;\n\t\n\t      // var s = 'Computing clipping point of node ' + node.id +\n\t      //   \" . Height:  \" + H + \", Width: \" + W +\n\t      //   \"\\nDirection \" + dX + \", \" + dY;\n\t      //\n\t      // Compute intersection\n\t      var res = {};\n\t      do {\n\t        // Case: Vertical direction (up)\n\t        if( 0 === dX && 0 < dY ){\n\t          res.x = X;\n\t          // s += \"\\nUp direction\";\n\t          res.y = Y + H / 2;\n\t          break;\n\t        }\n\t\n\t        // Case: Vertical direction (down)\n\t        if( 0 === dX && 0 > dY ){\n\t          res.x = X;\n\t          res.y = Y + H / 2;\n\t          // s += \"\\nDown direction\";\n\t          break;\n\t        }\n\t\n\t        // Case: Intersects the right border\n\t        if( 0 < dX &&\n\t        -1 * nodeSlope <= dirSlope &&\n\t        dirSlope <= nodeSlope ){\n\t          res.x = X + W / 2;\n\t          res.y = Y + (W * dY / 2 / dX);\n\t          // s += \"\\nRightborder\";\n\t          break;\n\t        }\n\t\n\t        // Case: Intersects the left border\n\t        if( 0 > dX &&\n\t        -1 * nodeSlope <= dirSlope &&\n\t        dirSlope <= nodeSlope ){\n\t          res.x = X - W / 2;\n\t          res.y = Y - (W * dY / 2 / dX);\n\t          // s += \"\\nLeftborder\";\n\t          break;\n\t        }\n\t\n\t        // Case: Intersects the top border\n\t        if( 0 < dY &&\n\t        ( dirSlope <= -1 * nodeSlope ||\n\t          dirSlope >= nodeSlope ) ){\n\t          res.x = X + (H * dX / 2 / dY);\n\t          res.y = Y + H / 2;\n\t          // s += \"\\nTop border\";\n\t          break;\n\t        }\n\t\n\t        // Case: Intersects the bottom border\n\t        if( 0 > dY &&\n\t        ( dirSlope <= -1 * nodeSlope ||\n\t          dirSlope >= nodeSlope ) ){\n\t          res.x = X - (H * dX / 2 / dY);\n\t          res.y = Y - H / 2;\n\t          // s += \"\\nBottom border\";\n\t          break;\n\t        }\n\t\n\t      } while( false);\n\t\n\t      // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n\t      // logDebug(s);\n\t      return res;\n\t    };\n\t\n\t    /**\n\t     * @brief : Calculates all edge forces\n\t     */\n\t    var calculateEdgeForces = function( layoutInfo, options ){\n\t      // Iterate over all edges\n\t      for( var i = 0; i < layoutInfo.edgeSize; i++ ){\n\t        // Get edge, source & target nodes\n\t        var edge     = layoutInfo.layoutEdges[ i ];\n\t        var sourceIx = layoutInfo.idToIndex[ edge.sourceId ];\n\t        var source   = layoutInfo.layoutNodes[ sourceIx ];\n\t        var targetIx = layoutInfo.idToIndex[ edge.targetId ];\n\t        var target   = layoutInfo.layoutNodes[ targetIx ];\n\t\n\t        // Get direction of line connecting both node centers\n\t        var directionX = target.positionX - source.positionX;\n\t        var directionY = target.positionY - source.positionY;\n\t\n\t        // If both centers are the same, do nothing.\n\t        // A random force has already been applied as node repulsion\n\t        if( 0 === directionX && 0 === directionY ){\n\t          return;\n\t        }\n\t\n\t        // Get clipping points for both nodes\n\t        var point1 = findClippingPoint( source, directionX, directionY );\n\t        var point2 = findClippingPoint( target, -1 * directionX, -1 * directionY );\n\t\n\t\n\t        var lx = point2.x - point1.x;\n\t        var ly = point2.y - point1.y;\n\t        var l  = Math.sqrt( lx * lx + ly * ly );\n\t\n\t        var force  = Math.pow( edge.idealLength - l, 2 ) / edge.elasticity;\n\t\n\t        if( 0 !== l ){\n\t          var forceX = force * lx / l;\n\t          var forceY = force * ly / l;\n\t        } else {\n\t          var forceX = 0;\n\t          var forceY = 0;\n\t        }\n\t\n\t        // Add this force to target and source nodes\n\t        if( !source.isLocked ){\n\t          source.offsetX += forceX;\n\t          source.offsetY += forceY;\n\t        }\n\t\n\t        if( !target.isLocked ){\n\t          target.offsetX -= forceX;\n\t          target.offsetY -= forceY;\n\t        }\n\t\n\t        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n\t        // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n\t        // logDebug(s);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Computes gravity forces for all nodes\n\t     */\n\t    var calculateGravityForces = function( layoutInfo, options ){\n\t      var distThreshold = 1;\n\t\n\t      // var s = 'calculateGravityForces';\n\t      // logDebug(s);\n\t      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){\n\t        var graph    = layoutInfo.graphSet[ i ];\n\t        var numNodes = graph.length;\n\t\n\t        // s = \"Set: \" + graph.toString();\n\t        // logDebug(s);\n\t\n\t        // Compute graph center\n\t        if( 0 === i ){\n\t          var centerX   = layoutInfo.clientHeight / 2;\n\t          var centerY   = layoutInfo.clientWidth  / 2;\n\t        } else {\n\t          // Get Parent node for this graph, and use its position as center\n\t          var temp    = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[0] ] ];\n\t          var parent  = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ temp.parentId ] ];\n\t          var centerX = parent.positionX;\n\t          var centerY = parent.positionY;\n\t        }\n\t        // s = \"Center found at: \" + centerX + \", \" + centerY;\n\t        // logDebug(s);\n\t\n\t        // Apply force to all nodes in graph\n\t        for( var j = 0; j < numNodes; j++ ){\n\t          var node = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];\n\t          // s = \"Node: \" + node.id;\n\t\n\t          if( node.isLocked ){ continue; }\n\t\n\t          var dx = centerX - node.positionX;\n\t          var dy = centerY - node.positionY;\n\t          var d  = Math.sqrt( dx * dx + dy * dy );\n\t          if( d > distThreshold ){\n\t            var fx = options.gravity * dx / d;\n\t            var fy = options.gravity * dy / d;\n\t            node.offsetX += fx;\n\t            node.offsetY += fy;\n\t            // s += \": Applied force: \" + fx + \", \" + fy;\n\t          } else {\n\t            // s += \": skypped since it's too close to center\";\n\t          }\n\t          // logDebug(s);\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief          : This function propagates the existing offsets from\n\t     *                   parent nodes to its descendents.\n\t     * @arg layoutInfo : layoutInfo Object\n\t     * @arg cy         : cytoscape Object\n\t     * @arg options    : Layout options\n\t     */\n\t    var propagateForces = function( layoutInfo, options ){\n\t      // Inline implementation of a queue, used for traversing the graph in BFS order\n\t      var queue = [];\n\t      var start = 0;   // Points to the start the queue\n\t      var end   = -1;  // Points to the end of the queue\n\t\n\t      // logDebug('propagateForces');\n\t\n\t      // Start by visiting the nodes in the root graph\n\t      queue.push.apply( queue, layoutInfo.graphSet[0] );\n\t      end += layoutInfo.graphSet[0].length;\n\t\n\t      // Traverse the graph, level by level,\n\t      while( start <= end ){\n\t        // Get the node to visit and remove it from queue\n\t        var nodeId    = queue[ start++ ];\n\t        var nodeIndex = layoutInfo.idToIndex[ nodeId ];\n\t        var node      = layoutInfo.layoutNodes[ nodeIndex ];\n\t        var children  = node.children;\n\t\n\t        // We only need to process the node if it's compound\n\t        if( 0 < children.length && !node.isLocked ){\n\t          var offX = node.offsetX;\n\t          var offY = node.offsetY;\n\t\n\t          // var s = \"Propagating offset from parent node : \" + node.id +\n\t          //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n\t          // s += \"\\n Children: \" + children.toString();\n\t          // logDebug(s);\n\t\n\t          for( var i = 0; i < children.length; i++ ){\n\t            var childNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ children[ i ] ] ];\n\t            // Propagate offset\n\t            childNode.offsetX += offX;\n\t            childNode.offsetY += offY;\n\t            // Add children to queue to be visited\n\t            queue[ ++end ] = children[ i ];\n\t          }\n\t\n\t          // Reset parent offsets\n\t          node.offsetX = 0;\n\t          node.offsetY = 0;\n\t        }\n\t\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Updates the layout model positions, based on\n\t     *          the accumulated forces\n\t     */\n\t    var updatePositions = function( layoutInfo, options ){\n\t      // var s = 'Updating positions';\n\t      // logDebug(s);\n\t\n\t      // Reset boundaries for compound nodes\n\t      for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n\t        var n = layoutInfo.layoutNodes[ i ];\n\t        if( 0 < n.children.length ){\n\t          // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n\t          n.maxX = undefined;\n\t          n.minX = undefined;\n\t          n.maxY = undefined;\n\t          n.minY = undefined;\n\t        }\n\t      }\n\t\n\t      for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n\t        var n = layoutInfo.layoutNodes[ i ];\n\t        if( 0 < n.children.length || n.isLocked ){\n\t          // No need to set compound or locked node position\n\t          // logDebug(\"Skipping position update of node: \" + n.id);\n\t          continue;\n\t        }\n\t        // s = \"Node: \" + n.id + \" Previous position: (\" +\n\t        // n.positionX + \", \" + n.positionY + \").\";\n\t\n\t        // Limit displacement in order to improve stability\n\t        var tempForce = limitForce( n.offsetX, n.offsetY, layoutInfo.temperature );\n\t        n.positionX += tempForce.x;\n\t        n.positionY += tempForce.y;\n\t        n.offsetX = 0;\n\t        n.offsetY = 0;\n\t        n.minX    = n.positionX - n.width;\n\t        n.maxX    = n.positionX + n.width;\n\t        n.minY    = n.positionY - n.height;\n\t        n.maxY    = n.positionY + n.height;\n\t        // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n\t        // logDebug(s);\n\t\n\t        // Update ancestry boudaries\n\t        updateAncestryBoundaries( n, layoutInfo );\n\t      }\n\t\n\t      // Update size, position of compund nodes\n\t      for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n\t        var n = layoutInfo.layoutNodes[ i ];\n\t        if( 0 < n.children.length && !n.isLocked ){\n\t          n.positionX = (n.maxX + n.minX) / 2;\n\t          n.positionY = (n.maxY + n.minY) / 2;\n\t          n.width     = n.maxX - n.minX;\n\t          n.height    = n.maxY - n.minY;\n\t          // s = \"Updating position, size of compound node \" + n.id;\n\t          // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n\t          // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n\t          // logDebug(s);\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @brief : Limits a force (forceX, forceY) to be not\n\t     *          greater (in modulo) than max.\n\t     8          Preserves force direction.\n\t     */\n\t    var limitForce = function( forceX, forceY, max ){\n\t      // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n\t      var force = Math.sqrt( forceX * forceX + forceY * forceY );\n\t\n\t      if( force > max ){\n\t        var res = {\n\t          x: max * forceX / force,\n\t          y: max * forceY / force\n\t        };\n\t\n\t      } else {\n\t        var res = {\n\t          x: forceX,\n\t          y: forceY\n\t        };\n\t      }\n\t\n\t      // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n\t      // logDebug(s);\n\t\n\t      return res;\n\t    };\n\t\n\t    /**\n\t     * @brief : Function used for keeping track of compound node\n\t     *          sizes, since they should bound all their subnodes.\n\t     */\n\t    var updateAncestryBoundaries = function( node, layoutInfo ){\n\t      // var s = \"Propagating new position/size of node \" + node.id;\n\t      var parentId = node.parentId;\n\t      if( null == parentId ){\n\t        // If there's no parent, we are done\n\t        // s += \". No parent node.\";\n\t        // logDebug(s);\n\t        return;\n\t      }\n\t\n\t      // Get Parent Node\n\t      var p = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ parentId ] ];\n\t      var flag = false;\n\t\n\t      // MaxX\n\t      if( null == p.maxX || node.maxX + p.padRight > p.maxX ){\n\t        p.maxX = node.maxX + p.padRight;\n\t        flag = true;\n\t        // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n\t      }\n\t\n\t      // MinX\n\t      if( null == p.minX || node.minX - p.padLeft < p.minX ){\n\t        p.minX = node.minX - p.padLeft;\n\t        flag = true;\n\t        // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n\t      }\n\t\n\t      // MaxY\n\t      if( null == p.maxY || node.maxY + p.padBottom > p.maxY ){\n\t        p.maxY = node.maxY + p.padBottom;\n\t        flag = true;\n\t        // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n\t      }\n\t\n\t      // MinY\n\t      if( null == p.minY || node.minY - p.padTop < p.minY ){\n\t        p.minY = node.minY - p.padTop;\n\t        flag = true;\n\t        // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n\t      }\n\t\n\t      // If updated boundaries, propagate changes upward\n\t      if( flag ){\n\t        // logDebug(s);\n\t        return updateAncestryBoundaries( p, layoutInfo );\n\t      }\n\t\n\t      // s += \". No changes in boundaries/position of parent node \" + p.id;\n\t      // logDebug(s);\n\t      return;\n\t    };\n\t\n\t    var separateComponents = function( layutInfo, options ){\n\t      var nodes = layoutInfo.layoutNodes;\n\t      var components = [];\n\t\n\t      for( var i = 0; i < nodes.length; i++ ){\n\t        var node = nodes[ i ];\n\t        var cid = node.cmptId;\n\t        var component = components[ cid ] = components[ cid ] || [];\n\t\n\t        component.push( node );\n\t      }\n\t\n\t      var totalA = 0;\n\t\n\t      for( var i = 0; i < components.length; i++ ){\n\t        var c = components[ i ];\n\t\n\t        if( !c ){ continue; }\n\t\n\t        c.x1 = Infinity;\n\t        c.x2 = -Infinity;\n\t        c.y1 = Infinity;\n\t        c.y2 = -Infinity;\n\t\n\t        for( var j = 0; j < c.length; j++ ){\n\t          var n = c[ j ];\n\t\n\t          c.x1 = Math.min( c.x1, n.positionX - n.width / 2 );\n\t          c.x2 = Math.max( c.x2, n.positionX + n.width / 2 );\n\t          c.y1 = Math.min( c.y1, n.positionY - n.height / 2 );\n\t          c.y2 = Math.max( c.y2, n.positionY + n.height / 2 );\n\t        }\n\t\n\t        c.w = c.x2 - c.x1;\n\t        c.h = c.y2 - c.y1;\n\t\n\t        totalA += c.w * c.h;\n\t      }\n\t\n\t      components.sort( function( c1, c2 ){\n\t        return c2.w * c2.h - c1.w * c1.h;\n\t      } );\n\t\n\t      var x = 0;\n\t      var y = 0;\n\t      var usedW = 0;\n\t      var rowH = 0;\n\t      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n\t\n\t      for( var i = 0; i < components.length; i++ ){\n\t        var c = components[ i ];\n\t\n\t        if( !c ){ continue; }\n\t\n\t        for( var j = 0; j < c.length; j++ ){\n\t          var n = c[ j ];\n\t\n\t          if( !n.isLocked ){\n\t            n.positionX += x;\n\t            n.positionY += y;\n\t          }\n\t        }\n\t\n\t        x += c.w + options.componentSpacing;\n\t        usedW += c.w + options.componentSpacing;\n\t        rowH = Math.max( rowH, c.h );\n\t\n\t        if( usedW > maxRowW ){\n\t          y += rowH + options.componentSpacing;\n\t          x = 0;\n\t          usedW = 0;\n\t          rowH = 0;\n\t        }\n\t      }\n\t    };\n\t\n\t    var mainLoop = function( i ){\n\t      if( stopped ){\n\t        // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n\t        return false;\n\t      }\n\t\n\t      // Do one step in the phisical simulation\n\t      step( layoutInfo, options, i );\n\t\n\t      // Update temperature\n\t      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n\t      // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\t\n\t      if( layoutInfo.temperature < options.minTemp ){\n\t        // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n\t        return false;\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    var i = 0;\n\t    var loopRet;\n\t\n\t    do {\n\t      var f = 0;\n\t\n\t      while( f < options.refresh && i < options.numIter ){\n\t        var loopRet = mainLoop( i );\n\t        if( !loopRet ){ break; }\n\t\n\t        f++;\n\t        i++;\n\t      }\n\t\n\t      if( options.animate ){\n\t        broadcast( layoutInfo.layoutNodes ); // jshint ignore:line\n\t      }\n\t\n\t    } while( loopRet && i + 1 < options.numIter );\n\t\n\t    separateComponents( layoutInfo, options );\n\t\n\t    return layoutInfo;\n\t  } ).then( function( layoutInfoUpdated ){\n\t    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions\n\t\n\t    thread.stop();\n\t    done();\n\t  } );\n\t\n\t  var done = function(){\n\t    refresh({\n\t      force: true,\n\t      next: function(){\n\t        // Layout has finished\n\t        layout.one('layoutstop', options.stop);\n\t        layout.trigger({ type: 'layoutstop', layout: layout });\n\t      }\n\t    });\n\t  };\n\t\n\t  return this; // chaining\n\t};\n\t\n\t\n\t/**\n\t * @brief : called on continuous layouts to stop them before they finish\n\t */\n\tCoseLayout.prototype.stop = function(){\n\t  this.stopped = true;\n\t\n\t  if( this.thread ){\n\t    this.thread.stop();\n\t  }\n\t\n\t  this.trigger( 'layoutstop' );\n\t\n\t  return this; // chaining\n\t};\n\t\n\tCoseLayout.prototype.destroy = function(){\n\t  if( this.thread ){\n\t    this.thread.stop();\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\t\n\t\n\t/**\n\t * @brief     : Creates an object which is contains all the data\n\t *              used in the layout process\n\t * @arg cy    : cytoscape.js object\n\t * @return    : layoutInfo object initialized\n\t */\n\tvar createLayoutInfo = function( cy, layout, options ){\n\t  // Shortcut\n\t  var edges = options.eles.edges();\n\t  var nodes = options.eles.nodes();\n\t\n\t  var layoutInfo   = {\n\t    isCompound: cy.hasCompoundNodes(),\n\t    layoutNodes: [],\n\t    idToIndex: {},\n\t    nodeSize: nodes.size(),\n\t    graphSet: [],\n\t    indexToGraph: [],\n\t    layoutEdges: [],\n\t    edgeSize: edges.size(),\n\t    temperature: options.initialTemp,\n\t    clientWidth: cy.width(),\n\t    clientHeight: cy.width(),\n\t    boundingBox: math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n\t                     x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t                   } )\n\t  };\n\t\n\t  var components = options.eles.components();\n\t  var id2cmptId = {};\n\t\n\t  for( var i = 0; i < components.length; i++ ){\n\t    var component = components[ i ];\n\t\n\t    for( var j = 0; j < component.length; j++ ){\n\t      var node = component[ j ];\n\t\n\t      id2cmptId[ node.id() ] = i;\n\t    }\n\t  }\n\t\n\t  // Iterate over all nodes, creating layout nodes\n\t  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n\t    var n = nodes[ i ];\n\t    var nbb = n.boundingBox();\n\t\n\t    var tempNode        = {};\n\t    tempNode.isLocked   = n.locked();\n\t    tempNode.id         = n.data( 'id' );\n\t    tempNode.parentId   = n.data( 'parent' );\n\t    tempNode.cmptId     = id2cmptId[ n.id() ];\n\t    tempNode.children   = [];\n\t    tempNode.positionX  = n.position( 'x' );\n\t    tempNode.positionY  = n.position( 'y' );\n\t    tempNode.offsetX    = 0;\n\t    tempNode.offsetY    = 0;\n\t    tempNode.height     = nbb.w;\n\t    tempNode.width      = nbb.h;\n\t    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;\n\t    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;\n\t    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;\n\t    tempNode.minY       = tempNode.positionY - tempNode.height / 2;\n\t    tempNode.padLeft    = parseFloat( n.style( 'padding-left' ) );\n\t    tempNode.padRight   = parseFloat( n.style( 'padding-right' ) );\n\t    tempNode.padTop     = parseFloat( n.style( 'padding-top' ) );\n\t    tempNode.padBottom  = parseFloat( n.style( 'padding-bottom' ) );\n\t\n\t    // forces\n\t    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion.call( n, n ) : options.nodeRepulsion;\n\t\n\t    // Add new node\n\t    layoutInfo.layoutNodes.push( tempNode );\n\t    // Add entry to id-index map\n\t    layoutInfo.idToIndex[ tempNode.id ] = i;\n\t  }\n\t\n\t  // Inline implementation of a queue, used for traversing the graph in BFS order\n\t  var queue = [];\n\t  var start = 0;   // Points to the start the queue\n\t  var end   = -1;  // Points to the end of the queue\n\t\n\t  var tempGraph = [];\n\t\n\t  // Second pass to add child information and\n\t  // initialize queue for hierarchical traversal\n\t  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n\t    var n = layoutInfo.layoutNodes[ i ];\n\t    var p_id = n.parentId;\n\t    // Check if node n has a parent node\n\t    if( null != p_id ){\n\t      // Add node Id to parent's list of children\n\t      layoutInfo.layoutNodes[ layoutInfo.idToIndex[ p_id ] ].children.push( n.id );\n\t    } else {\n\t      // If a node doesn't have a parent, then it's in the root graph\n\t      queue[ ++end ] = n.id;\n\t      tempGraph.push( n.id );\n\t    }\n\t  }\n\t\n\t  // Add root graph to graphSet\n\t  layoutInfo.graphSet.push( tempGraph );\n\t\n\t  // Traverse the graph, level by level,\n\t  while( start <= end ){\n\t    // Get the node to visit and remove it from queue\n\t    var node_id  = queue[ start++ ];\n\t    var node_ix  = layoutInfo.idToIndex[ node_id ];\n\t    var node     = layoutInfo.layoutNodes[ node_ix ];\n\t    var children = node.children;\n\t    if( children.length > 0 ){\n\t      // Add children nodes as a new graph to graph set\n\t      layoutInfo.graphSet.push( children );\n\t      // Add children to que queue to be visited\n\t      for( var i = 0; i < children.length; i++ ){\n\t        queue[ ++end ] = children[ i ];\n\t      }\n\t    }\n\t  }\n\t\n\t  // Create indexToGraph map\n\t  for( var i = 0; i < layoutInfo.graphSet.length; i++ ){\n\t    var graph = layoutInfo.graphSet[ i ];\n\t    for( var j = 0; j < graph.length; j++ ){\n\t      var index = layoutInfo.idToIndex[ graph[ j ] ];\n\t      layoutInfo.indexToGraph[ index ] = i;\n\t    }\n\t  }\n\t\n\t  // Iterate over all edges, creating Layout Edges\n\t  for( var i = 0; i < layoutInfo.edgeSize; i++ ){\n\t    var e = edges[ i ];\n\t    var tempEdge = {};\n\t    tempEdge.id       = e.data( 'id' );\n\t    tempEdge.sourceId = e.data( 'source' );\n\t    tempEdge.targetId = e.data( 'target' );\n\t\n\t    // Compute ideal length\n\t    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength.call( e, e ) : options.idealEdgeLength;\n\t    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity.call( e, e ) : options.edgeElasticity;\n\t\n\t    // Check if it's an inter graph edge\n\t    var sourceIx    = layoutInfo.idToIndex[ tempEdge.sourceId ];\n\t    var targetIx    = layoutInfo.idToIndex[ tempEdge.targetId ];\n\t    var sourceGraph = layoutInfo.indexToGraph[ sourceIx ];\n\t    var targetGraph = layoutInfo.indexToGraph[ targetIx ];\n\t\n\t    if( sourceGraph != targetGraph ){\n\t      // Find lowest common graph ancestor\n\t      var lca = findLCA( tempEdge.sourceId, tempEdge.targetId, layoutInfo );\n\t\n\t      // Compute sum of node depths, relative to lca graph\n\t      var lcaGraph = layoutInfo.graphSet[ lca ];\n\t      var depth    = 0;\n\t\n\t      // Source depth\n\t      var tempNode = layoutInfo.layoutNodes[ sourceIx ];\n\t      while( -1 === lcaGraph.indexOf( tempNode.id ) ){\n\t        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];\n\t        depth++;\n\t      }\n\t\n\t      // Target depth\n\t      tempNode = layoutInfo.layoutNodes[ targetIx ];\n\t      while( -1 === lcaGraph.indexOf( tempNode.id ) ){\n\t        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];\n\t        depth++;\n\t      }\n\t\n\t      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n\t      //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n\t      //  \". Depth: \" + depth);\n\t\n\t      // Update idealLength\n\t      idealLength *= depth * options.nestingFactor;\n\t    }\n\t\n\t    tempEdge.idealLength = idealLength;\n\t    tempEdge.elasticity = elasticity;\n\t\n\t    layoutInfo.layoutEdges.push( tempEdge );\n\t  }\n\t\n\t  // Finally, return layoutInfo object\n\t  return layoutInfo;\n\t};\n\t\n\t\n\t/**\n\t * @brief : This function finds the index of the lowest common\n\t *          graph ancestor between 2 nodes in the subtree\n\t *          (from the graph hierarchy induced tree) whose\n\t *          root is graphIx\n\t *\n\t * @arg node1: node1's ID\n\t * @arg node2: node2's ID\n\t * @arg layoutInfo: layoutInfo object\n\t *\n\t */\n\tvar findLCA = function( node1, node2, layoutInfo ){\n\t  // Find their common ancester, starting from the root graph\n\t  var res = findLCA_aux( node1, node2, 0, layoutInfo );\n\t  if( 2 > res.count ){\n\t    // If aux function couldn't find the common ancester,\n\t    // then it is the root graph\n\t    return 0;\n\t  } else {\n\t    return res.graph;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * @brief          : Auxiliary function used for LCA computation\n\t *\n\t * @arg node1      : node1's ID\n\t * @arg node2      : node2's ID\n\t * @arg graphIx    : subgraph index\n\t * @arg layoutInfo : layoutInfo object\n\t *\n\t * @return         : object of the form {count: X, graph: Y}, where:\n\t *                   X is the number of ancesters (max: 2) found in\n\t *                   graphIx (and it's subgraphs),\n\t *                   Y is the graph index of the lowest graph containing\n\t *                   all X nodes\n\t */\n\tvar findLCA_aux = function( node1, node2, graphIx, layoutInfo ){\n\t  var graph = layoutInfo.graphSet[ graphIx ];\n\t  // If both nodes belongs to graphIx\n\t  if( -1 < graph.indexOf( node1 ) && -1 < graph.indexOf( node2 ) ){\n\t    return {count: 2, graph: graphIx};\n\t  }\n\t\n\t  // Make recursive calls for all subgraphs\n\t  var c = 0;\n\t  for( var i = 0; i < graph.length; i++ ){\n\t    var nodeId   = graph[ i ];\n\t    var nodeIx   = layoutInfo.idToIndex[ nodeId ];\n\t    var children = layoutInfo.layoutNodes[ nodeIx ].children;\n\t\n\t    // If the node has no child, skip it\n\t    if( 0 === children.length ){\n\t      continue;\n\t    }\n\t\n\t    var childGraphIx = layoutInfo.indexToGraph[ layoutInfo.idToIndex[ children[0] ] ];\n\t    var result = findLCA_aux( node1, node2, childGraphIx, layoutInfo );\n\t    if( 0 === result.count ){\n\t      // Neither node1 nor node2 are present in this subgraph\n\t      continue;\n\t    } else if( 1 === result.count ){\n\t      // One of (node1, node2) is present in this subgraph\n\t      c++;\n\t      if( 2 === c ){\n\t        // We've already found both nodes, no need to keep searching\n\t        break;\n\t      }\n\t    } else {\n\t      // Both nodes are present in this subgraph\n\t      return result;\n\t    }\n\t  }\n\t\n\t  return {count: c, graph: graphIx};\n\t};\n\t\n\t\n\t/**\n\t * @brief: printsLayoutInfo into js console\n\t *         Only used for debbuging\n\t */\n\tvar printLayoutInfo = function( layoutInfo ){\n\t  /* jshint ignore:start */\n\t\n\t  if( !DEBUG ){\n\t    return;\n\t  }\n\t  console.debug( 'layoutNodes:' );\n\t  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n\t    var n = layoutInfo.layoutNodes[ i ];\n\t    var s =\n\t    '\\nindex: '     + i +\n\t    '\\nId: '        + n.id +\n\t    '\\nChildren: '  + n.children.toString() +\n\t    '\\nparentId: '  + n.parentId  +\n\t    '\\npositionX: ' + n.positionX +\n\t    '\\npositionY: ' + n.positionY +\n\t    '\\nOffsetX: ' + n.offsetX +\n\t    '\\nOffsetY: ' + n.offsetY +\n\t    '\\npadLeft: ' + n.padLeft +\n\t    '\\npadRight: ' + n.padRight +\n\t    '\\npadTop: ' + n.padTop +\n\t    '\\npadBottom: ' + n.padBottom;\n\t\n\t    console.debug( s );\n\t  }\n\t\n\t  console.debug( 'idToIndex' );\n\t  for( var i in layoutInfo.idToIndex ){\n\t    console.debug( 'Id: ' + i + '\\nIndex: ' + layoutInfo.idToIndex[ i ] );\n\t  }\n\t\n\t  console.debug( 'Graph Set' );\n\t  var set = layoutInfo.graphSet;\n\t  for( var i = 0; i < set.length; i ++ ){\n\t    console.debug( 'Set : ' + i + ': ' + set[ i ].toString() );\n\t  }\n\t\n\t  var s = 'IndexToGraph';\n\t  for( var i = 0; i < layoutInfo.indexToGraph.length; i ++ ){\n\t    s += '\\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[ i ];\n\t  }\n\t  console.debug( s );\n\t\n\t  s = 'Layout Edges';\n\t  for( var i = 0; i < layoutInfo.layoutEdges.length; i++ ){\n\t    var e = layoutInfo.layoutEdges[ i ];\n\t    s += '\\nEdge Index: ' + i + ' ID: ' + e.id +\n\t    ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId +\n\t    ' Ideal Length: ' + e.idealLength;\n\t  }\n\t  console.debug( s );\n\t\n\t  s =  'nodeSize: ' + layoutInfo.nodeSize;\n\t  s += '\\nedgeSize: ' + layoutInfo.edgeSize;\n\t  s += '\\ntemperature: ' + layoutInfo.temperature;\n\t  console.debug( s );\n\t\n\t  return;\n\t  /* jshint ignore:end */\n\t};\n\t\n\t\n\t/**\n\t * @brief : Randomizes the position of all nodes\n\t */\n\tvar randomizePositions = function( layoutInfo, cy ){\n\t  var width     = layoutInfo.clientWidth;\n\t  var height    = layoutInfo.clientHeight;\n\t\n\t  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n\t    var n = layoutInfo.layoutNodes[ i ];\n\t\n\t    // No need to randomize compound nodes or locked nodes\n\t    if( 0 === n.children.length && !n.isLocked ){\n\t      n.positionX = Math.random() * width;\n\t      n.positionY = Math.random() * height;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * @brief          : Updates the positions of nodes in the network\n\t * @arg layoutInfo : LayoutInfo object\n\t * @arg cy         : Cytoscape object\n\t * @arg options    : Layout options\n\t */\n\tvar refreshPositions = function( layoutInfo, cy, options ){\n\t  // var s = 'Refreshing positions';\n\t  // logDebug(s);\n\t\n\t  var layout = options.layout;\n\t  var nodes = options.eles.nodes();\n\t  var bb = layoutInfo.boundingBox;\n\t  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n\t\n\t  if( options.boundingBox ){\n\t    nodes.forEach( function( node ){\n\t      var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ node.data( 'id' ) ] ];\n\t\n\t      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );\n\t      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );\n\t\n\t      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );\n\t      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );\n\t    } );\n\t\n\t    coseBB.w = coseBB.x2 - coseBB.x1;\n\t    coseBB.h = coseBB.y2 - coseBB.y1;\n\t  }\n\t\n\t  nodes.positions( function( i, ele ){\n\t    var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ ele.data( 'id' ) ] ];\n\t    // s = \"Node: \" + lnode.id + \". Refreshed position: (\" +\n\t    // lnode.positionX + \", \" + lnode.positionY + \").\";\n\t    // logDebug(s);\n\t\n\t    if( options.boundingBox ){ // then add extra bounding box constraint\n\t      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n\t      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n\t\n\t      return {\n\t        x: bb.x1 + pctX * bb.w,\n\t        y: bb.y1 + pctY * bb.h\n\t      };\n\t    } else {\n\t      return {\n\t        x: lnode.positionX,\n\t        y: lnode.positionY\n\t      };\n\t    }\n\t  } );\n\t\n\t  // Trigger layoutReady only on first call\n\t  if( true !== layoutInfo.ready ){\n\t    // s = 'Triggering layoutready';\n\t    // logDebug(s);\n\t    layoutInfo.ready = true;\n\t    layout.one( 'layoutready', options.ready );\n\t    layout.trigger( { type: 'layoutready', layout: this } );\n\t  }\n\t};\n\t\n\t/**\n\t * @brief : Logs a debug message in JS console, if DEBUG is ON\n\t */\n\t// var logDebug = function(text) {\n\t//   if (DEBUG) {\n\t//     console.debug(text);\n\t//   }\n\t// };\n\t\n\tmodule.exports = CoseLayout;\n\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__dirname) {/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n\t\n\t// cross-env thread/worker\n\t// NB : uses (heavyweight) processes on nodejs so best not to create too many threads\n\t\n\t'use strict';\n\t\n\tvar window = __webpack_require__(29);\n\tvar util = __webpack_require__(32);\n\tvar Promise = __webpack_require__(58);\n\tvar Event = __webpack_require__(60);\n\tvar define = __webpack_require__(56);\n\tvar is = __webpack_require__(30);\n\t\n\tvar Thread = function( opts ){\n\t  if( !(this instanceof Thread) ){\n\t    return new Thread( opts );\n\t  }\n\t\n\t  var _p = this._private = {\n\t    requires: [],\n\t    files: [],\n\t    queue: null,\n\t    pass: [],\n\t    disabled: false\n\t  };\n\t\n\t  if( is.plainObject(opts) ){\n\t    if( opts.disabled != null ){\n\t      _p.disabled = !!opts.disabled;\n\t    }\n\t  }\n\t\n\t};\n\t\n\tvar thdfn = Thread.prototype; // short alias\n\t\n\tvar stringifyFieldVal = function( val ){\n\t  var valStr = is.fn( val ) ? val.toString() : \"JSON.parse('\" + JSON.stringify(val) + \"')\";\n\t\n\t  return valStr;\n\t};\n\t\n\t// allows for requires with prototypes and subobjs etc\n\tvar fnAsRequire = function( fn ){\n\t  var req;\n\t  var fnName;\n\t\n\t  if( is.object(fn) && fn.fn ){ // manual fn\n\t    req = fnAs( fn.fn, fn.name );\n\t    fnName = fn.name;\n\t    fn = fn.fn;\n\t  } else if( is.fn(fn) ){ // auto fn\n\t    req = fn.toString();\n\t    fnName = fn.name;\n\t  } else if( is.string(fn) ){ // stringified fn\n\t    req = fn;\n\t  } else if( is.object(fn) ){ // plain object\n\t    if( fn.proto ){\n\t      req = '';\n\t    } else {\n\t      req = fn.name + ' = {};';\n\t    }\n\t\n\t    fnName = fn.name;\n\t    fn = fn.obj;\n\t  }\n\t\n\t  req += '\\n';\n\t\n\t  var protoreq = function( val, subname ){\n\t    if( val.prototype ){\n\t      var protoNonempty = false;\n\t      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line\n\t\n\t      if( protoNonempty ){\n\t        req += fnAsRequire( {\n\t          name: subname,\n\t          obj: val,\n\t          proto: true\n\t        }, val );\n\t      }\n\t    }\n\t  };\n\t\n\t  // pull in prototype\n\t  if( fn.prototype && fnName != null ){\n\t\n\t    for( var name in fn.prototype ){\n\t      var protoStr = '';\n\t\n\t      var val = fn.prototype[ name ];\n\t      var valStr = stringifyFieldVal( val );\n\t      var subname = fnName + '.prototype.' + name;\n\t\n\t      protoStr += subname + ' = ' + valStr + ';\\n';\n\t\n\t      if( protoStr ){\n\t        req += protoStr;\n\t      }\n\t\n\t      protoreq( val, subname ); // subobject with prototype\n\t    }\n\t\n\t  }\n\t\n\t  // pull in properties for obj/fns\n\t  if( !is.string(fn) ){ for( var name in fn ){\n\t    var propsStr = '';\n\t\n\t    if( fn.hasOwnProperty(name) ){\n\t      var val = fn[ name ];\n\t      var valStr = stringifyFieldVal( val );\n\t      var subname = fnName + '[\"' + name + '\"]';\n\t\n\t      propsStr += subname + ' = ' + valStr + ';\\n';\n\t    }\n\t\n\t    if( propsStr ){\n\t      req += propsStr;\n\t    }\n\t\n\t    protoreq( val, subname ); // subobject with prototype\n\t  } }\n\t\n\t  return req;\n\t};\n\t\n\tvar isPathStr = function( str ){\n\t  return is.string(str) && str.match(/\\.js$/);\n\t};\n\t\n\tutil.extend(thdfn, {\n\t\n\t  instanceString: function(){ return 'thread'; },\n\t\n\t  require: function( fn, as ){\n\t    var requires = this._private.requires;\n\t\n\t    if( isPathStr(fn) ){\n\t      this._private.files.push( fn );\n\t\n\t      return this;\n\t    }\n\t\n\t    if( as ){\n\t      if( is.fn(fn) ){\n\t        fn = { name: as, fn: fn };\n\t      } else {\n\t        fn = { name: as, obj: fn };\n\t      }\n\t    } else {\n\t      if( is.fn(fn) ){\n\t        if( !fn.name ){\n\t          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, \"someFunction\" )';\n\t        }\n\t\n\t        fn = { name: fn.name, fn: fn };\n\t      }\n\t    }\n\t\n\t    requires.push( fn );\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  pass: function( data ){\n\t    this._private.pass.push( data );\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  run: function( fn, pass ){ // fn used like main()\n\t    var self = this;\n\t    var _p = this._private;\n\t    pass = pass || _p.pass.shift();\n\t\n\t    if( _p.stopped ){\n\t      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';\n\t    }\n\t\n\t    if( _p.running ){\n\t      return ( _p.queue = _p.queue.then(function(){ // inductive step\n\t        return self.run( fn, pass );\n\t      }) );\n\t    }\n\t\n\t    var useWW = window != null && !_p.disabled;\n\t    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;\n\t\n\t    self.trigger('run');\n\t\n\t    var runP = new Promise(function( resolve, reject ){\n\t\n\t      _p.running = true;\n\t\n\t      var threadTechAlreadyExists = _p.ran;\n\t\n\t      var fnImplStr = is.string( fn ) ? fn : fn.toString();\n\t\n\t      // worker code to exec\n\t      var fnStr = '\\n' + ( _p.requires.map(function( r ){\n\t        return fnAsRequire( r );\n\t      }) ).concat( _p.files.map(function( f ){\n\t        if( useWW ){\n\t          var wwifyFile = function( file ){\n\t            if( file.match(/^\\.\\//) || file.match(/^\\.\\./) ){\n\t              return window.location.origin + window.location.pathname + file;\n\t            } else if( file.match(/^\\//) ){\n\t              return window.location.origin + '/' + file;\n\t            }\n\t            return file;\n\t          };\n\t\n\t          return 'importScripts(\"' + wwifyFile(f) + '\");';\n\t        } else if( useNode ) {\n\t          return 'eval( require(\"fs\").readFileSync(\"' + f + '\", { encoding: \"utf8\" }) );';\n\t        } else {\n\t          throw 'External file `' + f + '` can not be required without any threading technology.';\n\t        }\n\t      }) ).concat([\n\t        '( function(){',\n\t          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',\n\t          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it\n\t        '} )()\\n'\n\t      ]).join('\\n');\n\t\n\t      // because we've now consumed the requires, empty the list so we don't dupe on next run()\n\t      _p.requires = [];\n\t      _p.files = [];\n\t\n\t      if( useWW ){\n\t        var fnBlob, fnUrl;\n\t\n\t        // add normalised thread api functions\n\t        if( !threadTechAlreadyExists ){\n\t          var fnPre = fnStr + '';\n\t\n\t          fnStr = [\n\t            'function _ref_(o){ return eval(o); };',\n\t            'function broadcast(m){ return message(m); };', // alias\n\t            'function message(m){ postMessage(m); };',\n\t            'function listen(fn){',\n\t            '  self.addEventListener(\"message\", function(m){ ',\n\t            '    if( typeof m === \"object\" && (m.data.$$eval || m.data === \"$$start\") ){',\n\t            '    } else { ',\n\t            '      fn( m.data );',\n\t            '    }',\n\t            '  });',\n\t            '};',\n\t            'self.addEventListener(\"message\", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',\n\t            'function resolve(v){ postMessage({ $$resolve: v }); };',\n\t            'function reject(v){ postMessage({ $$reject: v }); };'\n\t          ].join('\\n');\n\t\n\t          fnStr += fnPre;\n\t\n\t          fnBlob = new Blob([ fnStr ], {\n\t            type: 'application/javascript'\n\t          });\n\t          fnUrl = window.URL.createObjectURL( fnBlob );\n\t        }\n\t        // create webworker and let it exec the serialised code\n\t        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );\n\t\n\t        if( threadTechAlreadyExists ){ // then just exec new run() code\n\t          ww.postMessage({\n\t            $$eval: fnStr\n\t          });\n\t        }\n\t\n\t        // worker messages => events\n\t        var cb;\n\t        ww.addEventListener('message', cb = function( m ){\n\t          var isObject = is.object(m) && is.object( m.data );\n\t\n\t          if( isObject && ('$$resolve' in m.data) ){\n\t            ww.removeEventListener('message', cb); // done listening b/c resolve()\n\t\n\t            resolve( m.data.$$resolve );\n\t          } else if( isObject && ('$$reject' in m.data) ){\n\t            ww.removeEventListener('message', cb); // done listening b/c reject()\n\t\n\t            reject( m.data.$$reject );\n\t          } else {\n\t            self.trigger( new Event(m, { type: 'message', message: m.data }) );\n\t          }\n\t        }, false);\n\t\n\t        if( !threadTechAlreadyExists ){\n\t          ww.postMessage('$$start'); // start up the worker\n\t        }\n\t\n\t      } else if( useNode ){\n\t        // create a new process\n\t\n\t        if( !_p.child ){\n\t          _p.child = ( __webpack_require__(104).fork( __webpack_require__(105).join(__dirname, 'thread-node-fork') ) );\n\t        }\n\t\n\t        var child = _p.child;\n\t\n\t        // child process messages => events\n\t        var cb;\n\t        child.on('message', cb = function( m ){\n\t          if( is.object(m) && ('$$resolve' in m) ){\n\t            child.removeListener('message', cb); // done listening b/c resolve()\n\t\n\t            resolve( m.$$resolve );\n\t          } else if( is.object(m) && ('$$reject' in m) ){\n\t            child.removeListener('message', cb); // done listening b/c reject()\n\t\n\t            reject( m.$$reject );\n\t          } else {\n\t            self.trigger( new Event({}, { type: 'message', message: m }) );\n\t          }\n\t        });\n\t\n\t        // ask the child process to eval the worker code\n\t        child.send({\n\t          $$eval: fnStr\n\t        });\n\t\n\t      } else { // use a fallback mechanism using a timeout\n\t\n\t        var promiseResolve = resolve;\n\t        var promiseReject = reject;\n\t\n\t        var timer = _p.timer = _p.timer || {\n\t\n\t          listeners: [],\n\t\n\t          exec: function(){\n\t            // as a string so it can't be mangled by minifiers and processors\n\t            fnStr = [\n\t              'function _ref_(o){ return eval(o); };',\n\t              'function broadcast(m){ return message(m); };',\n\t              'function message(m){ self.trigger( new Event({}, { type: \"message\", message: m }) ); };',\n\t              'function listen(fn){ timer.listeners.push( fn ); };',\n\t              'function resolve(v){ promiseResolve(v); };',\n\t              'function reject(v){ promiseReject(v); };'\n\t            ].join('\\n') + fnStr;\n\t\n\t            // the .run() code\n\t            eval( fnStr ); // jshint ignore:line\n\t          },\n\t\n\t          message: function( m ){\n\t            var ls = timer.listeners;\n\t\n\t            for( var i = 0; i < ls.length; i++ ){\n\t              var fn = ls[i];\n\t\n\t              fn( m );\n\t            }\n\t          }\n\t\n\t        };\n\t\n\t        timer.exec();\n\t      }\n\t\n\t    }).then(function( v ){\n\t      _p.running = false;\n\t      _p.ran = true;\n\t\n\t      self.trigger('ran');\n\t\n\t      return v;\n\t    });\n\t\n\t    if( _p.queue == null ){\n\t      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)\n\t    }\n\t\n\t    return runP;\n\t  },\n\t\n\t  // send the thread a message\n\t  message: function( m ){\n\t    var _p = this._private;\n\t\n\t    if( _p.webworker ){\n\t      _p.webworker.postMessage( m );\n\t    }\n\t\n\t    if( _p.child ){\n\t      _p.child.send( m );\n\t    }\n\t\n\t    if( _p.timer ){\n\t      _p.timer.message( m );\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  stop: function(){\n\t    var _p = this._private;\n\t\n\t    if( _p.webworker ){\n\t      _p.webworker.terminate();\n\t    }\n\t\n\t    if( _p.child ){\n\t      _p.child.kill();\n\t    }\n\t\n\t    if( _p.timer ){\n\t      // nothing we can do if we've run a timeout\n\t    }\n\t\n\t    _p.stopped = true;\n\t\n\t    return this.trigger('stop'); // chaining\n\t  },\n\t\n\t  stopped: function(){\n\t    return this._private.stopped;\n\t  }\n\t\n\t});\n\t\n\t// turns a stringified function into a (re)named function\n\tvar fnAs = function( fn, name ){\n\t  var fnStr = fn.toString();\n\t  fnStr = fnStr.replace(/function\\s*?\\S*?\\s*?\\(/, 'function ' + name + '(');\n\t\n\t  return fnStr;\n\t};\n\t\n\tvar defineFnal = function( opts ){\n\t  opts = opts || {};\n\t\n\t  return function fnalImpl( fn, arg1 ){\n\t    var fnStr = fnAs( fn, '_$_$_' + opts.name );\n\t\n\t    this.require( fnStr );\n\t\n\t    return this.run( [\n\t      'function( data ){',\n\t      '  var origResolve = resolve;',\n\t      '  var res = [];',\n\t      '  ',\n\t      '  resolve = function( val ){',\n\t      '    res.push( val );',\n\t      '  };',\n\t      '  ',\n\t      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',\n\t      '  ',\n\t      '  resolve = origResolve;',\n\t      '  resolve( res.length > 0 ? res : ret );',\n\t      '}'\n\t    ].join('\\n') );\n\t  };\n\t};\n\t\n\tutil.extend(thdfn, {\n\t  reduce: defineFnal({ name: 'reduce' }),\n\t\n\t  reduceRight: defineFnal({ name: 'reduceRight' }),\n\t\n\t  map: defineFnal({ name: 'map' })\n\t});\n\t\n\t// aliases\n\tvar fn = thdfn;\n\tfn.promise = fn.run;\n\tfn.terminate = fn.halt = fn.stop;\n\tfn.include = fn.require;\n\t\n\t// pull in event apis\n\tutil.extend(thdfn, {\n\t  on: define.on(),\n\t  one: define.on({ unbindSelfOnTrigger: true }),\n\t  off: define.off(),\n\t  trigger: define.trigger()\n\t});\n\t\n\tdefine.eventAliasesOn( thdfn );\n\t\n\tmodule.exports = Thread;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"/\"))\n\n/***/ },\n/* 104 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit the viewport to the graph\n\t  padding: 30, // padding used on fit\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n\t  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true\n\t  condense: false, // uses all available space on false, uses minimal space on true\n\t  rows: undefined, // force num of rows in the grid\n\t  cols: undefined, // force num of columns in the grid\n\t  position: function( node ){}, // returns { row, col } for element\n\t  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined // callback on layoutstop\n\t};\n\t\n\tfunction GridLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t}\n\t\n\tGridLayout.prototype.run = function(){\n\t  var params = this.options;\n\t  var options = params;\n\t\n\t  var cy = params.cy;\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not( ':parent' );\n\t\n\t  if( options.sort ){\n\t    nodes = nodes.sort( options.sort );\n\t  }\n\t\n\t  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  } );\n\t\n\t  if( bb.h === 0 || bb.w === 0 ){\n\t    nodes.layoutPositions( this, options, function(){\n\t      return { x: bb.x1, y: bb.y1 };\n\t    } );\n\t\n\t  } else {\n\t\n\t    // width/height * splits^2 = cells where splits is number of times to split width\n\t    var cells = nodes.size();\n\t    var splits = Math.sqrt( cells * bb.h / bb.w );\n\t    var rows = Math.round( splits );\n\t    var cols = Math.round( bb.w / bb.h * splits );\n\t\n\t    var small = function( val ){\n\t      if( val == null ){\n\t        return Math.min( rows, cols );\n\t      } else {\n\t        var min = Math.min( rows, cols );\n\t        if( min == rows ){\n\t          rows = val;\n\t        } else {\n\t          cols = val;\n\t        }\n\t      }\n\t    };\n\t\n\t    var large = function( val ){\n\t      if( val == null ){\n\t        return Math.max( rows, cols );\n\t      } else {\n\t        var max = Math.max( rows, cols );\n\t        if( max == rows ){\n\t          rows = val;\n\t        } else {\n\t          cols = val;\n\t        }\n\t      }\n\t    };\n\t\n\t    var oRows = options.rows;\n\t    var oCols = options.cols != null ? options.cols : options.columns;\n\t\n\t    // if rows or columns were set in options, use those values\n\t    if( oRows != null && oCols != null ){\n\t      rows = oRows;\n\t      cols = oCols;\n\t    } else if( oRows != null && oCols == null ){\n\t      rows = oRows;\n\t      cols = Math.ceil( cells / rows );\n\t    } else if( oRows == null && oCols != null ){\n\t      cols = oCols;\n\t      rows = Math.ceil( cells / cols );\n\t    }\n\t\n\t    // otherwise use the automatic values and adjust accordingly\n\t\n\t    // if rounding was up, see if we can reduce rows or columns\n\t    else if( cols * rows > cells ){\n\t      var sm = small();\n\t      var lg = large();\n\t\n\t      // reducing the small side takes away the most cells, so try it first\n\t      if( (sm - 1) * lg >= cells ){\n\t        small( sm - 1 );\n\t      } else if( (lg - 1) * sm >= cells ){\n\t        large( lg - 1 );\n\t      }\n\t    } else {\n\t\n\t      // if rounding was too low, add rows or columns\n\t      while( cols * rows < cells ){\n\t        var sm = small();\n\t        var lg = large();\n\t\n\t        // try to add to larger side first (adds less in multiplication)\n\t        if( (lg + 1) * sm >= cells ){\n\t          large( lg + 1 );\n\t        } else {\n\t          small( sm + 1 );\n\t        }\n\t      }\n\t    }\n\t\n\t    var cellWidth = bb.w / cols;\n\t    var cellHeight = bb.h / rows;\n\t\n\t    if( options.condense ){\n\t      cellWidth = 0;\n\t      cellHeight = 0;\n\t    }\n\t\n\t    if( options.avoidOverlap ){\n\t      for( var i = 0; i < nodes.length; i++ ){\n\t        var node = nodes[ i ];\n\t        var pos = node._private.position;\n\t\n\t        if( pos.x == null || pos.y == null ){ // for bb\n\t          pos.x = 0;\n\t          pos.y = 0;\n\t        }\n\t\n\t        var nbb = node.boundingBox();\n\t        var p = options.avoidOverlapPadding;\n\t\n\t        var w = nbb.w + p;\n\t        var h = nbb.h + p;\n\t\n\t        cellWidth = Math.max( cellWidth, w );\n\t        cellHeight = Math.max( cellHeight, h );\n\t      }\n\t    }\n\t\n\t    var cellUsed = {}; // e.g. 'c-0-2' => true\n\t\n\t    var used = function( row, col ){\n\t      return cellUsed[ 'c-' + row + '-' + col ] ? true : false;\n\t    };\n\t\n\t    var use = function( row, col ){\n\t      cellUsed[ 'c-' + row + '-' + col ] = true;\n\t    };\n\t\n\t    // to keep track of current cell position\n\t    var row = 0;\n\t    var col = 0;\n\t    var moveToNextCell = function(){\n\t      col++;\n\t      if( col >= cols ){\n\t        col = 0;\n\t        row++;\n\t      }\n\t    };\n\t\n\t    // get a cache of all the manual positions\n\t    var id2manPos = {};\n\t    for( var i = 0; i < nodes.length; i++ ){\n\t      var node = nodes[ i ];\n\t      var rcPos = options.position( node );\n\t\n\t      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd\n\t        var pos = {\n\t          row: rcPos.row,\n\t          col: rcPos.col\n\t        };\n\t\n\t        if( pos.col === undefined ){ // find unused col\n\t          pos.col = 0;\n\t\n\t          while( used( pos.row, pos.col ) ){\n\t            pos.col++;\n\t          }\n\t        } else if( pos.row === undefined ){ // find unused row\n\t          pos.row = 0;\n\t\n\t          while( used( pos.row, pos.col ) ){\n\t            pos.row++;\n\t          }\n\t        }\n\t\n\t        id2manPos[ node.id() ] = pos;\n\t        use( pos.row, pos.col );\n\t      }\n\t    }\n\t\n\t    var getPos = function( i, element ){\n\t      var x, y;\n\t\n\t      if( element.locked() || element.isFullAutoParent() ){\n\t        return false;\n\t      }\n\t\n\t      // see if we have a manual position set\n\t      var rcPos = id2manPos[ element.id() ];\n\t      if( rcPos ){\n\t        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n\t        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n\t\n\t      } else { // otherwise set automatically\n\t\n\t        while( used( row, col ) ){\n\t          moveToNextCell();\n\t        }\n\t\n\t        x = col * cellWidth + cellWidth / 2 + bb.x1;\n\t        y = row * cellHeight + cellHeight / 2 + bb.y1;\n\t        use( row, col );\n\t\n\t        moveToNextCell();\n\t      }\n\t\n\t      return { x: x, y: y };\n\t\n\t    };\n\t\n\t    nodes.layoutPositions( this, options, getPos );\n\t  }\n\t\n\t  return this; // chaining\n\t\n\t};\n\t\n\tmodule.exports = GridLayout;\n\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\t// default layout options\n\tvar defaults = {\n\t  ready: function(){}, // on layoutready\n\t  stop: function(){} // on layoutstop\n\t};\n\t\n\t// constructor\n\t// options : object containing layout options\n\tfunction NullLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t}\n\t\n\t// runs the layout\n\tNullLayout.prototype.run = function(){\n\t  var options = this.options;\n\t  var eles = options.eles; // elements to consider in the layout\n\t  var layout = this;\n\t\n\t  // cy is automatically populated for us in the constructor\n\t  var cy = options.cy; // jshint ignore:line\n\t\n\t  layout.trigger( 'layoutstart' );\n\t\n\t  // puts all nodes at (0, 0)\n\t  eles.nodes().positions( function(){\n\t    return {\n\t      x: 0,\n\t      y: 0\n\t    };\n\t  } );\n\t\n\t  // trigger layoutready when each node has had its position set at least once\n\t  layout.one( 'layoutready', options.ready );\n\t  layout.trigger( 'layoutready' );\n\t\n\t  // trigger layoutstop when the layout stops (e.g. finishes)\n\t  layout.one( 'layoutstop', options.stop );\n\t  layout.trigger( 'layoutstop' );\n\t\n\t  return this; // chaining\n\t};\n\t\n\t// called on continuous layouts to stop them before they finish\n\tNullLayout.prototype.stop = function(){\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = NullLayout;\n\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar defaults = {\n\t  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }\n\t  zoom: undefined, // the zoom level to set (prob want fit = false if set)\n\t  pan: undefined, // the pan level to set (prob want fit = false if set)\n\t  fit: true, // whether to fit to viewport\n\t  padding: 30, // padding on fit\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined // callback on layoutstop\n\t};\n\t\n\tfunction PresetLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t}\n\t\n\tPresetLayout.prototype.run = function(){\n\t  var options = this.options;\n\t  var eles = options.eles;\n\t\n\t  var nodes = eles.nodes();\n\t  var posIsFn = is.fn( options.positions );\n\t\n\t  function getPosition( node ){\n\t    if( options.positions == null ){\n\t      return null;\n\t    }\n\t\n\t    if( posIsFn ){\n\t      return options.positions.apply( node, [ node ] );\n\t    }\n\t\n\t    var pos = options.positions[ node._private.data.id ];\n\t\n\t    if( pos == null ){\n\t      return null;\n\t    }\n\t\n\t    return pos;\n\t  }\n\t\n\t  nodes.layoutPositions( this, options, function( i, node ){\n\t    var position = getPosition( node );\n\t\n\t    if( node.locked() || position == null ){\n\t      return false;\n\t    }\n\t\n\t    return position;\n\t  } );\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = PresetLayout;\n\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar defaults = {\n\t  fit: true, // whether to fit to viewport\n\t  padding: 30, // fit padding\n\t  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\t  animate: false, // whether to transition the node positions\n\t  animationDuration: 500, // duration of animation in ms if enabled\n\t  animationEasing: undefined, // easing of animation if enabled\n\t  ready: undefined, // callback on layoutready\n\t  stop: undefined // callback on layoutstop\n\t};\n\t\n\tfunction RandomLayout( options ){\n\t  this.options = util.extend( {}, defaults, options );\n\t}\n\t\n\tRandomLayout.prototype.run = function(){\n\t  var options = this.options;\n\t  var cy = options.cy;\n\t  var eles = options.eles;\n\t  var nodes = eles.nodes().not( ':parent' );\n\t\n\t  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n\t    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n\t  } );\n\t\n\t  var getPos = function( i, node ){\n\t    return {\n\t      x: bb.x1 + Math.round( Math.random() * bb.w ),\n\t      y: bb.y1 + Math.round( Math.random() * bb.h )\n\t    };\n\t  };\n\t\n\t  nodes.layoutPositions( this, options, getPos );\n\t\n\t  return this; // chaining\n\t};\n\t\n\tmodule.exports = RandomLayout;\n\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = [\n\t  { name: 'null', impl: __webpack_require__( 111 ) },\n\t  { name: 'base', impl: __webpack_require__( 112 ) },\n\t  { name: 'canvas', impl: __webpack_require__( 119 ) }\n\t];\n\n\n/***/ },\n/* 111 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction NullRenderer( options ){\n\t  this.options = options;\n\t  this.notifications = 0; // for testing\n\t}\n\t\n\tvar noop = function(){};\n\t\n\tNullRenderer.prototype = {\n\t  recalculateRenderedStyle: noop,\n\t  notify: function(){ this.notifications++; },\n\t  init: noop\n\t};\n\t\n\tmodule.exports = NullRenderer;\n\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar BaseRenderer = function( options ){ this.init( options ); };\n\tvar BR = BaseRenderer;\n\tvar BRp = BR.prototype;\n\t\n\tBRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];\n\t\n\tBRp.init = function( options ){\n\t  var r = this;\n\t\n\t  r.options = options;\n\t\n\t  r.cy = options.cy;\n\t\n\t  r.container = options.cy.container();\n\t\n\t  r.selection = [ undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\t\n\t  r.bezierProjPcts = [ 0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95 ];\n\t\n\t  //--Pointer-related data\n\t  r.hoverData = {down: null, last: null,\n\t      downTime: null, triggerMode: null,\n\t      dragging: false,\n\t      initialPan: [ null, null ], capture: false};\n\t\n\t  r.dragData = {possibleDragElements: []};\n\t\n\t  r.touchData = {\n\t    start: null, capture: false,\n\t\n\t    // These 3 fields related to tap, taphold events\n\t    startPosition: [ null, null, null, null, null, null ],\n\t    singleTouchStartTime: null,\n\t    singleTouchMoved: true,\n\t\n\t    now: [ null, null, null, null, null, null ],\n\t    earlier: [ null, null, null, null, null, null ]\n\t  };\n\t\n\t  r.redraws = 0;\n\t  r.showFps = options.showFps;\n\t\n\t  r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n\t  r.hideLabelsOnViewport = options.hideLabelsOnViewport;\n\t  r.textureOnViewport = options.textureOnViewport;\n\t  r.wheelSensitivity = options.wheelSensitivity;\n\t  r.motionBlurEnabled = options.motionBlur; // on by default\n\t  r.forcedPixelRatio = options.pixelRatio;\n\t  r.motionBlur = options.motionBlur; // for initial kick off\n\t  r.motionBlurOpacity = options.motionBlurOpacity;\n\t  r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n\t  r.motionBlurPxRatio = 1;\n\t  r.mbPxRBlurry = 1; //0.8;\n\t  r.minMbLowQualFrames = 4;\n\t  r.fullQualityMb = false;\n\t  r.clearedForMotionBlur = [];\n\t  r.desktopTapThreshold = options.desktopTapThreshold;\n\t  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n\t  r.touchTapThreshold = options.touchTapThreshold;\n\t  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n\t  r.tapholdDuration = 500;\n\t\n\t  r.bindings = [];\n\t  r.beforeRenderCallbacks = [];\n\t  r.beforeRenderPriorities = { // higher priority execs before lower one\n\t    animations:   400,\n\t    eleCalcs:     300,\n\t    eleTxrDeq:    200,\n\t    lyrTxrDeq:    100\n\t  };\n\t\n\t  r.registerNodeShapes();\n\t  r.registerArrowShapes();\n\t  r.registerCalculationListeners();\n\t  r.load();\n\t};\n\t\n\tBRp.notify = function( params ){\n\t  var types;\n\t  var r = this;\n\t\n\t  if( is.array( params.type ) ){\n\t    types = params.type;\n\t\n\t  } else {\n\t    types = [ params.type ];\n\t  }\n\t\n\t  var has = {};\n\t  for( var i = 0; i < types.length; i++ ){\n\t    var type = types[ i ];\n\t\n\t    has[ type ] = true;\n\t  } // for\n\t\n\t  if( has['destroy'] ){\n\t    r.destroy();\n\t    return;\n\t  }\n\t\n\t  if( has['add'] || has['remove'] || has['load'] || has['style'] ){\n\t    r.updateCachedZSortedEles();\n\t  }\n\t\n\t  if( has['viewport'] ){\n\t    r.redrawHint( 'select', true );\n\t  }\n\t\n\t  if( has['load'] || has['resize'] ){\n\t    r.invalidateContainerClientCoordsCache();\n\t    r.matchCanvasSize( r.container );\n\t  }\n\t\n\t  r.redrawHint( 'eles', true );\n\t  r.redrawHint( 'drag', true );\n\t\n\t  this.startRenderLoop();\n\t\n\t  this.redraw();\n\t};\n\t\n\tBRp.destroy = function(){\n\t  var r = this;\n\t\n\t  r.destroyed = true;\n\t\n\t  r.cy.stopAnimationLoop();\n\t\n\t  for( var i = 0; i < r.bindings.length; i++ ){\n\t    var binding = r.bindings[ i ];\n\t    var b = binding;\n\t    var tgt = b.target;\n\t\n\t    ( tgt.off || tgt.removeEventListener ).apply( tgt, b.args );\n\t  }\n\t\n\t  if( r.removeObserver ){\n\t    r.removeObserver.disconnect();\n\t  }\n\t\n\t  if( r.styleObserver ){\n\t    r.styleObserver.disconnect();\n\t  }\n\t\n\t  if( r.labelCalcDiv ){\n\t    try {\n\t      document.body.removeChild( r.labelCalcDiv );\n\t    } catch( e ){\n\t      // ie10 issue #1014\n\t    }\n\t  }\n\t};\n\t\n\t[\n\t  __webpack_require__( 113 ),\n\t  __webpack_require__( 114 ),\n\t  __webpack_require__( 115 ),\n\t  __webpack_require__( 116 ),\n\t  __webpack_require__( 117 ),\n\t  __webpack_require__( 118 )\n\t].forEach( function( props ){\n\t  util.extend( BRp, props );\n\t} );\n\t\n\tmodule.exports = BR;\n\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar math = __webpack_require__( 33 );\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar BRp = {};\n\t\n\tBRp.arrowShapeWidth = 0.3;\n\t\n\tBRp.registerArrowShapes = function(){\n\t  var arrowShapes = this.arrowShapes = {};\n\t  var renderer = this;\n\t\n\t  // Contract for arrow shapes:\n\t  // 0, 0 is arrow tip\n\t  // (0, 1) is direction towards node\n\t  // (1, 0) is right\n\t  //\n\t  // functional api:\n\t  // collide: check x, y in shape\n\t  // roughCollide: called before collide, no false negatives\n\t  // draw: draw\n\t  // spacing: dist(arrowTip, nodeBoundary)\n\t  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\t\n\t  var bbCollide = function( x, y, size, angle, translation, padding ){\n\t    var x1 = translation.x - size / 2 - padding;\n\t    var x2 = translation.x + size / 2 + padding;\n\t    var y1 = translation.y - size / 2 - padding;\n\t    var y2 = translation.y + size / 2 + padding;\n\t\n\t    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);\n\t\n\t    return inside;\n\t  };\n\t\n\t  var transform = function( x, y, size, angle, translation ){\n\t    var xRotated = x * Math.cos( angle ) - y * Math.sin( angle );\n\t    var yRotated = x * Math.sin( angle ) + y * Math.cos( angle );\n\t\n\t    var xScaled = xRotated * size;\n\t    var yScaled = yRotated * size;\n\t\n\t    var xTranslated = xScaled + translation.x;\n\t    var yTranslated = yScaled + translation.y;\n\t\n\t    return {\n\t      x: xTranslated,\n\t      y: yTranslated\n\t    };\n\t  };\n\t\n\t  var transformPoints = function( pts, size, angle, translation ){\n\t    var retPts = [];\n\t\n\t    for( var i = 0; i < pts.length; i += 2 ){\n\t      var x = pts[ i ];\n\t      var y = pts[ i + 1];\n\t\n\t      retPts.push( transform( x, y, size, angle, translation ) );\n\t    }\n\t\n\t    return retPts;\n\t  };\n\t\n\t  var pointsToArr = function( pts ){\n\t    var ret = [];\n\t\n\t    for( var i = 0; i < pts.length; i++ ){\n\t      var p = pts[ i ];\n\t\n\t      ret.push( p.x, p.y );\n\t    }\n\t\n\t    return ret;\n\t  };\n\t\n\t  var defineArrowShape = function( name, defn ){\n\t    if( is.string( defn ) ){\n\t      defn = arrowShapes[ defn ];\n\t    }\n\t\n\t    arrowShapes[ name ] = util.extend( {\n\t      name: name,\n\t\n\t      points: [\n\t        -0.15, -0.3,\n\t        0.15, -0.3,\n\t        0.15, 0.3,\n\t        -0.15, 0.3\n\t      ],\n\t\n\t      collide: function( x, y, size, angle, translation, padding ){\n\t        var points = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );\n\t        var inside = math.pointInsidePolygonPoints( x, y, points );\n\t\n\t        return inside;\n\t      },\n\t\n\t      roughCollide: bbCollide,\n\t\n\t      draw: function( context, size, angle, translation ){\n\t        var points = transformPoints( this.points, size, angle, translation );\n\t\n\t        renderer.arrowShapeImpl( 'polygon' )( context, points );\n\t      },\n\t\n\t      spacing: function( edge ){\n\t        return 0;\n\t      },\n\t\n\t      gap: function( edge ){\n\t        return edge.pstyle( 'width' ).pfValue * 2;\n\t      }\n\t    }, defn );\n\t  };\n\t\n\t  defineArrowShape( 'none', {\n\t    collide: util.falsify,\n\t\n\t    roughCollide: util.falsify,\n\t\n\t    draw: util.noop,\n\t\n\t    spacing: util.zeroify,\n\t\n\t    gap: util.zeroify\n\t  } );\n\t\n\t  defineArrowShape( 'triangle', {\n\t    points: [\n\t      -0.15, -0.3,\n\t      0, 0,\n\t      0.15, -0.3\n\t    ]\n\t  } );\n\t\n\t  defineArrowShape( 'arrow', 'triangle' );\n\t\n\t  defineArrowShape( 'triangle-backcurve', {\n\t    points: arrowShapes[ 'triangle' ].points,\n\t\n\t    controlPoint: [ 0, -0.15 ],\n\t\n\t    roughCollide: bbCollide,\n\t\n\t    draw: function( context, size, angle, translation ){\n\t      var ptsTrans = transformPoints( this.points, size, angle, translation );\n\t      var ctrlPt = this.controlPoint;\n\t      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );\n\t\n\t      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );\n\t    },\n\t\n\t    gap: function( edge ){\n\t      return edge.pstyle( 'width' ).pfValue;\n\t    }\n\t  } );\n\t\n\t\n\t  defineArrowShape( 'triangle-tee', {\n\t    points: [\n\t      -0.15, -0.3,\n\t      0, 0,\n\t      0.15, -0.3,\n\t      -0.15, -0.3\n\t    ],\n\t\n\t    pointsTee: [\n\t      -0.15, -0.4,\n\t      -0.15, -0.5,\n\t      0.15, -0.5,\n\t      0.15, -0.4\n\t    ],\n\t\n\t    collide: function( x, y, size, angle, translation, padding ){\n\t      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );\n\t      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2 * padding, angle, translation ) );\n\t\n\t      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );\n\t\n\t      return inside;\n\t    },\n\t\n\t    draw: function( context, size, angle, translation ){\n\t      var triPts = transformPoints( this.points, size, angle, translation );\n\t      var teePts = transformPoints( this.pointsTee, size, angle, translation );\n\t\n\t      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );\n\t    }\n\t  } );\n\t\n\t  defineArrowShape( 'vee', {\n\t    points: [\n\t      -0.15, -0.3,\n\t      0, 0,\n\t      0.15, -0.3,\n\t      0, -0.15\n\t    ],\n\t\n\t    gap: function( edge ){\n\t      return edge.pstyle( 'width' ).pfValue;\n\t    }\n\t  } );\n\t\n\t  defineArrowShape( 'circle', {\n\t    radius: 0.15,\n\t\n\t    collide: function( x, y, size, angle, translation, padding ){\n\t      var t = translation;\n\t      var inside = ( Math.pow( t.x - x, 2 ) + Math.pow( t.y - y, 2 ) <= Math.pow( (size + 2 * padding) * this.radius, 2 ) );\n\t\n\t      return inside;\n\t    },\n\t\n\t    draw: function( context, size, angle, translation ){\n\t      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );\n\t    },\n\t\n\t    spacing: function( edge ){\n\t      return renderer.getArrowWidth( edge.pstyle( 'width' ).pfValue )\n\t        * this.radius;\n\t    }\n\t  } );\n\t\n\t  defineArrowShape( 'inhibitor', {\n\t    points: [\n\t      -0.15, 0,\n\t      -0.15, -0.1,\n\t      0.15, -0.1,\n\t      0.15, 0\n\t    ],\n\t\n\t    spacing: function( edge ){\n\t      return 1;\n\t    },\n\t\n\t    gap: function( edge ){\n\t      return 1;\n\t    }\n\t  } );\n\t\n\t  defineArrowShape( 'tee', 'inhibitor' );\n\t\n\t  defineArrowShape( 'square', {\n\t    points: [\n\t      -0.15, 0.00,\n\t      0.15, 0.00,\n\t      0.15, -0.3,\n\t      -0.15, -0.3\n\t    ]\n\t  } );\n\t\n\t  defineArrowShape( 'diamond', {\n\t    points: [\n\t      -0.15, -0.15,\n\t      0, -0.3,\n\t      0.15, -0.15,\n\t      0, 0\n\t    ],\n\t\n\t    gap: function( edge ){\n\t      return edge.pstyle( 'width' ).pfValue;\n\t    }\n\t  } );\n\t\n\t};\n\t\n\tmodule.exports = BRp;\n\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar math = __webpack_require__( 33 );\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\tvar zIndexSort = __webpack_require__( 72 );\n\t\n\tvar BRp = {};\n\t\n\tBRp.registerCalculationListeners = function(){\n\t  var cy = this.cy;\n\t  var elesToUpdate = cy.collection();\n\t  var r = this;\n\t\n\t  var enqueue = function( eles, e ){\n\t    elesToUpdate.merge( eles );\n\t\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[i];\n\t      var _p = ele._private;\n\t      var rstyle = _p.rstyle;\n\t\n\t      rstyle.clean = false;\n\t      _p.bbCache = null;\n\t\n\t      var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };\n\t\n\t      if( !evts[ e.type ] ){\n\t        evts[ e.type ] = true;\n\t        evts.length++;\n\t//\n\t        // elesToUpdate.merge( ele );\n\t      }\n\t    }\n\t  };\n\t\n\t  r.binder( cy )\n\t    // nodes\n\t\n\t    .on('position.* style.* free.*', 'node', function onDirtyModNode( e ){\n\t      var node = e.cyTarget;\n\t\n\t      enqueue( node, e );\n\t      enqueue( node.connectedEdges(), e );\n\t\n\t      if( cy.hasCompoundNodes() ){\n\t        var parents = node.parents();\n\t\n\t        enqueue( parents, e );\n\t        enqueue( parents.connectedEdges(), e );\n\t      }\n\t    })\n\t\n\t    .on('add.* background.*', 'node', function onDirtyAddNode( e ){\n\t      var ele = e.cyTarget;\n\t\n\t      enqueue( ele, e );\n\t    })\n\t\n\t    // edges\n\t\n\t    .on('add.* style.*', 'edge', function onDirtyEdge( e ){\n\t      var edge = e.cyTarget;\n\t\n\t      enqueue( edge, e );\n\t      enqueue( edge.parallelEdges(), e );\n\t    })\n\t\n\t    .on('remove.*', 'edge', function onDirtyRemoveEdge( e ){\n\t      var edge = e.cyTarget;\n\t      var pEdges = edge.parallelEdges();\n\t\n\t      for( var i = 0; i < pEdges.length; i++ ){\n\t        var pEdge = pEdges[i];\n\t\n\t        if( !pEdge.removed() ){\n\t          enqueue( pEdge, e );\n\t        }\n\t      }\n\t    })\n\t  ;\n\t\n\t  var updateEleCalcs = function( willDraw ){\n\t    if( willDraw ){\n\t      var fns = r.onUpdateEleCalcsFns;\n\t\n\t      if( fns ){ for( var i = 0; i < fns.length; i++ ){\n\t        var fn = fns[i];\n\t\n\t        fn( willDraw, elesToUpdate );\n\t      } }\n\t\n\t      r.recalculateRenderedStyle( elesToUpdate, false );\n\t\n\t      for( var i = 0; i < elesToUpdate.length; i++ ){\n\t        elesToUpdate[i]._private.rstyle.dirtyEvents = null;\n\t      }\n\t\n\t      elesToUpdate = cy.collection();\n\t    }\n\t  };\n\t\n\t  r.beforeRender( updateEleCalcs, r.beforeRenderPriorities.eleCalcs );\n\t};\n\t\n\tBRp.onUpdateEleCalcs = function( fn ){\n\t  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n\t\n\t  fns.push( fn );\n\t};\n\t\n\tBRp.recalculateRenderedStyle = function( eles, useCache ){\n\t  var edges = [];\n\t  var nodes = [];\n\t\n\t  // use cache by default for perf\n\t  if( useCache === undefined ){ useCache = true; }\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[ i ];\n\t    var _p = ele._private;\n\t    var rstyle = _p.rstyle;\n\t\n\t    // only update if dirty and in graph\n\t    if( (useCache && rstyle.clean) || ele.removed() ){ continue; }\n\t\n\t    if( _p.group === 'nodes' ){\n\t      var pos = _p.position;\n\t\n\t      nodes.push( ele );\n\t\n\t      rstyle.nodeX = pos.x;\n\t      rstyle.nodeY = pos.y;\n\t      rstyle.nodeW = ele.pstyle( 'width' ).pfValue;\n\t      rstyle.nodeH = ele.pstyle( 'height' ).pfValue;\n\t    } else { // edges\n\t\n\t      edges.push( ele );\n\t\n\t    } // if edges\n\t\n\t    rstyle.clean = true;\n\t    // rstyle.dirtyEvents = null;\n\t  }\n\t\n\t  this.recalculateEdgeProjections( edges );\n\t  this.recalculateLabelProjections( nodes, edges );\n\t\n\t  // update edge data from projections\n\t  for( var i = 0; i < edges.length; i++ ){\n\t    var ele = edges[ i ];\n\t    var _p = ele._private;\n\t    var rstyle = _p.rstyle;\n\t    var rs = _p.rscratch;\n\t\n\t    // update rstyle positions\n\t    rstyle.srcX = rs.arrowStartX;\n\t    rstyle.srcY = rs.arrowStartY;\n\t    rstyle.tgtX = rs.arrowEndX;\n\t    rstyle.tgtY = rs.arrowEndY;\n\t    rstyle.midX = rs.midX;\n\t    rstyle.midY = rs.midY;\n\t  }\n\t};\n\t\n\t// Project mouse\n\tBRp.projectIntoViewport = function( clientX, clientY ){\n\t  var offsets = this.findContainerClientCoords();\n\t  var offsetLeft = offsets[0];\n\t  var offsetTop = offsets[1];\n\t\n\t  var x = clientX - offsetLeft;\n\t  var y = clientY - offsetTop;\n\t\n\t  x -= this.cy.pan().x; y -= this.cy.pan().y; x /= this.cy.zoom(); y /= this.cy.zoom();\n\t  return [ x, y ];\n\t};\n\t\n\tBRp.findContainerClientCoords = function(){\n\t  var container = this.container;\n\t\n\t  var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();\n\t\n\t  return [ bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top ];\n\t};\n\t\n\tBRp.invalidateContainerClientCoordsCache = function(){\n\t  this.containerBB = null;\n\t};\n\t\n\tBRp.findNearestElement = function( x, y, visibleElementsOnly, isTouch ){\n\t  return this.findNearestElements( x, y, visibleElementsOnly, isTouch )[0];\n\t};\n\t\n\tBRp.findNearestElements = function( x, y, visibleElementsOnly, isTouch ){\n\t  var self = this;\n\t  var r = this;\n\t  var eles = r.getCachedZSortedEles();\n\t  var near = []; // 1 node max, 1 edge max\n\t  var zoom = r.cy.zoom();\n\t  var hasCompounds = r.cy.hasCompoundNodes();\n\t  var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n\t  var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n\t  var labelThreshold = (isTouch ? 8 : 2) / zoom;\n\t  var minSqDist = Infinity;\n\t  var nearEdge;\n\t  var nearNode;\n\t\n\t  function addEle( ele, sqDist ){\n\t    if( ele.isNode() ){\n\t      if( nearNode ){\n\t        return; // can't replace node\n\t      } else {\n\t        nearNode = ele;\n\t        near.push( ele );\n\t      }\n\t    }\n\t\n\t    if( ele.isEdge() && ( sqDist == null || sqDist < minSqDist ) ){\n\t      if( nearEdge ){ // then replace existing edge\n\t        // can replace only if same z-index\n\t        if( nearEdge.pstyle( 'z-index' ).value === ele.pstyle('z-index').value ){\n\t          for( var i = 0; i < near.length; i++ ){\n\t            if( near[i].isEdge() ){\n\t              near[i] = ele;\n\t              nearEdge = ele;\n\t              minSqDist = sqDist != null ? sqDist : minSqDist;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        near.push( ele );\n\t        nearEdge = ele;\n\t        minSqDist = sqDist != null ? sqDist : minSqDist;\n\t      }\n\t    }\n\t  }\n\t\n\t  function checkNode( node ){\n\t    var _p = node._private;\n\t\n\t    if( node.pstyle( 'events' ).strValue === 'no' ){ return; }\n\t\n\t    var width = node.outerWidth() + 2 * nodeThreshold;\n\t    var height = node.outerHeight() + 2 * nodeThreshold;\n\t    var hw = width / 2;\n\t    var hh = height / 2;\n\t    var pos = _p.position;\n\t\n\t    if(\n\t      pos.x - hw <= x && x <= pos.x + hw // bb check x\n\t        &&\n\t      pos.y - hh <= y && y <= pos.y + hh // bb check y\n\t    ){\n\t      var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );\n\t\n\t      // exit early if invisible edge and must be visible\n\t      if( visibleElementsOnly && !visible ){\n\t        return;\n\t      }\n\t\n\t      var shape = r.nodeShapes[ self.getNodeShape( node ) ];\n\t\n\t      if(\n\t        shape.checkPoint( x, y, 0, width, height, pos.x, pos.y )\n\t      ){\n\t        addEle( node, 0 );\n\t      }\n\t\n\t    }\n\t  }\n\t\n\t  function checkEdge( edge ){\n\t    var _p = edge._private;\n\t\n\t    if( edge.pstyle('events').strValue === 'no' ){ return; }\n\t\n\t    var rs = _p.rscratch;\n\t    var width = edge.pstyle( 'width' ).pfValue / 2 + edgeThreshold; // more like a distance radius from centre\n\t    var widthSq = width * width;\n\t    var width2 = width * 2;\n\t    var src = _p.source;\n\t    var tgt = _p.target;\n\t    var inEdgeBB = false;\n\t    var sqDist;\n\t\n\t    // exit early if invisible edge and must be visible\n\t    var passedVisibilityCheck;\n\t    var passesVisibilityCheck = function(){\n\t      if( passedVisibilityCheck !== undefined ){\n\t        return passedVisibilityCheck;\n\t      }\n\t\n\t      if( !visibleElementsOnly ){\n\t        passedVisibilityCheck = true;\n\t        return true;\n\t      }\n\t\n\t      var visible = edge.visible() && !edge.transparent();\n\t      if( visible ){\n\t        passedVisibilityCheck = true;\n\t        return true;\n\t      }\n\t\n\t      passedVisibilityCheck = false;\n\t      return false;\n\t    };\n\t\n\t    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){\n\t      var pts = rs.allpts;\n\t\n\t      for( var i = 0; i + 3 < pts.length; i += 2 ){\n\t        if(\n\t          (inEdgeBB = math.inLineVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], width2 ))\n\t            && passesVisibilityCheck() &&\n\t          widthSq > ( sqDist = math.sqdistToFiniteLine( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] ) )\n\t        ){\n\t          addEle( edge, sqDist );\n\t        }\n\t      }\n\t\n\t    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){\n\t      var pts = rs.allpts;\n\t      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){\n\t        if(\n\t          (inEdgeBB = math.inBezierVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5], width2 ))\n\t            && passesVisibilityCheck() &&\n\t          (widthSq > (sqDist = math.sqdistToQuadraticBezier( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5] )) )\n\t        ){\n\t          addEle( edge, sqDist );\n\t        }\n\t      }\n\t    }\n\t\n\t    // if we're close to the edge but didn't hit it, maybe we hit its arrows\n\t    if( inEdgeBB && passesVisibilityCheck() ){\n\t      var src = src || _p.source;\n\t      var tgt = tgt || _p.target;\n\t\n\t      var eWidth = edge.pstyle( 'width' ).pfValue;\n\t      var arSize = self.getArrowWidth( eWidth );\n\t\n\t      var arrows = [\n\t        { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },\n\t        { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },\n\t        { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },\n\t        { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }\n\t      ];\n\t\n\t      for( var i = 0; i < arrows.length; i++ ){\n\t        var ar = arrows[ i ];\n\t        var shape = r.arrowShapes[ edge.pstyle( ar.name + '-arrow-shape' ).value ];\n\t\n\t        if(\n\t          shape.roughCollide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )\n\t           &&\n\t          shape.collide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )\n\t        ){\n\t          addEle( edge );\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n\t    if( hasCompounds && near.length > 0 ){\n\t      checkNode( src );\n\t      checkNode( tgt );\n\t    }\n\t  }\n\t\n\t  function preprop( obj, name, pre ){\n\t    return util.getPrefixedProperty( obj, name, pre );\n\t  }\n\t\n\t  function checkLabel( ele, prefix ){\n\t    var _p = ele._private;\n\t    var th = labelThreshold;\n\t\n\t    var prefixDash;\n\t    if( prefix ){\n\t      prefixDash = prefix + '-';\n\t    } else {\n\t      prefixDash = '';\n\t    }\n\t\n\t    if( ele.pstyle( 'text-events' ).strValue === 'no' ){ return; }\n\t\n\t    var rotation = ele.pstyle( prefixDash + 'text-rotation' );\n\t\n\t    // adjust bb w/ angle\n\t    if( rotation.strValue === 'autorotate' || !!rotation.pfValue ){\n\t\n\t      var rstyle = _p.rstyle;\n\t      var bw = ele.pstyle('text-border-width').pfValue;\n\t      var lw = preprop( rstyle, 'labelWidth', prefix ) + bw/2 + 2*th;\n\t      var lh = preprop( rstyle, 'labelHeight', prefix ) + bw/2 + 2*th;\n\t      var lx = preprop( rstyle, 'labelX', prefix );\n\t      var ly = preprop( rstyle, 'labelY', prefix );\n\t\n\t      var theta = preprop( _p.rscratch, 'labelAngle', prefix );\n\t      var cos = Math.cos( theta );\n\t      var sin = Math.sin( theta );\n\t\n\t      var rotate = function( x, y ){\n\t        x = x - lx;\n\t        y = y - ly;\n\t\n\t        return {\n\t          x: x * cos - y * sin + lx,\n\t          y: x * sin + y * cos + ly\n\t        };\n\t      };\n\t\n\t      var lx1 = lx - lw / 2;\n\t      var lx2 = lx + lw / 2;\n\t      var ly1 = ly - lh / 2;\n\t      var ly2 = ly + lh / 2;\n\t\n\t      var px1y1 = rotate( lx1, ly1 );\n\t      var px1y2 = rotate( lx1, ly2 );\n\t      var px2y1 = rotate( lx2, ly1 );\n\t      var px2y2 = rotate( lx2, ly2 );\n\t\n\t      var points = [\n\t        px1y1.x, px1y1.y,\n\t        px2y1.x, px2y1.y,\n\t        px2y2.x, px2y2.y,\n\t        px1y2.x, px1y2.y\n\t      ];\n\t\n\t      if( math.pointInsidePolygonPoints( x, y, points ) ){\n\t        addEle( ele );\n\t      }\n\t\n\t    } else {\n\t      var bb = ele.boundingBox( {\n\t        includeLabels: true,\n\t        includeNodes: false,\n\t        includeEdges: false\n\t      } );\n\t\n\t      // adjust bb w/ threshold\n\t      bb.x1 -= th;\n\t      bb.y1 -= th;\n\t      bb.x2 += th;\n\t      bb.y2 += th;\n\t      bb.w = bb.x2 - bb.x1;\n\t      bb.h = bb.y2 - bb.y1;\n\t\n\t      if( math.inBoundingBox( bb, x, y ) ){\n\t        addEle( ele );\n\t      }\n\t    }\n\t\n\t  }\n\t\n\t  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence\n\t    var ele = eles[ i ];\n\t\n\t    if( ele.isNode() ){\n\t      checkNode( ele );\n\t\n\t      checkLabel( ele );\n\t\n\t    } else { // then edge\n\t      checkEdge( ele );\n\t\n\t      checkLabel( ele );\n\t      checkLabel( ele, 'source' );\n\t      checkLabel( ele, 'target' );\n\t    }\n\t  }\n\t\n\t  return near;\n\t};\n\t\n\t// 'Give me everything from this box'\n\tBRp.getAllInBox = function( x1, y1, x2, y2 ){\n\t  var eles = this.getCachedZSortedEles();\n\t  var nodes = eles.nodes;\n\t  var edges = eles.edges;\n\t  var box = [];\n\t\n\t  var x1c = Math.min( x1, x2 );\n\t  var x2c = Math.max( x1, x2 );\n\t  var y1c = Math.min( y1, y2 );\n\t  var y2c = Math.max( y1, y2 );\n\t\n\t  x1 = x1c;\n\t  x2 = x2c;\n\t  y1 = y1c;\n\t  y2 = y2c;\n\t\n\t  var boxBb = math.makeBoundingBox( {\n\t    x1: x1, y1: y1,\n\t    x2: x2, y2: y2\n\t  } );\n\t\n\t  for( var i = 0; i < nodes.length; i++ ){\n\t    var node = nodes[ i ];\n\t    var nodeBb = node.boundingBox( {\n\t      includeNodes: true,\n\t      includeEdges: false,\n\t      includeLabels: false,\n\t      includeShadows: false\n\t    } );\n\t\n\t    if( math.boundingBoxesIntersect( boxBb, nodeBb ) ){\n\t      box.push( nodes[ i ] );\n\t    }\n\t  }\n\t\n\t  for( var e = 0; e < edges.length; e++ ){\n\t    var edge = edges[ e ];\n\t    var _p = edge._private;\n\t    var rs = _p.rscratch;\n\t\n\t    if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }\n\t    if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }\n\t\n\t    if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){\n\t\n\t      var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n\t      var allInside = true;\n\t\n\t      for( var i = 0; i < pts.length; i++ ){\n\t        if( !math.pointInBoundingBox( boxBb, pts[ i ] ) ){\n\t          allInside = false;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if( allInside ){\n\t        box.push( edge );\n\t      }\n\t\n\t    } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){\n\t      box.push( edge );\n\t    }\n\t\n\t  }\n\t\n\t  return box;\n\t};\n\t\n\t\n\t/**\n\t * Returns the shape of the given node. If the height or width of the given node\n\t * is set to auto, the node is considered to be a compound.\n\t *\n\t * @param node          a node\n\t * @return {String}     shape of the node\n\t */\n\tBRp.getNodeShape = function( node ){\n\t  var r = this;\n\t  var shape = node.pstyle( 'shape' ).value;\n\t\n\t  if( node.isParent() ){\n\t    if( shape === 'rectangle' || shape === 'roundrectangle' ){\n\t      return shape;\n\t    } else {\n\t      return 'rectangle';\n\t    }\n\t  }\n\t\n\t  if( shape === 'polygon' ){\n\t    var points = node.pstyle( 'shape-polygon-points' ).value;\n\t\n\t    return r.nodeShapes.makePolygon( points ).name;\n\t  }\n\t\n\t  return shape;\n\t};\n\t\n\tBRp.updateCachedZSortedEles = function(){\n\t  this.getCachedZSortedEles( true );\n\t};\n\t\n\tBRp.updateCachedGrabbedEles = function(){\n\t  var eles = this.cachedZSortedEles;\n\t\n\t  eles.drag = [];\n\t  eles.nondrag = [];\n\t\n\t  var grabTarget;\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[i];\n\t    var rs = ele._private.rscratch;\n\t\n\t    if( rs.isGrabTarget && !ele.isParent() ){\n\t      grabTarget = ele;\n\t    } else if( rs.inDragLayer ){\n\t      eles.drag.push( ele );\n\t    } else {\n\t      eles.nondrag.push( ele );\n\t    }\n\t  }\n\t\n\t  // put the grab target node last so it's on top of its neighbourhood\n\t  if( grabTarget ){\n\t    eles.drag.push( grabTarget );\n\t  }\n\t};\n\t\n\tBRp.getCachedZSortedEles = function( forceRecalc ){\n\t  if( forceRecalc || !this.cachedZSortedEles ){\n\t    //console.time('cachezorder')\n\t\n\t    var cyEles = this.cy.mutableElements();\n\t    var eles = [];\n\t\n\t    eles.nodes = [];\n\t    eles.edges = [];\n\t\n\t    for( var i = 0; i < cyEles.length; i++ ){\n\t      var ele = cyEles[i];\n\t\n\t      if( ele.animated() || (ele.visible() && !ele.transparent()) ){\n\t        eles.push( ele );\n\t\n\t        if( ele.isNode() ){\n\t          eles.nodes.push( ele );\n\t        } else {\n\t          eles.edges.push( ele );\n\t        }\n\t      }\n\t    }\n\t\n\t    eles.sort( zIndexSort );\n\t\n\t    this.cachedZSortedEles = eles;\n\t\n\t    this.updateCachedGrabbedEles();\n\t\n\t    //console.log('make cache')\n\t\n\t    //console.timeEnd('cachezorder')\n\t  } else {\n\t    eles = this.cachedZSortedEles;\n\t    //console.log('read cache')\n\t  }\n\t\n\t  return eles;\n\t};\n\t\n\tfunction pushBezierPts( r, edge, pts ){\n\t  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt( p1, p2, p3, t ); };\n\t  var _p = edge._private;\n\t  var bpts = _p.rstyle.bezierPts;\n\t\n\t  for( var i = 0; i < r.bezierProjPcts.length; i++ ){\n\t    var p = r.bezierProjPcts[i];\n\t\n\t    bpts.push( {\n\t      x: qbezierAt( pts[0], pts[2], pts[4], p ),\n\t      y: qbezierAt( pts[1], pts[3], pts[5], p )\n\t    } );\n\t  }\n\t}\n\t\n\tBRp.projectLines = function( edge ){\n\t  var _p = edge._private;\n\t  var rs = _p.rscratch;\n\t  var et = rs.edgeType;\n\t\n\t  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){\n\t    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line\n\t\n\t    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){\n\t      pushBezierPts( this, edge, rs.allpts.slice( i, i + 6 ) );\n\t    }\n\t  } else if(  et === 'segments' ){\n\t    var lpts = _p.rstyle.linePts = [];\n\t\n\t    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){\n\t      lpts.push( {\n\t        x: rs.allpts[ i ],\n\t        y: rs.allpts[ i + 1]\n\t      } );\n\t    }\n\t  } else if( et === 'haystack' ){\n\t    var hpts = rs.haystackPts;\n\t\n\t    _p.rstyle.haystackPts = [\n\t      { x: hpts[0], y: hpts[1] },\n\t      { x: hpts[2], y: hpts[3] }\n\t    ];\n\t  }\n\t\n\t  _p.rstyle.arrowWidth = this.getArrowWidth( edge.pstyle('width').pfValue ) * this.arrowShapeWidth;\n\t};\n\t\n\tBRp.projectBezier = BRp.projectLines;\n\t\n\tBRp.recalculateNodeLabelProjection = function( node ){\n\t  var content = node.pstyle( 'label' ).strValue;\n\t\n\t  if( is.emptyString(content) ){ return; }\n\t\n\t  var textX, textY;\n\t  var _p = node._private;\n\t  var nodeWidth = node.width();\n\t  var nodeHeight = node.height();\n\t  var paddingLeft = node.pstyle('padding-left').pfValue;\n\t  var paddingRight = node.pstyle('padding-right').pfValue;\n\t  var paddingTop = node.pstyle('padding-top').pfValue;\n\t  var paddingBottom = node.pstyle('padding-bottom').pfValue;\n\t  var nodePos = _p.position;\n\t  var textHalign = node.pstyle( 'text-halign' ).strValue;\n\t  var textValign = node.pstyle( 'text-valign' ).strValue;\n\t  var rs = _p.rscratch;\n\t  var rstyle = _p.rstyle;\n\t\n\t  switch( textHalign ){\n\t    case 'left':\n\t      textX = nodePos.x - nodeWidth / 2 - paddingLeft;\n\t      break;\n\t\n\t    case 'right':\n\t      textX = nodePos.x + nodeWidth / 2 + paddingRight;\n\t      break;\n\t\n\t    default: // e.g. center\n\t      textX = nodePos.x;\n\t  }\n\t\n\t  switch( textValign ){\n\t    case 'top':\n\t      textY = nodePos.y - nodeHeight / 2 - paddingTop;\n\t      break;\n\t\n\t    case 'bottom':\n\t      textY = nodePos.y + nodeHeight / 2 + paddingBottom;\n\t      break;\n\t\n\t    default: // e.g. middle\n\t      textY = nodePos.y;\n\t  }\n\t\n\t  rs.labelX = textX;\n\t  rs.labelY = textY;\n\t  rstyle.labelX = textX;\n\t  rstyle.labelY = textY;\n\t\n\t  this.applyLabelDimensions( node );\n\t};\n\t\n\tBRp.recalculateEdgeLabelProjections = function( edge ){\n\t  var p;\n\t  var _p = edge._private;\n\t  var rs = _p.rscratch;\n\t  var r = this;\n\t  var content = {\n\t    mid: edge.pstyle('label').strValue,\n\t    source: edge.pstyle('source-label').strValue,\n\t    target: edge.pstyle('target-label').strValue\n\t  };\n\t\n\t  if( content.mid || content.source || content.target ){\n\t    // then we have to calculate...\n\t  } else {\n\t    return; // no labels => no calcs\n\t  }\n\t\n\t  // add center point to style so bounding box calculations can use it\n\t  //\n\t  p = {\n\t    x: rs.midX,\n\t    y: rs.midY\n\t  };\n\t\n\t  var setRs = function( propName, prefix, value ){\n\t    util.setPrefixedProperty( _p.rscratch, propName, prefix, value );\n\t    util.setPrefixedProperty( _p.rstyle, propName, prefix, value );\n\t  };\n\t\n\t  setRs( 'labelX', null, p.x );\n\t  setRs( 'labelY', null, p.y );\n\t\n\t  var createControlPointInfo = function(){\n\t    if( createControlPointInfo.cache ){ return createControlPointInfo.cache; } // use cache so only 1x per edge\n\t\n\t    var ctrlpts = [];\n\t\n\t    // store each ctrlpt info init\n\t    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){\n\t      var p0 = { x: rs.allpts[i], y: rs.allpts[i+1] };\n\t      var p1 = { x: rs.allpts[i+2], y: rs.allpts[i+3] }; // ctrlpt\n\t      var p2 = { x: rs.allpts[i+4], y: rs.allpts[i+5] };\n\t\n\t      ctrlpts.push({\n\t        p0: p0,\n\t        p1: p1,\n\t        p2: p2,\n\t        startDist: 0,\n\t        length: 0,\n\t        segments: []\n\t      });\n\t    }\n\t\n\t    var bpts = _p.rstyle.bezierPts;\n\t    var nProjs = r.bezierProjPcts.length;\n\t\n\t    function addSegment( cp, p0, p1, t0, t1 ){\n\t      var length = math.dist( p0, p1 );\n\t      var prevSegment = cp.segments[ cp.segments.length - 1 ];\n\t      var segment = {\n\t        p0: p0,\n\t        p1: p1,\n\t        t0: t0,\n\t        t1: t1,\n\t        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n\t        length: length\n\t      };\n\t\n\t      cp.segments.push( segment );\n\t\n\t      cp.length += length;\n\t    }\n\t\n\t    // update each ctrlpt with segment info\n\t    for( var i = 0; i < ctrlpts.length; i++ ){\n\t      var cp = ctrlpts[i];\n\t      var prevCp = ctrlpts[i - 1];\n\t\n\t      if( prevCp ){\n\t        cp.startDist = prevCp.startDist + prevCp.length;\n\t      }\n\t\n\t      addSegment(\n\t        cp,\n\t        cp.p0,   bpts[ i * nProjs ],\n\t        0,       r.bezierProjPcts[ 0 ]\n\t      ); // first\n\t\n\t      for( var j = 0; j < nProjs - 1; j++ ){\n\t        addSegment(\n\t          cp,\n\t          bpts[ i * nProjs + j ],   bpts[ i * nProjs + j + 1 ],\n\t          r.bezierProjPcts[ j ],    r.bezierProjPcts[ j + 1 ]\n\t        );\n\t      }\n\t\n\t      addSegment(\n\t        cp,\n\t        bpts[ i * nProjs + nProjs - 1 ],   cp.p2,\n\t        r.bezierProjPcts[ nProjs - 1 ],    1\n\t      ); // last\n\t    }\n\t\n\t    return ( createControlPointInfo.cache = ctrlpts );\n\t  };\n\t\n\t  var calculateEndProjection = function( prefix ){\n\t    var angle;\n\t    var isSrc = prefix === 'source';\n\t\n\t    if( !content[ prefix ] ){ return; }\n\t\n\t    var offset = edge.pstyle(prefix+'-text-offset').pfValue;\n\t\n\t    var lineAngle = function( p0, p1 ){\n\t      var dx = p1.x - p0.x;\n\t      var dy = p1.y - p0.y;\n\t\n\t      return Math.atan( dy / dx );\n\t    };\n\t\n\t    var bezierAngle = function( p0, p1, p2, t ){\n\t      var t0 = math.bound( 0, t - 0.001, 1 );\n\t      var t1 = math.bound( 0, t + 0.001, 1 );\n\t\n\t      var lp0 = math.qbezierPtAt( p0, p1, p2, t0 );\n\t      var lp1 = math.qbezierPtAt( p0, p1, p2, t1 );\n\t\n\t      return lineAngle( lp0, lp1 );\n\t    };\n\t\n\t    switch( rs.edgeType ){\n\t      case 'self':\n\t      case 'compound':\n\t      case 'bezier':\n\t      case 'multibezier':\n\t        var cps = createControlPointInfo();\n\t        var selected;\n\t        var startDist = 0;\n\t        var totalDist = 0;\n\t\n\t        // find the segment we're on\n\t        for( var i = 0; i < cps.length; i++ ){\n\t          var cp = cps[ isSrc ? i : cps.length - 1 - i ];\n\t\n\t          for( var j = 0; j < cp.segments.length; j++ ){\n\t            var seg = cp.segments[ isSrc ? j : cp.segments.length - 1 - j ];\n\t            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;\n\t\n\t            startDist = totalDist;\n\t            totalDist += seg.length;\n\t\n\t            if( totalDist >= offset || lastSeg ){\n\t              selected = { cp: cp, segment: seg };\n\t              break;\n\t            }\n\t          }\n\t\n\t          if( selected ){ break; }\n\t        }\n\t\n\t        var cp = selected.cp;\n\t        var seg = selected.segment;\n\t        var tSegment = ( offset - startDist ) / ( seg.length );\n\t        var segDt = seg.t1 - seg.t0;\n\t        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n\t\n\t        t = math.bound( 0, t, 1 );\n\t        p = math.qbezierPtAt( cp.p0, cp.p1, cp.p2, t );\n\t        angle = bezierAngle( cp.p0, cp.p1, cp.p2, t, p );\n\t\n\t        break;\n\t\n\t      case 'straight':\n\t      case 'segments':\n\t      case 'haystack':\n\t        var d = 0, di, d0;\n\t        var p0, p1;\n\t        var l = rs.allpts.length;\n\t\n\t        for( var i = 0; i + 3 < l; i += 2 ){\n\t          if( isSrc ){\n\t            p0 = { x: rs.allpts[i],     y: rs.allpts[i+1] };\n\t            p1 = { x: rs.allpts[i+2],   y: rs.allpts[i+3] };\n\t          } else {\n\t            p0 = { x: rs.allpts[l-2-i], y: rs.allpts[l-1-i] };\n\t            p1 = { x: rs.allpts[l-4-i], y: rs.allpts[l-3-i] };\n\t          }\n\t\n\t          di = math.dist( p0, p1 );\n\t          d0 = d;\n\t          d += di;\n\t\n\t          if( d >= offset ){ break; }\n\t        }\n\t\n\t        var pD = offset - d0;\n\t        var t = pD / di;\n\t\n\t        t  = math.bound( 0, t, 1 );\n\t        p = math.lineAt( p0, p1, t );\n\t        angle = lineAngle( p0, p1 );\n\t\n\t        break;\n\t    }\n\t\n\t    setRs( 'labelX', prefix, p.x );\n\t    setRs( 'labelY', prefix, p.y );\n\t    setRs( 'labelAutoAngle', prefix, angle );\n\t  };\n\t\n\t  calculateEndProjection( 'source' );\n\t  calculateEndProjection( 'target' );\n\t\n\t  this.applyLabelDimensions( edge );\n\t};\n\t\n\tBRp.applyLabelDimensions = function( ele ){\n\t  this.applyPrefixedLabelDimensions( ele );\n\t\n\t  if( ele.isEdge() ){\n\t    this.applyPrefixedLabelDimensions( ele, 'source' );\n\t    this.applyPrefixedLabelDimensions( ele, 'target' );\n\t  }\n\t};\n\t\n\tBRp.applyPrefixedLabelDimensions = function( ele, prefix ){\n\t  var _p = ele._private;\n\t\n\t  var text = this.getLabelText( ele, prefix );\n\t  var labelDims = this.calculateLabelDimensions( ele, text );\n\t\n\t  util.setPrefixedProperty( _p.rstyle,   'labelWidth', prefix, labelDims.width );\n\t  util.setPrefixedProperty( _p.rscratch, 'labelWidth', prefix, labelDims.width );\n\t\n\t  util.setPrefixedProperty( _p.rstyle,   'labelHeight', prefix, labelDims.height );\n\t  util.setPrefixedProperty( _p.rscratch, 'labelHeight', prefix, labelDims.height );\n\t};\n\t\n\tBRp.getLabelText = function( ele, prefix ){\n\t  var _p = ele._private;\n\t  var pfd = prefix ? prefix + '-' : '';\n\t  var text = ele.pstyle( pfd + 'label' ).strValue;\n\t  var textTransform = ele.pstyle( 'text-transform' ).value;\n\t  var rscratch = function( propName, value ){\n\t    if( value ){\n\t      util.setPrefixedProperty( _p.rscratch, propName, prefix, value );\n\t      return value;\n\t    } else {\n\t      return util.getPrefixedProperty( _p.rscratch, propName, prefix );\n\t    }\n\t  };\n\t\n\t  if( textTransform == 'none' ){\n\t  } else if( textTransform == 'uppercase' ){\n\t    text = text.toUpperCase();\n\t  } else if( textTransform == 'lowercase' ){\n\t    text = text.toLowerCase();\n\t  }\n\t\n\t  if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){\n\t    //console.log('wrap');\n\t\n\t    var labelKey = rscratch( 'labelKey' );\n\t\n\t    // save recalc if the label is the same as before\n\t    if( labelKey && rscratch( 'labelWrapKey' ) === labelKey ){\n\t      // console.log('wrap cache hit');\n\t      return rscratch( 'labelWrapCachedText' );\n\t    }\n\t    // console.log('wrap cache miss');\n\t\n\t    var lines = text.split( '\\n' );\n\t    var maxW = ele.pstyle( 'text-max-width' ).pfValue;\n\t    var wrappedLines = [];\n\t\n\t    for( var l = 0; l < lines.length; l++ ){\n\t      var line = lines[ l ];\n\t      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );\n\t      var lineW = lineDims.width;\n\t\n\t      if( lineW > maxW ){ // line is too long\n\t        var words = line.split( /\\s+/ ); // NB: assume collapsed whitespace into single space\n\t        var subline = '';\n\t\n\t        for( var w = 0; w < words.length; w++ ){\n\t          var word = words[ w ];\n\t          var testLine = subline.length === 0 ? word : subline + ' ' + word;\n\t          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );\n\t          var testW = testDims.width;\n\t\n\t          if( testW <= maxW ){ // word fits on current line\n\t            subline += word + ' ';\n\t          } else { // word starts new line\n\t            wrappedLines.push( subline );\n\t            subline = word + ' ';\n\t          }\n\t        }\n\t\n\t        // if there's remaining text, put it in a wrapped line\n\t        if( !subline.match( /^\\s+$/ ) ){\n\t          wrappedLines.push( subline );\n\t        }\n\t      } else { // line is already short enough\n\t        wrappedLines.push( line );\n\t      }\n\t    } // for\n\t\n\t    rscratch( 'labelWrapCachedLines', wrappedLines );\n\t    text = rscratch( 'labelWrapCachedText', wrappedLines.join( '\\n' ) );\n\t    rscratch( 'labelWrapKey', labelKey );\n\t\n\t    // console.log(text)\n\t  } // if wrap\n\t\n\t  return text;\n\t};\n\t\n\tBRp.calculateLabelDimensions = function( ele, text, extraKey ){\n\t  var r = this;\n\t\n\t  var cacheKey = ele._private.labelStyleKey + '$@$' + text;\n\t\n\t  if( extraKey ){\n\t    cacheKey += '$@$' + extraKey;\n\t  }\n\t\n\t  var cache = r.labelDimCache || (r.labelDimCache = {});\n\t\n\t  if( cache[ cacheKey ] ){\n\t    return cache[ cacheKey ];\n\t  }\n\t\n\t  var fStyle = ele.pstyle( 'font-style' ).strValue;\n\t  var size = ele.pstyle( 'font-size' ).pfValue + 'px';\n\t  var family = ele.pstyle( 'font-family' ).strValue;\n\t  var weight = ele.pstyle( 'font-weight' ).strValue;\n\t\n\t  var div = this.labelCalcDiv;\n\t\n\t  if( !div ){\n\t    div = this.labelCalcDiv = document.createElement( 'div' );\n\t    document.body.appendChild( div );\n\t  }\n\t\n\t  var ds = div.style;\n\t\n\t  // from ele style\n\t  ds.fontFamily = family;\n\t  ds.fontStyle = fStyle;\n\t  ds.fontSize = size;\n\t  ds.fontWeight = weight;\n\t\n\t  // forced style\n\t  ds.position = 'absolute';\n\t  ds.left = '-9999px';\n\t  ds.top = '-9999px';\n\t  ds.zIndex = '-1';\n\t  ds.visibility = 'hidden';\n\t  ds.pointerEvents = 'none';\n\t  ds.padding = '0';\n\t  ds.lineHeight = '1';\n\t\n\t  if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){\n\t    ds.whiteSpace = 'pre'; // so newlines are taken into account\n\t  } else {\n\t    ds.whiteSpace = 'normal';\n\t  }\n\t\n\t  // put label content in div\n\t  div.textContent = text;\n\t\n\t  cache[ cacheKey ] = {\n\t    width: div.clientWidth,\n\t    height: div.clientHeight\n\t  };\n\t\n\t  return cache[ cacheKey ];\n\t};\n\t\n\tBRp.recalculateLabelProjections = function( nodes, edges ){\n\t  for( var i = 0; i < nodes.length; i++ ){\n\t    this.recalculateNodeLabelProjection( nodes[ i ] );\n\t  }\n\t\n\t  for( var i = 0; i < edges.length; i++ ){\n\t    this.recalculateEdgeLabelProjections( edges[ i ] );\n\t  }\n\t};\n\t\n\tBRp.recalculateEdgeProjections = function( edges ){\n\t  this.findEdgeControlPoints( edges );\n\t};\n\t\n\t\n\t// Find edge control points\n\tBRp.findEdgeControlPoints = function( edges ){\n\t  if( !edges || edges.length === 0 ){ return; }\n\t\n\t  var r = this;\n\t  var cy = r.cy;\n\t  var hasCompounds = cy.hasCompoundNodes();\n\t  var hashTable = {};\n\t  var pairIds = [];\n\t  var haystackEdges = [];\n\t\n\t  // create a table of edge (src, tgt) => list of edges between them\n\t  var pairId;\n\t  for( var i = 0; i < edges.length; i++ ){\n\t    var edge = edges[ i ];\n\t    var _p = edge._private;\n\t    var data = _p.data;\n\t    var curveStyle = edge.pstyle( 'curve-style' ).value;\n\t    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n\t\n\t    // ignore edges who are not to be displayed\n\t    // they shouldn't take up space\n\t    if( edge.pstyle( 'display').value === 'none' ){\n\t      continue;\n\t    }\n\t\n\t    if( curveStyle === 'haystack' ){\n\t      haystackEdges.push( edge );\n\t      continue;\n\t    }\n\t\n\t    var srcId = data.source;\n\t    var tgtId = data.target;\n\t\n\t    pairId = srcId > tgtId ?\n\t      tgtId + '$-$' + srcId :\n\t      srcId + '$-$' + tgtId ;\n\t\n\t    if( edgeIsUnbundled ){\n\t      pairId = 'unbundled' + '$-$' + data.id;\n\t    }\n\t\n\t    if( hashTable[ pairId ] == null ){\n\t      hashTable[ pairId ] = [];\n\t      pairIds.push( pairId );\n\t    }\n\t\n\t    hashTable[ pairId ].push( edge );\n\t\n\t    if( edgeIsUnbundled ){\n\t      hashTable[ pairId ].hasUnbundled = true;\n\t    }\n\t  }\n\t\n\t  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;\n\t  var vectorNormInverse;\n\t  var badBezier;\n\t\n\t  // for each pair (src, tgt), create the ctrl pts\n\t  // Nested for loop is OK; total number of iterations for both loops = edgeCount\n\t  for( var p = 0; p < pairIds.length; p++ ){\n\t    pairId = pairIds[ p ];\n\t    var pairEdges = hashTable[ pairId ];\n\t\n\t    // for each pair id, the edges should be sorted by index\n\t    pairEdges.sort( function( edge1, edge2 ){\n\t      return edge1.poolIndex() - edge2.poolIndex();\n\t    } );\n\t\n\t    src = pairEdges[0]._private.source;\n\t    tgt = pairEdges[0]._private.target;\n\t\n\t    src_p = src._private;\n\t    tgt_p = tgt._private;\n\t\n\t    // make sure src/tgt distinction is consistent\n\t    // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)\n\t    if( src_p.data.id > tgt_p.data.id ){\n\t      var temp = src;\n\t      src = tgt;\n\t      tgt = temp;\n\t    }\n\t\n\t    srcPos = src_p.position;\n\t    tgtPos = tgt_p.position;\n\t\n\t    srcW = src.outerWidth();\n\t    srcH = src.outerHeight();\n\t\n\t    tgtW = tgt.outerWidth();\n\t    tgtH = tgt.outerHeight();\n\t\n\t    srcShape = r.nodeShapes[ this.getNodeShape( src ) ];\n\t    tgtShape = r.nodeShapes[ this.getNodeShape( tgt ) ];\n\t\n\t    badBezier = false;\n\t\n\t\n\t    if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){\n\t\n\t      // pt outside src shape to calc distance/displacement from src to tgt\n\t      var srcOutside = srcShape.intersectLine(\n\t        srcPos.x,\n\t        srcPos.y,\n\t        srcW,\n\t        srcH,\n\t        tgtPos.x,\n\t        tgtPos.y,\n\t        0\n\t      );\n\t\n\t      // pt outside tgt shape to calc distance/displacement from src to tgt\n\t      var tgtOutside = tgtShape.intersectLine(\n\t        tgtPos.x,\n\t        tgtPos.y,\n\t        tgtW,\n\t        tgtH,\n\t        srcPos.x,\n\t        srcPos.y,\n\t        0\n\t      );\n\t\n\t      var midptSrcPts = {\n\t        x1: srcOutside[0],\n\t        x2: tgtOutside[0],\n\t        y1: srcOutside[1],\n\t        y2: tgtOutside[1]\n\t      };\n\t\n\t      var posPts = {\n\t        x1: srcPos.x,\n\t        x2: tgtPos.x,\n\t        y1: srcPos.y,\n\t        y2: tgtPos.y\n\t      };\n\t\n\t      var dy = ( tgtOutside[1] - srcOutside[1] );\n\t      var dx = ( tgtOutside[0] - srcOutside[0] );\n\t      var l = Math.sqrt( dx * dx + dy * dy );\n\t\n\t      var vector = {\n\t        x: dx,\n\t        y: dy\n\t      };\n\t\n\t      var vectorNorm = {\n\t        x: vector.x / l,\n\t        y: vector.y / l\n\t      };\n\t      vectorNormInverse = {\n\t        x: -vectorNorm.y,\n\t        y: vectorNorm.x\n\t      };\n\t\n\t\n\t      // if node shapes overlap, then no ctrl pts to draw\n\t      if(\n\t        tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  &&\n\t        srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )\n\t      ){\n\t        vectorNormInverse = {};\n\t        badBezier = true;\n\t      }\n\t\n\t    }\n\t\n\t    var edge;\n\t    var edge_p;\n\t    var rs;\n\t\n\t    for( var i = 0; i < pairEdges.length; i++ ){\n\t      edge = pairEdges[ i ];\n\t      edge_p = edge._private;\n\t      rs = edge_p.rscratch;\n\t\n\t      var edgeIndex1 = rs.lastEdgeIndex;\n\t      var edgeIndex2 = i;\n\t\n\t      var numEdges1 = rs.lastNumEdges;\n\t      var numEdges2 = pairEdges.length;\n\t\n\t      var curveStyle = edge.pstyle( 'curve-style' ).value;\n\t      var ctrlptDists = edge.pstyle( 'control-point-distances' );\n\t      var ctrlptWs = edge.pstyle( 'control-point-weights' );\n\t      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;\n\t      var stepSize = edge.pstyle( 'control-point-step-size' ).pfValue;\n\t      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n\t      var ctrlptWeight = ctrlptWs.value[0];\n\t      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n\t\n\t      var swappedDirection = edge_p.source !== src;\n\t\n\t      if( swappedDirection && edgeIsUnbundled ){\n\t        ctrlptDist *= -1;\n\t      }\n\t\n\t      var srcX1 = rs.lastSrcCtlPtX;\n\t      var srcX2 = srcPos.x;\n\t      var srcY1 = rs.lastSrcCtlPtY;\n\t      var srcY2 = srcPos.y;\n\t      var srcW1 = rs.lastSrcCtlPtW;\n\t      var srcW2 = src.outerWidth();\n\t      var srcH1 = rs.lastSrcCtlPtH;\n\t      var srcH2 = src.outerHeight();\n\t\n\t      var tgtX1 = rs.lastTgtCtlPtX;\n\t      var tgtX2 = tgtPos.x;\n\t      var tgtY1 = rs.lastTgtCtlPtY;\n\t      var tgtY2 = tgtPos.y;\n\t      var tgtW1 = rs.lastTgtCtlPtW;\n\t      var tgtW2 = tgt.outerWidth();\n\t      var tgtH1 = rs.lastTgtCtlPtH;\n\t      var tgtH2 = tgt.outerHeight();\n\t\n\t      var width1 = rs.lastW;\n\t      var width2 = edge.pstyle( 'control-point-step-size' ).pfValue;\n\t\n\t      var edgeDistances = edge.pstyle('edge-distances').value;\n\t\n\t      if( badBezier ){\n\t        rs.badBezier = true;\n\t      } else {\n\t        rs.badBezier = false;\n\t      }\n\t\n\t      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2\n\t      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2\n\t      &&  width1 === width2\n\t      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){\n\t        // console.log('edge ctrl pt cache HIT')\n\t        continue; // then the control points haven't changed and we can skip calculating them\n\t      } else {\n\t        rs.lastSrcCtlPtX = srcX2;\n\t        rs.lastSrcCtlPtY = srcY2;\n\t        rs.lastSrcCtlPtW = srcW2;\n\t        rs.lastSrcCtlPtH = srcH2;\n\t        rs.lastTgtCtlPtX = tgtX2;\n\t        rs.lastTgtCtlPtY = tgtY2;\n\t        rs.lastTgtCtlPtW = tgtW2;\n\t        rs.lastTgtCtlPtH = tgtH2;\n\t        rs.lastEdgeIndex = edgeIndex2;\n\t        rs.lastNumEdges = numEdges2;\n\t        rs.lastWidth = width2;\n\t        // console.log('edge ctrl pt cache MISS')\n\t      }\n\t\n\t      if( src === tgt ){\n\t        // Self-edge\n\t\n\t        rs.edgeType = 'self';\n\t\n\t        var j = i;\n\t        var loopDist = stepSize;\n\t\n\t        if( edgeIsUnbundled ){\n\t          j = 0;\n\t          loopDist = ctrlptDist;\n\t        }\n\t\n\t        rs.ctrlpts = [\n\t          srcPos.x,\n\t          srcPos.y - (1 + Math.pow( srcH, 1.12 ) / 100) * loopDist * (j / 3 + 1),\n\t\n\t          srcPos.x - (1 + Math.pow( srcW, 1.12 ) / 100) * loopDist * (j / 3 + 1),\n\t          srcPos.y\n\t        ];\n\t\n\t      } else if(\n\t        hasCompounds &&\n\t        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&\n\t        ( src.parents().anySame( tgt ) || tgt.parents().anySame( src ) )\n\t      ){\n\t        // Compound edge\n\t\n\t        rs.edgeType = 'compound';\n\t\n\t        // because the line approximation doesn't apply for compound beziers\n\t        // (loop/self edges are already elided b/c of cheap src==tgt check)\n\t        rs.badBezier = false;\n\t\n\t        var j = i;\n\t        var loopDist = stepSize;\n\t\n\t        if( edgeIsUnbundled ){\n\t          j = 0;\n\t          loopDist = ctrlptDist;\n\t        }\n\t\n\t        var loopW = 50;\n\t\n\t        var loopaPos = {\n\t          x: srcPos.x - srcW / 2,\n\t          y: srcPos.y - srcH / 2\n\t        };\n\t\n\t        var loopbPos = {\n\t          x: tgtPos.x - tgtW / 2,\n\t          y: tgtPos.y - tgtH / 2\n\t        };\n\t\n\t        var loopPos = {\n\t          x: Math.min( loopaPos.x, loopbPos.x ),\n\t          y: Math.min( loopaPos.y, loopbPos.y )\n\t        };\n\t\n\t        // avoids cases with impossible beziers\n\t        var minCompoundStretch = 0.5;\n\t        var compoundStretchA = Math.max( minCompoundStretch, Math.log( srcW * 0.01 ) );\n\t        var compoundStretchB = Math.max( minCompoundStretch, Math.log( tgtW * 0.01 ) );\n\t\n\t        rs.ctrlpts = [\n\t          loopPos.x,\n\t          loopPos.y - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,\n\t\n\t          loopPos.x - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,\n\t          loopPos.y\n\t        ];\n\t\n\t      } else if( curveStyle === 'segments' ){\n\t        // Segments (multiple straight lines)\n\t\n\t        rs.edgeType = 'segments';\n\t        rs.segpts = [];\n\t\n\t        var segmentWs = edge.pstyle( 'segment-weights' ).pfValue;\n\t        var segmentDs = edge.pstyle( 'segment-distances' ).pfValue;\n\t        var segmentsN = Math.min( segmentWs.length, segmentDs.length );\n\t\n\t        for( var s = 0; s < segmentsN; s++ ){\n\t          var w = segmentWs[ s ];\n\t          var d = segmentDs[ s ];\n\t\n\t          // d = swappedDirection ? -d : d;\n\t          //\n\t          // d = Math.abs(d);\n\t\n\t          // var w1 = !swappedDirection ? (1 - w) : w;\n\t          // var w2 = !swappedDirection ? w : (1 - w);\n\t\n\t          var w1 = (1 - w);\n\t          var w2 = w;\n\t\n\t          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\t\n\t          var adjustedMidpt = {\n\t            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n\t            y: midptPts.y1 * w1 + midptPts.y2 * w2\n\t          };\n\t\n\t          rs.segpts.push(\n\t            adjustedMidpt.x + vectorNormInverse.x * d,\n\t            adjustedMidpt.y + vectorNormInverse.y * d\n\t          );\n\t        }\n\t\n\t      // Straight edge\n\t      } else if(\n\t        pairEdges.length % 2 === 1\n\t        && i === Math.floor( pairEdges.length / 2 )\n\t        && !edgeIsUnbundled\n\t      ){\n\t\n\t        rs.edgeType = 'straight';\n\t\n\t      } else {\n\t        // (Multi)bezier\n\t\n\t        var multi = edgeIsUnbundled;\n\t\n\t        rs.edgeType = multi ? 'multibezier' : 'bezier';\n\t        rs.ctrlpts = [];\n\t\n\t        for( var b = 0; b < bezierN; b++ ){\n\t          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;\n\t          var manctrlptDist;\n\t          var sign = math.signum( normctrlptDist );\n\t\n\t          if( multi ){\n\t            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[ b ] : stepSize; // fall back on step size\n\t            ctrlptWeight = ctrlptWs.value[ b ];\n\t          }\n\t\n\t          if( edgeIsUnbundled ){ // multi or single unbundled\n\t            manctrlptDist = ctrlptDist;\n\t          } else {\n\t            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n\t          }\n\t\n\t          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n\t\n\t          var w1 = !swappedDirection || edgeIsUnbundled ? (1 - ctrlptWeight) : ctrlptWeight;\n\t          var w2 = !swappedDirection || edgeIsUnbundled ? ctrlptWeight : (1 - ctrlptWeight);\n\t\n\t          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\t\n\t          var adjustedMidpt = {\n\t            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n\t            y: midptPts.y1 * w1 + midptPts.y2 * w2\n\t          };\n\t\n\t          rs.ctrlpts.push(\n\t            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,\n\t            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint\n\t          );\n\t        }\n\t\n\t      }\n\t\n\t      // find endpts for edge\n\t      this.findEndpoints( edge );\n\t\n\t      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );\n\t      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );\n\t      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );\n\t      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );\n\t\n\t      var minCpADistFactor = 3;\n\t      var arrowW = this.getArrowWidth( edge.pstyle( 'width' ).pfValue ) * this.arrowShapeWidth;\n\t      var minCpADist = minCpADistFactor * arrowW;\n\t\n\t      if( rs.edgeType === 'bezier' ){\n\t        var startACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );\n\t        var closeStartACp = startACpDist < minCpADist;\n\t        var endACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );\n\t        var closeEndACp = endACpDist < minCpADist;\n\t\n\t        var overlapping = false;\n\t\n\t        if( badStart || badAStart || closeStartACp ){\n\t          overlapping = true;\n\t\n\t          // project control point along line from src centre to outside the src shape\n\t          // (otherwise intersection will yield nothing)\n\t          var cpD = { // delta\n\t            x: rs.ctrlpts[0] - srcPos.x,\n\t            y: rs.ctrlpts[1] - srcPos.y\n\t          };\n\t          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line\n\t          var cpM = { // normalised delta\n\t            x: cpD.x / cpL,\n\t            y: cpD.y / cpL\n\t          };\n\t          var radius = Math.max( srcW, srcH );\n\t          var cpProj = { // *2 radius guarantees outside shape\n\t            x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n\t            y: rs.ctrlpts[1] + cpM.y * 2 * radius\n\t          };\n\t\n\t          var srcCtrlPtIntn = srcShape.intersectLine(\n\t            srcPos.x,\n\t            srcPos.y,\n\t            srcW,\n\t            srcH,\n\t            cpProj.x,\n\t            cpProj.y,\n\t            0\n\t          );\n\t\n\t          if( closeStartACp ){\n\t            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n\t            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n\t          } else {\n\t            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n\t            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n\t          }\n\t        }\n\t\n\t        if( badEnd || badAEnd || closeEndACp ){\n\t          overlapping = true;\n\t\n\t          // project control point along line from tgt centre to outside the tgt shape\n\t          // (otherwise intersection will yield nothing)\n\t          var cpD = { // delta\n\t            x: rs.ctrlpts[0] - tgtPos.x,\n\t            y: rs.ctrlpts[1] - tgtPos.y\n\t          };\n\t          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line\n\t          var cpM = { // normalised delta\n\t            x: cpD.x / cpL,\n\t            y: cpD.y / cpL\n\t          };\n\t          var radius = Math.max( srcW, srcH );\n\t          var cpProj = { // *2 radius guarantees outside shape\n\t            x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n\t            y: rs.ctrlpts[1] + cpM.y * 2 * radius\n\t          };\n\t\n\t          var tgtCtrlPtIntn = tgtShape.intersectLine(\n\t            tgtPos.x,\n\t            tgtPos.y,\n\t            tgtW,\n\t            tgtH,\n\t            cpProj.x,\n\t            cpProj.y,\n\t            0\n\t          );\n\t\n\t          if( closeEndACp ){\n\t            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);\n\t            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);\n\t          } else {\n\t            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;\n\t            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;\n\t          }\n\t\n\t        }\n\t\n\t        if( overlapping ){\n\t          // recalc endpts\n\t          this.findEndpoints( edge );\n\t        }\n\t\n\t      }\n\t\n\t      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){\n\t        rs.allpts = [];\n\t\n\t        rs.allpts.push( rs.startX, rs.startY );\n\t\n\t        for( var b = 0; b + 1 < rs.ctrlpts.length; b += 2 ){\n\t          // ctrl pt itself\n\t          rs.allpts.push( rs.ctrlpts[ b ], rs.ctrlpts[ b + 1] );\n\t\n\t          // the midpt between ctrlpts as intermediate destination pts\n\t          if( b + 3 < rs.ctrlpts.length ){\n\t            rs.allpts.push( (rs.ctrlpts[ b ] + rs.ctrlpts[ b + 2]) / 2, (rs.ctrlpts[ b + 1] + rs.ctrlpts[ b + 3]) / 2 );\n\t          }\n\t        }\n\t\n\t        rs.allpts.push( rs.endX, rs.endY );\n\t\n\t        var m, mt;\n\t        if( rs.ctrlpts.length / 2 % 2 === 0 ){\n\t          m = rs.allpts.length / 2 - 1;\n\t\n\t          rs.midX = rs.allpts[ m ];\n\t          rs.midY = rs.allpts[ m + 1];\n\t        } else {\n\t          m = rs.allpts.length / 2 - 3;\n\t          mt = 0.5;\n\t\n\t          rs.midX = math.qbezierAt( rs.allpts[ m ], rs.allpts[ m + 2], rs.allpts[ m + 4], mt );\n\t          rs.midY = math.qbezierAt( rs.allpts[ m + 1], rs.allpts[ m + 3], rs.allpts[ m + 5], mt );\n\t        }\n\t\n\t      } else if( rs.edgeType === 'straight' ){\n\t        // need to calc these after endpts\n\t        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];\n\t\n\t        // default midpt for labels etc\n\t        rs.midX = ( rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX ) / 4;\n\t        rs.midY = ( rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY ) / 4;\n\t\n\t      } else if( rs.edgeType === 'segments' ){\n\t        rs.allpts = [];\n\t        rs.allpts.push( rs.startX, rs.startY );\n\t        rs.allpts.push.apply( rs.allpts, rs.segpts );\n\t        rs.allpts.push( rs.endX, rs.endY );\n\t\n\t        if( rs.segpts.length % 4 === 0 ){\n\t          var i2 = rs.segpts.length / 2;\n\t          var i1 = i2 - 2;\n\t\n\t          rs.midX = ( rs.segpts[ i1 ] + rs.segpts[ i2 ] ) / 2;\n\t          rs.midY = ( rs.segpts[ i1 + 1] + rs.segpts[ i2 + 1] ) / 2;\n\t        } else {\n\t          var i1 = rs.segpts.length / 2 - 1;\n\t\n\t          rs.midX = rs.segpts[ i1 ];\n\t          rs.midY = rs.segpts[ i1 + 1];\n\t        }\n\t\n\t\n\t      }\n\t\n\t      this.projectLines( edge );\n\t      this.calculateArrowAngles( edge );\n\t      this.recalculateEdgeLabelProjections( edge );\n\t      this.calculateLabelAngles( edge );\n\t\n\t    } // for pair edges\n\t  } // for pair ids\n\t\n\t  for( var i = 0; i < haystackEdges.length; i++ ){\n\t    var edge = haystackEdges[ i ];\n\t    var _p = edge._private;\n\t    var rscratch = _p.rscratch;\n\t    var rs = rscratch;\n\t\n\t    if( !rscratch.haystack ){\n\t      var angle = Math.random() * 2 * Math.PI;\n\t\n\t      rscratch.source = {\n\t        x: Math.cos( angle ),\n\t        y: Math.sin( angle )\n\t      };\n\t\n\t      var angle = Math.random() * 2 * Math.PI;\n\t\n\t      rscratch.target = {\n\t        x: Math.cos( angle ),\n\t        y: Math.sin( angle )\n\t      };\n\t\n\t    }\n\t\n\t    var src = _p.source;\n\t    var tgt = _p.target;\n\t    var srcPos = src._private.position;\n\t    var tgtPos = tgt._private.position;\n\t    var srcW = src.width();\n\t    var tgtW = tgt.width();\n\t    var srcH = src.height();\n\t    var tgtH = tgt.height();\n\t    var radius = edge.pstyle( 'haystack-radius' ).value;\n\t    var halfRadius = radius / 2; // b/c have to half width/height\n\t\n\t    rs.haystackPts = rs.allpts = [\n\t      rs.source.x * srcW * halfRadius + srcPos.x,\n\t      rs.source.y * srcH * halfRadius + srcPos.y,\n\t      rs.target.x * tgtW * halfRadius + tgtPos.x,\n\t      rs.target.y * tgtH * halfRadius + tgtPos.y\n\t    ];\n\t\n\t    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n\t    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n\t\n\t    // always override as haystack in case set to different type previously\n\t    rscratch.edgeType = 'haystack';\n\t    rscratch.haystack = true;\n\t\n\t    this.projectLines( edge );\n\t    this.calculateArrowAngles( edge );\n\t    this.recalculateEdgeLabelProjections( edge );\n\t    this.calculateLabelAngles( edge );\n\t  }\n\t\n\t  return hashTable;\n\t};\n\t\n\tvar getAngleFromDisp = function( dispX, dispY ){\n\t  return Math.atan2( dispY, dispX ) - Math.PI / 2;\n\t};\n\t\n\tBRp.calculateArrowAngles = function( edge ){\n\t  var rs = edge._private.rscratch;\n\t  var isHaystack = rs.edgeType === 'haystack';\n\t  var isMultibezier = rs.edgeType === 'multibezier';\n\t  var isSegments = rs.edgeType === 'segments';\n\t  var isCompound = rs.edgeType === 'compound';\n\t  var isSelf = rs.edgeType === 'self';\n\t\n\t  // Displacement gives direction for arrowhead orientation\n\t  var dispX, dispY;\n\t  var startX, startY, endX, endY;\n\t\n\t  var srcPos = edge._private.source._private.position;\n\t  var tgtPos = edge._private.target._private.position;\n\t\n\t  if( isHaystack ){\n\t    startX = rs.haystackPts[0];\n\t    startY = rs.haystackPts[1];\n\t    endX = rs.haystackPts[2];\n\t    endY = rs.haystackPts[3];\n\t  } else {\n\t    startX = rs.arrowStartX;\n\t    startY = rs.arrowStartY;\n\t    endX = rs.arrowEndX;\n\t    endY = rs.arrowEndY;\n\t  }\n\t\n\t  // source\n\t  //\n\t\n\t  dispX = srcPos.x - startX;\n\t  dispY = srcPos.y - startY;\n\t\n\t  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );\n\t\n\t  // mid target\n\t  //\n\t\n\t  var midX = rs.midX;\n\t  var midY = rs.midY;\n\t\n\t  if( isHaystack ){\n\t    midX = ( startX + endX ) / 2;\n\t    midY = ( startY + endY ) / 2;\n\t  }\n\t\n\t  dispX = endX - startX;\n\t  dispY = endY - startY;\n\t\n\t  if( isSelf ){\n\t    dispX = -1;\n\t    dispY = 1;\n\t  } else if( isSegments ){\n\t    var pts = rs.allpts;\n\t\n\t    if( pts.length / 2 % 2 === 0 ){\n\t      var i2 = pts.length / 2;\n\t      var i1 = i2 - 2;\n\t\n\t      dispX = ( pts[ i2 ] - pts[ i1 ] );\n\t      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );\n\t    } else {\n\t      var i2 = pts.length / 2 - 1;\n\t      var i1 = i2 - 2;\n\t      var i3 = i2 + 2;\n\t\n\t      dispX = ( pts[ i2 ] - pts[ i1 ] );\n\t      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );\n\t    }\n\t  } else if( isMultibezier || isCompound ){\n\t    var pts = rs.allpts;\n\t    var cpts = rs.ctrlpts;\n\t    var bp0x, bp0y;\n\t    var bp1x, bp1y;\n\t\n\t    if( cpts.length / 2 % 2 === 0 ){\n\t      var p0 = pts.length / 2 - 1; // startpt\n\t      var ic = p0 + 2;\n\t      var p1 = ic + 2;\n\t\n\t      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0 );\n\t      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0 );\n\t\n\t      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0001 );\n\t      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0001 );\n\t    } else {\n\t      var ic = pts.length / 2 - 1; // ctrpt\n\t      var p0 = ic - 2; // startpt\n\t      var p1 = ic + 2; // endpt\n\t\n\t      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.4999 );\n\t      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.4999 );\n\t\n\t      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.5 );\n\t      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.5 );\n\t    }\n\t\n\t    dispX = ( bp1x - bp0x );\n\t    dispY = ( bp1y - bp0y );\n\t  }\n\t\n\t  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );\n\t\n\t  rs.midDispX = dispX;\n\t  rs.midDispY = dispY;\n\t\n\t  // mid source\n\t  //\n\t\n\t  dispX *= -1;\n\t  dispY *= -1;\n\t\n\t  if( isSegments ){\n\t    var pts = rs.allpts;\n\t\n\t    if( pts.length / 2 % 2 === 0 ){\n\t      // already ok\n\t    } else {\n\t      var i2 = pts.length / 2 - 1;\n\t      var i3 = i2 + 2;\n\t\n\t      dispX = -( pts[ i3 ] - pts[ i2 ] );\n\t      dispY = -( pts[ i3 + 1] - pts[ i2 + 1] );\n\t    }\n\t  }\n\t\n\t  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );\n\t\n\t  // target\n\t  //\n\t\n\t  dispX = tgtPos.x - endX;\n\t  dispY = tgtPos.y - endY;\n\t\n\t  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );\n\t};\n\t\n\tBRp.calculateLabelAngles = function( ele ){\n\t  var _p = ele._private;\n\t  var rs = _p.rscratch;\n\t  var isEdge = ele.isEdge();\n\t  var rot = ele.pstyle( 'text-rotation' );\n\t  var rotStr = rot.strValue;\n\t\n\t  if( rotStr === 'none' ){\n\t    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n\t  } else if( isEdge && rotStr === 'autorotate' ){\n\t    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );\n\t    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;\n\t    rs.targetLabelAngle = rs.targetLabelAutoAngle;\n\t  } else if( rotStr === 'autorotate' ){\n\t    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n\t  } else {\n\t    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;\n\t  }\n\t};\n\t\n\t\n\tBRp.findEndpoints = function( edge ){\n\t  var r = this;\n\t  var intersect;\n\t\n\t  var source = edge.source()[0];\n\t  var target = edge.target()[0];\n\t\n\t  var src_p = source._private;\n\t  var tgt_p = target._private;\n\t\n\t  var srcPos = src_p.position;\n\t  var tgtPos = tgt_p.position;\n\t\n\t  var tgtArShape = edge.pstyle( 'target-arrow-shape' ).value;\n\t  var srcArShape = edge.pstyle( 'source-arrow-shape' ).value;\n\t\n\t  var rs = edge._private.rscratch;\n\t\n\t  var et = rs.edgeType;\n\t  var bezier = et === 'bezier' || et === 'multibezier' || et === 'self' || et === 'compound';\n\t  var multi = et !== 'bezier';\n\t  var lines = et === 'straight' || et === 'segments';\n\t  var segments = et === 'segments';\n\t  var hasEndpts = bezier || multi || lines;\n\t\n\t  var p1, p2;\n\t\n\t  if( bezier ){\n\t    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];\n\t    var cpEnd = multi ? [ rs.ctrlpts[ rs.ctrlpts.length - 2], rs.ctrlpts[ rs.ctrlpts.length - 1] ] : cpStart;\n\t\n\t    p1 = cpEnd;\n\t    p2 = cpStart;\n\t  } else if( lines ){\n\t    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );\n\t    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );\n\t\n\t    p1 = tgtArrowFromPt;\n\t    p2 = srcArrowFromPt;\n\t  }\n\t\n\t  intersect = r.nodeShapes[ this.getNodeShape( target ) ].intersectLine(\n\t    tgtPos.x,\n\t    tgtPos.y,\n\t    target.outerWidth(),\n\t    target.outerHeight(),\n\t    p1[0],\n\t    p1[1],\n\t    0\n\t  );\n\t\n\t  var arrowEnd = math.shortenIntersection( intersect, p1,\n\t    r.arrowShapes[ tgtArShape ].spacing( edge ) );\n\t  var edgeEnd = math.shortenIntersection( intersect, p1,\n\t    r.arrowShapes[ tgtArShape ].gap( edge ) );\n\t\n\t  rs.endX = edgeEnd[0];\n\t  rs.endY = edgeEnd[1];\n\t\n\t  rs.arrowEndX = arrowEnd[0];\n\t  rs.arrowEndY = arrowEnd[1];\n\t\n\t  intersect = r.nodeShapes[ this.getNodeShape( source ) ].intersectLine(\n\t    srcPos.x,\n\t    srcPos.y,\n\t    source.outerWidth(),\n\t    source.outerHeight(),\n\t    p2[0],\n\t    p2[1],\n\t    0\n\t  );\n\t\n\t  var arrowStart = math.shortenIntersection(\n\t    intersect, p2,\n\t    r.arrowShapes[ srcArShape ].spacing( edge )\n\t  );\n\t  var edgeStart = math.shortenIntersection(\n\t    intersect, p2,\n\t    r.arrowShapes[ srcArShape ].gap( edge )\n\t  );\n\t\n\t  rs.startX = edgeStart[0];\n\t  rs.startY = edgeStart[1];\n\t\n\t  rs.arrowStartX = arrowStart[0];\n\t  rs.arrowStartY = arrowStart[1];\n\t\n\t  if( hasEndpts ){\n\t    if( !is.number( rs.startX ) || !is.number( rs.startY ) || !is.number( rs.endX ) || !is.number( rs.endY ) ){\n\t      rs.badLine = true;\n\t    } else {\n\t      rs.badLine = false;\n\t    }\n\t  }\n\t};\n\t\n\tBRp.getArrowWidth = BRp.getArrowHeight = function( edgeWidth ){\n\t  var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n\t\n\t  var cachedVal = cache[ edgeWidth ];\n\t  if( cachedVal ){\n\t    return cachedVal;\n\t  }\n\t\n\t  cachedVal =  Math.max( Math.pow( edgeWidth * 13.37, 0.9 ), 29 );\n\t  cache[ edgeWidth ] = cachedVal;\n\t\n\t  return cachedVal;\n\t};\n\t\n\tmodule.exports = BRp;\n\n\n/***/ },\n/* 115 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar BRp = {};\n\t\n\tBRp.getCachedImage = function( url, onLoad ){\n\t  var r = this;\n\t  var imageCache = r.imageCache = r.imageCache || {};\n\t\n\t  if( imageCache[ url ] && imageCache[ url ].image ){\n\t    return imageCache[ url ].image;\n\t  }\n\t\n\t  var cache = imageCache[ url ] = imageCache[ url ] || {};\n\t\n\t  var image = cache.image = new Image();\n\t  image.addEventListener('load', onLoad);\n\t  image.crossOrigin = 'Anonymous'; // prevent tainted canvas\n\t  image.src = url;\n\t\n\t  return image;\n\t};\n\t\n\tmodule.exports = BRp;\n\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\tvar Event = __webpack_require__( 60 );\n\t\n\tvar BRp = {};\n\t\n\tBRp.registerBinding = function( target, event, handler, useCapture ){\n\t  var args = Array.prototype.slice.apply( arguments, [1] ); // copy\n\t  var b = this.binder( target );\n\t\n\t  return b.on.apply( b, args );\n\t};\n\t\n\tBRp.binder = function( tgt ){\n\t  var r = this;\n\t\n\t  var on = function(){\n\t    var args = arguments;\n\t\n\t    r.bindings.push({\n\t      target: tgt,\n\t      args: args\n\t    });\n\t\n\t    ( tgt.on || tgt.addEventListener ).apply( tgt, args );\n\t\n\t    return this;\n\t  };\n\t\n\t  return {\n\t    on: on,\n\t    addEventListener: on,\n\t    addListener: on,\n\t    bind: on\n\t  };\n\t};\n\t\n\tBRp.nodeIsDraggable = function( node ){\n\t  return (\n\t    node\n\t    && node.isNode()\n\t    && !node.locked()\n\t    && node.grabbable()\n\t  );\n\t};\n\t\n\tBRp.nodeIsGrabbable = function( node ){\n\t  return (\n\t    this.nodeIsDraggable( node )\n\t    && node.pstyle( 'opacity' ).value !== 0\n\t    && node.pstyle( 'visibility' ).value === 'visible'\n\t    && node.pstyle( 'display' ).value === 'element'\n\t  );\n\t};\n\t\n\tBRp.load = function(){\n\t  var r = this;\n\t\n\t  var triggerEvents = function( target, names, e, props ){\n\t    if( target == null ){\n\t      target = r.cy;\n\t    }\n\t\n\t    for( var i = 0; i < names.length; i++ ){\n\t      var name = names[ i ];\n\t\n\t      var event = new Event( e, util.extend( { type: name }, props ) );\n\t      target.trigger( event );\n\t    }\n\t  };\n\t\n\t  var isMultSelKeyDown = function( e ){\n\t    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n\t  };\n\t\n\t  var allowPanningPassthrough = function( down, downs ){\n\t    var allowPassthrough = true;\n\t\n\t    if( r.cy.hasCompoundNodes() && down && down.isEdge() ){\n\t      // a compound node below the edge => no passthrough panning\n\t      for( var i = 0; downs && i < downs.length; i++ ){\n\t        var down = downs[i];\n\t\n\t        if( down.isNode() && down.isParent() ){\n\t          allowPassthrough = false;\n\t          break;\n\t        }\n\t      }\n\t    } else {\n\t      allowPassthrough = true;\n\t    }\n\t\n\t    return allowPassthrough;\n\t  };\n\t\n\t  var getDragListIds = function( opts ){\n\t    var listHasId;\n\t\n\t    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs\n\t      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist\n\t        opts.addToList.hasId = {};\n\t\n\t        for( var i = 0; i < opts.addToList.length; i++ ){\n\t          var ele = opts.addToList[ i ];\n\t\n\t          opts.addToList.hasId[ ele.id() ] = true;\n\t        }\n\t      }\n\t\n\t      listHasId = opts.addToList.hasId;\n\t    }\n\t\n\t    return listHasId || {};\n\t  };\n\t\n\t  var setGrabbed = function( ele ){\n\t    ele[0]._private.grabbed = true;\n\t  };\n\t\n\t  var setFreed = function( ele ){\n\t    ele[0]._private.grabbed = false;\n\t  };\n\t\n\t  var setInDragLayer = function( ele ){\n\t    ele[0]._private.rscratch.inDragLayer = true;\n\t  };\n\t\n\t  var setOutDragLayer = function( ele ){\n\t    ele[0]._private.rscratch.inDragLayer = false;\n\t  };\n\t\n\t  var setGrabTarget = function( ele ){\n\t    ele[0]._private.rscratch.isGrabTarget = true;\n\t  };\n\t\n\t  var removeGrabTarget = function( ele ){\n\t    ele[0]._private.rscratch.isGrabTarget = false;\n\t  };\n\t\n\t  var addToDragList = function( ele, opts ){\n\t    var listHasId = getDragListIds( opts );\n\t\n\t    if( !listHasId[ ele.id() ] ){\n\t      opts.addToList.push( ele );\n\t      listHasId[ ele.id() ] = true;\n\t\n\t      setGrabbed( ele );\n\t    }\n\t  };\n\t\n\t  // helper function to determine which child nodes and inner edges\n\t  // of a compound node to be dragged as well as the grabbed and selected nodes\n\t  var addDescendantsToDrag = function( node, opts ){\n\t    if( !node.cy().hasCompoundNodes() ){\n\t      return;\n\t    }\n\t\n\t    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do\n\t\n\t    var innerNodes = node.descendants();\n\t\n\t    if( opts.inDragLayer ){\n\t      innerNodes.forEach( setInDragLayer );\n\t      innerNodes.connectedEdges().forEach( setInDragLayer );\n\t    }\n\t\n\t    if( opts.addToList ){\n\t      innerNodes.forEach(function( ele ){\n\t        addToDragList( ele, opts );\n\t      });\n\t    }\n\t  };\n\t\n\t  // adds the given nodes and its neighbourhood to the drag layer\n\t  var addNodesToDrag = function( nodes, opts ){\n\t    opts = opts || {};\n\t\n\t    var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n\t\n\t    if( opts.inDragLayer ){\n\t      nodes.forEach( setInDragLayer );\n\t\n\t      nodes.neighborhood().stdFilter(function( ele ){\n\t        return !hasCompoundNodes || ele.isEdge();\n\t      }).forEach( setInDragLayer );\n\t    }\n\t\n\t    if( opts.addToList ){\n\t      nodes.forEach(function( ele ){\n\t        addToDragList( ele, opts );\n\t      });\n\t    }\n\t\n\t    addDescendantsToDrag( nodes, opts ); // always add to drag\n\t\n\t    // also add nodes and edges related to the topmost ancestor\n\t    updateAncestorsInDragLayer( nodes, {\n\t      inDragLayer: opts.inDragLayer\n\t    } );\n\t\n\t    r.updateCachedGrabbedEles();\n\t  };\n\t\n\t  var addNodeToDrag = addNodesToDrag;\n\t\n\t  var freeDraggedElements = function( grabbedEles ){\n\t    if( !grabbedEles ){ return; }\n\t\n\t    grabbedEles.hasId = {}; // clear the id list\n\t\n\t    // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n\t    r.getCachedZSortedEles().forEach(function( ele ){\n\t      setFreed( ele );\n\t      setOutDragLayer( ele );\n\t      removeGrabTarget( ele );\n\t    });\n\t\n\t    r.updateCachedGrabbedEles();\n\t  };\n\t\n\t  // helper function to determine which ancestor nodes and edges should go\n\t  // to the drag layer (or should be removed from drag layer).\n\t  var updateAncestorsInDragLayer = function( node, opts ){\n\t\n\t    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do\n\t\n\t    if( !node.cy().hasCompoundNodes() ){\n\t      return;\n\t    }\n\t\n\t    // find top-level parent\n\t    var parent = node.ancestors().orphans();\n\t\n\t    // no parent node: no nodes to add to the drag layer\n\t    if( parent.same( node ) ){\n\t      return;\n\t    }\n\t\n\t    var nodes = parent.descendants().spawnSelf()\n\t      .merge( parent )\n\t      .unmerge( node )\n\t      .unmerge( node.descendants() )\n\t    ;\n\t\n\t    var edges = nodes.connectedEdges();\n\t\n\t    if( opts.inDragLayer ){\n\t      edges.forEach( setInDragLayer );\n\t      nodes.forEach( setInDragLayer );\n\t    }\n\t\n\t    if( opts.addToList ){\n\t      nodes.forEach(function( ele ){\n\t        addToDragList( ele, opts );\n\t      });\n\t    }\n\t  };\n\t\n\t  var haveMutationsApi = typeof MutationObserver !== 'undefined';\n\t\n\t  // watch for when the cy container is removed from the dom\n\t  if( haveMutationsApi ){\n\t    r.removeObserver = new MutationObserver( function( mutns ){\n\t      for( var i = 0; i < mutns.length; i++ ){\n\t        var mutn = mutns[ i ];\n\t        var rNodes = mutn.removedNodes;\n\t\n\t        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){\n\t          var rNode = rNodes[ j ];\n\t\n\t          if( rNode === r.container ){\n\t            r.destroy();\n\t            break;\n\t          }\n\t        } }\n\t      }\n\t    } );\n\t\n\t    if( r.container.parentNode ){\n\t      r.removeObserver.observe( r.container.parentNode, { childList: true } );\n\t    }\n\t  } else {\n\t    r.registerBinding( r.container, 'DOMNodeRemoved', function( e ){\n\t      r.destroy();\n\t    } );\n\t  }\n\t\n\t  var onResize = util.debounce( function(){\n\t    r.cy.invalidateSize();\n\t    r.invalidateContainerClientCoordsCache();\n\t\n\t    r.matchCanvasSize( r.container );\n\t    r.redrawHint( 'eles', true );\n\t    r.redrawHint( 'drag', true );\n\t    r.redraw();\n\t  }, 100 );\n\t\n\t  if( haveMutationsApi ){\n\t    r.styleObserver = new MutationObserver( onResize );\n\t\n\t    r.styleObserver.observe( r.container, { attributes: true } );\n\t  }\n\t\n\t  // auto resize\n\t  r.registerBinding( window, 'resize', onResize );\n\t\n\t  var invalCtnrBBOnScroll = function( domEle ){\n\t    r.registerBinding( domEle, 'scroll', function( e ){\n\t      r.invalidateContainerClientCoordsCache();\n\t    } );\n\t  };\n\t\n\t  var bbCtnr = r.cy.container();\n\t\n\t  for( ;; ){\n\t\n\t    invalCtnrBBOnScroll( bbCtnr );\n\t\n\t    if( bbCtnr.parentNode ){\n\t      bbCtnr = bbCtnr.parentNode;\n\t    } else {\n\t      break;\n\t    }\n\t\n\t  }\n\t\n\t  // stop right click menu from appearing on cy\n\t  r.registerBinding( r.container, 'contextmenu', function( e ){\n\t    e.preventDefault();\n\t  } );\n\t\n\t  var inBoxSelection = function(){\n\t    return r.selection[4] !== 0;\n\t  };\n\t\n\t  // Primary key\n\t  r.registerBinding( r.container, 'mousedown', function mousedownHandler( e ){\n\t    e.preventDefault();\n\t    r.hoverData.capture = true;\n\t    r.hoverData.which = e.which;\n\t\n\t    var cy = r.cy;\n\t    var gpos = [ e.clientX, e.clientY ];\n\t    var pos = r.projectIntoViewport( gpos[0], gpos[1] );\n\t    var select = r.selection;\n\t    var nears = r.findNearestElements( pos[0], pos[1], true, false );\n\t    var near = nears[0];\n\t    var draggedElements = r.dragData.possibleDragElements;\n\t\n\t    r.hoverData.mdownPos = pos;\n\t    r.hoverData.mdownGPos = gpos;\n\t\n\t    var checkForTaphold = function(){\n\t      r.hoverData.tapholdCancelled = false;\n\t\n\t      clearTimeout( r.hoverData.tapholdTimeout );\n\t\n\t      r.hoverData.tapholdTimeout = setTimeout( function(){\n\t\n\t        if( r.hoverData.tapholdCancelled ){\n\t          return;\n\t        } else {\n\t          var ele = r.hoverData.down;\n\t\n\t          if( ele ){\n\t            ele.trigger( new Event( e, {\n\t              type: 'taphold',\n\t              cyPosition: { x: pos[0], y: pos[1] }\n\t            } ) );\n\t          } else {\n\t            cy.trigger( new Event( e, {\n\t              type: 'taphold',\n\t              cyPosition: { x: pos[0], y: pos[1] }\n\t            } ) );\n\t          }\n\t        }\n\t\n\t      }, r.tapholdDuration );\n\t    };\n\t\n\t    // Right click button\n\t    if( e.which == 3 ){\n\t\n\t      r.hoverData.cxtStarted = true;\n\t\n\t      var cxtEvt = new Event( e, {\n\t        type: 'cxttapstart',\n\t        cyPosition: { x: pos[0], y: pos[1] }\n\t      } );\n\t\n\t      if( near ){\n\t        near.activate();\n\t        near.trigger( cxtEvt );\n\t\n\t        r.hoverData.down = near;\n\t      } else {\n\t        cy.trigger( cxtEvt );\n\t      }\n\t\n\t      r.hoverData.downTime = (new Date()).getTime();\n\t      r.hoverData.cxtDragged = false;\n\t\n\t    // Primary button\n\t    } else if( e.which == 1 ){\n\t\n\t      if( near ){\n\t        near.activate();\n\t      }\n\t\n\t      // Element dragging\n\t      {\n\t        // If something is under the cursor and it is draggable, prepare to grab it\n\t        if( near != null ){\n\t\n\t          if( r.nodeIsGrabbable( near ) ){\n\t\n\t            var grabEvent = new Event( e, {\n\t              type: 'grab',\n\t              cyPosition: { x: pos[0], y: pos[1] }\n\t            } );\n\t\n\t            setGrabTarget( near );\n\t\n\t            if( !near.selected() ){\n\t\n\t              draggedElements = r.dragData.possibleDragElements = [];\n\t              addNodeToDrag( near, { addToList: draggedElements } );\n\t\n\t              near.trigger( grabEvent );\n\t\n\t            } else if( near.selected() ){\n\t              draggedElements = r.dragData.possibleDragElements = [  ];\n\t\n\t              var selectedNodes = cy.$( function(){ return this.isNode() && this.selected() && r.nodeIsGrabbable( this ); } );\n\t\n\t              addNodesToDrag( selectedNodes, { addToList: draggedElements } );\n\t\n\t              near.trigger( grabEvent );\n\t            }\n\t\n\t            r.redrawHint( 'eles', true );\n\t            r.redrawHint( 'drag', true );\n\t\n\t          }\n\t\n\t        }\n\t\n\t        r.hoverData.down = near;\n\t        r.hoverData.downs = nears;\n\t        r.hoverData.downTime = (new Date()).getTime();\n\t      }\n\t\n\t      triggerEvents( near, [ 'mousedown', 'tapstart', 'vmousedown' ], e, {\n\t        cyPosition: { x: pos[0], y: pos[1] }\n\t      } );\n\t\n\t      if( near == null ){\n\t        select[4] = 1;\n\t\n\t        r.data.bgActivePosistion = {\n\t          x: pos[0],\n\t          y: pos[1]\n\t        };\n\t\n\t        r.redrawHint( 'select', true );\n\t\n\t        r.redraw();\n\t      } else if( near.isEdge() ){\n\t        select[4] = 1; // for future pan\n\t      }\n\t\n\t      checkForTaphold();\n\t\n\t    }\n\t\n\t    // Initialize selection box coordinates\n\t    select[0] = select[2] = pos[0];\n\t    select[1] = select[3] = pos[1];\n\t\n\t  }, false );\n\t\n\t  r.registerBinding( window, 'mousemove', function mousemoveHandler( e ){\n\t    var preventDefault = false;\n\t    var capture = r.hoverData.capture;\n\t\n\t    // save cycles if mouse events aren't to be captured\n\t    if( !capture ){\n\t      var containerPageCoords = r.findContainerClientCoords();\n\t\n\t      if( e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth\n\t        && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight\n\t      ){\n\t        // inside container bounds so OK\n\t      } else {\n\t        return;\n\t      }\n\t\n\t      var cyContainer = r.container;\n\t      var target = e.target;\n\t      var tParent = target.parentNode;\n\t      var containerIsTarget = false;\n\t\n\t      while( tParent ){\n\t        if( tParent === cyContainer ){\n\t          containerIsTarget = true;\n\t          break;\n\t        }\n\t\n\t        tParent = tParent.parentNode;\n\t      }\n\t\n\t      if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us\n\t    }\n\t\n\t    var cy = r.cy;\n\t    var zoom = cy.zoom();\n\t    var gpos = [ e.clientX, e.clientY ];\n\t    var pos = r.projectIntoViewport( gpos[0], gpos[1] );\n\t    var mdownPos = r.hoverData.mdownPos;\n\t    var mdownGPos = r.hoverData.mdownGPos;\n\t    var select = r.selection;\n\t\n\t    var near = null;\n\t    if( !r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting ){\n\t      near = r.findNearestElement( pos[0], pos[1], true, false );\n\t    }\n\t    var last = r.hoverData.last;\n\t    var down = r.hoverData.down;\n\t\n\t    var disp = [ pos[0] - select[2], pos[1] - select[3] ];\n\t\n\t    var draggedElements = r.dragData.possibleDragElements;\n\t\n\t    var isOverThresholdDrag;\n\t\n\t    if( mdownGPos ){\n\t      var dx = gpos[0] - mdownGPos[0];\n\t      var dx2 = dx * dx;\n\t      var dy = gpos[1] - mdownGPos[1];\n\t      var dy2 = dy * dy;\n\t      var dist2 = dx2 + dy2;\n\t\n\t      isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n\t    }\n\t\n\t    var multSelKeyDown = isMultSelKeyDown( e );\n\t\n\t    if (isOverThresholdDrag) {\n\t      r.hoverData.tapholdCancelled = true;\n\t    }\n\t\n\t    var updateDragDelta = function(){\n\t      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\t\n\t      if( dragDelta.length === 0 ){\n\t        dragDelta.push( disp[0] );\n\t        dragDelta.push( disp[1] );\n\t      } else {\n\t        dragDelta[0] += disp[0];\n\t        dragDelta[1] += disp[1];\n\t      }\n\t    };\n\t\n\t\n\t    preventDefault = true;\n\t\n\t    triggerEvents( near, [ 'mousemove', 'vmousemove', 'tapdrag' ], e, {\n\t      cyPosition: { x: pos[0], y: pos[1] }\n\t    } );\n\t\n\t    // trigger context drag if rmouse down\n\t    if( r.hoverData.which === 3 ){\n\t      // but only if over threshold\n\t      if( isOverThresholdDrag ){\n\t        var cxtEvt = new Event( e, {\n\t          type: 'cxtdrag',\n\t          cyPosition: { x: pos[0], y: pos[1] }\n\t        } );\n\t\n\t        if( down ){\n\t          down.trigger( cxtEvt );\n\t        } else {\n\t          cy.trigger( cxtEvt );\n\t        }\n\t\n\t        r.hoverData.cxtDragged = true;\n\t\n\t        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){\n\t\n\t          if( r.hoverData.cxtOver ){\n\t            r.hoverData.cxtOver.trigger( new Event( e, {\n\t              type: 'cxtdragout',\n\t              cyPosition: { x: pos[0], y: pos[1] }\n\t            } ) );\n\t          }\n\t\n\t          r.hoverData.cxtOver = near;\n\t\n\t          if( near ){\n\t            near.trigger( new Event( e, {\n\t              type: 'cxtdragover',\n\t              cyPosition: { x: pos[0], y: pos[1] }\n\t            } ) );\n\t          }\n\t\n\t        }\n\t      }\n\t\n\t    // Check if we are drag panning the entire graph\n\t    } else if( r.hoverData.dragging ){\n\t      preventDefault = true;\n\t\n\t      if( cy.panningEnabled() && cy.userPanningEnabled() ){\n\t        var deltaP;\n\t\n\t        if( r.hoverData.justStartedPan ){\n\t          var mdPos = r.hoverData.mdownPos;\n\t\n\t          deltaP = {\n\t            x: ( pos[0] - mdPos[0] ) * zoom,\n\t            y: ( pos[1] - mdPos[1] ) * zoom\n\t          };\n\t\n\t          r.hoverData.justStartedPan = false;\n\t\n\t        } else {\n\t          deltaP = {\n\t            x: disp[0] * zoom,\n\t            y: disp[1] * zoom\n\t          };\n\t\n\t        }\n\t\n\t        cy.panBy( deltaP );\n\t\n\t        r.hoverData.dragged = true;\n\t      }\n\t\n\t      // Needs reproject due to pan changing viewport\n\t      pos = r.projectIntoViewport( e.clientX, e.clientY );\n\t\n\t    // Checks primary button down & out of time & mouse not moved much\n\t    } else if(\n\t        select[4] == 1 && (down == null || down.isEdge())\n\t    ){\n\t\n\t      if( isOverThresholdDrag ){\n\t\n\t        if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){\n\t          r.data.bgActivePosistion = undefined;\n\t\n\t          if( !r.hoverData.selecting ){\n\t            cy.trigger('boxstart');\n\t          }\n\t\n\t          r.hoverData.selecting = true;\n\t\n\t          r.redrawHint( 'select', true );\n\t          r.redraw();\n\t\n\t        } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){\n\t          var allowPassthrough = allowPanningPassthrough( down, r.hoverData.downs );\n\t\n\t          if( allowPassthrough ){\n\t            r.hoverData.dragging = true;\n\t            r.hoverData.justStartedPan = true;\n\t            select[4] = 0;\n\t\n\t            r.data.bgActivePosistion = math.array2point( mdownPos );\n\t\n\t            r.redrawHint( 'select', true );\n\t            r.redraw();\n\t          }\n\t        }\n\t\n\t        if( down && down.isEdge() && down.active() ){ down.unactivate(); }\n\t\n\t      }\n\t\n\t    } else {\n\t      if( down && down.isEdge() && down.active() ){ down.unactivate(); }\n\t\n\t      if( ( !down || !down.grabbed() ) && near != last ){\n\t\n\t        if( last ){\n\t          triggerEvents( last, [ 'mouseout', 'tapdragout' ], e, {\n\t            cyPosition: { x: pos[0], y: pos[1] }\n\t          } );\n\t        }\n\t\n\t        if( near ){\n\t          triggerEvents( near, [ 'mouseover', 'tapdragover' ], e, {\n\t            cyPosition: { x: pos[0], y: pos[1] }\n\t          } );\n\t        }\n\t\n\t        r.hoverData.last = near;\n\t      }\n\t\n\t      if( down && r.nodeIsDraggable( down ) ){\n\t\n\t        if( isOverThresholdDrag ){ // then drag\n\t\n\t          var justStartedDrag = !r.dragData.didDrag;\n\t\n\t          if( justStartedDrag ){\n\t            r.redrawHint( 'eles', true );\n\t          }\n\t\n\t          r.dragData.didDrag = true; // indicate that we actually did drag the node\n\t\n\t          var toTrigger = [];\n\t\n\t          // now, add the elements to the drag layer if not done already\n\t          if( !r.hoverData.draggingEles ){\n\t            addNodesToDrag( cy.collection( draggedElements ), { inDragLayer: true } );\n\t          }\n\t\n\t          for( var i = 0; i < draggedElements.length; i++ ){\n\t            var dEle = draggedElements[ i ];\n\t\n\t            // Locked nodes not draggable, as well as non-visible nodes\n\t            if( r.nodeIsDraggable( dEle ) && dEle.grabbed() ){\n\t              var dPos = dEle._private.position;\n\t\n\t              toTrigger.push( dEle );\n\t\n\t              if( is.number( disp[0] ) && is.number( disp[1] ) ){\n\t                var updatePos = !dEle.isParent();\n\t\n\t                if( updatePos ){\n\t                  dPos.x += disp[0];\n\t                  dPos.y += disp[1];\n\t                }\n\t\n\t                if( justStartedDrag ){\n\t                  var dragDelta = r.hoverData.dragDelta;\n\t\n\t                  if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){\n\t                    dPos.x += dragDelta[0];\n\t                    dPos.y += dragDelta[1];\n\t                  }\n\t                }\n\t              }\n\t\n\t            }\n\t          }\n\t\n\t          r.hoverData.draggingEles = true;\n\t\n\t          var tcol = cy.collection( toTrigger );\n\t\n\t          tcol.updateCompoundBounds();\n\t          tcol.trigger( 'position drag' );\n\t\n\t          r.redrawHint( 'drag', true );\n\t          r.redraw();\n\t\n\t        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n\t          updateDragDelta();\n\t        }\n\t      }\n\t\n\t      // prevent the dragging from triggering text selection on the page\n\t      preventDefault = true;\n\t    }\n\t\n\t    select[2] = pos[0]; select[3] = pos[1];\n\t\n\t    if( preventDefault ){\n\t      if( e.stopPropagation ) e.stopPropagation();\n\t      if( e.preventDefault ) e.preventDefault();\n\t      return false;\n\t    }\n\t  }, false );\n\t\n\t  r.registerBinding( window, 'mouseup', function mouseupHandler( e ){\n\t    var capture = r.hoverData.capture;\n\t    if( !capture ){ return; }\n\t    r.hoverData.capture = false;\n\t\n\t    var cy = r.cy; var pos = r.projectIntoViewport( e.clientX, e.clientY ); var select = r.selection;\n\t    var near = r.findNearestElement( pos[0], pos[1], true, false );\n\t    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;\n\t    var multSelKeyDown = isMultSelKeyDown( e );\n\t\n\t    if( r.data.bgActivePosistion ){\n\t      r.redrawHint( 'select', true );\n\t      r.redraw();\n\t    }\n\t\n\t    r.hoverData.tapholdCancelled = true;\n\t\n\t    r.data.bgActivePosistion = undefined; // not active bg now\n\t\n\t    if( down ){\n\t      down.unactivate();\n\t    }\n\t\n\t    if( r.hoverData.which === 3 ){\n\t      var cxtEvt = new Event( e, {\n\t        type: 'cxttapend',\n\t        cyPosition: { x: pos[0], y: pos[1] }\n\t      } );\n\t\n\t      if( down ){\n\t        down.trigger( cxtEvt );\n\t      } else {\n\t        cy.trigger( cxtEvt );\n\t      }\n\t\n\t      if( !r.hoverData.cxtDragged ){\n\t        var cxtTap = new Event( e, {\n\t          type: 'cxttap',\n\t          cyPosition: { x: pos[0], y: pos[1] }\n\t        } );\n\t\n\t        if( down ){\n\t          down.trigger( cxtTap );\n\t        } else {\n\t          cy.trigger( cxtTap );\n\t        }\n\t      }\n\t\n\t      r.hoverData.cxtDragged = false;\n\t      r.hoverData.which = null;\n\t\n\t    } else if( r.hoverData.which === 1 ){\n\t\n\t      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n\t      if( (down == null) // not mousedown on node\n\t        && !r.dragData.didDrag // didn't move the node around\n\t        && !r.hoverData.selecting // not box selection\n\t        && !r.hoverData.dragged // didn't pan\n\t        && !isMultSelKeyDown( e )\n\t      ){\n\t\n\t        cy.$( function(){\n\t          return this.selected();\n\t        } ).unselect();\n\t\n\t        if( draggedElements.length > 0 ){\n\t          r.redrawHint( 'eles', true );\n\t        }\n\t\n\t        r.dragData.possibleDragElements = draggedElements = [];\n\t      }\n\t\n\t      triggerEvents( near, [ 'mouseup', 'tapend', 'vmouseup' ], e, {\n\t        cyPosition: { x: pos[0], y: pos[1] }\n\t      } );\n\t\n\t      if(\n\t        !r.dragData.didDrag // didn't move a node around\n\t        && !r.hoverData.dragged // didn't pan\n\t        && !r.hoverData.selecting // not box selection\n\t      ){\n\t        triggerEvents( down, ['click', 'tap', 'vclick'], e, {\n\t          cyPosition: { x: pos[0], y: pos[1] }\n\t        } );\n\t      }\n\t\n\t      // Single selection\n\t      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){\n\t        if( near != null && near._private.selectable ){\n\t\n\t          if( r.hoverData.dragging ){\n\t            // if panning, don't change selection state\n\t          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){\n\t            if( near.selected() ){\n\t              near.unselect();\n\t            } else {\n\t              near.select();\n\t            }\n\t          } else {\n\t            if( !multSelKeyDown ){\n\t              cy.$( ':selected' ).unmerge( near ).unselect();\n\t              near.select();\n\t            }\n\t          }\n\t\n\t          r.redrawHint( 'eles', true );\n\t        }\n\t      }\n\t\n\t      if( r.hoverData.selecting ){\n\t        var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );\n\t\n\t        r.redrawHint( 'select', true );\n\t\n\t        if( box.length > 0 ){\n\t          r.redrawHint( 'eles', true );\n\t        }\n\t\n\t        cy.trigger('boxend');\n\t\n\t        var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };\n\t\n\t        if( cy.selectionType() === 'additive' ){\n\t          box\n\t            .trigger('box')\n\t            .stdFilter( eleWouldBeSelected )\n\t              .select()\n\t              .trigger('boxselect')\n\t          ;\n\t        } else {\n\t          if( !multSelKeyDown ){\n\t            cy.$( ':selected' ).unmerge( box ).unselect();\n\t          }\n\t\n\t          box\n\t            .trigger('box')\n\t            .stdFilter( eleWouldBeSelected )\n\t              .select()\n\t              .trigger('boxselect')\n\t          ;\n\t        }\n\t\n\t        // always need redraw in case eles unselectable\n\t        r.redraw();\n\t\n\t      }\n\t\n\t      // Cancel drag pan\n\t      if( r.hoverData.dragging ){\n\t        r.hoverData.dragging = false;\n\t\n\t        r.redrawHint( 'select', true );\n\t        r.redrawHint( 'eles', true );\n\t\n\t        r.redraw();\n\t      }\n\t\n\t      if( !select[4] ) {\n\t        r.redrawHint('drag', true);\n\t        r.redrawHint('eles', true);\n\t\n\t        var downWasGrabbed = down && down.grabbed();\n\t\n\t        freeDraggedElements( draggedElements );\n\t\n\t        if( downWasGrabbed ){ down.trigger('free'); }\n\t      }\n\t\n\t    } // else not right mouse\n\t\n\t    select[4] = 0; r.hoverData.down = null;\n\t\n\t    r.hoverData.cxtStarted = false;\n\t    r.hoverData.draggingEles = false;\n\t    r.hoverData.selecting = false;\n\t    r.dragData.didDrag = false;\n\t    r.hoverData.dragged = false;\n\t    r.hoverData.dragDelta = [];\n\t    r.hoverData.mdownPos = null;\n\t    r.hoverData.mdownGPos = null;\n\t\n\t  }, false );\n\t\n\t  var wheelHandler = function( e ){\n\t\n\t\n\t    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom\n\t\n\t    var cy = r.cy;\n\t    var pos = r.projectIntoViewport( e.clientX, e.clientY );\n\t    var rpos = [ pos[0] * cy.zoom() + cy.pan().x,\n\t                  pos[1] * cy.zoom() + cy.pan().y ];\n\t\n\t    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom\n\t      e.preventDefault();\n\t      return;\n\t    }\n\t\n\t    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){\n\t      e.preventDefault();\n\t\n\t      r.data.wheelZooming = true;\n\t      clearTimeout( r.data.wheelTimeout );\n\t      r.data.wheelTimeout = setTimeout( function(){\n\t        r.data.wheelZooming = false;\n\t\n\t        r.redrawHint( 'eles', true );\n\t        r.redraw();\n\t      }, 150 );\n\t\n\t      var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;\n\t      diff = diff * r.wheelSensitivity;\n\t\n\t      var needsWheelFix = e.deltaMode === 1;\n\t      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows\n\t        diff *= 33;\n\t      }\n\t\n\t      cy.zoom( {\n\t        level: cy.zoom() * Math.pow( 10, diff ),\n\t        renderedPosition: { x: rpos[0], y: rpos[1] }\n\t      } );\n\t    }\n\t\n\t  };\n\t\n\t  // Functions to help with whether mouse wheel should trigger zooming\n\t  // --\n\t  r.registerBinding( r.container, 'wheel', wheelHandler, true );\n\t\n\t  // disable nonstandard wheel events\n\t  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n\t  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n\t  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\t\n\t  r.registerBinding( window, 'scroll', function scrollHandler( e ){\n\t    r.scrollingPage = true;\n\t\n\t    clearTimeout( r.scrollingPageTimeout );\n\t    r.scrollingPageTimeout = setTimeout( function(){\n\t      r.scrollingPage = false;\n\t    }, 250 );\n\t  }, true );\n\t\n\t  // Functions to help with handling mouseout/mouseover on the Cytoscape container\n\t  // Handle mouseout on Cytoscape container\n\t  r.registerBinding( r.container, 'mouseout', function mouseOutHandler( e ){\n\t    var pos = r.projectIntoViewport( e.clientX, e.clientY );\n\t\n\t    r.cy.trigger( new Event( e, {\n\t      type: 'mouseout',\n\t      cyPosition: { x: pos[0], y: pos[1] }\n\t    } ) );\n\t  }, false );\n\t\n\t  r.registerBinding( r.container, 'mouseover', function mouseOverHandler( e ){\n\t    var pos = r.projectIntoViewport( e.clientX, e.clientY );\n\t\n\t    r.cy.trigger( new Event( e, {\n\t      type: 'mouseover',\n\t      cyPosition: { x: pos[0], y: pos[1] }\n\t    } ) );\n\t  }, false );\n\t\n\t  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n\t  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n\t  var center1, modelCenter1; // center point on start pinch to zoom\n\t  var offsetLeft, offsetTop;\n\t  var containerWidth, containerHeight;\n\t  var twoFingersStartInside;\n\t\n\t  var distance = function( x1, y1, x2, y2 ){\n\t    return Math.sqrt( (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) );\n\t  };\n\t\n\t  var distanceSq = function( x1, y1, x2, y2 ){\n\t    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\t  };\n\t\n\t  var touchstartHandler;\n\t  r.registerBinding( r.container, 'touchstart', touchstartHandler = function( e ){\n\t    r.touchData.capture = true;\n\t    r.data.bgActivePosistion = undefined;\n\t\n\t    var cy = r.cy;\n\t    var now = r.touchData.now;\n\t    var earlier = r.touchData.earlier;\n\t\n\t    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n\t    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n\t    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\t\n\t    // record starting points for pinch-to-zoom\n\t    if( e.touches[1] ){\n\t\n\t      freeDraggedElements( r.dragData.touchDragEles );\n\t\n\t      var offsets = r.findContainerClientCoords();\n\t      offsetLeft = offsets[0];\n\t      offsetTop = offsets[1];\n\t      containerWidth = offsets[2];\n\t      containerHeight = offsets[3];\n\t\n\t      f1x1 = e.touches[0].clientX - offsetLeft;\n\t      f1y1 = e.touches[0].clientY - offsetTop;\n\t\n\t      f2x1 = e.touches[1].clientX - offsetLeft;\n\t      f2y1 = e.touches[1].clientY - offsetTop;\n\t\n\t      twoFingersStartInside =\n\t           0 <= f1x1 && f1x1 <= containerWidth\n\t        && 0 <= f2x1 && f2x1 <= containerWidth\n\t        && 0 <= f1y1 && f1y1 <= containerHeight\n\t        && 0 <= f2y1 && f2y1 <= containerHeight\n\t      ;\n\t\n\t      var pan = cy.pan();\n\t      var zoom = cy.zoom();\n\t\n\t      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );\n\t      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );\n\t      center1 = [ (f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2 ];\n\t      modelCenter1 = [\n\t        (center1[0] - pan.x) / zoom,\n\t        (center1[1] - pan.y) / zoom\n\t      ];\n\t\n\t      // consider context tap\n\t      var cxtDistThreshold = 200;\n\t      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n\t      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){\n\t\n\t        var near1 = r.findNearestElement( now[0], now[1], true, true );\n\t        var near2 = r.findNearestElement( now[2], now[3], true, true );\n\t\n\t        if( near1 && near1.isNode() ){\n\t          near1.activate().trigger( new Event( e, {\n\t            type: 'cxttapstart',\n\t            cyPosition: { x: now[0], y: now[1] }\n\t          } ) );\n\t          r.touchData.start = near1;\n\t\n\t        } else if( near2 && near2.isNode() ){\n\t          near2.activate().trigger( new Event( e, {\n\t            type: 'cxttapstart',\n\t            cyPosition: { x: now[0], y: now[1] }\n\t          } ) );\n\t          r.touchData.start = near2;\n\t\n\t        } else {\n\t          cy.trigger( new Event( e, {\n\t            type: 'cxttapstart',\n\t            cyPosition: { x: now[0], y: now[1] }\n\t          } ) );\n\t          r.touchData.start = null;\n\t        }\n\t\n\t        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n\t        r.touchData.cxt = true;\n\t        r.touchData.cxtDragged = false;\n\t        r.data.bgActivePosistion = undefined;\n\t\n\t        r.redraw();\n\t        return;\n\t\n\t      }\n\t\n\t    }\n\t\n\t    if( e.touches[2] ){\n\t\n\t    } else if( e.touches[1] ){\n\t\n\t    } else if( e.touches[0] ){\n\t      var nears = r.findNearestElements( now[0], now[1], true, true );\n\t      var near = nears[0];\n\t\n\t      if( near != null ){\n\t        near.activate();\n\t\n\t        r.touchData.start = near;\n\t        r.touchData.starts = nears;\n\t\n\t        if( r.nodeIsGrabbable( near ) ){\n\t\n\t          var draggedEles = r.dragData.touchDragEles = [];\n\t\n\t          r.redrawHint( 'eles', true );\n\t          r.redrawHint( 'drag', true );\n\t\n\t          if( near.selected() ){\n\t            // reset drag elements, since near will be added again\n\t\n\t            var selectedNodes = cy.$( function(){\n\t              return this.selected() && r.nodeIsGrabbable( this );\n\t            } );\n\t\n\t            addNodesToDrag( selectedNodes, { addToList: draggedEles } );\n\t          } else {\n\t            addNodeToDrag( near, { addToList: draggedEles } );\n\t          }\n\t\n\t          setGrabTarget( near );\n\t\n\t          near.trigger( new Event( e, {\n\t            type: 'grab',\n\t            cyPosition: { x: now[0], y: now[1] }\n\t          } ) );\n\t        }\n\t      }\n\t\n\t      triggerEvents( near, [ 'touchstart', 'tapstart', 'vmousedown' ], e, {\n\t        cyPosition: { x: now[0], y: now[1] }\n\t      } );\n\t\n\t      if( near == null ){\n\t        r.data.bgActivePosistion = {\n\t          x: pos[0],\n\t          y: pos[1]\n\t        };\n\t\n\t        r.redrawHint( 'select', true );\n\t        r.redraw();\n\t      }\n\t\n\t\n\t      // Tap, taphold\n\t      // -----\n\t\n\t      r.touchData.startPosition = [];\n\t      for (var i=0; i<now.length; i++) {\n\t        earlier[i] = now[i];\n\t        r.touchData.startPosition[i] = now[i];\n\t      }\n\t\n\t      r.touchData.startGPosition = [ e.touches[0].clientX, e.touches[0].clientY ];\n\t\n\t      r.touchData.singleTouchMoved = false;\n\t      r.touchData.singleTouchStartTime = +new Date();\n\t\n\t      clearTimeout( r.touchData.tapholdTimeout );\n\t      r.touchData.tapholdTimeout = setTimeout( function(){\n\t        if(\n\t            r.touchData.singleTouchMoved === false\n\t            && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n\t            && !r.touchData.selecting // box selection shouldn't allow taphold through\n\t        ){\n\t          triggerEvents( r.touchData.start, [ 'taphold' ], e, {\n\t            cyPosition: { x: now[0], y: now[1] }\n\t          } );\n\t\n\t          if( !r.touchData.start ){\n\t            cy.$( ':selected' ).unselect();\n\t          }\n\t\n\t        }\n\t      }, r.tapholdDuration );\n\t    }\n\t\n\t  }, false );\n\t\n\t  var touchmoveHandler;\n\t  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) {\n\t    var select = r.selection;\n\t    var capture = r.touchData.capture;\n\t    var cy = r.cy;\n\t    var now = r.touchData.now;\n\t    var earlier = r.touchData.earlier;\n\t    var zoom = cy.zoom();\n\t\n\t    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n\t    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n\t    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\t\n\t    var isOverThresholdDrag;\n\t\n\t    if( capture && e.touches[0] ){\n\t      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }\n\t      var startGPos = r.touchData.startGPosition;\n\t      var dx = e.touches[0].clientX - startGPos[0];\n\t      var dx2 = dx * dx;\n\t      var dy = e.touches[0].clientY - startGPos[1];\n\t      var dy2 = dy * dy;\n\t      var dist2 = dx2 + dy2;\n\t\n\t      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n\t    }\n\t\n\t    // context swipe cancelling\n\t    if( capture && r.touchData.cxt ){\n\t      e.preventDefault();\n\t\n\t      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n\t      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n\t      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n\t      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n\t      var factorSq = distance2Sq / distance1Sq;\n\t\n\t      var distThreshold = 150;\n\t      var distThresholdSq = distThreshold * distThreshold;\n\t      var factorThreshold = 1.5;\n\t      var factorThresholdSq = factorThreshold * factorThreshold;\n\t\n\t      // cancel ctx gestures if the distance b/t the fingers increases\n\t      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){\n\t        r.touchData.cxt = false;\n\t        if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }\n\t        r.data.bgActivePosistion = undefined;\n\t        r.redrawHint( 'select', true );\n\t\n\t        var cxtEvt = new Event( e, {\n\t          type: 'cxttapend',\n\t          cyPosition: { x: now[0], y: now[1] }\n\t        } );\n\t        if( r.touchData.start ){\n\t          r.touchData.start.trigger( cxtEvt );\n\t        } else {\n\t          cy.trigger( cxtEvt );\n\t        }\n\t      }\n\t\n\t    }\n\t\n\t    // context swipe\n\t    if( capture && r.touchData.cxt ){\n\t      var cxtEvt = new Event( e, {\n\t        type: 'cxtdrag',\n\t        cyPosition: { x: now[0], y: now[1] }\n\t      } );\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint( 'select', true );\n\t\n\t      if( r.touchData.start ){\n\t        r.touchData.start.trigger( cxtEvt );\n\t      } else {\n\t        cy.trigger( cxtEvt );\n\t      }\n\t\n\t      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n\t      r.touchData.cxtDragged = true;\n\t\n\t      var near = r.findNearestElement( now[0], now[1], true, true );\n\t\n\t      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){\n\t\n\t        if( r.touchData.cxtOver ){\n\t          r.touchData.cxtOver.trigger( new Event( e, {\n\t            type: 'cxtdragout',\n\t            cyPosition: { x: now[0], y: now[1] }\n\t          } ) );\n\t        }\n\t\n\t        r.touchData.cxtOver = near;\n\t\n\t        if( near ){\n\t          near.trigger( new Event( e, {\n\t            type: 'cxtdragover',\n\t            cyPosition: { x: now[0], y: now[1] }\n\t          } ) );\n\t\n\t        }\n\t\n\t      }\n\t\n\t    // box selection\n\t    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){\n\t      e.preventDefault();\n\t\n\t      r.data.bgActivePosistion = undefined;\n\t\n\t      this.lastThreeTouch = +new Date();\n\t\n\t      if( !r.touchData.selecting ){\n\t        cy.trigger('boxstart');\n\t      }\n\t\n\t      r.touchData.selecting = true;\n\t\n\t      r.redrawHint( 'select', true );\n\t\n\t      if( !select || select.length === 0 || select[0] === undefined ){\n\t        select[0] = (now[0] + now[2] + now[4]) / 3;\n\t        select[1] = (now[1] + now[3] + now[5]) / 3;\n\t        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n\t        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n\t      } else {\n\t        select[2] = (now[0] + now[2] + now[4]) / 3;\n\t        select[3] = (now[1] + now[3] + now[5]) / 3;\n\t      }\n\t\n\t      select[4] = 1;\n\t      r.touchData.selecting = true;\n\t\n\t      r.redraw();\n\t\n\t    // pinch to zoom\n\t    } else if( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ){ // two fingers => pinch to zoom\n\t      e.preventDefault();\n\t\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint( 'select', true );\n\t\n\t      var draggedEles = r.dragData.touchDragEles;\n\t      if( draggedEles ){\n\t        r.redrawHint( 'drag', true );\n\t\n\t        for( var i = 0; i < draggedEles.length; i++ ){\n\t          draggedEles[ i ]._private.grabbed = false;\n\t          draggedEles[ i ]._private.rscratch.inDragLayer = false;\n\t        }\n\t      }\n\t\n\t      // (x2, y2) for fingers 1 and 2\n\t      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n\t      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n\t\n\t\n\t      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n\t      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n\t      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n\t      var factor = distance2 / distance1;\n\t\n\t      if( factor != 1 && twoFingersStartInside ){\n\t        // delta finger1\n\t        var df1x = f1x2 - f1x1;\n\t        var df1y = f1y2 - f1y1;\n\t\n\t        // delta finger 2\n\t        var df2x = f2x2 - f2x1;\n\t        var df2y = f2y2 - f2y1;\n\t\n\t        // translation is the normalised vector of the two fingers movement\n\t        // i.e. so pinching cancels out and moving together pans\n\t        var tx = (df1x + df2x) / 2;\n\t        var ty = (df1y + df2y) / 2;\n\t\n\t        // adjust factor by the speed multiplier\n\t        // var speed = 1.5;\n\t        // if( factor > 1 ){\n\t        //   factor = (factor - 1) * speed + 1;\n\t        // } else {\n\t        //   factor = 1 - (1 - factor) * speed;\n\t        // }\n\t\n\t        // now calculate the zoom\n\t        var zoom1 = cy.zoom();\n\t        var zoom2 = zoom1 * factor;\n\t        var pan1 = cy.pan();\n\t\n\t        // the model center point converted to the current rendered pos\n\t        var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n\t        var ctry = modelCenter1[1] * zoom1 + pan1.y;\n\t\n\t        var pan2 = {\n\t          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n\t          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n\t        };\n\t\n\t        // remove dragged eles\n\t        if( r.touchData.start ){\n\t          var draggedEles = r.dragData.touchDragEles;\n\t\n\t          freeDraggedElements( draggedEles );\n\t\n\t          r.redrawHint( 'drag', true );\n\t          r.redrawHint( 'eles', true );\n\t\n\t          r.touchData.start\n\t            .trigger( 'free' )\n\t            .unactivate()\n\t          ;\n\t        }\n\t\n\t        cy.viewport( {\n\t          zoom: zoom2,\n\t          pan: pan2,\n\t          cancelOnFailedZoom: true\n\t        } );\n\t\n\t        distance1 = distance2;\n\t        f1x1 = f1x2;\n\t        f1y1 = f1y2;\n\t        f2x1 = f2x2;\n\t        f2y1 = f2y2;\n\t\n\t        r.pinching = true;\n\t      }\n\t\n\t      // Re-project\n\t      if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n\t      if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n\t      if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\t\n\t    } else if( e.touches[0] ){\n\t      var start = r.touchData.start;\n\t      var last = r.touchData.last;\n\t      var near;\n\t\n\t      if( !r.hoverData.draggingEles && !r.swipePanning ){\n\t        near = r.findNearestElement( now[0], now[1], true, true );\n\t      }\n\t\n\t      if( capture && start != null ){\n\t        e.preventDefault();\n\t      }\n\t\n\t      // dragging nodes\n\t      if( capture && start != null && r.nodeIsDraggable( start ) ){\n\t\n\t        if( isOverThresholdDrag ){ // then dragging can happen\n\t          var draggedEles = r.dragData.touchDragEles;\n\t          var justStartedDrag = !r.dragData.didDrag;\n\t\n\t          if( justStartedDrag ){\n\t            addNodesToDrag( cy.collection( draggedEles ), { inDragLayer: true } );\n\t          }\n\t\n\t          for( var k = 0; k < draggedEles.length; k++ ){\n\t            var draggedEle = draggedEles[ k ];\n\t\n\t            if( r.nodeIsDraggable( draggedEle ) && draggedEle.grabbed() ){\n\t              r.dragData.didDrag = true;\n\t              var dPos = draggedEle._private.position;\n\t              var updatePos = !draggedEle.isParent();\n\t\n\t              if( updatePos && is.number( disp[0] ) && is.number( disp[1] ) ){\n\t                dPos.x += disp[0];\n\t                dPos.y += disp[1];\n\t              }\n\t\n\t              if( justStartedDrag ){\n\t                r.redrawHint( 'eles', true );\n\t\n\t                var dragDelta = r.touchData.dragDelta;\n\t\n\t                if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){\n\t                  dPos.x += dragDelta[0];\n\t                  dPos.y += dragDelta[1];\n\t                }\n\t\n\t              }\n\t            }\n\t          }\n\t\n\t          var tcol = cy.collection( draggedEles );\n\t\n\t          tcol.updateCompoundBounds();\n\t          tcol.trigger( 'position drag' );\n\t\n\t          r.hoverData.draggingEles = true;\n\t\n\t          r.redrawHint( 'drag', true );\n\t\n\t          if(\n\t               r.touchData.startPosition[0] == earlier[0]\n\t            && r.touchData.startPosition[1] == earlier[1]\n\t          ){\n\t\n\t            r.redrawHint( 'eles', true );\n\t          }\n\t\n\t          r.redraw();\n\t        } else { // otherise keep track of drag delta for later\n\t          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\t\n\t          if( dragDelta.length === 0 ){\n\t            dragDelta.push( disp[0] );\n\t            dragDelta.push( disp[1] );\n\t          } else {\n\t            dragDelta[0] += disp[0];\n\t            dragDelta[1] += disp[1];\n\t          }\n\t        }\n\t      }\n\t\n\t      // touchmove\n\t      {\n\t        triggerEvents( (start || near), [ 'touchmove', 'tapdrag', 'vmousemove' ], e, {\n\t          cyPosition: { x: now[0], y: now[1] }\n\t        } );\n\t\n\t        if( ( !start || !start.grabbed() ) && near != last ){\n\t          if( last ){ last.trigger( new Event( e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } } ) ); }\n\t          if( near ){ near.trigger( new Event( e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } } ) ); }\n\t        }\n\t\n\t        r.touchData.last = near;\n\t      }\n\t\n\t      // check to cancel taphold\n\t      if( capture ){\n\t        for( var i = 0; i < now.length; i++ ){\n\t          if( now[ i ]\n\t            && r.touchData.startPosition[ i ]\n\t            && isOverThresholdDrag ){\n\t\n\t            r.touchData.singleTouchMoved = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      // panning\n\t      if(\n\t          capture\n\t          && ( start == null || start.isEdge() )\n\t          && cy.panningEnabled() && cy.userPanningEnabled()\n\t      ){\n\t\n\t        var allowPassthrough = allowPanningPassthrough( start, r.touchData.starts );\n\t\n\t        if( allowPassthrough ){\n\t          e.preventDefault();\n\t\n\t          if( r.swipePanning ){\n\t            cy.panBy( {\n\t              x: disp[0] * zoom,\n\t              y: disp[1] * zoom\n\t            } );\n\t\n\t          } else if( isOverThresholdDrag ){\n\t            r.swipePanning = true;\n\t\n\t            cy.panBy( {\n\t              x: dx * zoom,\n\t              y: dy * zoom\n\t            } );\n\t\n\t            if( start ){\n\t              start.unactivate();\n\t\n\t              if( !r.data.bgActivePosistion ){\n\t                r.data.bgActivePosistion = math.array2point( r.touchData.startPosition );\n\t              }\n\t\n\t              r.redrawHint( 'select', true );\n\t\n\t              r.touchData.start = null;\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t        // Re-project\n\t        var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY );\n\t        now[0] = pos[0]; now[1] = pos[1];\n\t      }\n\t    }\n\t\n\t    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }\n\t    //r.redraw();\n\t\n\t  }, false );\n\t\n\t  var touchcancelHandler;\n\t  r.registerBinding( window, 'touchcancel', touchcancelHandler = function( e ){\n\t    var start = r.touchData.start;\n\t\n\t    r.touchData.capture = false;\n\t\n\t    if( start ){\n\t      start.unactivate();\n\t    }\n\t  } );\n\t\n\t  var touchendHandler;\n\t  r.registerBinding( window, 'touchend', touchendHandler = function( e ){\n\t    var start = r.touchData.start;\n\t\n\t    var capture = r.touchData.capture;\n\t\n\t    if( capture ){\n\t      r.touchData.capture = false;\n\t\n\t      e.preventDefault();\n\t    } else {\n\t      return;\n\t    }\n\t\n\t    var select = r.selection;\n\t\n\t    r.swipePanning = false;\n\t    r.hoverData.draggingEles = false;\n\t\n\t    var cy = r.cy;\n\t    var zoom = cy.zoom();\n\t    var now = r.touchData.now;\n\t    var earlier = r.touchData.earlier;\n\t\n\t    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n\t    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n\t    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\t\n\t    if( start ){\n\t      start.unactivate();\n\t    }\n\t\n\t    var ctxTapend;\n\t    if( r.touchData.cxt ){\n\t      ctxTapend = new Event( e, {\n\t        type: 'cxttapend',\n\t        cyPosition: { x: now[0], y: now[1] }\n\t      } );\n\t\n\t      if( start ){\n\t        start.trigger( ctxTapend );\n\t      } else {\n\t        cy.trigger( ctxTapend );\n\t      }\n\t\n\t      if( !r.touchData.cxtDragged ){\n\t        var ctxTap = new Event( e, {\n\t          type: 'cxttap',\n\t          cyPosition: { x: now[0], y: now[1] }\n\t        } );\n\t\n\t        if( start ){\n\t          start.trigger( ctxTap );\n\t        } else {\n\t          cy.trigger( ctxTap );\n\t        }\n\t\n\t      }\n\t\n\t      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n\t      r.touchData.cxt = false;\n\t      r.touchData.start = null;\n\t\n\t      r.redraw();\n\t      return;\n\t    }\n\t\n\t    // no more box selection if we don't have three fingers\n\t    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){\n\t      r.touchData.selecting = false;\n\t\n\t      var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );\n\t\n\t      select[0] = undefined;\n\t      select[1] = undefined;\n\t      select[2] = undefined;\n\t      select[3] = undefined;\n\t      select[4] = 0;\n\t\n\t      r.redrawHint( 'select', true );\n\t\n\t      cy.trigger('boxend');\n\t\n\t      var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };\n\t\n\t      box\n\t        .trigger('box')\n\t        .stdFilter( eleWouldBeSelected )\n\t          .select()\n\t          .trigger('boxselect')\n\t      ;\n\t\n\t      if( box.nonempty() ){\n\t        r.redrawHint( 'eles', true );\n\t      }\n\t\n\t      r.redraw();\n\t    }\n\t\n\t    if( start != null ){\n\t      start.unactivate();\n\t    }\n\t\n\t    if( e.touches[2] ){\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint( 'select', true );\n\t    } else if( e.touches[1] ){\n\t\n\t    } else if( e.touches[0] ){\n\t\n\t    // Last touch released\n\t    } else if( !e.touches[0] ){\n\t\n\t      r.data.bgActivePosistion = undefined;\n\t      r.redrawHint( 'select', true );\n\t\n\t      var draggedEles = r.dragData.touchDragEles;\n\t\n\t      if( start != null ){\n\t\n\t        var startWasGrabbed = start._private.grabbed;\n\t\n\t        freeDraggedElements( draggedEles );\n\t\n\t        r.redrawHint( 'drag', true );\n\t        r.redrawHint( 'eles', true );\n\t\n\t        if( startWasGrabbed ){\n\t          start.trigger( 'free' );\n\t        }\n\t\n\t        triggerEvents( start, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {\n\t          cyPosition: { x: now[0], y: now[1] }\n\t        } );\n\t\n\t        start.unactivate();\n\t\n\t        r.touchData.start = null;\n\t\n\t      } else {\n\t        var near = r.findNearestElement( now[0], now[1], true, true );\n\t\n\t        triggerEvents( near, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {\n\t          cyPosition: { x: now[0], y: now[1] }\n\t        } );\n\t\n\t      }\n\t\n\t      var dx = r.touchData.startPosition[0] - now[0];\n\t      var dx2 = dx * dx;\n\t      var dy = r.touchData.startPosition[1] - now[1];\n\t      var dy2 = dy * dy;\n\t      var dist2 = dx2 + dy2;\n\t      var rdist2 = dist2 * zoom * zoom;\n\t\n\t      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n\t      if( start != null\n\t          && !r.dragData.didDrag // didn't drag nodes around\n\t          && start._private.selectable\n\t          && rdist2 < r.touchTapThreshold2\n\t          && !r.pinching // pinch to zoom should not affect selection\n\t      ){\n\t\n\t        if( cy.selectionType() === 'single' ){\n\t          cy.$( ':selected' ).unmerge( start ).unselect();\n\t          start.select();\n\t        } else {\n\t          if( start.selected() ){\n\t            start.unselect();\n\t          } else {\n\t            start.select();\n\t          }\n\t        }\n\t\n\t        r.redrawHint( 'eles', true );\n\t      }\n\t\n\t      // Tap event, roughly same as mouse click event for touch\n\t      if( !r.touchData.singleTouchMoved ){\n\t        triggerEvents( start, [ 'tap', 'vclick' ], e, {\n\t          cyPosition: { x: now[0], y: now[1] }\n\t        } );\n\t      }\n\t\n\t      r.touchData.singleTouchMoved = true;\n\t    }\n\t\n\t    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }\n\t\n\t    r.dragData.didDrag = false; // reset for next mousedown\n\t\n\t    if( e.touches.length === 0 ){\n\t      r.touchData.dragDelta = [];\n\t      r.touchData.startPosition = null;\n\t      r.touchData.startGPosition = null;\n\t    }\n\t\n\t    if( e.touches.length < 2 ){\n\t      r.pinching = false;\n\t      r.redrawHint( 'eles', true );\n\t      r.redraw();\n\t    }\n\t\n\t    //r.redraw();\n\t\n\t  }, false );\n\t\n\t  // fallback compatibility layer for ms pointer events\n\t  if( typeof TouchEvent === 'undefined' ){\n\t\n\t    var pointers = [];\n\t\n\t    var makeTouch = function( e ){\n\t      return {\n\t        clientX: e.clientX,\n\t        clientY: e.clientY,\n\t        force: 1,\n\t        identifier: e.pointerId,\n\t        pageX: e.pageX,\n\t        pageY: e.pageY,\n\t        radiusX: e.width / 2,\n\t        radiusY: e.height / 2,\n\t        screenX: e.screenX,\n\t        screenY: e.screenY,\n\t        target: e.target\n\t      };\n\t    };\n\t\n\t    var makePointer = function( e ){\n\t      return {\n\t        event: e,\n\t        touch: makeTouch( e )\n\t      };\n\t    };\n\t\n\t    var addPointer = function( e ){\n\t      pointers.push( makePointer( e ) );\n\t    };\n\t\n\t    var removePointer = function( e ){\n\t      for( var i = 0; i < pointers.length; i++ ){\n\t        var p = pointers[ i ];\n\t\n\t        if( p.event.pointerId === e.pointerId ){\n\t          pointers.splice( i, 1 );\n\t          return;\n\t        }\n\t      }\n\t    };\n\t\n\t    var updatePointer = function( e ){\n\t      var p = pointers.filter( function( p ){\n\t        return p.event.pointerId === e.pointerId;\n\t      } )[0];\n\t\n\t      p.event = e;\n\t      p.touch = makeTouch( e );\n\t    };\n\t\n\t    var addTouchesToEvent = function( e ){\n\t      e.touches = pointers.map( function( p ){\n\t        return p.touch;\n\t      } );\n\t    };\n\t\n\t    r.registerBinding( r.container, 'pointerdown', function( e ){\n\t      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\t\n\t      e.preventDefault();\n\t\n\t      addPointer( e );\n\t\n\t      addTouchesToEvent( e );\n\t      touchstartHandler( e );\n\t    } );\n\t\n\t    r.registerBinding( r.container, 'pointerup', function( e ){\n\t      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\t\n\t      removePointer( e );\n\t\n\t      addTouchesToEvent( e );\n\t      touchendHandler( e );\n\t    } );\n\t\n\t    r.registerBinding( r.container, 'pointercancel', function( e ){\n\t      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\t\n\t      removePointer( e );\n\t\n\t      addTouchesToEvent( e );\n\t      touchcancelHandler( e );\n\t    } );\n\t\n\t    r.registerBinding( r.container, 'pointermove', function( e ){\n\t      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\t\n\t      e.preventDefault();\n\t\n\t      updatePointer( e );\n\t\n\t      addTouchesToEvent( e );\n\t      touchmoveHandler( e );\n\t    } );\n\t\n\t  }\n\t};\n\t\n\tmodule.exports = BRp;\n\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar BRp = {};\n\t\n\tBRp.registerNodeShapes = function(){\n\t  var nodeShapes = this.nodeShapes = {};\n\t  var renderer = this;\n\t\n\t  nodeShapes[ 'ellipse' ] = {\n\t    name: 'ellipse',\n\t\n\t    draw: function( context, centerX, centerY, width, height ){\n\t      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );\n\t    },\n\t\n\t    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){\n\t      return math.intersectLineEllipse(\n\t        x, y,\n\t        nodeX,\n\t        nodeY,\n\t        width / 2 + padding,\n\t        height / 2 + padding )\n\t      ;\n\t    },\n\t\n\t    checkPoint: function( x, y, padding, width, height, centerX, centerY ){\n\t      x -= centerX;\n\t      y -= centerY;\n\t\n\t      x /= (width / 2 + padding);\n\t      y /= (height / 2 + padding);\n\t\n\t      return x * x + y * y <= 1;\n\t    }\n\t  };\n\t\n\t  function generatePolygon( name, points ){\n\t    return ( nodeShapes[ name ] = {\n\t      name: name,\n\t\n\t      points: points,\n\t\n\t      draw: function( context, centerX, centerY, width, height ){\n\t        renderer.nodeShapeImpl( 'polygon' )( context, centerX, centerY, width, height, this.points );\n\t      },\n\t\n\t      intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){\n\t        return math.polygonIntersectLine(\n\t            x, y,\n\t            this.points,\n\t            nodeX,\n\t            nodeY,\n\t            width / 2, height / 2,\n\t            padding )\n\t          ;\n\t      },\n\t\n\t      checkPoint: function( x, y, padding, width, height, centerX, centerY ){\n\t        return math.pointInsidePolygon( x, y, nodeShapes[ name ].points,\n\t          centerX, centerY, width, height, [0, -1], padding )\n\t        ;\n\t      }\n\t    } );\n\t  }\n\t\n\t  generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare( 3, 0 ) );\n\t\n\t  generatePolygon( 'square', math.generateUnitNgonPointsFitToSquare( 4, 0 ) );\n\t  nodeShapes[ 'rectangle' ] = nodeShapes[ 'square' ];\n\t\n\t  nodeShapes[ 'roundrectangle' ] = {\n\t    name: 'roundrectangle',\n\t\n\t    points: math.generateUnitNgonPointsFitToSquare( 4, 0 ),\n\t\n\t    draw: function( context, centerX, centerY, width, height ){\n\t      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );\n\t    },\n\t\n\t    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){\n\t      return math.roundRectangleIntersectLine(\n\t        x, y,\n\t        nodeX,\n\t        nodeY,\n\t        width, height,\n\t        padding )\n\t      ;\n\t    },\n\t\n\t    // Looks like the width passed into this function is actually the total width / 2\n\t    checkPoint: function(\n\t      x, y, padding, width, height, centerX, centerY ){\n\t\n\t      var cornerRadius = math.getRoundRectangleRadius( width, height );\n\t\n\t      // Check hBox\n\t      if( math.pointInsidePolygon( x, y, this.points,\n\t        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding ) ){\n\t        return true;\n\t      }\n\t\n\t      // Check vBox\n\t      if( math.pointInsidePolygon( x, y, this.points,\n\t        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding ) ){\n\t        return true;\n\t      }\n\t\n\t      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){\n\t        x -= centerX;\n\t        y -= centerY;\n\t\n\t        x /= (width / 2 + padding);\n\t        y /= (height / 2 + padding);\n\t\n\t        return (x * x + y * y <= 1);\n\t      };\n\t\n\t\n\t      // Check top left quarter circle\n\t      if( checkInEllipse( x, y,\n\t        centerX - width / 2 + cornerRadius,\n\t        centerY - height / 2 + cornerRadius,\n\t        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\t\n\t        return true;\n\t      }\n\t\n\t      // Check top right quarter circle\n\t      if( checkInEllipse( x, y,\n\t        centerX + width / 2 - cornerRadius,\n\t        centerY - height / 2 + cornerRadius,\n\t        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\t\n\t        return true;\n\t      }\n\t\n\t      // Check bottom right quarter circle\n\t      if( checkInEllipse( x, y,\n\t        centerX + width / 2 - cornerRadius,\n\t        centerY + height / 2 - cornerRadius,\n\t        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\t\n\t        return true;\n\t      }\n\t\n\t      // Check bottom left quarter circle\n\t      if( checkInEllipse( x, y,\n\t        centerX - width / 2 + cornerRadius,\n\t        centerY + height / 2 - cornerRadius,\n\t        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\t\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    }\n\t  };\n\t\n\t  generatePolygon( 'diamond', [\n\t    0, 1,\n\t    1, 0,\n\t    0, -1,\n\t    -1, 0\n\t  ] );\n\t\n\t  generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare( 5, 0 ) );\n\t\n\t  generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare( 6, 0 ) );\n\t\n\t  generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare( 7, 0 ) );\n\t\n\t  generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare( 8, 0 ) );\n\t\n\t  var star5Points = new Array( 20 );\n\t  {\n\t    var outerPoints = math.generateUnitNgonPoints( 5, 0 );\n\t    var innerPoints = math.generateUnitNgonPoints( 5, Math.PI / 5 );\n\t\n\t    // Outer radius is 1; inner radius of star is smaller\n\t    var innerRadius = 0.5 * (3 - Math.sqrt( 5 ));\n\t    innerRadius *= 1.57;\n\t\n\t    for( var i = 0;i < innerPoints.length / 2;i++ ){\n\t      innerPoints[ i * 2] *= innerRadius;\n\t      innerPoints[ i * 2 + 1] *= innerRadius;\n\t    }\n\t\n\t    for( var i = 0;i < 20 / 4;i++ ){\n\t      star5Points[ i * 4] = outerPoints[ i * 2];\n\t      star5Points[ i * 4 + 1] = outerPoints[ i * 2 + 1];\n\t\n\t      star5Points[ i * 4 + 2] = innerPoints[ i * 2];\n\t      star5Points[ i * 4 + 3] = innerPoints[ i * 2 + 1];\n\t    }\n\t  }\n\t\n\t  star5Points = math.fitPolygonToSquare( star5Points );\n\t\n\t  generatePolygon( 'star', star5Points );\n\t\n\t  generatePolygon( 'vee', [\n\t    -1, -1,\n\t    0, -0.333,\n\t    1, -1,\n\t    0, 1\n\t  ] );\n\t\n\t  generatePolygon( 'rhomboid', [\n\t    -1, -1,\n\t    0.333, -1,\n\t    1, 1,\n\t    -0.333, 1\n\t  ] );\n\t\n\t  nodeShapes.makePolygon = function( points ){\n\t\n\t    // use caching on user-specified polygons so they are as fast as native shapes\n\t\n\t    var key = points.join( '$' );\n\t    var name = 'polygon-' + key;\n\t    var shape;\n\t\n\t    if( (shape = nodeShapes[ name ]) ){ // got cached shape\n\t      return shape;\n\t    }\n\t\n\t    // create and cache new shape\n\t    return generatePolygon( name, points );\n\t  };\n\t\n\t};\n\t\n\tmodule.exports = BRp;\n\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar BRp = {};\n\t\n\tBRp.timeToRender = function(){\n\t  return this.redrawTotalTime / this.redrawCount;\n\t};\n\t\n\tBRp.redraw = function( options ){\n\t  options = options || util.staticEmptyObject();\n\t\n\t  var r = this;\n\t\n\t  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }\n\t  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }\n\t  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }\n\t\n\t  r.requestedFrame = true;\n\t  r.renderOptions = options;\n\t};\n\t\n\tBRp.beforeRender = function( fn, priority ){\n\t  priority = priority || 0;\n\t\n\t  var cbs = this.beforeRenderCallbacks;\n\t\n\t  cbs.push({ fn: fn, priority: priority });\n\t\n\t  // higher priority callbacks executed first\n\t  cbs.sort(function( a, b ){ return b.priority - a.priority; });\n\t};\n\t\n\tBRp.startRenderLoop = function(){\n\t  var r = this;\n\t\n\t  if( r.renderLoopStarted ){\n\t    return;\n\t  } else {\n\t    r.renderLoopStarted = true;\n\t  }\n\t\n\t  var beforeRenderCallbacks = function( willDraw, startTime ){\n\t    var cbs = r.beforeRenderCallbacks;\n\t\n\t    for( var i = 0; i < cbs.length; i++ ){\n\t      cbs[i].fn( willDraw, startTime );\n\t    }\n\t  };\n\t\n\t  var renderFn = function( requestTime ){\n\t    if( r.destroyed ){ return; }\n\t\n\t    if( r.requestedFrame && !r.skipFrame ){\n\t      beforeRenderCallbacks( true, requestTime );\n\t\n\t      var startTime = util.performanceNow();\n\t\n\t      r.render( r.renderOptions );\n\t\n\t      var endTime = r.lastDrawTime = util.performanceNow();\n\t\n\t      if( r.averageRedrawTime === undefined ){\n\t        r.averageRedrawTime = endTime - startTime;\n\t      }\n\t\n\t      if( r.redrawCount === undefined ){\n\t        r.redrawCount = 0;\n\t      }\n\t\n\t      r.redrawCount++;\n\t\n\t      if( r.redrawTotalTime === undefined ){\n\t        r.redrawTotalTime = 0;\n\t      }\n\t\n\t      var duration = endTime - startTime;\n\t\n\t      r.redrawTotalTime += duration;\n\t      r.lastRedrawTime = duration;\n\t\n\t      // use a weighted average with a bias from the previous average so we don't spike so easily\n\t      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n\t\n\t      r.requestedFrame = false;\n\t    } else {\n\t      beforeRenderCallbacks( false, requestTime );\n\t    }\n\t\n\t    r.skipFrame = false;\n\t\n\t    util.requestAnimationFrame( renderFn );\n\t  };\n\t\n\t  util.requestAnimationFrame( renderFn );\n\t\n\t};\n\t\n\tmodule.exports = BRp;\n\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\tThe canvas renderer was written by Yue Dong.\n\t\n\tModifications tracked on Github.\n\t*/\n\t\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar is = __webpack_require__( 30 );\n\tvar ElementTextureCache = __webpack_require__(120);\n\tvar LayeredTextureCache = __webpack_require__(122);\n\t\n\tvar CR = CanvasRenderer;\n\tvar CRp = CanvasRenderer.prototype;\n\t\n\tCRp.CANVAS_LAYERS = 3;\n\t//\n\tCRp.SELECT_BOX = 0;\n\tCRp.DRAG = 1;\n\tCRp.NODE = 2;\n\t\n\tCRp.BUFFER_COUNT = 3;\n\t//\n\tCRp.TEXTURE_BUFFER = 0;\n\tCRp.MOTIONBLUR_BUFFER_NODE = 1;\n\tCRp.MOTIONBLUR_BUFFER_DRAG = 2;\n\t\n\tfunction CanvasRenderer( options ){\n\t  var r = this;\n\t\n\t  r.data = {\n\t    canvases: new Array( CRp.CANVAS_LAYERS ),\n\t    contexts: new Array( CRp.CANVAS_LAYERS ),\n\t    canvasNeedsRedraw: new Array( CRp.CANVAS_LAYERS ),\n\t\n\t    bufferCanvases: new Array( CRp.BUFFER_COUNT ),\n\t    bufferContexts: new Array( CRp.CANVAS_LAYERS ),\n\t  };\n\t\n\t  r.data.canvasContainer = document.createElement( 'div' );\n\t  var containerStyle = r.data.canvasContainer.style;\n\t  r.data.canvasContainer.setAttribute( 'style', '-webkit-tap-highlight-color: rgba(0,0,0,0);' );\n\t  containerStyle.position = 'relative';\n\t  containerStyle.zIndex = '0';\n\t  containerStyle.overflow = 'hidden';\n\t\n\t  var container = options.cy.container();\n\t  container.appendChild( r.data.canvasContainer );\n\t  container.setAttribute( 'style', ( container.getAttribute( 'style' ) || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);' );\n\t\n\t  for( var i = 0; i < CRp.CANVAS_LAYERS; i++ ){\n\t    var canvas = r.data.canvases[ i ] = document.createElement( 'canvas' );\n\t    r.data.contexts[ i ] = canvas.getContext( '2d' );\n\t    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );\n\t    canvas.style.position = 'absolute';\n\t    canvas.setAttribute( 'data-id', 'layer' + i );\n\t    canvas.style.zIndex = String( CRp.CANVAS_LAYERS - i );\n\t    r.data.canvasContainer.appendChild( canvas );\n\t\n\t    r.data.canvasNeedsRedraw[ i ] = false;\n\t  }\n\t  r.data.topCanvas = r.data.canvases[0];\n\t\n\t  r.data.canvases[ CRp.NODE ].setAttribute( 'data-id', 'layer' + CRp.NODE + '-node' );\n\t  r.data.canvases[ CRp.SELECT_BOX ].setAttribute( 'data-id', 'layer' + CRp.SELECT_BOX + '-selectbox' );\n\t  r.data.canvases[ CRp.DRAG ].setAttribute( 'data-id', 'layer' + CRp.DRAG + '-drag' );\n\t\n\t  for( var i = 0; i < CRp.BUFFER_COUNT; i++ ){\n\t    r.data.bufferCanvases[ i ] = document.createElement( 'canvas' );\n\t    r.data.bufferContexts[ i ] = r.data.bufferCanvases[ i ].getContext( '2d' );\n\t    r.data.bufferCanvases[ i ].style.position = 'absolute';\n\t    r.data.bufferCanvases[ i ].setAttribute( 'data-id', 'buffer' + i );\n\t    r.data.bufferCanvases[ i ].style.zIndex = String( -i - 1 );\n\t    r.data.bufferCanvases[ i ].style.visibility = 'hidden';\n\t    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n\t  }\n\t\n\t  r.pathsEnabled = true;\n\t\n\t  r.data.eleTxrCache = new ElementTextureCache( r );\n\t  r.data.lyrTxrCache = new LayeredTextureCache( r, r.data.eleTxrCache );\n\t\n\t  r.onUpdateEleCalcs(function invalidateTextureCaches( willDraw, eles ){\n\t    for( var i = 0; i < eles.length; i++ ){\n\t      var ele = eles[i];\n\t      var rs = ele._private.rstyle;\n\t      var de = rs.dirtyEvents;\n\t\n\t      if( ele.isNode() && de && de.length === 1 && de['position'] ){\n\t        // then keep cached ele texture\n\t      } else {\n\t        r.data.eleTxrCache.invalidateElement( ele );\n\t      }\n\t    }\n\t\n\t    if( eles.length > 0 ){\n\t      r.data.lyrTxrCache.invalidateElements( eles );\n\t    }\n\t  });\n\t}\n\t\n\tCRp.redrawHint = function( group, bool ){\n\t  var r = this;\n\t\n\t  switch( group ){\n\t    case 'eles':\n\t      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;\n\t      break;\n\t    case 'drag':\n\t      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;\n\t      break;\n\t    case 'select':\n\t      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;\n\t      break;\n\t  }\n\t};\n\t\n\t// whether to use Path2D caching for drawing\n\tvar pathsImpld = typeof Path2D !== 'undefined';\n\t\n\tCRp.path2dEnabled = function( on ){\n\t  if( on === undefined ){\n\t    return this.pathsEnabled;\n\t  }\n\t\n\t  this.pathsEnabled = on ? true : false;\n\t};\n\t\n\tCRp.usePaths = function(){\n\t  return pathsImpld && this.pathsEnabled;\n\t};\n\t\n\t[\n\t  __webpack_require__( 123 ),\n\t  __webpack_require__( 124 ),\n\t  __webpack_require__( 125 ),\n\t  __webpack_require__( 126 ),\n\t  __webpack_require__( 127 ),\n\t  __webpack_require__( 128 ),\n\t  __webpack_require__( 129 ),\n\t  __webpack_require__( 130 ),\n\t  __webpack_require__( 131 ),\n\t  __webpack_require__( 132 )\n\t].forEach( function( props ){\n\t  util.extend( CRp, props );\n\t} );\n\t\n\tmodule.exports = CR;\n\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar math = __webpack_require__( 33 );\n\tvar util = __webpack_require__( 32 );\n\tvar Heap = __webpack_require__( 45 );\n\tvar defs = __webpack_require__( 121 );\n\t\n\tvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\n\tvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\n\tvar minLvl = -4; // when scaling smaller than that we don't need to re-render\n\tvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n\tvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n\tvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\n\tvar defTxrWidth = 1024; // default/minimum texture width\n\tvar maxTxrW = 1024; // the maximum width of a texture\n\tvar maxTxrH = 1024;  // the maximum height of a texture\n\tvar minUtility = 0.5; // if usage of texture is less than this, it is retired\n\tvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\n\tvar maxFullnessChecks = 10; // dequeued after this many checks\n\tvar allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)\n\tvar allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)\n\tvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\tvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\tvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\tvar deqFastCost = 0.9; // % of frame time to be used when >60fps\n\tvar deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\tvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\t\n\tvar getTxrReasons = {\n\t  dequeue: 'dequeue',\n\t  downscale: 'downscale',\n\t  highQuality: 'highQuality'\n\t};\n\t\n\tvar ElementTextureCache = function( renderer ){\n\t  var self = this;\n\t\n\t  self.renderer = renderer;\n\t  self.onDequeues = [];\n\t\n\t  self.setupDequeueing();\n\t};\n\t\n\tvar ETCp = ElementTextureCache.prototype;\n\t\n\tETCp.reasons = getTxrReasons;\n\t\n\t// the list of textures in which new subtextures for elements can be placed\n\tETCp.getTextureQueue = function( txrH ){\n\t  var self = this;\n\t  self.eleImgCaches = self.eleImgCaches || {};\n\t\n\t  return ( self.eleImgCaches[ txrH ] = self.eleImgCaches[ txrH ] || [] );\n\t};\n\t\n\t// the list of usused textures which can be recycled (in use in texture queue)\n\tETCp.getRetiredTextureQueue = function( txrH ){\n\t  var self = this;\n\t\n\t  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n\t  var rtxtrQ = rtxtrQs[ txrH ] = rtxtrQs[ txrH ] || [];\n\t\n\t  return rtxtrQ;\n\t};\n\t\n\t// queue of element draw requests at different scale levels\n\tETCp.getElementQueue = function(){\n\t  var self = this;\n\t\n\t  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function( a, b ){\n\t    return b.reqs - a.reqs;\n\t  });\n\t\n\t  return q;\n\t};\n\t\n\t// queue of element draw requests at different scale levels (element id lookup)\n\tETCp.getElementIdToQueue = function(){\n\t  var self = this;\n\t\n\t  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};\n\t\n\t  return id2q;\n\t};\n\t\n\tETCp.getElement = function( ele, bb, pxRatio, lvl, reason ){\n\t  var self = this;\n\t  var r = this.renderer;\n\t  var rs = ele._private.rscratch;\n\t  var zoom = r.cy.zoom();\n\t\n\t  if( lvl == null ){\n\t    lvl = Math.ceil( math.log2( zoom * pxRatio ) );\n\t  }\n\t\n\t  if( lvl < minLvl ){\n\t    lvl = minLvl;\n\t  } else if( zoom >= maxZoom || lvl > maxLvl ){\n\t    return null;\n\t  }\n\t\n\t  var scale = Math.pow( 2, lvl );\n\t  var eleScaledH = bb.h * scale;\n\t  var eleScaledW = bb.w * scale;\n\t  var caches = rs.imgCaches = rs.imgCaches || {};\n\t  var eleCache = caches[lvl];\n\t\n\t  if( eleCache ){\n\t    return eleCache;\n\t  }\n\t\n\t  var txrH; // which texture height this ele belongs to\n\t\n\t  if( eleScaledH <= minTxrH ){\n\t    txrH = minTxrH;\n\t  } else if( eleScaledH <= txrStepH ){\n\t    txrH = txrStepH;\n\t  } else {\n\t    txrH = Math.ceil( eleScaledH / txrStepH ) * txrStepH;\n\t  }\n\t\n\t  if(\n\t    eleScaledH > maxTxrH\n\t    || eleScaledW > maxTxrW\n\t    || ( !allowEdgeTxrCaching && ele.isEdge() )\n\t    || ( !allowParentTxrCaching && ele.isParent() )\n\t  ){\n\t    return null; // caching large elements is not efficient\n\t  }\n\t\n\t  var txrQ = self.getTextureQueue( txrH );\n\t\n\t  // first try the second last one in case it has space at the end\n\t  var txr = txrQ[ txrQ.length - 2 ];\n\t\n\t  var addNewTxr = function(){\n\t    return self.recycleTexture( txrH, eleScaledW ) || self.addTexture( txrH, eleScaledW );\n\t  };\n\t\n\t  // try the last one if there is no second last one\n\t  if( !txr ){\n\t    txr = txrQ[ txrQ.length - 1 ];\n\t  }\n\t\n\t  // if the last one doesn't exist, we need a first one\n\t  if( !txr ){\n\t    txr = addNewTxr();\n\t  }\n\t\n\t  // if there's no room in the current texture, we need a new one\n\t  if( txr.width - txr.usedWidth < eleScaledW ){\n\t    txr = addNewTxr();\n\t  }\n\t\n\t  var scaledLabelShown = r.eleTextBiggerThanMin( ele, scale );\n\t  var scalableFrom = function( otherCache ){\n\t    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n\t  };\n\t\n\t  var deqing = reason && reason === getTxrReasons.dequeue;\n\t  var highQualityReq = reason && reason === getTxrReasons.highQuality;\n\t  var downscaleReq = reason && reason === getTxrReasons.downscale;\n\t\n\t  var higherCache; // the nearest cache with a higher level\n\t  for( var l = lvl + 1; l <= maxLvl; l++ ){\n\t    var c = caches[l];\n\t\n\t    if( c ){ higherCache = c; break; }\n\t  }\n\t\n\t  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n\t\n\t  var downscale = function(){\n\t    txr.context.drawImage(\n\t      oneUpCache.texture.canvas,\n\t      oneUpCache.x, 0,\n\t      oneUpCache.width, oneUpCache.height,\n\t      txr.usedWidth, 0,\n\t      eleScaledW, eleScaledH\n\t    );\n\t  };\n\t\n\t  if( scalableFrom(oneUpCache) ){\n\t    // then we can relatively cheaply rescale the existing image w/o rerendering\n\t    downscale();\n\t\n\t  } else if( scalableFrom(higherCache) ){\n\t    // then use the higher cache for now and queue the next level down\n\t    // to cheaply scale towards the smaller level\n\t\n\t    if( highQualityReq ){\n\t      for( var l = higherCache.level; l > lvl; l-- ){\n\t        oneUpCache = self.getElement( ele, bb, pxRatio, l, getTxrReasons.downscale );\n\t      }\n\t\n\t      downscale();\n\t\n\t    } else {\n\t      self.queueElement( ele, bb, higherCache.level - 1 );\n\t\n\t      return higherCache;\n\t    }\n\t  } else {\n\t\n\t    var lowerCache; // the nearest cache with a lower level\n\t    if( !deqing && !highQualityReq && !downscaleReq ){\n\t      for( var l = lvl - 1; l >= minLvl; l-- ){\n\t        var c = caches[l];\n\t\n\t        if( c ){ lowerCache = c; break; }\n\t      }\n\t    }\n\t\n\t    if( scalableFrom(lowerCache) ){\n\t      // then use the lower quality cache for now and queue the better one for later\n\t\n\t      self.queueElement( ele, bb, lvl );\n\t\n\t      return lowerCache;\n\t    }\n\t\n\t    txr.context.translate( txr.usedWidth, 0 );\n\t    txr.context.scale( scale, scale );\n\t\n\t    r.drawElement( txr.context, ele, bb, scaledLabelShown );\n\t\n\t    txr.context.scale( 1/scale, 1/scale );\n\t    txr.context.translate( -txr.usedWidth, 0 );\n\t  }\n\t\n\t  eleCache = caches[lvl] = {\n\t    ele: ele,\n\t    x: txr.usedWidth,\n\t    texture: txr,\n\t    level: lvl,\n\t    scale: scale,\n\t    width: eleScaledW,\n\t    height: eleScaledH,\n\t    scaledLabelShown: scaledLabelShown\n\t  };\n\t\n\t  txr.usedWidth += Math.ceil( eleScaledW + eleTxrSpacing );\n\t\n\t  txr.eleCaches.push( eleCache );\n\t\n\t  self.checkTextureFullness( txr );\n\t\n\t  return eleCache;\n\t};\n\t\n\tETCp.invalidateElement = function( ele ){\n\t  var self = this;\n\t  var caches = ele._private.rscratch.imgCaches;\n\t\n\t  if( caches ){\n\t    for( var lvl = minLvl; lvl <= maxLvl; lvl++ ){\n\t      var cache = caches[ lvl ];\n\t\n\t      if( cache ){\n\t        var txr = cache.texture;\n\t\n\t        // remove space from the texture it belongs to\n\t        txr.invalidatedWidth += cache.width;\n\t\n\t        // remove refs with the element\n\t        caches[ lvl ] = null;\n\t        util.removeFromArray( txr.eleCaches, cache );\n\t\n\t        // might have to remove the entire texture if it's not efficiently using its space\n\t        self.checkTextureUtility( txr );\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tETCp.checkTextureUtility = function( txr ){\n\t  // invalidate all entries in the cache if the cache size is small\n\t  if( txr.invalidatedWidth >= minUtility * txr.width ){\n\t    this.retireTexture( txr );\n\t  }\n\t};\n\t\n\tETCp.checkTextureFullness = function( txr ){\n\t  // if texture has been mostly filled and passed over several times, remove\n\t  // it from the queue so we don't need to waste time looking at it to put new things\n\t\n\t  var self = this;\n\t  var txrQ = self.getTextureQueue( txr.height );\n\t\n\t  if( txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks ){\n\t    util.removeFromArray( txrQ, txr );\n\t  } else {\n\t    txr.fullnessChecks++;\n\t  }\n\t};\n\t\n\tETCp.retireTexture = function( txr ){\n\t  var self = this;\n\t  var txrH = txr.height;\n\t  var txrQ = self.getTextureQueue( txrH );\n\t\n\t  // retire the texture from the active / searchable queue:\n\t\n\t  util.removeFromArray( txrQ, txr );\n\t\n\t  txr.retired = true;\n\t\n\t  // remove the refs from the eles to the caches:\n\t\n\t  var eleCaches = txr.eleCaches;\n\t\n\t  for( var i = 0; i < eleCaches.length; i++ ){\n\t    var eleCache = eleCaches[i];\n\t    var ele = eleCache.ele;\n\t    var lvl = eleCache.level;\n\t    var imgCaches = ele._private.rscratch.imgCaches;\n\t\n\t    if( imgCaches ){\n\t      imgCaches[ lvl ] = null;\n\t    }\n\t  }\n\t\n\t  util.clearArray( eleCaches );\n\t\n\t  // add the texture to a retired queue so it can be recycled in future:\n\t\n\t  var rtxtrQ = self.getRetiredTextureQueue( txrH );\n\t\n\t  rtxtrQ.push( txr );\n\t};\n\t\n\tETCp.addTexture = function( txrH, minW ){\n\t  var self = this;\n\t  var txrQ = self.getTextureQueue( txrH );\n\t  var txr = {};\n\t\n\t  txrQ.push( txr );\n\t\n\t  txr.eleCaches = [];\n\t\n\t  txr.height = txrH;\n\t  txr.width = Math.max( defTxrWidth, minW );\n\t  txr.usedWidth = 0;\n\t  txr.invalidatedWidth = 0;\n\t  txr.fullnessChecks = 0;\n\t\n\t  txr.canvas = document.createElement('canvas');\n\t  txr.canvas.width = txr.width;\n\t  txr.canvas.height = txr.height;\n\t\n\t  txr.context = txr.canvas.getContext('2d');\n\t\n\t  return txr;\n\t};\n\t\n\tETCp.recycleTexture = function( txrH, minW ){\n\t  var self = this;\n\t  var txrQ = self.getTextureQueue( txrH );\n\t  var rtxtrQ = self.getRetiredTextureQueue( txrH );\n\t\n\t  for( var i = 0; i < rtxtrQ.length; i++ ){\n\t    var txr = rtxtrQ[i];\n\t\n\t    if( txr.width >= minW ){\n\t      txr.retired = false;\n\t\n\t      txr.usedWidth = 0;\n\t      txr.invalidatedWidth = 0;\n\t      txr.fullnessChecks = 0;\n\t\n\t      util.clearArray( txr.eleCaches );\n\t\n\t      txr.context.clearRect( 0, 0, txr.width, txr.height );\n\t\n\t      util.removeFromArray( rtxtrQ, txr );\n\t      txrQ.push( txr );\n\t\n\t      return txr;\n\t    }\n\t  }\n\t};\n\t\n\tETCp.queueElement = function( ele, bb, lvl ){\n\t  var self = this;\n\t  var q = self.getElementQueue();\n\t  var id2q = self.getElementIdToQueue();\n\t  var id = ele.id();\n\t  var existingReq = id2q[ id ];\n\t\n\t  if( existingReq ){ // use the max lvl b/c in between lvls are cheap to make\n\t    existingReq.level = Math.max( existingReq.level, lvl );\n\t    existingReq.reqs++;\n\t\n\t    q.updateItem( existingReq );\n\t  } else {\n\t    var req = {\n\t      ele: ele,\n\t      bb: bb,\n\t      position: math.copyPosition( ele.position() ),\n\t      level: lvl,\n\t      reqs: 1\n\t    };\n\t\n\t    if( ele.isEdge() ){\n\t      req.positions = {\n\t        source: math.copyPosition( ele.source().position() ),\n\t        target: math.copyPosition( ele.target().position() )\n\t      };\n\t    }\n\t\n\t    q.push( req );\n\t\n\t    id2q[ id ] = req;\n\t  }\n\t};\n\t\n\tETCp.dequeue = function( pxRatio, extent ){\n\t  var self = this;\n\t  var q = self.getElementQueue();\n\t  var id2q = self.getElementIdToQueue();\n\t  var dequeued = [];\n\t\n\t  for( var i = 0; i < maxDeqSize; i++ ){\n\t    if( q.size() > 0 ){\n\t      var req = q.pop();\n\t\n\t      id2q[ req.ele.id() ] = null;\n\t\n\t      dequeued.push( req );\n\t\n\t      var ele = req.ele;\n\t      var bb;\n\t\n\t      if(\n\t        ( ele.isEdge()\n\t          && (\n\t            !math.arePositionsSame( ele.source().position(), req.positions.source )\n\t            || !math.arePositionsSame( ele.target().position(), req.positions.target )\n\t          )\n\t        )\n\t        || ( !math.arePositionsSame( ele.position(), req.position ) )\n\t      ){\n\t        bb = ele.boundingBox();\n\t      } else {\n\t        bb = req.bb;\n\t      }\n\t\n\t      self.getElement( req.ele, bb, pxRatio, req.level, getTxrReasons.dequeue );\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\t\n\t  return dequeued;\n\t};\n\t\n\tETCp.onDequeue = function( fn ){ this.onDequeues.push( fn ); };\n\tETCp.offDequeue = function( fn ){ util.removeFromArray( this.onDequeues, fn ); };\n\t\n\tETCp.setupDequeueing = defs.setupDequeueing({\n\t  deqRedrawThreshold: deqRedrawThreshold,\n\t  deqCost: deqCost,\n\t  deqAvgCost: deqAvgCost,\n\t  deqNoDrawCost: deqNoDrawCost,\n\t  deqFastCost: deqFastCost,\n\t  deq: function( self, pxRatio, extent ){\n\t    return self.dequeue( pxRatio, extent );\n\t  },\n\t  onDeqd: function( self, deqd ){\n\t    for( var i = 0; i < self.onDequeues.length; i++ ){\n\t      var fn = self.onDequeues[i];\n\t\n\t      fn( deqd );\n\t    }\n\t  },\n\t  shouldRedraw: function( self, deqd, pxRatio, extent ){\n\t    for( var i = 0; i < deqd.length; i++ ){\n\t      var bb = deqd[i].bb;\n\t\n\t      if( math.boundingBoxesIntersect( bb, extent ) ){\n\t        return true;\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t  priority: function( self ){\n\t    return self.renderer.beforeRenderPriorities.eleTxrDeq;\n\t  }\n\t});\n\t\n\tmodule.exports = ElementTextureCache;\n\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar fullFpsTime = 1000/60; // assume 60 frames per second\n\t\n\tmodule.exports = {\n\t  setupDequeueing: function( opts ){\n\t    return function setupDequeueingImpl(){\n\t      var self = this;\n\t      var r = this.renderer;\n\t\n\t      if( self.dequeueingSetup ){\n\t        return;\n\t      } else {\n\t        self.dequeueingSetup = true;\n\t      }\n\t\n\t      var queueRedraw = util.debounce( function(){\n\t        r.redrawHint( 'eles', true );\n\t        r.redrawHint( 'drag', true );\n\t\n\t        r.redraw();\n\t      }, opts.deqRedrawThreshold );\n\t\n\t      var dequeue = function( willDraw, frameStartTime ){\n\t        var startTime = util.performanceNow();\n\t        var avgRenderTime = r.averageRedrawTime;\n\t        var renderTime = r.lastRedrawTime;\n\t        var deqd = [];\n\t        var extent = r.cy.extent();\n\t        var pixelRatio = r.getPixelRatio();\n\t\n\t        while( true ){\n\t          var now = util.performanceNow();\n\t          var duration = now - startTime;\n\t          var frameDuration = now - frameStartTime;\n\t\n\t          if( renderTime < fullFpsTime ){\n\t            // if we're rendering faster than the ideal fps, then do dequeueing\n\t            // during all of the remaining frame time\n\t\n\t            var timeAvailable = fullFpsTime - ( willDraw ? avgRenderTime : 0 );\n\t\n\t            if( frameDuration >= opts.deqFastCost * timeAvailable ){\n\t              break;\n\t            }\n\t          } else {\n\t            if( willDraw ){\n\t              if(\n\t                   duration >= opts.deqCost * renderTime\n\t                || duration >= opts.deqAvgCost * avgRenderTime\n\t              ){\n\t                break;\n\t              }\n\t            } else if( frameDuration >= opts.deqNoDrawCost * fullFpsTime ){\n\t              break;\n\t            }\n\t          }\n\t\n\t          var thisDeqd = opts.deq( self, pixelRatio, extent );\n\t\n\t          if( thisDeqd.length > 0 ){\n\t            for( var i = 0; i < thisDeqd.length; i++ ){\n\t              deqd.push( thisDeqd[i] );\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t\n\t        // callbacks on dequeue\n\t        if( deqd.length > 0 ){\n\t          opts.onDeqd( self, deqd );\n\t\n\t          if( !willDraw && opts.shouldRedraw( self, deqd, pixelRatio, extent ) ){\n\t            queueRedraw();\n\t          }\n\t        }\n\t      };\n\t\n\t      var priority = opts.priority || util.noop;\n\t\n\t      r.beforeRender( dequeue, priority( self ) );\n\t    };\n\t  }\n\t};\n\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\tvar Heap = __webpack_require__( 45 );\n\tvar is = __webpack_require__( 30 );\n\tvar defs = __webpack_require__( 121 );\n\t\n\tvar defNumLayers = 1; // default number of layers to use\n\tvar minLvl = -4; // when scaling smaller than that we don't need to re-render\n\tvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n\tvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n\tvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\tvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\n\tvar disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true\n\tvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\tvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\tvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\tvar deqFastCost = 0.9; // % of frame time to be used when >60fps\n\tvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\tvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\n\tvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\n\tvar alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued\n\tvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n\t\n\tvar useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache\n\t\n\t// var log = function(){ console.log.apply( console, arguments ); };\n\t\n\tvar LayeredTextureCache = function( renderer, eleTxrCache ){\n\t  var self = this;\n\t\n\t  // TODO disable once not debugging\n\t  window.cache = this;\n\t\n\t  var r = self.renderer = renderer;\n\t\n\t  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\t\n\t  self.firstGet = true;\n\t\n\t  self.lastInvalidationTime = util.performanceNow() - 2*invalidThreshold;\n\t\n\t  self.skipping = false;\n\t\n\t  r.beforeRender(function( willDraw, now ){\n\t    if( now - self.lastInvalidationTime <= invalidThreshold ){\n\t      self.skipping = true;\n\t    } else {\n\t      self.skipping = false;\n\t    }\n\t  });\n\t\n\t  var qSort = function(a, b){\n\t    return b.reqs - a.reqs;\n\t  };\n\t\n\t  self.layersQueue = new Heap( qSort );\n\t\n\t  self.eleTxrCache = eleTxrCache;\n\t\n\t  self.setupEleCacheInvalidation();\n\t\n\t  self.setupDequeueing();\n\t};\n\t\n\tvar LTCp = LayeredTextureCache.prototype;\n\t\n\tvar layerIdPool = 0;\n\tvar MAX_INT = Math.pow(2, 53) - 1;\n\t\n\tLTCp.makeLayer = function( bb, lvl ){\n\t  var scale = Math.pow( 2, lvl );\n\t\n\t  var w = Math.ceil( bb.w * scale );\n\t  var h = Math.ceil( bb.h * scale );\n\t\n\t  var canvas = document.createElement('canvas');\n\t\n\t  canvas.width = w;\n\t  canvas.height = h;\n\t\n\t  var layer = {\n\t    id: (layerIdPool = ++layerIdPool % MAX_INT ),\n\t    bb: bb,\n\t    level: lvl,\n\t    width: w,\n\t    height: h,\n\t    canvas: canvas,\n\t    context: canvas.getContext('2d'),\n\t    eles: [],\n\t    elesQueue: [],\n\t    reqs: 0\n\t  };\n\t\n\t  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\t\n\t  var cxt = layer.context;\n\t  var dx = -layer.bb.x1;\n\t  var dy = -layer.bb.y1;\n\t\n\t  // do the transform on creation to save cycles (it's the same for all eles)\n\t  cxt.scale( scale, scale );\n\t  cxt.translate( dx, dy );\n\t\n\t  return layer;\n\t};\n\t\n\tLTCp.getLayers = function( eles, pxRatio, lvl ){\n\t  var self = this;\n\t  var r = self.renderer;\n\t  var cy = r.cy;\n\t  var zoom = cy.zoom();\n\t  var firstGet = self.firstGet;\n\t\n\t  self.firstGet = false;\n\t\n\t  // log('--\\nget layers with %s eles', eles.length);\n\t  //log eles.map(function(ele){ return ele.id() }) );\n\t\n\t  if( lvl == null ){\n\t    lvl = Math.ceil( math.log2( zoom * pxRatio ) );\n\t\n\t    if( lvl < minLvl ){\n\t      lvl = minLvl;\n\t    } else if( zoom >= maxZoom || lvl > maxLvl ){\n\t      return null;\n\t    }\n\t  }\n\t\n\t  self.validateLayersElesOrdering( lvl, eles );\n\t\n\t  var layersByLvl = self.layersByLevel;\n\t  var scale = Math.pow( 2, lvl );\n\t  var layers = layersByLvl[ lvl ] = layersByLvl[ lvl ] || [];\n\t  var bb;\n\t\n\t  var lvlComplete = self.levelIsComplete( lvl, eles );\n\t  var tmpLayers;\n\t\n\t  var checkTempLevels = function(){\n\t    var canUseAsTmpLvl = function( l ){\n\t      self.validateLayersElesOrdering( l, eles );\n\t\n\t      if( self.levelIsComplete( l, eles ) ){\n\t        tmpLayers = layersByLvl[l];\n\t        return true;\n\t      }\n\t    };\n\t\n\t    var checkLvls = function( dir ){\n\t      if( tmpLayers ){ return; }\n\t\n\t      for( var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir ){\n\t        if( canUseAsTmpLvl(l) ){ break; }\n\t      }\n\t    };\n\t\n\t    checkLvls( +1 );\n\t    checkLvls( -1 );\n\t\n\t    // remove the invalid layers; they will be replaced as needed later in this function\n\t    for( var i = layers.length - 1; i >= 0; i-- ){\n\t      var layer = layers[i];\n\t\n\t      if( layer.invalid ){\n\t        util.removeFromArray( layers, layer );\n\t      }\n\t    }\n\t  };\n\t\n\t  if( !lvlComplete ){\n\t    // if the current level is incomplete, then use the closest, best quality layerset temporarily\n\t    // and later queue the current layerset so we can get the proper quality level soon\n\t\n\t    checkTempLevels();\n\t\n\t  } else {\n\t    // log('level complete, using existing layers\\n--');\n\t    return layers;\n\t  }\n\t\n\t  var getBb = function(){\n\t    if( !bb ){\n\t      bb = math.makeBoundingBox();\n\t\n\t      for( var i = 0; i < eles.length; i++ ){\n\t        math.updateBoundingBox( bb, eles[i].boundingBox() );\n\t      }\n\t    }\n\t\n\t    return bb;\n\t  };\n\t\n\t  var makeLayer = function( opts ){\n\t    opts = opts || {};\n\t\n\t    var after = opts.after;\n\t\n\t    getBb();\n\t\n\t    var area = ( bb.w * scale ) * ( bb.h * scale );\n\t\n\t    if( area > maxLayerArea ){\n\t      return null;\n\t    }\n\t\n\t    var layer = self.makeLayer( bb, lvl );\n\t\n\t    if( after != null ){\n\t      var index = layers.indexOf( after ) + 1;\n\t\n\t      layers.splice( index, 0, layer );\n\t    } else if( opts.insert === undefined || opts.insert ){\n\t      // no after specified => first layer made so put at start\n\t      layers.unshift( layer );\n\t    }\n\t\n\t    // if( tmpLayers ){\n\t      //self.queueLayer( layer );\n\t    // }\n\t\n\t    return layer;\n\t  };\n\t\n\t  if( self.skipping && !firstGet ){\n\t    // log('skip layers');\n\t    return null;\n\t  }\n\t\n\t  // log('do layers');\n\t\n\t  var layer = null;\n\t  var maxElesPerLayer = eles.length / defNumLayers;\n\t  var allowLazyQueueing = alwaysQueue && !firstGet;\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[i];\n\t    var rs = ele._private.rscratch;\n\t    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\t\n\t    // log('look at ele', ele.id());\n\t\n\t    var existingLayer = caches[ lvl ];\n\t\n\t    if( existingLayer ){\n\t      // reuse layer for later eles\n\t      // log('reuse layer for', ele.id());\n\t      layer = existingLayer;\n\t      continue;\n\t    }\n\t\n\t    if(\n\t      !layer\n\t      || layer.eles.length >= maxElesPerLayer\n\t      || ( defNumLayers > 1 && !math.boundingBoxInBoundingBox( layer.bb, ele.boundingBox() ) )\n\t    ){\n\t      // log('make new layer for ele %s', ele.id());\n\t\n\t      layer = makeLayer({ insert: true, after: layer });\n\t\n\t      // if now layer can be built then we can't use layers at this level\n\t      if( !layer ){ return null; }\n\t\n\t      // log('new layer with id %s', layer.id);\n\t    }\n\t\n\t    if( tmpLayers || allowLazyQueueing ){\n\t      // log('queue ele %s in layer %s', ele.id(), layer.id);\n\t      self.queueLayer( layer, ele );\n\t    } else {\n\t      // log('draw ele %s in layer %s', ele.id(), layer.id);\n\t      self.drawEleInLayer( layer, ele, lvl, pxRatio );\n\t    }\n\t\n\t    layer.eles.push( ele );\n\t\n\t    caches[ lvl ] = layer;\n\t  }\n\t\n\t  // log('--');\n\t\n\t  if( tmpLayers ){ // then we only queued the current layerset and can't draw it yet\n\t    return tmpLayers;\n\t  }\n\t\n\t  if( allowLazyQueueing ){\n\t    // log('lazy queue level', lvl);\n\t    return null;\n\t  }\n\t\n\t  return layers;\n\t};\n\t\n\t// a layer may want to use an ele cache of a higher level to avoid blurriness\n\t// so the layer level might not equal the ele level\n\tLTCp.getEleLevelForLayerLevel = function( lvl, pxRatio ){\n\t  return lvl;\n\t};\n\t\n\tfunction imgSmoothing( context, bool ){\n\t  if( context.imageSmoothingEnabled != null ){\n\t    context.imageSmoothingEnabled = bool;\n\t  } else {\n\t    context.webkitImageSmoothingEnabled = bool;\n\t    context.mozImageSmoothingEnabled = bool;\n\t    context.msImageSmoothingEnabled = bool;\n\t  }\n\t}\n\t\n\tLTCp.drawEleInLayer = function( layer, ele, lvl, pxRatio ){\n\t  var self = this;\n\t  var r = this.renderer;\n\t  var context = layer.context;\n\t  var bb = ele.boundingBox();\n\t  var eleCache = self.eleTxrCache;\n\t  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;\n\t\n\t  lvl = self.getEleLevelForLayerLevel( lvl, pxRatio );\n\t\n\t  var cache = useEleTxrCaching ? eleCache.getElement( ele, bb, null, lvl, reason ) : null;\n\t\n\t  if( cache ){\n\t    if( disableEleImgSmoothing ){ imgSmoothing( context, false ); }\n\t\n\t    context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );\n\t\n\t    if( disableEleImgSmoothing ){ imgSmoothing( context, true ); }\n\t  } else { // if the element is not cacheable, then draw directly\n\t    r.drawElement( context, ele );\n\t  }\n\t};\n\t\n\tLTCp.levelIsComplete = function( lvl, eles ){\n\t  var self = this;\n\t  var layers = self.layersByLevel[ lvl ];\n\t\n\t  if( !layers || layers.length === 0 ){ return false; }\n\t\n\t  var numElesInLayers = 0;\n\t\n\t  for( var i = 0; i < layers.length; i++ ){\n\t    var layer = layers[i];\n\t\n\t    // if there are any eles needed to be drawn yet, the level is not complete\n\t    if( layer.reqs > 0 ){ return false; }\n\t\n\t    // if the layer is invalid, the level is not complete\n\t    if( layer.invalid ){ return false; }\n\t\n\t    numElesInLayers += layer.eles.length;\n\t  }\n\t\n\t  // we should have exactly the number of eles passed in to be complete\n\t  if( numElesInLayers !== eles.length ){ return false; }\n\t\n\t  return true;\n\t};\n\t\n\tLTCp.validateLayersElesOrdering = function( lvl, eles ){\n\t  var layers = this.layersByLevel[ lvl ];\n\t\n\t  if( !layers ){ return; }\n\t\n\t  // if in a layer the eles are not in the same order, then the layer is invalid\n\t  // (i.e. there is an ele in between the eles in the layer)\n\t\n\t  for( var i = 0; i < layers.length; i++ ){\n\t    var layer = layers[i];\n\t    var offset = -1;\n\t\n\t    // find the offset\n\t    for( var j = 0; j < eles.length; j++ ){\n\t      if( layer.eles[0] === eles[j] ){\n\t        offset = j;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if( offset < 0 ){\n\t      // then the layer has nonexistant elements and is invalid\n\t      this.invalidateLayer( layer );\n\t      continue;\n\t    }\n\t\n\t    // the eles in the layer must be in the same continuous order, else the layer is invalid\n\t\n\t    var o = offset;\n\t\n\t    for( var j = 0; j < layer.eles.length; j++ ){\n\t      if( layer.eles[j] !== eles[o+j] ){\n\t        // log('invalidate based on ordering', layer.id);\n\t\n\t        this.invalidateLayer( layer );\n\t        break;\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tLTCp.updateElementsInLayers = function( eles, update ){\n\t  var self = this;\n\t  var isEles = is.element( eles[0] );\n\t\n\t  // collect udpated elements (cascaded from the layers) and update each\n\t  // layer itself along the way\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var req = isEles ? null : eles[i];\n\t    var ele = isEles ? eles[i] : eles[i].ele;\n\t    var rs = ele._private.rscratch;\n\t    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\t\n\t    for( var l = minLvl; l <= maxLvl; l++ ){\n\t      var layer = caches[l];\n\t\n\t      if( !layer ){ continue; }\n\t\n\t      // if update is a request from the ele cache, then it affects only\n\t      // the matching level\n\t      if( req && self.getEleLevelForLayerLevel( layer.level ) !== req.level ){\n\t        continue;\n\t      }\n\t\n\t      update( layer, ele, req );\n\t    }\n\t  }\n\t};\n\t\n\tLTCp.haveLayers = function(){\n\t  var self = this;\n\t  var haveLayers = false;\n\t\n\t  for( var l = minLvl; l <= maxLvl; l++ ){\n\t    var layers = self.layersByLevel[l];\n\t\n\t    if( layers && layers.length > 0 ){\n\t      haveLayers = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  return haveLayers;\n\t};\n\t\n\tLTCp.invalidateElements = function( eles ){\n\t  var self = this;\n\t\n\t  self.lastInvalidationTime = util.performanceNow();\n\t\n\t  // log('update invalidate layer time from eles');\n\t\n\t  if( eles.length === 0 || !self.haveLayers() ){ return; }\n\t\n\t  self.updateElementsInLayers( eles, function invalAssocLayers( layer, ele, req ){\n\t    self.invalidateLayer( layer );\n\t  } );\n\t};\n\t\n\tLTCp.invalidateLayer = function( layer ){\n\t  // log('update invalidate layer time');\n\t\n\t  this.lastInvalidationTime = util.performanceNow();\n\t\n\t  if( layer.invalid ){ return; } // save cycles\n\t\n\t  var lvl = layer.level;\n\t  var eles = layer.eles;\n\t  var layers = this.layersByLevel[ lvl ];\n\t\n\t   // log('invalidate layer', layer.id );\n\t\n\t  util.removeFromArray( layers, layer );\n\t  // layer.eles = [];\n\t\n\t  layer.elesQueue = [];\n\t\n\t  layer.invalid = true;\n\t\n\t  if( layer.replacement ){\n\t    layer.replacement.invalid = true;\n\t  }\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var caches = eles[i]._private.rscratch.imgLayerCaches;\n\t\n\t    if( caches ){\n\t      caches[ lvl ] = null;\n\t    }\n\t  }\n\t};\n\t\n\tLTCp.refineElementTextures = function( eles ){\n\t  var self = this;\n\t\n\t  // log('refine', eles.length);\n\t\n\t  self.updateElementsInLayers( eles, function refineEachEle( layer, ele, req ){\n\t    var rLyr = layer.replacement;\n\t\n\t    if( !rLyr ){\n\t      rLyr = layer.replacement = self.makeLayer( layer.bb, layer.level );\n\t      rLyr.replaces = layer;\n\t      rLyr.eles = layer.eles;\n\t\n\t       // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n\t    }\n\t\n\t    if( !rLyr.reqs ){\n\t      for( var i = 0; i < rLyr.eles.length; i++ ){\n\t        self.queueLayer( rLyr, rLyr.eles[i] );\n\t      }\n\t\n\t       // log('queue replacement layer refinement', rLyr.id);\n\t    }\n\t  } );\n\t};\n\t\n\tLTCp.setupEleCacheInvalidation = function(){\n\t  var self = this;\n\t  var eleDeqs = [];\n\t\n\t  if( !useEleTxrCaching ){ return; }\n\t\n\t  var updatedElesInLayers = util.debounce( function(){\n\t    self.refineElementTextures( eleDeqs );\n\t\n\t    eleDeqs = [];\n\t  }, refineEleDebounceTime );\n\t\n\t  self.eleTxrCache.onDequeue(function( reqs ){\n\t    for( var i = 0; i < reqs.length; i++ ){\n\t      eleDeqs.push( reqs[i] );\n\t    }\n\t\n\t    updatedElesInLayers();\n\t  });\n\t};\n\t\n\tLTCp.queueLayer = function( layer, ele ){\n\t  var self = this;\n\t  var q = self.layersQueue;\n\t  var elesQ = layer.elesQueue;\n\t  var hasId = elesQ.hasId = elesQ.hasId || {};\n\t\n\t  // if a layer is going to be replaced, queuing is a waste of time\n\t  if( layer.replacement ){ return; }\n\t\n\t  if( ele ){\n\t    if( hasId[ ele.id() ] ){\n\t      return;\n\t    }\n\t\n\t    elesQ.push( ele );\n\t    hasId[ ele.id() ] = true;\n\t  }\n\t\n\t  if( layer.reqs ){\n\t    layer.reqs++;\n\t\n\t    q.updateItem( layer );\n\t  } else {\n\t    layer.reqs = 1;\n\t\n\t    q.push( layer );\n\t  }\n\t};\n\t\n\tLTCp.dequeue = function( pxRatio ){\n\t  var self = this;\n\t  var q = self.layersQueue;\n\t  var deqd = [];\n\t  var eleDeqs = 0;\n\t\n\t  while( eleDeqs < maxDeqSize ){\n\t    if( q.size() === 0 ){ break; }\n\t\n\t    var layer = q.peek();\n\t\n\t    // if a layer has been or will be replaced, then don't waste time with it\n\t    if( layer.replacement ){\n\t       // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n\t      q.pop();\n\t      continue;\n\t    }\n\t\n\t    // if this is a replacement layer that has been superceded, then forget it\n\t    if( layer.replaces && layer !== layer.replaces.replacement ){\n\t       // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n\t      q.pop();\n\t      continue;\n\t    }\n\t\n\t    if( layer.invalid ){\n\t       // log('replacement layer %s is invalid; dequeued', layer.id);\n\t      q.pop();\n\t      continue;\n\t    }\n\t\n\t    var ele = layer.elesQueue.shift();\n\t\n\t    if( ele ){\n\t       // log('dequeue layer %s', layer.id);\n\t\n\t      self.drawEleInLayer( layer, ele, layer.level, pxRatio );\n\t\n\t      eleDeqs++;\n\t    }\n\t\n\t    if( deqd.length === 0 ){\n\t      // we need only one entry in deqd to queue redrawing etc\n\t      deqd.push( true );\n\t    }\n\t\n\t    // if the layer has all its eles done, then remove from the queue\n\t    if( layer.elesQueue.length === 0 ){\n\t      q.pop();\n\t\n\t      layer.reqs = 0;\n\t\n\t       // log('dequeue of layer %s complete', layer.id);\n\t\n\t      // when a replacement layer is dequeued, it replaces the old layer in the level\n\t      if( layer.replaces ){\n\t        self.applyLayerReplacement( layer );\n\t      }\n\t\n\t      self.requestRedraw();\n\t    }\n\t  }\n\t\n\t  return deqd;\n\t};\n\t\n\tLTCp.applyLayerReplacement = function( layer ){\n\t  var self = this;\n\t  var layersInLevel = self.layersByLevel[ layer.level ];\n\t  var replaced = layer.replaces;\n\t  var index = layersInLevel.indexOf( replaced );\n\t\n\t  // if the replaced layer is not in the active list for the level, then replacing\n\t  // refs would be a mistake (i.e. overwriting the true active layer)\n\t  if( index < 0 || replaced.invalid ){\n\t     // log('replacement layer would have no effect', layer.id);\n\t    return;\n\t  }\n\t\n\t  layersInLevel[ index ] = layer; // replace level ref\n\t\n\t  // replace refs in eles\n\t  for( var i = 0; i < layer.eles.length; i++ ){\n\t    var _p = layer.eles[i]._private;\n\t    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n\t\n\t    if( cache ){\n\t      cache[ layer.level ] = layer;\n\t    }\n\t  }\n\t\n\t   // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\t\n\t  self.requestRedraw();\n\t};\n\t\n\tLTCp.requestRedraw = util.debounce( function(){\n\t  var r = this.renderer;\n\t\n\t  r.redrawHint( 'eles', true );\n\t  r.redrawHint( 'drag', true );\n\t  r.redraw();\n\t}, 100 );\n\t\n\tLTCp.setupDequeueing = defs.setupDequeueing({\n\t  deqRedrawThreshold: deqRedrawThreshold,\n\t  deqCost: deqCost,\n\t  deqAvgCost: deqAvgCost,\n\t  deqNoDrawCost: deqNoDrawCost,\n\t  deqFastCost: deqFastCost,\n\t  deq: function( self, pxRatio ){\n\t    return self.dequeue( pxRatio );\n\t  },\n\t  onDeqd: util.noop,\n\t  shouldRedraw: util.trueify,\n\t  priority: function( self ){\n\t    return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n\t  }\n\t});\n\t\n\tmodule.exports = LayeredTextureCache;\n\n\n/***/ },\n/* 123 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar CRp = {};\n\t\n\tvar impl;\n\t\n\tCRp.arrowShapeImpl = function( name ){\n\t  return ( impl || (impl = {\n\t    'polygon': function( context, points ){\n\t      for( var i = 0; i < points.length; i++ ){\n\t        var pt = points[ i ];\n\t\n\t        context.lineTo( pt.x, pt.y );\n\t      }\n\t    },\n\t\n\t    'triangle-backcurve': function( context, points, controlPoint ){\n\t      var firstPt;\n\t\n\t      for( var i = 0; i < points.length; i++ ){\n\t        var pt = points[ i ];\n\t\n\t        if( i === 0 ){\n\t          firstPt = pt;\n\t        }\n\t\n\t        context.lineTo( pt.x, pt.y );\n\t      }\n\t\n\t      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );\n\t    },\n\t\n\t    'triangle-tee': function( context, trianglePoints, teePoints ){\n\t      var triPts = trianglePoints;\n\t      for( var i = 0; i < triPts.length; i++ ){\n\t        var pt = triPts[ i ];\n\t\n\t        context.lineTo( pt.x, pt.y );\n\t      }\n\t\n\t      var teePts = teePoints;\n\t      var firstTeePt = teePoints[0];\n\t      context.moveTo( firstTeePt.x, firstTeePt.y );\n\t\n\t      for( var i = 0; i < teePts.length; i++ ){\n\t        var pt = teePts[ i ];\n\t\n\t        context.lineTo( pt.x, pt.y );\n\t      }\n\t    },\n\t\n\t    'circle': function( context, rx, ry, r ){\n\t      context.arc( rx, ry, r, 0, Math.PI * 2, false );\n\t    }\n\t  }) )[ name ];\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar CRp = {};\n\t\n\tCRp.drawElement = function( context, ele, shiftToOriginWithBb, showLabel ){\n\t  var r = this;\n\t\n\t  if( ele.isNode() ){\n\t    r.drawNode( context, ele, shiftToOriginWithBb, showLabel );\n\t  } else {\n\t    r.drawEdge( context, ele, shiftToOriginWithBb, showLabel );\n\t  }\n\t};\n\t\n\tCRp.drawCachedElement = function( context, ele, pxRatio, extent ){\n\t  var r = this;\n\t  var bb = ele.boundingBox();\n\t\n\t  if( !extent || math.boundingBoxesIntersect( bb, extent ) ){\n\t    var cache = r.data.eleTxrCache.getElement( ele, bb, pxRatio );\n\t\n\t    if( cache ){\n\t      context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );\n\t    } else { // if the element is not cacheable, then draw directly\n\t      r.drawElement( context, ele );\n\t    }\n\t  }\n\t};\n\t\n\tCRp.drawElements = function( context, eles ){\n\t  var r = this;\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[ i ];\n\t\n\t    r.drawElement( context, ele );\n\t  }\n\t};\n\t\n\tCRp.drawCachedElements = function( context, eles, pxRatio, extent ){\n\t  var r = this;\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[ i ];\n\t\n\t    r.drawCachedElement( context, ele, pxRatio, extent );\n\t  }\n\t};\n\t\n\tCRp.drawCachedNodes = function( context, eles, pxRatio, extent ){\n\t  var r = this;\n\t\n\t  for( var i = 0; i < eles.length; i++ ){\n\t    var ele = eles[ i ];\n\t\n\t    if( !ele.isNode() ){ continue; }\n\t\n\t    r.drawCachedElement( context, ele, pxRatio, extent );\n\t  }\n\t};\n\t\n\tCRp.drawLayeredElements = function( context, eles, pxRatio, extent ){\n\t  var r = this;\n\t\n\t  var layers = r.data.lyrTxrCache.getLayers( eles, pxRatio );\n\t\n\t  if( layers ){\n\t    for( var i = 0; i < layers.length; i++ ){\n\t      var layer = layers[i];\n\t      var bb = layer.bb;\n\t\n\t      context.drawImage( layer.canvas, bb.x1, bb.y1, bb.w, bb.h );\n\t    }\n\t  } else { // fall back on plain caching if no layers\n\t    r.drawCachedElements( context, eles, pxRatio, extent );\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 125 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar CRp = {};\n\t\n\tCRp.drawEdge = function( context, edge, shiftToOriginWithBb, drawLabel, drawOverlayInstead ){\n\t  var rs = edge._private.rscratch;\n\t  var usePaths = this.usePaths();\n\t\n\t  // if bezier ctrl pts can not be calculated, then die\n\t  if( rs.badLine || isNaN(rs.allpts[0]) ){ // isNaN in case edge is impossible and browser bugs (e.g. safari)\n\t    return;\n\t  }\n\t\n\t  // Edge line width\n\t  if( edge.pstyle( 'width' ).pfValue <= 0 ){\n\t    return;\n\t  }\n\t\n\t  var bb;\n\t  if( shiftToOriginWithBb ){\n\t    bb = shiftToOriginWithBb;\n\t\n\t    context.translate( -bb.x1, -bb.y1 );\n\t  }\n\t\n\t  var overlayPadding = edge.pstyle( 'overlay-padding' ).pfValue;\n\t  var overlayOpacity = edge.pstyle( 'overlay-opacity' ).value;\n\t  var overlayColor = edge.pstyle( 'overlay-color' ).value;\n\t\n\t  // Edge color & opacity\n\t  if( drawOverlayInstead ){\n\t\n\t    if( overlayOpacity === 0 ){ // exit early if no overlay\n\t      return;\n\t    }\n\t\n\t    this.strokeStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );\n\t    context.lineCap = 'round';\n\t\n\t    if( rs.edgeType == 'self' && !usePaths ){\n\t      context.lineCap = 'butt';\n\t    }\n\t\n\t  } else {\n\t    var lineColor = edge.pstyle( 'line-color' ).value;\n\t\n\t    this.strokeStyle( context, lineColor[0], lineColor[1], lineColor[2], edge.pstyle( 'opacity' ).value );\n\t\n\t    context.lineCap = 'butt';\n\t  }\n\t\n\t  context.lineJoin = 'round';\n\t\n\t  var edgeWidth = edge.pstyle( 'width' ).pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);\n\t  var lineStyle = drawOverlayInstead ? 'solid' : edge.pstyle( 'line-style' ).value;\n\t  context.lineWidth = edgeWidth;\n\t\n\t  var shadowBlur = edge.pstyle( 'shadow-blur' ).pfValue;\n\t  var shadowOpacity = edge.pstyle( 'shadow-opacity' ).value;\n\t  var shadowColor = edge.pstyle( 'shadow-color' ).value;\n\t  var shadowOffsetX = edge.pstyle( 'shadow-offset-x' ).pfValue;\n\t  var shadowOffsetY = edge.pstyle( 'shadow-offset-y' ).pfValue;\n\t\n\t  this.shadowStyle( context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );\n\t\n\t  this.drawEdgePath(\n\t    edge,\n\t    context,\n\t    rs.allpts,\n\t    lineStyle,\n\t    edgeWidth\n\t  );\n\t\n\t  this.drawArrowheads( context, edge, drawOverlayInstead );\n\t\n\t  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy\n\t\n\t  if( !drawOverlayInstead ){\n\t    this.drawEdge( context, edge, false, drawLabel, true );\n\t  }\n\t\n\t  this.drawElementText( context, edge, drawLabel );\n\t\n\t  if( shiftToOriginWithBb ){\n\t    context.translate( bb.x1, bb.y1 );\n\t  }\n\t};\n\t\n\t\n\tCRp.drawEdgePath = function( edge, context, pts, type, width ){\n\t  var rs = edge._private.rscratch;\n\t  var canvasCxt = context;\n\t  var path;\n\t  var pathCacheHit = false;\n\t  var usePaths = this.usePaths();\n\t\n\t  if( usePaths ){\n\t    var pathCacheKey = pts.join( '$' );\n\t    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n\t\n\t    if( keyMatches ){\n\t      path = context = rs.pathCache;\n\t      pathCacheHit = true;\n\t    } else {\n\t      path = context = new Path2D();\n\t      rs.pathCacheKey = pathCacheKey;\n\t      rs.pathCache = path;\n\t    }\n\t  }\n\t\n\t  if( canvasCxt.setLineDash ){ // for very outofdate browsers\n\t    switch( type ){\n\t      case 'dotted':\n\t        canvasCxt.setLineDash( [ 1, 1 ] );\n\t        break;\n\t\n\t      case 'dashed':\n\t        canvasCxt.setLineDash( [ 6, 3 ] );\n\t        break;\n\t\n\t      case 'solid':\n\t        canvasCxt.setLineDash( [ ] );\n\t        break;\n\t    }\n\t  }\n\t\n\t  if( !pathCacheHit && !rs.badLine ){\n\t    if( context.beginPath ){ context.beginPath(); }\n\t    context.moveTo( pts[0], pts[1] );\n\t\n\t    switch( rs.edgeType ){\n\t      case 'bezier':\n\t      case 'self':\n\t      case 'compound':\n\t      case 'multibezier':\n\t        for( var i = 2; i + 3 < pts.length; i += 4 ){\n\t          context.quadraticCurveTo( pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] );\n\t        }\n\t        break;\n\t\n\t      case 'straight':\n\t      case 'segments':\n\t      case 'haystack':\n\t        for( var i = 2; i + 1 < pts.length; i += 2 ){\n\t          context.lineTo( pts[ i ], pts[ i + 1] );\n\t        }\n\t        break;\n\t    }\n\t  }\n\t\n\t  context = canvasCxt;\n\t  if( usePaths ){\n\t    context.stroke( path );\n\t  } else {\n\t    context.stroke();\n\t  }\n\t\n\t  // reset any line dashes\n\t  if( context.setLineDash ){ // for very outofdate browsers\n\t    context.setLineDash( [ ] );\n\t  }\n\t\n\t};\n\t\n\tCRp.drawArrowheads = function( context, edge, drawOverlayInstead ){\n\t  if( drawOverlayInstead ){ return; } // don't do anything for overlays\n\t\n\t  var rs = edge._private.rscratch;\n\t  var isHaystack = rs.edgeType === 'haystack';\n\t\n\t  if( !isHaystack ){\n\t    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );\n\t  }\n\t\n\t  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );\n\t\n\t  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );\n\t\n\t  if( !isHaystack ){\n\t    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );\n\t  }\n\t};\n\t\n\tCRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){\n\t  if( isNaN( x ) || x == null || isNaN( y ) || y == null || isNaN( angle ) || angle == null ){ return; }\n\t\n\t  var self = this;\n\t  var arrowShape = edge.pstyle( prefix + '-arrow-shape' ).value;\n\t\n\t  if( arrowShape === 'none' ){\n\t    return;\n\t  }\n\t\n\t  var gco = context.globalCompositeOperation;\n\t\n\t  var arrowClearFill = edge.pstyle( prefix + '-arrow-fill' ).value === 'hollow' ? 'both' : 'filled';\n\t  var arrowFill = edge.pstyle( prefix + '-arrow-fill' ).value;\n\t  var opacity = edge.pstyle( 'opacity' ).value;\n\t\n\t  if( arrowShape === 'half-triangle-overshot' ){\n\t    arrowFill = 'hollow';\n\t    arrowClearFill = 'hollow';\n\t  }\n\t\n\t  if( opacity !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed\n\t    context.globalCompositeOperation = 'destination-out';\n\t\n\t    self.fillStyle( context, 255, 255, 255, 1 );\n\t    self.strokeStyle( context, 255, 255, 255, 1 );\n\t\n\t    self.drawArrowShape( edge, prefix, context,\n\t      arrowClearFill, edge.pstyle( 'width' ).pfValue, edge.pstyle( prefix + '-arrow-shape' ).value,\n\t      x, y, angle\n\t    );\n\t\n\t    context.globalCompositeOperation = gco;\n\t  } // otherwise, the opaque arrow clears it for free :)\n\t\n\t  var color = edge.pstyle( prefix + '-arrow-color' ).value;\n\t  self.fillStyle( context, color[0], color[1], color[2], opacity );\n\t  self.strokeStyle( context, color[0], color[1], color[2], opacity );\n\t\n\t  self.drawArrowShape( edge, prefix, context,\n\t    arrowFill, edge.pstyle( 'width' ).pfValue, edge.pstyle( prefix + '-arrow-shape' ).value,\n\t    x, y, angle\n\t  );\n\t};\n\t\n\tCRp.drawArrowShape = function( edge, arrowType, context, fill, edgeWidth, shape, x, y, angle ){\n\t  var r = this;\n\t  var usePaths = this.usePaths();\n\t  var rs = edge._private.rscratch;\n\t  var pathCacheHit = false;\n\t  var path;\n\t  var canvasContext = context;\n\t  var translation = { x: x, y: y };\n\t  var size = this.getArrowWidth( edgeWidth );\n\t  var shapeImpl = r.arrowShapes[ shape ];\n\t\n\t  if( usePaths ){\n\t    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;\n\t    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};\n\t    rs.arrowPathCache = rs.arrowPathCache || {};\n\t\n\t    var alreadyCached = rs.arrowPathCacheKey[ arrowType ] === pathCacheKey;\n\t    if( alreadyCached ){\n\t      path = context = rs.arrowPathCache[ arrowType ];\n\t      pathCacheHit = true;\n\t    } else {\n\t      path = context = new Path2D();\n\t      rs.arrowPathCacheKey[ arrowType ] = pathCacheKey;\n\t      rs.arrowPathCache[ arrowType ] = path;\n\t    }\n\t  }\n\t\n\t  if( context.beginPath ){ context.beginPath(); }\n\t\n\t  if( !pathCacheHit ){\n\t    shapeImpl.draw( context, size, angle, translation );\n\t  }\n\t\n\t  if( !shapeImpl.leavePathOpen && context.closePath ){\n\t    context.closePath();\n\t  }\n\t\n\t  context = canvasContext;\n\t\n\t  if( fill === 'filled' || fill === 'both' ){\n\t    if( usePaths ){\n\t      context.fill( path );\n\t    } else {\n\t      context.fill();\n\t    }\n\t  }\n\t\n\t  if( fill === 'hollow' || fill === 'both' ){\n\t    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );\n\t    context.lineJoin = 'miter';\n\t\n\t    if( usePaths ){\n\t      context.stroke( path );\n\t    } else {\n\t      context.stroke();\n\t    }\n\t\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 126 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar CRp = {};\n\t\n\tCRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){\n\t  var r = this;\n\t\n\t  try {\n\t    context.drawImage( img, ix, iy, iw, ih, x, y, w, h );\n\t  } catch( e ){\n\t    r.redrawHint( 'eles', true );\n\t    r.redrawHint( 'drag', true );\n\t\n\t    r.drawingImage = true;\n\t\n\t    r.redraw();\n\t  }\n\t};\n\t\n\tCRp.drawInscribedImage = function( context, img, node ){\n\t  var r = this;\n\t  var nodeX = node._private.position.x;\n\t  var nodeY = node._private.position.y;\n\t  var fit = node.pstyle( 'background-fit' ).value;\n\t  var xPos = node.pstyle( 'background-position-x' );\n\t  var yPos = node.pstyle( 'background-position-y' );\n\t  var repeat = node.pstyle( 'background-repeat' ).value;\n\t  var nodeW = node.width();\n\t  var nodeH = node.height();\n\t  var rs = node._private.rscratch;\n\t  var clip = node.pstyle( 'background-clip' ).value;\n\t  var shouldClip = clip === 'node';\n\t  var imgOpacity = node.pstyle( 'background-image-opacity' ).value;\n\t\n\t  var imgW = img.width || img.cachedW;\n\t  var imgH = img.height || img.cachedH;\n\t\n\t  // workaround for broken browsers like ie\n\t  if( null == imgW || null == imgH ){\n\t    document.body.appendChild( img );\n\t\n\t    imgW = img.cachedW = img.width || img.offsetWidth;\n\t    imgH = img.cachedH = img.height || img.offsetHeight;\n\t\n\t    document.body.removeChild( img );\n\t  }\n\t\n\t  var w = imgW;\n\t  var h = imgH;\n\t\n\t  var bgW = node.pstyle( 'background-width' );\n\t  if( bgW.value !== 'auto' ){\n\t    if( bgW.units === '%' ){\n\t      w = bgW.value / 100 * nodeW;\n\t    } else {\n\t      w = bgW.pfValue;\n\t    }\n\t  }\n\t\n\t  var bgH = node.pstyle( 'background-height' );\n\t  if( bgH.value !== 'auto' ){\n\t    if( bgH.units === '%' ){\n\t      h = bgH.value / 100 * nodeH;\n\t    } else {\n\t      h = bgH.pfValue;\n\t    }\n\t  }\n\t\n\t  if( w === 0 || h === 0 ){\n\t    return; // no point in drawing empty image (and chrome is broken in this case)\n\t  }\n\t\n\t  if( fit === 'contain' ){\n\t    var scale = Math.min( nodeW / w, nodeH / h );\n\t\n\t    w *= scale;\n\t    h *= scale;\n\t\n\t  } else if( fit === 'cover' ){\n\t    var scale = Math.max( nodeW / w, nodeH / h );\n\t\n\t    w *= scale;\n\t    h *= scale;\n\t  }\n\t\n\t  var x = (nodeX - nodeW / 2); // left\n\t  if( xPos.units === '%' ){\n\t    x += (nodeW - w) * xPos.value / 100;\n\t  } else {\n\t    x += xPos.pfValue;\n\t  }\n\t\n\t  var y = (nodeY - nodeH / 2); // top\n\t  if( yPos.units === '%' ){\n\t    y += (nodeH - h) * yPos.value / 100;\n\t  } else {\n\t    y += yPos.pfValue;\n\t  }\n\t\n\t  if( rs.pathCache ){\n\t    x -= nodeX;\n\t    y -= nodeY;\n\t\n\t    nodeX = 0;\n\t    nodeY = 0;\n\t  }\n\t\n\t  var gAlpha = context.globalAlpha;\n\t\n\t  context.globalAlpha = imgOpacity;\n\t\n\t  if( repeat === 'no-repeat' ){\n\t\n\t    if( shouldClip ){\n\t      context.save();\n\t\n\t      if( rs.pathCache ){\n\t        context.clip( rs.pathCache );\n\t      } else {\n\t        r.nodeShapes[ r.getNodeShape( node ) ].draw(\n\t          context,\n\t          nodeX, nodeY,\n\t          nodeW, nodeH );\n\t\n\t        context.clip();\n\t      }\n\t    }\n\t\n\t    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );\n\t\n\t    if( shouldClip ){\n\t      context.restore();\n\t    }\n\t  } else {\n\t    var pattern = context.createPattern( img, repeat );\n\t    context.fillStyle = pattern;\n\t\n\t    r.nodeShapes[ r.getNodeShape( node ) ].draw(\n\t        context,\n\t        nodeX, nodeY,\n\t        nodeW, nodeH );\n\t\n\t    context.translate( x, y );\n\t    context.fill();\n\t    context.translate( -x, -y );\n\t  }\n\t\n\t  context.globalAlpha = gAlpha;\n\t\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__( 32 );\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar CRp = {};\n\t\n\tCRp.eleTextBiggerThanMin = function( ele, scale ){\n\t  if( !scale ){\n\t    var zoom = ele.cy().zoom();\n\t    var pxRatio = this.getPixelRatio();\n\t    var lvl = Math.ceil( math.log2( zoom * pxRatio ) ); // the effective texture level\n\t\n\t    scale = Math.pow( 2, lvl );\n\t  }\n\t\n\t  var computedSize = ele.pstyle( 'font-size' ).pfValue * scale;\n\t  var minSize = ele.pstyle( 'min-zoomed-font-size' ).pfValue;\n\t\n\t  if( computedSize < minSize ){\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tCRp.drawElementText = function( context, ele, force ){\n\t  var r = this;\n\t\n\t  if( force === undefined ){\n\t    if( !r.eleTextBiggerThanMin( ele ) ){ return; }\n\t  } else {\n\t    if( !force ){ return; }\n\t  }\n\t\n\t  if( ele.isNode() ){\n\t    var label = ele.pstyle( 'label' );\n\t\n\t    if( !label || !label.value ){ return; }\n\t\n\t    var textHalign = ele.pstyle( 'text-halign' ).strValue;\n\t    var textValign = ele.pstyle( 'text-valign' ).strValue;\n\t\n\t    switch( textHalign ){\n\t      case 'left':\n\t        context.textAlign = 'right';\n\t        break;\n\t\n\t      case 'right':\n\t        context.textAlign = 'left';\n\t        break;\n\t\n\t      default: // e.g. center\n\t        context.textAlign = 'center';\n\t    }\n\t\n\t    switch( textValign ){\n\t      case 'top':\n\t        context.textBaseline = 'bottom';\n\t        break;\n\t\n\t      case 'bottom':\n\t        context.textBaseline = 'top';\n\t        break;\n\t\n\t      default: // e.g. center\n\t        context.textBaseline = 'middle';\n\t    }\n\t  } else {\n\t    var label = ele.pstyle( 'label' );\n\t    var srcLabel = ele.pstyle( 'source-label' );\n\t    var tgtLabel = ele.pstyle( 'target-label' );\n\t\n\t    if(\n\t      ( !label || !label.value )\n\t      && ( !srcLabel || !srcLabel.value )\n\t      && ( !tgtLabel || !tgtLabel.value )\n\t    ){\n\t      return;\n\t    }\n\t\n\t    context.textAlign = 'center';\n\t    context.textBaseline = 'middle';\n\t  }\n\t\n\t\n\t  r.drawText( context, ele );\n\t\n\t  if( ele.isEdge() ){\n\t    r.drawText( context, ele, 'source' );\n\t\n\t    r.drawText( context, ele, 'target' );\n\t  }\n\t};\n\t\n\tCRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;\n\t\n\tCRp.getFontCache = function( context ){\n\t  var cache;\n\t\n\t  this.fontCaches = this.fontCaches || [];\n\t\n\t  for( var i = 0; i < this.fontCaches.length; i++ ){\n\t    cache = this.fontCaches[ i ];\n\t\n\t    if( cache.context === context ){\n\t      return cache;\n\t    }\n\t  }\n\t\n\t  cache = {\n\t    context: context\n\t  };\n\t  this.fontCaches.push( cache );\n\t\n\t  return cache;\n\t};\n\t\n\t// set up canvas context with font\n\t// returns transformed text string\n\tCRp.setupTextStyle = function( context, ele ){\n\t  // Font style\n\t  var parentOpacity = ele.effectiveOpacity();\n\t  var labelStyle = ele.pstyle( 'font-style' ).strValue;\n\t  var labelSize = ele.pstyle( 'font-size' ).pfValue + 'px';\n\t  var labelFamily = ele.pstyle( 'font-family' ).strValue;\n\t  var labelWeight = ele.pstyle( 'font-weight' ).strValue;\n\t  var opacity = ele.pstyle( 'text-opacity' ).value * ele.pstyle( 'opacity' ).value * parentOpacity;\n\t  var outlineOpacity = ele.pstyle( 'text-outline-opacity' ).value * opacity;\n\t  var color = ele.pstyle( 'color' ).value;\n\t  var outlineColor = ele.pstyle( 'text-outline-color' ).value;\n\t  var shadowBlur = ele.pstyle( 'text-shadow-blur' ).pfValue;\n\t  var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;\n\t  var shadowColor = ele.pstyle( 'text-shadow-color' ).value;\n\t  var shadowOffsetX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;\n\t  var shadowOffsetY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;\n\t\n\t  var fontCacheKey = ele._private.fontKey;\n\t  var cache = this.getFontCache( context );\n\t\n\t  if( cache.key !== fontCacheKey ){\n\t    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n\t\n\t    cache.key = fontCacheKey;\n\t  }\n\t\n\t  // Calculate text draw position based on text alignment\n\t\n\t  // so text outlines aren't jagged\n\t  context.lineJoin = 'round';\n\t\n\t  this.fillStyle( context, color[ 0 ], color[ 1 ], color[ 2 ], opacity );\n\t\n\t  this.strokeStyle( context, outlineColor[ 0 ], outlineColor[ 1 ], outlineColor[ 2 ], outlineOpacity );\n\t\n\t  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );\n\t};\n\t\n\tfunction roundRect( ctx, x, y, width, height, radius ){\n\t  var radius = radius || 5;\n\t  ctx.beginPath();\n\t  ctx.moveTo( x + radius, y );\n\t  ctx.lineTo( x + width - radius, y );\n\t  ctx.quadraticCurveTo( x + width, y, x + width, y + radius );\n\t  ctx.lineTo( x + width, y + height - radius );\n\t  ctx.quadraticCurveTo( x + width, y + height, x + width - radius, y + height );\n\t  ctx.lineTo( x + radius, y + height );\n\t  ctx.quadraticCurveTo( x, y + height, x, y + height - radius );\n\t  ctx.lineTo( x, y + radius );\n\t  ctx.quadraticCurveTo( x, y, x + radius, y );\n\t  ctx.closePath();\n\t  ctx.fill();\n\t}\n\t\n\t// Draw text\n\tCRp.drawText = function( context, ele, prefix ){\n\t  var _p = ele._private;\n\t  var rscratch = _p.rscratch;\n\t  var parentOpacity = ele.effectiveOpacity();\n\t  if( parentOpacity === 0 || ele.pstyle( 'text-opacity' ).value === 0 ){\n\t    return;\n\t  }\n\t\n\t  var textX = util.getPrefixedProperty( rscratch, 'labelX', prefix );\n\t  var textY = util.getPrefixedProperty( rscratch, 'labelY', prefix );\n\t  var text = this.getLabelText( ele, prefix );\n\t\n\t  if( text != null && text !== '' && !isNaN( textX ) && !isNaN( textY ) ){\n\t    this.setupTextStyle( context, ele );\n\t\n\t    var pdash = prefix ? prefix + '-' : '';\n\t    var textW = util.getPrefixedProperty( rscratch, 'labelWidth', prefix );\n\t    var textH = util.getPrefixedProperty( rscratch, 'labelHeight', prefix );\n\t    var textAngle = util.getPrefixedProperty( rscratch, 'labelAngle', prefix );\n\t    var marginX = ele.pstyle( pdash + 'text-margin-x' ).pfValue;\n\t    var marginY = ele.pstyle( pdash + 'text-margin-y' ).pfValue;\n\t\n\t    var isEdge = ele.isEdge();\n\t    var isNode = ele.isNode();\n\t\n\t    var halign = ele.pstyle( 'text-halign' ).value;\n\t    var valign = ele.pstyle( 'text-valign' ).value;\n\t\n\t    if( isEdge ){\n\t      halign = 'center';\n\t      valign = 'center';\n\t    }\n\t\n\t    textX += marginX;\n\t    textY += marginY;\n\t\n\t    var rotation = ele.pstyle( 'text-rotation' );\n\t    var theta;\n\t\n\t    if( rotation.strValue === 'autorotate' ){\n\t      theta = isEdge ? textAngle : 0;\n\t    } else if( rotation.strValue === 'none' ){\n\t      theta = 0;\n\t    } else {\n\t      theta = rotation.pfValue;\n\t    }\n\t\n\t    if( theta !== 0 ){\n\t      var orgTextX = textX;\n\t      var orgTextY = textY;\n\t\n\t      context.translate( orgTextX, orgTextY );\n\t      context.rotate( theta );\n\t\n\t      textX = 0;\n\t      textY = 0;\n\t    }\n\t\n\t    if( isNode ){\n\t      var pLeft = ele.pstyle( 'padding-left' ).pfValue;\n\t      var pRight = ele.pstyle( 'padding-right' ).pfValue;\n\t      var pTop = ele.pstyle( 'padding-top' ).pfValue;\n\t      var pBottom = ele.pstyle( 'padding-bottom' ).pfValue;\n\t\n\t      textX += pLeft / 2;\n\t      textX -= pRight / 2;\n\t\n\t      textY += pTop / 2;\n\t      textY -= pBottom / 2;\n\t    }\n\t\n\t    var backgroundOpacity = ele.pstyle( 'text-background-opacity' ).value;\n\t    var borderOpacity = ele.pstyle( 'text-border-opacity' ).value;\n\t    var textBorderWidth = ele.pstyle( 'text-border-width' ).pfValue;\n\t\n\t    if( backgroundOpacity > 0 || ( textBorderWidth > 0 && borderOpacity > 0 ) ){\n\t      var bgWidth = textW;\n\t      var bgHeight = textH;\n\t      var bgX = textX;\n\t\n\t      if( halign ){\n\t        if( halign == 'center' ){\n\t          bgX = bgX - bgWidth / 2;\n\t        } else if( halign == 'left' ){\n\t          bgX = bgX - bgWidth;\n\t        }\n\t      }\n\t\n\t      var bgY = textY;\n\t\n\t      if( isNode ){\n\t        if( valign == 'top' ){\n\t          bgY = bgY - bgHeight;\n\t        } else if( valign == 'center' ){\n\t          bgY = bgY - bgHeight / 2;\n\t        }\n\t      } else {\n\t        bgY = bgY - bgHeight / 2;\n\t      }\n\t\n\t      if( backgroundOpacity > 0 ){\n\t        var textFill = context.fillStyle;\n\t        var textBackgroundColor = ele.pstyle( 'text-background-color' ).value;\n\t\n\t        context.fillStyle = 'rgba(' + textBackgroundColor[ 0 ] + ',' + textBackgroundColor[ 1 ] + ',' + textBackgroundColor[ 2 ] + ',' + backgroundOpacity * parentOpacity + ')';\n\t        var styleShape = ele.pstyle( 'text-background-shape' ).strValue;\n\t        if( styleShape == 'roundrectangle' ){\n\t          roundRect( context, bgX, bgY, bgWidth, bgHeight, 2 );\n\t        } else {\n\t          context.fillRect( bgX, bgY, bgWidth, bgHeight );\n\t        }\n\t        context.fillStyle = textFill;\n\t      }\n\t\n\t      if( textBorderWidth > 0 && borderOpacity > 0 ){\n\t        var textStroke = context.strokeStyle;\n\t        var textLineWidth = context.lineWidth;\n\t        var textBorderColor = ele.pstyle( 'text-border-color' ).value;\n\t        var textBorderStyle = ele.pstyle( 'text-border-style' ).value;\n\t\n\t        context.strokeStyle = 'rgba(' + textBorderColor[ 0 ] + ',' + textBorderColor[ 1 ] + ',' + textBorderColor[ 2 ] + ',' + borderOpacity * parentOpacity + ')';\n\t        context.lineWidth = textBorderWidth;\n\t\n\t        if( context.setLineDash ){ // for very outofdate browsers\n\t          switch( textBorderStyle ){\n\t            case 'dotted':\n\t              context.setLineDash( [ 1, 1 ] );\n\t              break;\n\t            case 'dashed':\n\t              context.setLineDash( [ 4, 2 ] );\n\t              break;\n\t            case 'double':\n\t              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n\t              context.setLineDash( [] );\n\t              break;\n\t            case 'solid':\n\t              context.setLineDash( [] );\n\t              break;\n\t          }\n\t        }\n\t\n\t        context.strokeRect( bgX, bgY, bgWidth, bgHeight );\n\t\n\t        if( textBorderStyle === 'double' ){\n\t          var whiteWidth = textBorderWidth / 2;\n\t\n\t          context.strokeRect( bgX + whiteWidth, bgY + whiteWidth, bgWidth - whiteWidth * 2, bgHeight - whiteWidth * 2 );\n\t        }\n\t\n\t        if( context.setLineDash ){ // for very outofdate browsers\n\t          context.setLineDash( [] );\n\t        }\n\t        context.lineWidth = textLineWidth;\n\t        context.strokeStyle = textStroke;\n\t      }\n\t\n\t    }\n\t\n\t    var lineWidth = 2 * ele.pstyle( 'text-outline-width' ).pfValue; // *2 b/c the stroke is drawn centred on the middle\n\t\n\t    if( lineWidth > 0 ){\n\t      context.lineWidth = lineWidth;\n\t    }\n\t\n\t    if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){\n\t      var lines = rscratch.labelWrapCachedLines;\n\t      var lineHeight = textH / lines.length;\n\t\n\t      switch( valign ){\n\t        case 'top':\n\t          textY -= ( lines.length - 1 ) * lineHeight;\n\t          break;\n\t\n\t        case 'bottom':\n\t          // nothing required\n\t          break;\n\t\n\t        default:\n\t        case 'center':\n\t          textY -= ( lines.length - 1 ) * lineHeight / 2;\n\t      }\n\t\n\t      for( var l = 0; l < lines.length; l++ ){\n\t        if( lineWidth > 0 ){\n\t          context.strokeText( lines[ l ], textX, textY );\n\t        }\n\t\n\t        context.fillText( lines[ l ], textX, textY );\n\t\n\t        textY += lineHeight;\n\t      }\n\t\n\t    } else {\n\t      if( lineWidth > 0 ){\n\t        context.strokeText( text, textX, textY );\n\t      }\n\t\n\t      context.fillText( text, textX, textY );\n\t    }\n\t\n\t    if( theta !== 0 ){\n\t      context.rotate( -theta );\n\t      context.translate( -orgTextX, -orgTextY );\n\t    }\n\t\n\t    this.shadowStyle( context, 'transparent', 0 ); // reset for next guy\n\t  }\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar CRp = {};\n\t\n\tCRp.drawNode = function( context, node, shiftToOriginWithBb, drawLabel ){\n\t  var r = this;\n\t  var nodeWidth, nodeHeight;\n\t  var rs = node._private.rscratch;\n\t  var _p = node._private;\n\t  var pos = pos || _p.position;\n\t\n\t  if( !is.number( pos.x ) || !is.number( pos.y ) ){\n\t    return; // can't draw node with undefined position\n\t  }\n\t\n\t  var usePaths = this.usePaths();\n\t  var path;\n\t  var pathCacheHit = false;\n\t\n\t  var parentOpacity = node.effectiveOpacity();\n\t  if( parentOpacity === 0 ){ return; }\n\t\n\t  nodeWidth = node.width() + node.pstyle( 'padding-left' ).pfValue + node.pstyle( 'padding-right' ).pfValue;\n\t  nodeHeight = node.height() + node.pstyle( 'padding-top' ).pfValue + node.pstyle( 'padding-bottom' ).pfValue;\n\t\n\t  context.lineWidth = node.pstyle( 'border-width' ).pfValue;\n\t\n\t  //\n\t  // setup shift\n\t\n\t  var bb;\n\t  if( shiftToOriginWithBb ){\n\t    bb = shiftToOriginWithBb;\n\t\n\t    context.translate( -bb.x1, -bb.y1 );\n\t  }\n\t\n\t  //\n\t  // load bg image\n\t\n\t  var bgImgProp = node.pstyle( 'background-image' );\n\t  var url = bgImgProp.value[2] || bgImgProp.value[1];\n\t  var image;\n\t\n\t  if( url !== undefined ){\n\t\n\t    // get image, and if not loaded then ask to redraw when later loaded\n\t    image = this.getCachedImage( url, function(){\n\t      node.trigger('background');\n\t\n\t      r.redrawHint( 'eles', true );\n\t      r.redrawHint( 'drag', true );\n\t\n\t      r.drawingImage = true;\n\t\n\t      r.redraw();\n\t    } );\n\t\n\t    var prevBging = _p.backgrounding;\n\t    _p.backgrounding = !image.complete;\n\t\n\t    if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed\n\t      node.updateStyle( false );\n\t    }\n\t  }\n\t\n\t  //\n\t  // setup styles\n\t\n\t  var bgColor = node.pstyle( 'background-color' ).value;\n\t  var borderColor = node.pstyle( 'border-color' ).value;\n\t  var borderStyle = node.pstyle( 'border-style' ).value;\n\t\n\t  this.fillStyle( context, bgColor[0], bgColor[1], bgColor[2], node.pstyle( 'background-opacity' ).value * parentOpacity );\n\t\n\t  this.strokeStyle( context, borderColor[0], borderColor[1], borderColor[2], node.pstyle( 'border-opacity' ).value * parentOpacity );\n\t\n\t  var shadowBlur = node.pstyle( 'shadow-blur' ).pfValue;\n\t  var shadowOpacity = node.pstyle( 'shadow-opacity' ).value;\n\t  var shadowColor = node.pstyle( 'shadow-color' ).value;\n\t  var shadowOffsetX = node.pstyle( 'shadow-offset-x' ).pfValue;\n\t  var shadowOffsetY = node.pstyle( 'shadow-offset-y' ).pfValue;\n\t\n\t  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );\n\t\n\t  context.lineJoin = 'miter'; // so borders are square with the node shape\n\t\n\t  if( context.setLineDash ){ // for very outofdate browsers\n\t    switch( borderStyle ){\n\t      case 'dotted':\n\t        context.setLineDash( [ 1, 1 ] );\n\t        break;\n\t\n\t      case 'dashed':\n\t        context.setLineDash( [ 4, 2 ] );\n\t        break;\n\t\n\t      case 'solid':\n\t      case 'double':\n\t        context.setLineDash( [ ] );\n\t        break;\n\t    }\n\t  }\n\t\n\t\n\t  //\n\t  // draw shape\n\t\n\t  var styleShape = node.pstyle( 'shape' ).strValue;\n\t\n\t  if( usePaths ){\n\t    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight;\n\t\n\t    context.translate( pos.x, pos.y );\n\t\n\t    if( rs.pathCacheKey === pathCacheKey ){\n\t      path = rs.pathCache;\n\t      pathCacheHit = true;\n\t    } else {\n\t      path = new Path2D();\n\t      rs.pathCacheKey = pathCacheKey;\n\t      rs.pathCache = path;\n\t    }\n\t  }\n\t\n\t  if( !pathCacheHit ){\n\t\n\t    var npos = pos;\n\t\n\t    if( usePaths ){\n\t      npos = {\n\t        x: 0,\n\t        y: 0\n\t      };\n\t    }\n\t\n\t    r.nodeShapes[ this.getNodeShape( node ) ].draw(\n\t          ( path || context ),\n\t          npos.x,\n\t          npos.y,\n\t          nodeWidth,\n\t          nodeHeight );\n\t  }\n\t\n\t  if( usePaths ){\n\t    context.fill( path );\n\t  } else {\n\t    context.fill();\n\t  }\n\t\n\t  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy\n\t\n\t  //\n\t  // bg image\n\t\n\t  if( url !== undefined ){\n\t    if( image.complete ){\n\t      this.drawInscribedImage( context, image, node );\n\t    }\n\t  }\n\t\n\t  //\n\t  // pie\n\t\n\t  var darkness = node.pstyle( 'background-blacken' ).value;\n\t  var borderWidth = node.pstyle( 'border-width' ).pfValue;\n\t\n\t  if( this.hasPie( node ) ){\n\t    this.drawPie( context, node, parentOpacity );\n\t\n\t    // redraw path for blacken and border\n\t    if( darkness !== 0 || borderWidth !== 0 ){\n\t\n\t      if( !usePaths ){\n\t        r.nodeShapes[ this.getNodeShape( node ) ].draw(\n\t            context,\n\t            pos.x,\n\t            pos.y,\n\t            nodeWidth,\n\t            nodeHeight );\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // darken/lighten\n\t\n\t  if( darkness > 0 ){\n\t    this.fillStyle( context, 0, 0, 0, darkness );\n\t\n\t    if( usePaths ){\n\t      context.fill( path );\n\t    } else {\n\t      context.fill();\n\t    }\n\t\n\t  } else if( darkness < 0 ){\n\t    this.fillStyle( context, 255, 255, 255, -darkness );\n\t\n\t    if( usePaths ){\n\t      context.fill( path );\n\t    } else {\n\t      context.fill();\n\t    }\n\t  }\n\t\n\t  //\n\t  // border\n\t\n\t  if( borderWidth > 0 ){\n\t\n\t    if( usePaths ){\n\t      context.stroke( path );\n\t    } else {\n\t      context.stroke();\n\t    }\n\t\n\t    if( borderStyle === 'double' ){\n\t      context.lineWidth = node.pstyle( 'border-width' ).pfValue / 3;\n\t\n\t      var gco = context.globalCompositeOperation;\n\t      context.globalCompositeOperation = 'destination-out';\n\t\n\t      if( usePaths ){\n\t        context.stroke( path );\n\t      } else {\n\t        context.stroke();\n\t      }\n\t\n\t      context.globalCompositeOperation = gco;\n\t    }\n\t\n\t  }\n\t\n\t  if( usePaths ){\n\t    context.translate( -pos.x, -pos.y );\n\t  }\n\t\n\t  // reset in case we changed the border style\n\t  if( context.setLineDash ){ // for very outofdate browsers\n\t    context.setLineDash( [ ] );\n\t  }\n\t\n\t  //\n\t  // label\n\t\n\t  r.drawElementText( context, node, drawLabel );\n\t\n\t  //\n\t  // overlay\n\t\n\t  var overlayPadding = node.pstyle( 'overlay-padding' ).pfValue;\n\t  var overlayOpacity = node.pstyle( 'overlay-opacity' ).value;\n\t  var overlayColor = node.pstyle( 'overlay-color' ).value;\n\t\n\t  if( overlayOpacity > 0 ){\n\t    this.fillStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );\n\t\n\t    r.nodeShapes[ 'roundrectangle' ].draw(\n\t      context,\n\t      node._private.position.x,\n\t      node._private.position.y,\n\t      nodeWidth + overlayPadding * 2,\n\t      nodeHeight + overlayPadding * 2\n\t    );\n\t\n\t    context.fill();\n\t  }\n\t\n\t  //\n\t  // clean up shift\n\t\n\t  if( shiftToOriginWithBb ){\n\t    context.translate( bb.x1, bb.y1 );\n\t  }\n\t\n\t};\n\t\n\t// does the node have at least one pie piece?\n\tCRp.hasPie = function( node ){\n\t  node = node[0]; // ensure ele ref\n\t\n\t  return node._private.hasPie;\n\t};\n\t\n\tCRp.drawPie = function( context, node, nodeOpacity, pos ){\n\t  node = node[0]; // ensure ele ref\n\t\n\t  var _p = node._private;\n\t  var cyStyle = node.cy().style();\n\t  var pieSize = node.pstyle( 'pie-size' );\n\t  var nodeW = node.width();\n\t  var nodeH = node.height();\n\t  var pos = pos || _p.position;\n\t  var x = pos.x;\n\t  var y = pos.y;\n\t  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node\n\t  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n\t  var usePaths = this.usePaths();\n\t\n\t  if( usePaths ){\n\t    x = 0;\n\t    y = 0;\n\t  }\n\t\n\t  if( pieSize.units === '%' ){\n\t    radius = radius * pieSize.value / 100;\n\t  } else if( pieSize.pfValue !== undefined ){\n\t    radius = pieSize.pfValue / 2;\n\t  }\n\t\n\t  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N\n\t    var size = node.pstyle( 'pie-' + i + '-background-size' ).value;\n\t    var color = node.pstyle( 'pie-' + i + '-background-color' ).value;\n\t    var opacity = node.pstyle( 'pie-' + i + '-background-opacity' ).value * nodeOpacity;\n\t    var percent = size / 100; // map integer range [0, 100] to [0, 1]\n\t\n\t    // percent can't push beyond 1\n\t    if( percent + lastPercent > 1 ){\n\t      percent = 1 - lastPercent;\n\t    }\n\t\n\t    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n\t    var angleDelta = 2 * Math.PI * percent;\n\t    var angleEnd = angleStart + angleDelta;\n\t\n\t    // ignore if\n\t    // - zero size\n\t    // - we're already beyond the full circle\n\t    // - adding the current slice would go beyond the full circle\n\t    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){\n\t      continue;\n\t    }\n\t\n\t    context.beginPath();\n\t    context.moveTo( x, y );\n\t    context.arc( x, y, radius, angleStart, angleEnd );\n\t    context.closePath();\n\t\n\t    this.fillStyle( context, color[0], color[1], color[2], opacity );\n\t\n\t    context.fill();\n\t\n\t    lastPercent += percent;\n\t  }\n\t\n\t};\n\t\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar CRp = {};\n\t\n\tvar util = __webpack_require__( 32 );\n\t\n\tvar motionBlurDelay = 100;\n\t\n\t// var isFirefox = typeof InstallTrigger !== 'undefined';\n\t\n\tCRp.getPixelRatio = function(){\n\t  var context = this.data.contexts[0];\n\t\n\t  if( this.forcedPixelRatio != null ){\n\t    return this.forcedPixelRatio;\n\t  }\n\t\n\t  var backingStore = context.backingStorePixelRatio ||\n\t    context.webkitBackingStorePixelRatio ||\n\t    context.mozBackingStorePixelRatio ||\n\t    context.msBackingStorePixelRatio ||\n\t    context.oBackingStorePixelRatio ||\n\t    context.backingStorePixelRatio || 1;\n\t\n\t  return (window.devicePixelRatio || 1) / backingStore;\n\t};\n\t\n\tCRp.paintCache = function( context ){\n\t  var caches = this.paintCaches = this.paintCaches || [];\n\t  var needToCreateCache = true;\n\t  var cache;\n\t\n\t  for( var i = 0; i < caches.length; i++ ){\n\t    cache = caches[ i ];\n\t\n\t    if( cache.context === context ){\n\t      needToCreateCache = false;\n\t      break;\n\t    }\n\t  }\n\t\n\t  if( needToCreateCache ){\n\t    cache = {\n\t      context: context\n\t    };\n\t    caches.push( cache );\n\t  }\n\t\n\t  return cache;\n\t};\n\t\n\tCRp.fillStyle = function( context, r, g, b, a ){\n\t  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // turn off for now, seems context does its own caching\n\t\n\t  // var cache = this.paintCache(context);\n\t\n\t  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // if( cache.fillStyle !== fillStyle ){\n\t  //   context.fillStyle = cache.fillStyle = fillStyle;\n\t  // }\n\t};\n\t\n\tCRp.strokeStyle = function( context, r, g, b, a ){\n\t  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // turn off for now, seems context does its own caching\n\t\n\t  // var cache = this.paintCache(context);\n\t\n\t  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t\n\t  // if( cache.strokeStyle !== strokeStyle ){\n\t  //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n\t  // }\n\t};\n\t\n\tCRp.shadowStyle = function( context, color, opacity, blur, offsetX, offsetY ){\n\t  var zoom = this.cy.zoom();\n\t\n\t  // var cache = this.paintCache( context );\n\t  //\n\t  // // don't make expensive changes to the shadow style if it's not used\n\t  // if( cache.shadowOpacity === 0 && opacity === 0 ){\n\t  //   return;\n\t  // }\n\t  //\n\t  // cache.shadowOpacity = opacity;\n\t\n\t  if( opacity > 0 ){\n\t    context.shadowBlur = blur * zoom;\n\t    context.shadowColor = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + opacity + ')';\n\t    context.shadowOffsetX = offsetX * zoom;\n\t    context.shadowOffsetY = offsetY * zoom;\n\t  } else {\n\t    context.shadowBlur = 0;\n\t    context.shadowColor = 'transparent';\n\t    context.shadowOffsetX = 0;\n\t    context.shadowOffsetY = 0;\n\t  }\n\t};\n\t\n\t// Resize canvas\n\tCRp.matchCanvasSize = function( container ){\n\t  var r = this;\n\t  var data = r.data;\n\t  var width = container.clientWidth;\n\t  var height = container.clientHeight;\n\t  var pixelRatio = r.getPixelRatio();\n\t  var mbPxRatio = r.motionBlurPxRatio;\n\t\n\t  if(\n\t    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ] ||\n\t    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ]\n\t  ){\n\t    pixelRatio = mbPxRatio;\n\t  }\n\t\n\t  var canvasWidth = width * pixelRatio;\n\t  var canvasHeight = height * pixelRatio;\n\t  var canvas;\n\t\n\t  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){\n\t    return; // save cycles if same\n\t  }\n\t\n\t  r.fontCaches = null; // resizing resets the style\n\t\n\t  var canvasContainer = data.canvasContainer;\n\t  canvasContainer.style.width = width + 'px';\n\t  canvasContainer.style.height = height + 'px';\n\t\n\t  for( var i = 0; i < r.CANVAS_LAYERS; i++ ){\n\t\n\t    canvas = data.canvases[ i ];\n\t\n\t    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){\n\t\n\t      canvas.width = canvasWidth;\n\t      canvas.height = canvasHeight;\n\t\n\t      canvas.style.width = width + 'px';\n\t      canvas.style.height = height + 'px';\n\t    }\n\t  }\n\t\n\t  for( var i = 0; i < r.BUFFER_COUNT; i++ ){\n\t\n\t    canvas = data.bufferCanvases[ i ];\n\t\n\t    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){\n\t\n\t      canvas.width = canvasWidth;\n\t      canvas.height = canvasHeight;\n\t\n\t      canvas.style.width = width + 'px';\n\t      canvas.style.height = height + 'px';\n\t    }\n\t  }\n\t\n\t  r.textureMult = 1;\n\t  if( pixelRatio <= 1 ){\n\t    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];\n\t\n\t    r.textureMult = 2;\n\t    canvas.width = canvasWidth * r.textureMult;\n\t    canvas.height = canvasHeight * r.textureMult;\n\t  }\n\t\n\t  r.canvasWidth = canvasWidth;\n\t  r.canvasHeight = canvasHeight;\n\t\n\t};\n\t\n\tCRp.renderTo = function( cxt, zoom, pan, pxRatio ){\n\t  this.render( {\n\t    forcedContext: cxt,\n\t    forcedZoom: zoom,\n\t    forcedPan: pan,\n\t    drawAllLayers: true,\n\t    forcedPxRatio: pxRatio\n\t  } );\n\t};\n\t\n\tCRp.render = function( options ){\n\t  options = options || util.staticEmptyObject();\n\t\n\t  var forcedContext = options.forcedContext;\n\t  var drawAllLayers = options.drawAllLayers;\n\t  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n\t  var forcedZoom = options.forcedZoom;\n\t  var forcedPan = options.forcedPan;\n\t  var r = this;\n\t  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n\t  var cy = r.cy; var data = r.data;\n\t  var needDraw = data.canvasNeedsRedraw;\n\t  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n\t  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n\t  var mbPxRatio = r.motionBlurPxRatio;\n\t  var hasCompoundNodes = cy.hasCompoundNodes();\n\t  var inNodeDragGesture = r.hoverData.draggingEles;\n\t  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n\t  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n\t  var motionBlurFadeEffect = motionBlur;\n\t\n\t  if( !forcedContext ){\n\t    if( r.prevPxRatio !== pixelRatio ){\n\t      r.invalidateContainerClientCoordsCache();\n\t      r.matchCanvasSize( r.container );\n\t\n\t      r.redrawHint('eles', true);\n\t      r.redrawHint('drag', true);\n\t    }\n\t\n\t    r.prevPxRatio = pixelRatio;\n\t  }\n\t\n\t  if( !forcedContext && r.motionBlurTimeout ){\n\t    clearTimeout( r.motionBlurTimeout );\n\t  }\n\t\n\t  if( motionBlur ){\n\t    if( r.mbFrames == null ){\n\t      r.mbFrames = 0;\n\t    }\n\t\n\t    if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames\n\t      r.mbFrames++;\n\t    }\n\t\n\t    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur\n\t      motionBlurFadeEffect = false;\n\t    }\n\t\n\t    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n\t    if( r.mbFrames > r.minMbLowQualFrames ){\n\t      //r.fullQualityMb = false;\n\t      r.motionBlurPxRatio = r.mbPxRBlurry;\n\t    }\n\t  }\n\t\n\t  if( r.clearingMotionBlur ){\n\t    r.motionBlurPxRatio = 1;\n\t  }\n\t\n\t  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n\t  // because a rogue async texture frame would clear needDraw\n\t  if( r.textureDrawLastFrame && !textureDraw ){\n\t    needDraw[ r.NODE ] = true;\n\t    needDraw[ r.SELECT_BOX ] = true;\n\t  }\n\t\n\t  var coreStyle = cy.style()._private.coreStyle;\n\t\n\t  var zoom = cy.zoom();\n\t  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n\t  var pan = cy.pan();\n\t  var effectivePan = {\n\t    x: pan.x,\n\t    y: pan.y\n\t  };\n\t\n\t  var vp = {\n\t    zoom: zoom,\n\t    pan: {\n\t      x: pan.x,\n\t      y: pan.y\n\t    }\n\t  };\n\t  var prevVp = r.prevViewport;\n\t  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n\t\n\t  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n\t  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){\n\t    r.motionBlurPxRatio = 1;\n\t  }\n\t\n\t  if( forcedPan ){\n\t    effectivePan = forcedPan;\n\t  }\n\t\n\t  // apply pixel ratio\n\t\n\t  effectiveZoom *= pixelRatio;\n\t  effectivePan.x *= pixelRatio;\n\t  effectivePan.y *= pixelRatio;\n\t\n\t  var eles = r.getCachedZSortedEles();\n\t\n\t  function mbclear( context, x, y, w, h ){\n\t    var gco = context.globalCompositeOperation;\n\t\n\t    context.globalCompositeOperation = 'destination-out';\n\t    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );\n\t    context.fillRect( x, y, w, h );\n\t\n\t    context.globalCompositeOperation = gco;\n\t  }\n\t\n\t  function setContextTransform( context, clear ){\n\t    var ePan, eZoom, w, h;\n\t\n\t    if( !r.clearingMotionBlur && (context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] || context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ]) ){\n\t      ePan = {\n\t        x: pan.x * mbPxRatio,\n\t        y: pan.y * mbPxRatio\n\t      };\n\t\n\t      eZoom = zoom * mbPxRatio;\n\t\n\t      w = r.canvasWidth * mbPxRatio;\n\t      h = r.canvasHeight * mbPxRatio;\n\t    } else {\n\t      ePan = effectivePan;\n\t      eZoom = effectiveZoom;\n\t\n\t      w = r.canvasWidth;\n\t      h = r.canvasHeight;\n\t    }\n\t\n\t    context.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\n\t    if( clear === 'motionBlur' ){\n\t      mbclear( context, 0, 0, w, h );\n\t    } else if( !forcedContext && (clear === undefined || clear) ){\n\t      context.clearRect( 0, 0, w, h );\n\t    }\n\t\n\t    if( !drawAllLayers ){\n\t      context.translate( ePan.x, ePan.y );\n\t      context.scale( eZoom, eZoom );\n\t    }\n\t    if( forcedPan ){\n\t      context.translate( forcedPan.x, forcedPan.y );\n\t    }\n\t    if( forcedZoom ){\n\t      context.scale( forcedZoom, forcedZoom );\n\t    }\n\t  }\n\t\n\t  if( !textureDraw ){\n\t    r.textureDrawLastFrame = false;\n\t  }\n\t\n\t  if( textureDraw ){\n\t    r.textureDrawLastFrame = true;\n\t\n\t    var bb;\n\t\n\t    if( !r.textureCache ){\n\t      r.textureCache = {};\n\t\n\t      bb = r.textureCache.bb = cy.mutableElements().boundingBox();\n\t\n\t      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];\n\t\n\t      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];\n\t\n\t      cxt.setTransform( 1, 0, 0, 1, 0, 0 );\n\t      cxt.clearRect( 0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult );\n\t\n\t      r.render( {\n\t        forcedContext: cxt,\n\t        drawOnlyNodeLayer: true,\n\t        forcedPxRatio: pixelRatio * r.textureMult\n\t      } );\n\t\n\t      var vp = r.textureCache.viewport = {\n\t        zoom: cy.zoom(),\n\t        pan: cy.pan(),\n\t        width: r.canvasWidth,\n\t        height: r.canvasHeight\n\t      };\n\t\n\t      vp.mpan = {\n\t        x: (0 - vp.pan.x) / vp.zoom,\n\t        y: (0 - vp.pan.y) / vp.zoom\n\t      };\n\t    }\n\t\n\t    needDraw[ r.DRAG ] = false;\n\t    needDraw[ r.NODE ] = false;\n\t\n\t    var context = data.contexts[ r.NODE ];\n\t\n\t    var texture = r.textureCache.texture;\n\t    var vp = r.textureCache.viewport;\n\t    bb = r.textureCache.bb;\n\t\n\t    context.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\n\t    if( motionBlur ){\n\t      mbclear( context, 0, 0, vp.width, vp.height );\n\t    } else {\n\t      context.clearRect( 0, 0, vp.width, vp.height );\n\t    }\n\t\n\t    var outsideBgColor = coreStyle[ 'outside-texture-bg-color' ].value;\n\t    var outsideBgOpacity = coreStyle[ 'outside-texture-bg-opacity' ].value;\n\t    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );\n\t    context.fillRect( 0, 0, vp.width, vp.height );\n\t\n\t    var zoom = cy.zoom();\n\t\n\t    setContextTransform( context, false );\n\t\n\t    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );\n\t    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );\n\t\n\t  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it\n\t    r.textureCache = null;\n\t  }\n\t\n\t  var extent = cy.extent();\n\t  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);\n\t  var hideEdges = r.hideEdgesOnViewport && vpManip;\n\t\n\t  var needMbClear = [];\n\t\n\t  needMbClear[ r.NODE ] = !needDraw[ r.NODE ] && motionBlur && !r.clearedForMotionBlur[ r.NODE ] || r.clearingMotionBlur;\n\t  if( needMbClear[ r.NODE ] ){ r.clearedForMotionBlur[ r.NODE ] = true; }\n\t\n\t  needMbClear[ r.DRAG ] = !needDraw[ r.DRAG ] && motionBlur && !r.clearedForMotionBlur[ r.DRAG ] || r.clearingMotionBlur;\n\t  if( needMbClear[ r.DRAG ] ){ r.clearedForMotionBlur[ r.DRAG ] = true; }\n\t\n\t  if( needDraw[ r.NODE ] || drawAllLayers || drawOnlyNodeLayer || needMbClear[ r.NODE ] ){\n\t    var useBuffer = motionBlur && !needMbClear[ r.NODE ] && mbPxRatio !== 1;\n\t    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[ r.NODE ] );\n\t    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n\t\n\t    setContextTransform( context, clear );\n\t\n\t    if( hideEdges ){\n\t      r.drawCachedNodes( context, eles.nondrag, pixelRatio, extent );\n\t    } else {\n\t      r.drawLayeredElements( context, eles.nondrag, pixelRatio, extent );\n\t    }\n\t\n\t    if( !drawAllLayers && !motionBlur ){\n\t      needDraw[ r.NODE ] = false;\n\t    }\n\t  }\n\t\n\t  if( !drawOnlyNodeLayer && (needDraw[ r.DRAG ] || drawAllLayers || needMbClear[ r.DRAG ]) ){\n\t    var useBuffer = motionBlur && !needMbClear[ r.DRAG ] && mbPxRatio !== 1;\n\t    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[ r.DRAG ] );\n\t\n\t    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );\n\t\n\t    if( hideEdges ){\n\t      r.drawCachedNodes( context, eles.drag, pixelRatio, extent );\n\t    } else {\n\t      r.drawCachedElements( context, eles.drag, pixelRatio, extent );\n\t    }\n\t\n\t    if( !drawAllLayers && !motionBlur ){\n\t      needDraw[ r.DRAG ] = false;\n\t    }\n\t  }\n\t\n\t  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[ r.SELECT_BOX ] && !drawAllLayers)) ){\n\t    var context = forcedContext || data.contexts[ r.SELECT_BOX ];\n\t\n\t    setContextTransform( context );\n\t\n\t    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){\n\t      var zoom = r.cy.zoom();\n\t      var borderWidth = coreStyle[ 'selection-box-border-width' ].value / zoom;\n\t\n\t      context.lineWidth = borderWidth;\n\t      context.fillStyle = 'rgba('\n\t        + coreStyle[ 'selection-box-color' ].value[0] + ','\n\t        + coreStyle[ 'selection-box-color' ].value[1] + ','\n\t        + coreStyle[ 'selection-box-color' ].value[2] + ','\n\t        + coreStyle[ 'selection-box-opacity' ].value + ')';\n\t\n\t      context.fillRect(\n\t        r.selection[0],\n\t        r.selection[1],\n\t        r.selection[2] - r.selection[0],\n\t        r.selection[3] - r.selection[1] );\n\t\n\t      if( borderWidth > 0 ){\n\t        context.strokeStyle = 'rgba('\n\t          + coreStyle[ 'selection-box-border-color' ].value[0] + ','\n\t          + coreStyle[ 'selection-box-border-color' ].value[1] + ','\n\t          + coreStyle[ 'selection-box-border-color' ].value[2] + ','\n\t          + coreStyle[ 'selection-box-opacity' ].value + ')';\n\t\n\t        context.strokeRect(\n\t          r.selection[0],\n\t          r.selection[1],\n\t          r.selection[2] - r.selection[0],\n\t          r.selection[3] - r.selection[1] );\n\t      }\n\t    }\n\t\n\t    if( data.bgActivePosistion && !r.hoverData.selecting ){\n\t      var zoom = r.cy.zoom();\n\t      var pos = data.bgActivePosistion;\n\t\n\t      context.fillStyle = 'rgba('\n\t        + coreStyle[ 'active-bg-color' ].value[0] + ','\n\t        + coreStyle[ 'active-bg-color' ].value[1] + ','\n\t        + coreStyle[ 'active-bg-color' ].value[2] + ','\n\t        + coreStyle[ 'active-bg-opacity' ].value + ')';\n\t\n\t      context.beginPath();\n\t      context.arc( pos.x, pos.y, coreStyle[ 'active-bg-size' ].pfValue / zoom, 0, 2 * Math.PI );\n\t      context.fill();\n\t    }\n\t\n\t    var timeToRender = r.lastRedrawTime;\n\t    if( r.showFps && timeToRender ){\n\t      timeToRender = Math.round( timeToRender );\n\t      var fps = Math.round( 1000 / timeToRender );\n\t\n\t      context.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\n\t      context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n\t      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n\t      context.lineWidth = 1;\n\t      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20 );\n\t\n\t      var maxFps = 60;\n\t      context.strokeRect( 0, 30, 250, 20 );\n\t      context.fillRect( 0, 30, 250 * Math.min( fps / maxFps, 1 ), 20 );\n\t    }\n\t\n\t    if( !drawAllLayers ){\n\t      needDraw[ r.SELECT_BOX ] = false;\n\t    }\n\t  }\n\t\n\t  // motionblur: blit rendered blurry frames\n\t  if( motionBlur && mbPxRatio !== 1 ){\n\t    var cxtNode = data.contexts[ r.NODE ];\n\t    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];\n\t\n\t    var cxtDrag = data.contexts[ r.DRAG ];\n\t    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];\n\t\n\t    var drawMotionBlur = function( cxt, txt, needClear ){\n\t      cxt.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\n\t      if( needClear || !motionBlurFadeEffect ){\n\t        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );\n\t      } else {\n\t        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );\n\t      }\n\t\n\t      var pxr = mbPxRatio;\n\t\n\t      cxt.drawImage(\n\t        txt, // img\n\t        0, 0, // sx, sy\n\t        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n\t        0, 0, // x, y\n\t        r.canvasWidth, r.canvasHeight // w, h\n\t      );\n\t    };\n\t\n\t    if( needDraw[ r.NODE ] || needMbClear[ r.NODE ] ){\n\t      drawMotionBlur( cxtNode, txtNode, needMbClear[ r.NODE ] );\n\t      needDraw[ r.NODE ] = false;\n\t    }\n\t\n\t    if( needDraw[ r.DRAG ] || needMbClear[ r.DRAG ] ){\n\t      drawMotionBlur( cxtDrag, txtDrag, needMbClear[ r.DRAG ] );\n\t      needDraw[ r.DRAG ] = false;\n\t    }\n\t  }\n\t\n\t  r.prevViewport = vp;\n\t\n\t  if( r.clearingMotionBlur ){\n\t    r.clearingMotionBlur = false;\n\t    r.motionBlurCleared = true;\n\t    r.motionBlur = true;\n\t  }\n\t\n\t  if( motionBlur ){\n\t    r.motionBlurTimeout = setTimeout( function(){\n\t      r.motionBlurTimeout = null;\n\t\n\t      r.clearedForMotionBlur[ r.NODE ] = false;\n\t      r.clearedForMotionBlur[ r.DRAG ] = false;\n\t      r.motionBlur = false;\n\t      r.clearingMotionBlur = !textureDraw;\n\t      r.mbFrames = 0;\n\t\n\t      needDraw[ r.NODE ] = true;\n\t      needDraw[ r.DRAG ] = true;\n\t\n\t      r.redraw();\n\t    }, motionBlurDelay );\n\t  }\n\t\n\t  r.drawingImage = false;\n\t\n\t\n\t  if( !forcedContext && !r.initrender ){\n\t    r.initrender = true;\n\t    cy.trigger( 'initrender' );\n\t  }\n\t\n\t  if( !forcedContext ){\n\t    cy.trigger('render');\n\t  }\n\t\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 130 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar math = __webpack_require__( 33 );\n\t\n\tvar CRp = {};\n\t\n\t// @O Polygon drawing\n\tCRp.drawPolygonPath = function(\n\t  context, x, y, width, height, points ){\n\t\n\t  var halfW = width / 2;\n\t  var halfH = height / 2;\n\t\n\t  if( context.beginPath ){ context.beginPath(); }\n\t\n\t  context.moveTo( x + halfW * points[0], y + halfH * points[1] );\n\t\n\t  for( var i = 1; i < points.length / 2; i++ ){\n\t    context.lineTo( x + halfW * points[ i * 2], y + halfH * points[ i * 2 + 1] );\n\t  }\n\t\n\t  context.closePath();\n\t};\n\t\n\t// Round rectangle drawing\n\tCRp.drawRoundRectanglePath = function(\n\t  context, x, y, width, height, radius ){\n\t\n\t  var halfWidth = width / 2;\n\t  var halfHeight = height / 2;\n\t  var cornerRadius = math.getRoundRectangleRadius( width, height );\n\t\n\t  if( context.beginPath ){ context.beginPath(); }\n\t\n\t  // Start at top middle\n\t  context.moveTo( x, y - halfHeight );\n\t  // Arc from middle top to right side\n\t  context.arcTo( x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius );\n\t  // Arc from right side to bottom\n\t  context.arcTo( x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius );\n\t  // Arc from bottom to left side\n\t  context.arcTo( x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius );\n\t  // Arc from left side to topBorder\n\t  context.arcTo( x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius );\n\t  // Join line\n\t  context.lineTo( x, y - halfHeight );\n\t\n\t\n\t  context.closePath();\n\t};\n\t\n\tvar sin0 = Math.sin( 0 );\n\tvar cos0 = Math.cos( 0 );\n\t\n\tvar sin = {};\n\tvar cos = {};\n\t\n\tvar ellipseStepSize = Math.PI / 40;\n\t\n\tfor( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){\n\t  sin[ i ] = Math.sin( i );\n\t  cos[ i ] = Math.cos( i );\n\t}\n\t\n\tCRp.drawEllipsePath = function( context, centerX, centerY, width, height ){\n\t    if( context.beginPath ){ context.beginPath(); }\n\t\n\t    if( context.ellipse ){\n\t      context.ellipse( centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI );\n\t    } else {\n\t      var xPos, yPos;\n\t      var rw = width / 2;\n\t      var rh = height / 2;\n\t      for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){\n\t        xPos = centerX - (rw * sin[ i ]) * sin0 + (rw * cos[ i ]) * cos0;\n\t        yPos = centerY + (rh * cos[ i ]) * sin0 + (rh * sin[ i ]) * cos0;\n\t\n\t        if( i === 0 ){\n\t          context.moveTo( xPos, yPos );\n\t        } else {\n\t          context.lineTo( xPos, yPos );\n\t        }\n\t      }\n\t    }\n\t\n\t    context.closePath();\n\t  };\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar CRp = {};\n\t\n\tCRp.createBuffer = function( w, h ){\n\t  var buffer = document.createElement( 'canvas' );\n\t  buffer.width = w;\n\t  buffer.height = h;\n\t\n\t  return [ buffer, buffer.getContext( '2d' ) ];\n\t};\n\t\n\tCRp.bufferCanvasImage = function( options ){\n\t  var cy = this.cy;\n\t  var eles = cy.mutableElements();\n\t  var bb = eles.boundingBox();\n\t  var width = options.full ? Math.ceil( bb.w ) : this.container.clientWidth;\n\t  var height = options.full ? Math.ceil( bb.h ) : this.container.clientHeight;\n\t  var specdMaxDims = is.number( options.maxWidth ) || is.number( options.maxHeight );\n\t  var pxRatio = this.getPixelRatio();\n\t  var scale = 1;\n\t\n\t  if( options.scale !== undefined ){\n\t    width *= options.scale;\n\t    height *= options.scale;\n\t\n\t    scale = options.scale;\n\t  } else if( specdMaxDims ){\n\t    var maxScaleW = Infinity;\n\t    var maxScaleH = Infinity;\n\t\n\t    if( is.number( options.maxWidth ) ){\n\t      maxScaleW = scale * options.maxWidth / width;\n\t    }\n\t\n\t    if( is.number( options.maxHeight ) ){\n\t      maxScaleH = scale * options.maxHeight / height;\n\t    }\n\t\n\t    scale = Math.min( maxScaleW, maxScaleH );\n\t\n\t    width *= scale;\n\t    height *= scale;\n\t  }\n\t\n\t  if( !specdMaxDims ){\n\t    width *= pxRatio;\n\t    height *= pxRatio;\n\t    scale *= pxRatio;\n\t  }\n\t\n\t  var buffCanvas = document.createElement( 'canvas' );\n\t\n\t  buffCanvas.width = width;\n\t  buffCanvas.height = height;\n\t\n\t  buffCanvas.style.width = width + 'px';\n\t  buffCanvas.style.height = height + 'px';\n\t\n\t  var buffCxt = buffCanvas.getContext( '2d' );\n\t\n\t  // Rasterize the layers, but only if container has nonzero size\n\t  if( width > 0 && height > 0 ){\n\t\n\t    buffCxt.clearRect( 0, 0, width, height );\n\t\n\t    if( options.bg ){\n\t      buffCxt.fillStyle = options.bg;\n\t      buffCxt.rect( 0, 0, width, height );\n\t      buffCxt.fill();\n\t    }\n\t\n\t    buffCxt.globalCompositeOperation = 'source-over';\n\t\n\t    var zsortedEles = this.getCachedZSortedEles();\n\t\n\t    if( options.full ){ // draw the full bounds of the graph\n\t      buffCxt.translate( -bb.x1 * scale, -bb.y1 * scale );\n\t      buffCxt.scale( scale, scale );\n\t\n\t      this.drawElements( buffCxt, zsortedEles );\n\t    } else { // draw the current view\n\t      var pan = cy.pan();\n\t\n\t      var translation = {\n\t        x: pan.x * scale,\n\t        y: pan.y * scale\n\t      };\n\t\n\t      scale *= cy.zoom();\n\t\n\t      buffCxt.translate( translation.x, translation.y );\n\t      buffCxt.scale( scale, scale );\n\t\n\t      this.drawElements( buffCxt, zsortedEles );\n\t    }\n\t  }\n\t\n\t  return buffCanvas;\n\t};\n\t\n\tCRp.png = function( options ){\n\t  return this.bufferCanvasImage( options ).toDataURL( 'image/png' );\n\t};\n\t\n\tCRp.jpg = function( options ){\n\t  return this.bufferCanvasImage( options ).toDataURL( 'image/jpeg' );\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 132 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar CRp = {};\n\t\n\tvar impl;\n\t\n\tCRp.nodeShapeImpl = function( name ){\n\t  var self = this;\n\t\n\t  return ( impl || (impl = {\n\t    'ellipse': function( context, centerX, centerY, width, height ){\n\t      self.drawEllipsePath( context, centerX, centerY, width, height );\n\t    },\n\t\n\t    'polygon': function( context, centerX, centerY, width, height, points ){\n\t      self.drawPolygonPath( context, centerX, centerY, width, height, points );\n\t    },\n\t\n\t    'roundrectangle': function( context, centerX, centerY, width, height ){\n\t      self.drawRoundRectanglePath( context, centerX, centerY, width, height, 10 );\n\t    }\n\t  }) )[ name ];\n\t};\n\t\n\tmodule.exports = CRp;\n\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\t\n\tvar cyReg = function( $ele ){\n\t  var d = $ele[0]._cyreg = $ele[0]._cyreg || {};\n\t\n\t  return d;\n\t};\n\t\n\tvar registerJquery = function( $, cytoscape ){\n\t  if( !$ ){ return; } // no jquery => don't need this\n\t\n\t  if( $.fn.cytoscape ){ return; } // already registered\n\t\n\t  // allow calls on a jQuery selector by proxying calls to $.cytoscape\n\t  // e.g. $(\"#foo\").cytoscape(options) => $.cytoscape(options) on #foo\n\t  $.fn.cytoscape = function( opts ){\n\t    var $this = $( this );\n\t\n\t    // get object\n\t    if( opts === 'get' ){\n\t      return cyReg( $this ).cy;\n\t    }\n\t\n\t    // bind to ready\n\t    else if( is.fn( opts ) ){\n\t\n\t      var ready = opts;\n\t      var cy = cyReg( $this ).cy;\n\t\n\t      if( cy && cy.isReady() ){ // already ready so just trigger now\n\t        cy.trigger( 'ready', [], ready );\n\t\n\t      } else { // not yet ready, so add to readies list\n\t        var data = cyReg( $this );\n\t        var readies = data.readies = data.readies || [];\n\t\n\t        readies.push( ready );\n\t      }\n\t\n\t    }\n\t\n\t    // proxy to create instance\n\t    else if( is.plainObject( opts ) ){\n\t      return $this.each( function(){\n\t        var options = $.extend( {}, opts, {\n\t          container: $( this )[0]\n\t        } );\n\t\n\t        cytoscape( options );\n\t      } );\n\t    }\n\t  };\n\t\n\t  // allow access to the global cytoscape object under jquery for legacy reasons\n\t  $.cytoscape = cytoscape;\n\t\n\t  // use short alias (cy) if not already defined\n\t  if( $.fn.cy == null && $.cy == null ){\n\t    $.fn.cy = $.fn.cytoscape;\n\t    $.cy = $.cytoscape;\n\t  }\n\t};\n\t\n\tmodule.exports = registerJquery;\n\n\n/***/ },\n/* 134 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar is = __webpack_require__( 30 );\n\tvar util = __webpack_require__( 32 );\n\tvar Style = __webpack_require__( 86 );\n\t\n\t// a dummy stylesheet object that doesn't need a reference to the core\n\t// (useful for init)\n\tvar Stylesheet = function(){\n\t  if( !(this instanceof Stylesheet) ){\n\t    return new Stylesheet();\n\t  }\n\t\n\t  this.length = 0;\n\t};\n\t\n\tvar sheetfn = Stylesheet.prototype;\n\t\n\tsheetfn.instanceString = function(){\n\t  return 'stylesheet';\n\t};\n\t\n\t// just store the selector to be parsed later\n\tsheetfn.selector = function( selector ){\n\t  var i = this.length++;\n\t\n\t  this[ i ] = {\n\t    selector: selector,\n\t    properties: []\n\t  };\n\t\n\t  return this; // chaining\n\t};\n\t\n\t// just store the property to be parsed later\n\tsheetfn.css = function( name, value ){\n\t  var i = this.length - 1;\n\t\n\t  if( is.string( name ) ){\n\t    this[ i ].properties.push( {\n\t      name: name,\n\t      value: value\n\t    } );\n\t  } else if( is.plainObject( name ) ){\n\t    var map = name;\n\t\n\t    for( var j = 0; j < Style.properties.length; j++ ){\n\t      var prop = Style.properties[ j ];\n\t      var mapVal = map[ prop.name ];\n\t\n\t      if( mapVal === undefined ){ // also try camel case name\n\t        mapVal = map[ util.dash2camel( prop.name ) ];\n\t      }\n\t\n\t      if( mapVal !== undefined ){\n\t        var name = prop.name;\n\t        var value = mapVal;\n\t\n\t        this[ i ].properties.push( {\n\t          name: name,\n\t          value: value\n\t        } );\n\t      }\n\t    }\n\t  }\n\t\n\t  return this; // chaining\n\t};\n\t\n\tsheetfn.style = sheetfn.css;\n\t\n\t// generate a real style object from the dummy stylesheet\n\tsheetfn.generateStyle = function( cy ){\n\t  var style = new Style( cy );\n\t\n\t  for( var i = 0; i < this.length; i++ ){\n\t    var context = this[ i ];\n\t    var selector = context.selector;\n\t    var props = context.properties;\n\t\n\t    style.selector( selector ); // apply selector\n\t\n\t    for( var j = 0; j < props.length; j++ ){\n\t      var prop = props[ j ];\n\t\n\t      style.css( prop.name, prop.value ); // apply property\n\t    }\n\t  }\n\t\n\t  return style;\n\t};\n\t\n\tmodule.exports = Stylesheet;\n\n\n/***/ },\n/* 135 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n\t\n\t'use strict';\n\t\n\tvar is = __webpack_require__(30);\n\tvar util = __webpack_require__(32);\n\tvar Thread = __webpack_require__(103);\n\tvar Promise = __webpack_require__(58);\n\tvar define = __webpack_require__(56);\n\t\n\tvar Fabric = function( N ){\n\t  if( !(this instanceof Fabric) ){\n\t    return new Fabric( N );\n\t  }\n\t\n\t  this._private = {\n\t    pass: []\n\t  };\n\t\n\t  var defN = 4;\n\t\n\t  if( is.number(N) ){\n\t    // then use the specified number of threads\n\t  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){\n\t    N = navigator.hardwareConcurrency;\n\t  } else {\n\t    try{\n\t      N = __webpack_require__(136).cpus().length;\n\t    } catch( err ){\n\t      N = defN;\n\t    }\n\t  } // TODO could use an estimation here but would the additional expense be worth it?\n\t\n\t  for( var i = 0; i < N; i++ ){\n\t    this[i] = new Thread();\n\t  }\n\t\n\t  this.length = N;\n\t};\n\t\n\tvar fabfn = Fabric.prototype; // short alias\n\t\n\tutil.extend(fabfn, {\n\t\n\t  instanceString: function(){ return 'fabric'; },\n\t\n\t  // require fn in all threads\n\t  require: function( fn, as ){\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var thread = this[i];\n\t\n\t      thread.require( fn, as );\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  // get a random thread\n\t  random: function(){\n\t    var i = Math.round( (this.length - 1) * Math.random() );\n\t    var thread = this[i];\n\t\n\t    return thread;\n\t  },\n\t\n\t  // run on random thread\n\t  run: function( fn ){\n\t    var pass = this._private.pass.shift();\n\t\n\t    return this.random().pass( pass ).run( fn );\n\t  },\n\t\n\t  // sends a random thread a message\n\t  message: function( m ){\n\t    return this.random().message( m );\n\t  },\n\t\n\t  // send all threads a message\n\t  broadcast: function( m ){\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var thread = this[i];\n\t\n\t      thread.message( m );\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  // stop all threads\n\t  stop: function(){\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var thread = this[i];\n\t\n\t      thread.stop();\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  // pass data to be used with .spread() etc.\n\t  pass: function( data ){\n\t    var pass = this._private.pass;\n\t\n\t    if( is.array(data) ){\n\t      pass.push( data );\n\t    } else {\n\t      throw 'Only arrays may be used with fabric.pass()';\n\t    }\n\t\n\t    return this; // chaining\n\t  },\n\t\n\t  spreadSize: function(){\n\t    var subsize =  Math.ceil( this._private.pass[0].length / this.length );\n\t\n\t    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread\n\t\n\t    return subsize;\n\t  },\n\t\n\t  // split the data into slices to spread the data equally among threads\n\t  spread: function( fn ){\n\t    var self = this;\n\t    var _p = self._private;\n\t    var subsize = self.spreadSize(); // number of pass eles to handle in each thread\n\t    var pass = _p.pass.shift().concat([]); // keep a copy\n\t    var runPs = [];\n\t\n\t    for( var i = 0; i < this.length; i++ ){\n\t      var thread = this[i];\n\t      var slice = pass.splice( 0, subsize );\n\t\n\t      var runP = thread.pass( slice ).run( fn );\n\t\n\t      runPs.push( runP );\n\t\n\t      var doneEarly = pass.length === 0;\n\t      if( doneEarly ){ break; }\n\t    }\n\t\n\t    return Promise.all( runPs ).then(function( thens ){\n\t      var postpass = [];\n\t      var p = 0;\n\t\n\t      // fill postpass with the total result joined from all threads\n\t      for( var i = 0; i < thens.length; i++ ){\n\t        var then = thens[i]; // array result from thread i\n\t\n\t        for( var j = 0; j < then.length; j++ ){\n\t          var t = then[j]; // array element\n\t\n\t          postpass[ p++ ] = t;\n\t        }\n\t      }\n\t\n\t      return postpass;\n\t    });\n\t  },\n\t\n\t  // parallel version of array.map()\n\t  map: function( fn ){\n\t    var self = this;\n\t\n\t    self.require( fn, '_$_$_fabmap' );\n\t\n\t    return self.spread(function( split ){\n\t      var mapped = [];\n\t      var origResolve = resolve; // jshint ignore:line\n\t\n\t      resolve = function( val ){ // jshint ignore:line\n\t        mapped.push( val );\n\t      };\n\t\n\t      for( var i = 0; i < split.length; i++ ){\n\t        var oldLen = mapped.length;\n\t        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line\n\t        var nothingInsdByResolve = oldLen === mapped.length;\n\t\n\t        if( nothingInsdByResolve ){\n\t          mapped.push( ret );\n\t        }\n\t      }\n\t\n\t      resolve = origResolve; // jshint ignore:line\n\t\n\t      return mapped;\n\t    });\n\t\n\t  },\n\t\n\t  // parallel version of array.filter()\n\t  filter: function( fn ){\n\t    var _p = this._private;\n\t    var pass = _p.pass[0];\n\t\n\t    return this.map( fn ).then(function( include ){\n\t      var ret = [];\n\t\n\t      for( var i = 0; i < pass.length; i++ ){\n\t        var datum = pass[i];\n\t        var incDatum = include[i];\n\t\n\t        if( incDatum ){\n\t          ret.push( datum );\n\t        }\n\t      }\n\t\n\t      return ret;\n\t    });\n\t  },\n\t\n\t  // sorts the passed array using a divide and conquer strategy\n\t  sort: function( cmp ){\n\t    var self = this;\n\t    var P = this._private.pass[0].length;\n\t    var subsize = this.spreadSize();\n\t\n\t    cmp = cmp || function( a, b ){ // default comparison function\n\t      if( a < b ){\n\t        return -1;\n\t      } else if( a > b ){\n\t        return 1;\n\t      }\n\t\n\t      return 0;\n\t    };\n\t\n\t    self.require( cmp, '_$_$_cmp' );\n\t\n\t    return self.spread(function( split ){ // sort each split normally\n\t      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line\n\t      resolve( sortedSplit ); // jshint ignore:line\n\t\n\t    }).then(function( joined ){\n\t      // do all the merging in the main thread to minimise data transfer\n\t\n\t      // TODO could do merging in separate threads but would incur add'l cost of data transfer\n\t      // for each level of the merge\n\t\n\t      var merge = function( i, j, max ){\n\t        // don't overflow array\n\t        j = Math.min( j, P );\n\t        max = Math.min( max, P );\n\t\n\t        // left and right sides of merge\n\t        var l = i;\n\t        var r = j;\n\t\n\t        var sorted = [];\n\t\n\t        for( var k = l; k < max; k++ ){\n\t\n\t          var eleI = joined[i];\n\t          var eleJ = joined[j];\n\t\n\t          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){\n\t            sorted.push( eleI );\n\t            i++;\n\t          } else {\n\t            sorted.push( eleJ );\n\t            j++;\n\t          }\n\t\n\t        }\n\t\n\t        // in the array proper, put the sorted values\n\t        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item\n\t          var index = l + k;\n\t\n\t          joined[ index ] = sorted[k];\n\t        }\n\t      };\n\t\n\t      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is \"split\" as 1\n\t\n\t        for( var i = 0; i < P; i += 2*splitL ){\n\t          merge( i, i + splitL, i + 2*splitL );\n\t        }\n\t\n\t      }\n\t\n\t      return joined;\n\t    });\n\t  }\n\t\n\t\n\t});\n\t\n\tvar defineRandomPasser = function( opts ){\n\t  opts = opts || {};\n\t\n\t  return function( fn, arg1 ){\n\t    var pass = this._private.pass.shift();\n\t\n\t    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );\n\t  };\n\t};\n\t\n\tutil.extend(fabfn, {\n\t  randomMap: defineRandomPasser({ threadFn: 'map' }),\n\t\n\t  reduce: defineRandomPasser({ threadFn: 'reduce' }),\n\t\n\t  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })\n\t});\n\t\n\t// aliases\n\tvar fn = fabfn;\n\tfn.promise = fn.run;\n\tfn.terminate = fn.halt = fn.stop;\n\tfn.include = fn.require;\n\t\n\t// pull in event apis\n\tutil.extend(fabfn, {\n\t  on: define.on(),\n\t  one: define.on({ unbindSelfOnTrigger: true }),\n\t  off: define.off(),\n\t  trigger: define.trigger()\n\t});\n\t\n\tdefine.eventAliasesOn( fabfn );\n\t\n\tmodule.exports = Fabric;\n\n\n/***/ },\n/* 136 */\n/***/ function(module, exports) {\n\n\texports.endianness = function () { return 'LE' };\n\t\n\texports.hostname = function () {\n\t    if (typeof location !== 'undefined') {\n\t        return location.hostname\n\t    }\n\t    else return '';\n\t};\n\t\n\texports.loadavg = function () { return [] };\n\t\n\texports.uptime = function () { return 0 };\n\t\n\texports.freemem = function () {\n\t    return Number.MAX_VALUE;\n\t};\n\t\n\texports.totalmem = function () {\n\t    return Number.MAX_VALUE;\n\t};\n\t\n\texports.cpus = function () { return [] };\n\t\n\texports.type = function () { return 'Browser' };\n\t\n\texports.release = function () {\n\t    if (typeof navigator !== 'undefined') {\n\t        return navigator.appVersion;\n\t    }\n\t    return '';\n\t};\n\t\n\texports.networkInterfaces\n\t= exports.getNetworkInterfaces\n\t= function () { return {} };\n\t\n\texports.arch = function () { return 'javascript' };\n\t\n\texports.platform = function () { return 'browser' };\n\t\n\texports.tmpdir = exports.tmpDir = function () {\n\t    return '/tmp';\n\t};\n\t\n\texports.EOL = '\\n';\n\n\n/***/ },\n/* 137 */\n/***/ function(module, exports) {\n\n\t\"2.7.6\"\n\n/***/ },\n/* 138 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar DEF_VISUAL_STYLE = exports.DEF_VISUAL_STYLE = [{\n\t  selector: 'node',\n\t  style: {\n\t    'background-color': '#436EEE',\n\t    'background-opacity': 0.9,\n\t    'width': '40px',\n\t    'height': '40px',\n\t    'label': 'data(name)',\n\t    'font-family': 'Roboto, sans-serif'\n\t  }\n\t}, {\n\t  selector: 'edge',\n\t  style: {\n\t    'line-color': '#aaaaaa',\n\t    'width': 1,\n\t    'label': 'data(interaction)',\n\t    'font-size': '0.15em',\n\t    'font-family': 'Roboto, sans-serif',\n\t    'text-opacity': 0.5\n\t  }\n\t}, {\n\t  selector: 'node:selected',\n\t  style: {\n\t    'background-color': 'yellow'\n\t  }\n\t}, {\n\t  selector: 'edge:selected',\n\t  style: {\n\t    'line-color': 'yellow',\n\t    'width': 6\n\t  }\n\t}];\n\n/***/ },\n/* 139 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = networkStore;\n\texports.addNetwork = addNetwork;\n\texports.deleteNetwork = deleteNetwork;\n\t\n\tvar _immutable = __webpack_require__(140);\n\t\n\tvar ADD_NETWORK = 'ADD_NETWORK';\n\tvar DELETE_NETWORK = 'DELETE_NETWORK';\n\t\n\tvar defaultState = (0, _immutable.Map)({});\n\t\n\tfunction networkStore() {\n\t  var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];\n\t  var action = arguments[1];\n\t\n\t  switch (action.type) {\n\t    case ADD_NETWORK:\n\t      return state.set(action.networkId, (0, _immutable.Map)(action.data));\n\t    case DELETE_NETWORK:\n\t      return state.delete(action.networkId);\n\t    default:\n\t      return state;\n\t  }\n\t}\n\t\n\tfunction addNetwork(networkId, data) {\n\t  return {\n\t    type: ADD_NETWORK,\n\t    networkId: networkId,\n\t    data: data\n\t  };\n\t}\n\t\n\tfunction deleteNetwork(networkId) {\n\t  return {\n\t    type: DELETE_NETWORK,\n\t    networkId: networkId\n\t  };\n\t}\n\n/***/ },\n/* 140 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2014-2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Immutable = factory());\n\t}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\t\n\t  function createClass(ctor, superClass) {\n\t    if (superClass) {\n\t      ctor.prototype = Object.create(superClass.prototype);\n\t    }\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t\n\t  function Iterable(value) {\n\t      return isIterable(value) ? value : Seq(value);\n\t    }\n\t\n\t\n\t  createClass(KeyedIterable, Iterable);\n\t    function KeyedIterable(value) {\n\t      return isKeyed(value) ? value : KeyedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(IndexedIterable, Iterable);\n\t    function IndexedIterable(value) {\n\t      return isIndexed(value) ? value : IndexedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(SetIterable, Iterable);\n\t    function SetIterable(value) {\n\t      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n\t    }\n\t\n\t\n\t\n\t  function isIterable(maybeIterable) {\n\t    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n\t  }\n\t\n\t  function isKeyed(maybeKeyed) {\n\t    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n\t  }\n\t\n\t  function isIndexed(maybeIndexed) {\n\t    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n\t  }\n\t\n\t  function isAssociative(maybeAssociative) {\n\t    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n\t  }\n\t\n\t  function isOrdered(maybeOrdered) {\n\t    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n\t  }\n\t\n\t  Iterable.isIterable = isIterable;\n\t  Iterable.isKeyed = isKeyed;\n\t  Iterable.isIndexed = isIndexed;\n\t  Iterable.isAssociative = isAssociative;\n\t  Iterable.isOrdered = isOrdered;\n\t\n\t  Iterable.Keyed = KeyedIterable;\n\t  Iterable.Indexed = IndexedIterable;\n\t  Iterable.Set = SetIterable;\n\t\n\t\n\t  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  // Used for setting prototype methods that IE8 chokes on.\n\t  var DELETE = 'delete';\n\t\n\t  // Constants describing the size of trie nodes.\n\t  var SHIFT = 5; // Resulted in best performance after ______?\n\t  var SIZE = 1 << SHIFT;\n\t  var MASK = SIZE - 1;\n\t\n\t  // A consistent shared value representing \"not set\" which equals nothing other\n\t  // than itself, and nothing that could be provided externally.\n\t  var NOT_SET = {};\n\t\n\t  // Boolean references, Rough equivalent of `bool &`.\n\t  var CHANGE_LENGTH = { value: false };\n\t  var DID_ALTER = { value: false };\n\t\n\t  function MakeRef(ref) {\n\t    ref.value = false;\n\t    return ref;\n\t  }\n\t\n\t  function SetRef(ref) {\n\t    ref && (ref.value = true);\n\t  }\n\t\n\t  // A function which returns a value representing an \"owner\" for transient writes\n\t  // to tries. The return value will only ever equal itself, and will not equal\n\t  // the return of any subsequent call of this function.\n\t  function OwnerID() {}\n\t\n\t  // http://jsperf.com/copy-array-inline\n\t  function arrCopy(arr, offset) {\n\t    offset = offset || 0;\n\t    var len = Math.max(0, arr.length - offset);\n\t    var newArr = new Array(len);\n\t    for (var ii = 0; ii < len; ii++) {\n\t      newArr[ii] = arr[ii + offset];\n\t    }\n\t    return newArr;\n\t  }\n\t\n\t  function ensureSize(iter) {\n\t    if (iter.size === undefined) {\n\t      iter.size = iter.__iterate(returnTrue);\n\t    }\n\t    return iter.size;\n\t  }\n\t\n\t  function wrapIndex(iter, index) {\n\t    // This implements \"is array index\" which the ECMAString spec defines as:\n\t    //\n\t    //     A String property name P is an array index if and only if\n\t    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n\t    //     to 2^32−1.\n\t    //\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n\t    if (typeof index !== 'number') {\n\t      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n\t      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n\t        return NaN;\n\t      }\n\t      index = uint32Index;\n\t    }\n\t    return index < 0 ? ensureSize(iter) + index : index;\n\t  }\n\t\n\t  function returnTrue() {\n\t    return true;\n\t  }\n\t\n\t  function wholeSlice(begin, end, size) {\n\t    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n\t      (end === undefined || (size !== undefined && end >= size));\n\t  }\n\t\n\t  function resolveBegin(begin, size) {\n\t    return resolveIndex(begin, size, 0);\n\t  }\n\t\n\t  function resolveEnd(end, size) {\n\t    return resolveIndex(end, size, size);\n\t  }\n\t\n\t  function resolveIndex(index, size, defaultIndex) {\n\t    return index === undefined ?\n\t      defaultIndex :\n\t      index < 0 ?\n\t        Math.max(0, size + index) :\n\t        size === undefined ?\n\t          index :\n\t          Math.min(size, index);\n\t  }\n\t\n\t  /* global Symbol */\n\t\n\t  var ITERATE_KEYS = 0;\n\t  var ITERATE_VALUES = 1;\n\t  var ITERATE_ENTRIES = 2;\n\t\n\t  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n\t  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\t  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\t\n\t\n\t  function Iterator(next) {\n\t      this.next = next;\n\t    }\n\t\n\t    Iterator.prototype.toString = function() {\n\t      return '[Iterator]';\n\t    };\n\t\n\t\n\t  Iterator.KEYS = ITERATE_KEYS;\n\t  Iterator.VALUES = ITERATE_VALUES;\n\t  Iterator.ENTRIES = ITERATE_ENTRIES;\n\t\n\t  Iterator.prototype.inspect =\n\t  Iterator.prototype.toSource = function () { return this.toString(); }\n\t  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n\t    return this;\n\t  };\n\t\n\t\n\t  function iteratorValue(type, k, v, iteratorResult) {\n\t    var value = type === 0 ? k : type === 1 ? v : [k, v];\n\t    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n\t      value: value, done: false\n\t    });\n\t    return iteratorResult;\n\t  }\n\t\n\t  function iteratorDone() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  function hasIterator(maybeIterable) {\n\t    return !!getIteratorFn(maybeIterable);\n\t  }\n\t\n\t  function isIterator(maybeIterator) {\n\t    return maybeIterator && typeof maybeIterator.next === 'function';\n\t  }\n\t\n\t  function getIterator(iterable) {\n\t    var iteratorFn = getIteratorFn(iterable);\n\t    return iteratorFn && iteratorFn.call(iterable);\n\t  }\n\t\n\t  function getIteratorFn(iterable) {\n\t    var iteratorFn = iterable && (\n\t      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n\t      iterable[FAUX_ITERATOR_SYMBOL]\n\t    );\n\t    if (typeof iteratorFn === 'function') {\n\t      return iteratorFn;\n\t    }\n\t  }\n\t\n\t  function isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t  }\n\t\n\t  createClass(Seq, Iterable);\n\t    function Seq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        isIterable(value) ? value.toSeq() : seqFromValue(value);\n\t    }\n\t\n\t    Seq.of = function(/*...values*/) {\n\t      return Seq(arguments);\n\t    };\n\t\n\t    Seq.prototype.toSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    Seq.prototype.toString = function() {\n\t      return this.__toString('Seq {', '}');\n\t    };\n\t\n\t    Seq.prototype.cacheResult = function() {\n\t      if (!this._cache && this.__iterateUncached) {\n\t        this._cache = this.entrySeq().toArray();\n\t        this.size = this._cache.length;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    // abstract __iterateUncached(fn, reverse)\n\t\n\t    Seq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, true);\n\t    };\n\t\n\t    // abstract __iteratorUncached(type, reverse)\n\t\n\t    Seq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, true);\n\t    };\n\t\n\t\n\t\n\t  createClass(KeyedSeq, Seq);\n\t    function KeyedSeq(value) {\n\t      return value === null || value === undefined ?\n\t        emptySequence().toKeyedSeq() :\n\t        isIterable(value) ?\n\t          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n\t          keyedSeqFromValue(value);\n\t    }\n\t\n\t    KeyedSeq.prototype.toKeyedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  createClass(IndexedSeq, Seq);\n\t    function IndexedSeq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n\t    }\n\t\n\t    IndexedSeq.of = function(/*...values*/) {\n\t      return IndexedSeq(arguments);\n\t    };\n\t\n\t    IndexedSeq.prototype.toIndexedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    IndexedSeq.prototype.toString = function() {\n\t      return this.__toString('Seq [', ']');\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, false);\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, false);\n\t    };\n\t\n\t\n\t\n\t  createClass(SetSeq, Seq);\n\t    function SetSeq(value) {\n\t      return (\n\t        value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value\n\t      ).toSetSeq();\n\t    }\n\t\n\t    SetSeq.of = function(/*...values*/) {\n\t      return SetSeq(arguments);\n\t    };\n\t\n\t    SetSeq.prototype.toSetSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  Seq.isSeq = isSeq;\n\t  Seq.Keyed = KeyedSeq;\n\t  Seq.Set = SetSeq;\n\t  Seq.Indexed = IndexedSeq;\n\t\n\t  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\t\n\t  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\t\n\t\n\t\n\t  createClass(ArraySeq, IndexedSeq);\n\t    function ArraySeq(array) {\n\t      this._array = array;\n\t      this.size = array.length;\n\t    }\n\t\n\t    ArraySeq.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterate = function(fn, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterator = function(type, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n\t      );\n\t    };\n\t\n\t\n\t\n\t  createClass(ObjectSeq, KeyedSeq);\n\t    function ObjectSeq(object) {\n\t      var keys = Object.keys(object);\n\t      this._object = object;\n\t      this._keys = keys;\n\t      this.size = keys.length;\n\t    }\n\t\n\t    ObjectSeq.prototype.get = function(key, notSetValue) {\n\t      if (notSetValue !== undefined && !this.has(key)) {\n\t        return notSetValue;\n\t      }\n\t      return this._object[key];\n\t    };\n\t\n\t    ObjectSeq.prototype.has = function(key) {\n\t      return this._object.hasOwnProperty(key);\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        if (fn(object[key], key, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterator = function(type, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, key, object[key]);\n\t      });\n\t    };\n\t\n\t  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(IterableSeq, IndexedSeq);\n\t    function IterableSeq(iterable) {\n\t      this._iterable = iterable;\n\t      this.size = iterable.length || iterable.size;\n\t    }\n\t\n\t    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      var iterations = 0;\n\t      if (isIterator(iterator)) {\n\t        var step;\n\t        while (!(step = iterator.next()).done) {\n\t          if (fn(step.value, iterations++, this) === false) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      if (!isIterator(iterator)) {\n\t        return new Iterator(iteratorDone);\n\t      }\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step : iteratorValue(type, iterations++, step.value);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(IteratorSeq, IndexedSeq);\n\t    function IteratorSeq(iterator) {\n\t      this._iterator = iterator;\n\t      this._iteratorCache = [];\n\t    }\n\t\n\t    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      while (iterations < cache.length) {\n\t        if (fn(cache[iterations], iterations++, this) === false) {\n\t          return iterations;\n\t        }\n\t      }\n\t      var step;\n\t      while (!(step = iterator.next()).done) {\n\t        var val = step.value;\n\t        cache[iterations] = val;\n\t        if (fn(val, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        if (iterations >= cache.length) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          cache[iterations] = step.value;\n\t        }\n\t        return iteratorValue(type, iterations, cache[iterations++]);\n\t      });\n\t    };\n\t\n\t\n\t\n\t\n\t  // # pragma Helper functions\n\t\n\t  function isSeq(maybeSeq) {\n\t    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n\t  }\n\t\n\t  var EMPTY_SEQ;\n\t\n\t  function emptySequence() {\n\t    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n\t  }\n\t\n\t  function keyedSeqFromValue(value) {\n\t    var seq =\n\t      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n\t      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n\t      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n\t      typeof value === 'object' ? new ObjectSeq(value) :\n\t      undefined;\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of [k, v] entries, '+\n\t        'or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function indexedSeqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value);\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function seqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value) ||\n\t      (typeof value === 'object' && new ObjectSeq(value));\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values, or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function maybeIndexedSeqFromValue(value) {\n\t    return (\n\t      isArrayLike(value) ? new ArraySeq(value) :\n\t      isIterator(value) ? new IteratorSeq(value) :\n\t      hasIterator(value) ? new IterableSeq(value) :\n\t      undefined\n\t    );\n\t  }\n\t\n\t  function seqIterate(seq, fn, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    }\n\t    return seq.__iterateUncached(fn, reverse);\n\t  }\n\t\n\t  function seqIterator(seq, type, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n\t      });\n\t    }\n\t    return seq.__iteratorUncached(type, reverse);\n\t  }\n\t\n\t  function fromJS(json, converter) {\n\t    return converter ?\n\t      fromJSWith(converter, json, '', {'': json}) :\n\t      fromJSDefault(json);\n\t  }\n\t\n\t  function fromJSWith(converter, json, key, parentJSON) {\n\t    if (Array.isArray(json)) {\n\t      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function fromJSDefault(json) {\n\t    if (Array.isArray(json)) {\n\t      return IndexedSeq(json).map(fromJSDefault).toList();\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return KeyedSeq(json).map(fromJSDefault).toMap();\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function isPlainObj(value) {\n\t    return value && (value.constructor === Object || value.constructor === undefined);\n\t  }\n\t\n\t  /**\n\t   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n\t   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n\t   *\n\t   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n\t   * value, which is different from the algorithm described by\n\t   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n\t   *\n\t   * This is extended further to allow Objects to describe the values they\n\t   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n\t   *\n\t   * Note: because of this extension, the key equality of Immutable.Map and the\n\t   * value equality of Immutable.Set will differ from ES6 Map and Set.\n\t   *\n\t   * ### Defining custom values\n\t   *\n\t   * The easiest way to describe the value an object represents is by implementing\n\t   * `valueOf`. For example, `Date` represents a value by returning a unix\n\t   * timestamp for `valueOf`:\n\t   *\n\t   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n\t   *     var date2 = new Date(1234567890000);\n\t   *     date1.valueOf(); // 1234567890000\n\t   *     assert( date1 !== date2 );\n\t   *     assert( Immutable.is( date1, date2 ) );\n\t   *\n\t   * Note: overriding `valueOf` may have other implications if you use this object\n\t   * where JavaScript expects a primitive, such as implicit string coercion.\n\t   *\n\t   * For more complex types, especially collections, implementing `valueOf` may\n\t   * not be performant. An alternative is to implement `equals` and `hashCode`.\n\t   *\n\t   * `equals` takes another object, presumably of similar type, and returns true\n\t   * if the it is equal. Equality is symmetrical, so the same result should be\n\t   * returned if this and the argument are flipped.\n\t   *\n\t   *     assert( a.equals(b) === b.equals(a) );\n\t   *\n\t   * `hashCode` returns a 32bit integer number representing the object which will\n\t   * be used to determine how to store the value object in a Map or Set. You must\n\t   * provide both or neither methods, one must not exist without the other.\n\t   *\n\t   * Also, an important relationship between these methods must be upheld: if two\n\t   * values are equal, they *must* return the same hashCode. If the values are not\n\t   * equal, they might have the same hashCode; this is called a hash collision,\n\t   * and while undesirable for performance reasons, it is acceptable.\n\t   *\n\t   *     if (a.equals(b)) {\n\t   *       assert( a.hashCode() === b.hashCode() );\n\t   *     }\n\t   *\n\t   * All Immutable collections implement `equals` and `hashCode`.\n\t   *\n\t   */\n\t  function is(valueA, valueB) {\n\t    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t      return true;\n\t    }\n\t    if (!valueA || !valueB) {\n\t      return false;\n\t    }\n\t    if (typeof valueA.valueOf === 'function' &&\n\t        typeof valueB.valueOf === 'function') {\n\t      valueA = valueA.valueOf();\n\t      valueB = valueB.valueOf();\n\t      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t        return true;\n\t      }\n\t      if (!valueA || !valueB) {\n\t        return false;\n\t      }\n\t    }\n\t    if (typeof valueA.equals === 'function' &&\n\t        typeof valueB.equals === 'function' &&\n\t        valueA.equals(valueB)) {\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function deepEqual(a, b) {\n\t    if (a === b) {\n\t      return true;\n\t    }\n\t\n\t    if (\n\t      !isIterable(b) ||\n\t      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n\t      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n\t      isKeyed(a) !== isKeyed(b) ||\n\t      isIndexed(a) !== isIndexed(b) ||\n\t      isOrdered(a) !== isOrdered(b)\n\t    ) {\n\t      return false;\n\t    }\n\t\n\t    if (a.size === 0 && b.size === 0) {\n\t      return true;\n\t    }\n\t\n\t    var notAssociative = !isAssociative(a);\n\t\n\t    if (isOrdered(a)) {\n\t      var entries = a.entries();\n\t      return b.every(function(v, k)  {\n\t        var entry = entries.next().value;\n\t        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n\t      }) && entries.next().done;\n\t    }\n\t\n\t    var flipped = false;\n\t\n\t    if (a.size === undefined) {\n\t      if (b.size === undefined) {\n\t        if (typeof a.cacheResult === 'function') {\n\t          a.cacheResult();\n\t        }\n\t      } else {\n\t        flipped = true;\n\t        var _ = a;\n\t        a = b;\n\t        b = _;\n\t      }\n\t    }\n\t\n\t    var allEqual = true;\n\t    var bSize = b.__iterate(function(v, k)  {\n\t      if (notAssociative ? !a.has(v) :\n\t          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n\t        allEqual = false;\n\t        return false;\n\t      }\n\t    });\n\t\n\t    return allEqual && a.size === bSize;\n\t  }\n\t\n\t  createClass(Repeat, IndexedSeq);\n\t\n\t    function Repeat(value, times) {\n\t      if (!(this instanceof Repeat)) {\n\t        return new Repeat(value, times);\n\t      }\n\t      this._value = value;\n\t      this.size = times === undefined ? Infinity : Math.max(0, times);\n\t      if (this.size === 0) {\n\t        if (EMPTY_REPEAT) {\n\t          return EMPTY_REPEAT;\n\t        }\n\t        EMPTY_REPEAT = this;\n\t      }\n\t    }\n\t\n\t    Repeat.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Repeat []';\n\t      }\n\t      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n\t    };\n\t\n\t    Repeat.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._value : notSetValue;\n\t    };\n\t\n\t    Repeat.prototype.includes = function(searchValue) {\n\t      return is(this._value, searchValue);\n\t    };\n\t\n\t    Repeat.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      return wholeSlice(begin, end, size) ? this :\n\t        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n\t    };\n\t\n\t    Repeat.prototype.reverse = function() {\n\t      return this;\n\t    };\n\t\n\t    Repeat.prototype.indexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return 0;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.lastIndexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return this.size;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.__iterate = function(fn, reverse) {\n\t      for (var ii = 0; ii < this.size; ii++) {\n\t        if (fn(this._value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n\t      );\n\t    };\n\t\n\t    Repeat.prototype.equals = function(other) {\n\t      return other instanceof Repeat ?\n\t        is(this._value, other._value) :\n\t        deepEqual(other);\n\t    };\n\t\n\t\n\t  var EMPTY_REPEAT;\n\t\n\t  function invariant(condition, error) {\n\t    if (!condition) throw new Error(error);\n\t  }\n\t\n\t  createClass(Range, IndexedSeq);\n\t\n\t    function Range(start, end, step) {\n\t      if (!(this instanceof Range)) {\n\t        return new Range(start, end, step);\n\t      }\n\t      invariant(step !== 0, 'Cannot step a Range by 0');\n\t      start = start || 0;\n\t      if (end === undefined) {\n\t        end = Infinity;\n\t      }\n\t      step = step === undefined ? 1 : Math.abs(step);\n\t      if (end < start) {\n\t        step = -step;\n\t      }\n\t      this._start = start;\n\t      this._end = end;\n\t      this._step = step;\n\t      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\t      if (this.size === 0) {\n\t        if (EMPTY_RANGE) {\n\t          return EMPTY_RANGE;\n\t        }\n\t        EMPTY_RANGE = this;\n\t      }\n\t    }\n\t\n\t    Range.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Range []';\n\t      }\n\t      return 'Range [ ' +\n\t        this._start + '...' + this._end +\n\t        (this._step !== 1 ? ' by ' + this._step : '') +\n\t      ' ]';\n\t    };\n\t\n\t    Range.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ?\n\t        this._start + wrapIndex(this, index) * this._step :\n\t        notSetValue;\n\t    };\n\t\n\t    Range.prototype.includes = function(searchValue) {\n\t      var possibleIndex = (searchValue - this._start) / this._step;\n\t      return possibleIndex >= 0 &&\n\t        possibleIndex < this.size &&\n\t        possibleIndex === Math.floor(possibleIndex);\n\t    };\n\t\n\t    Range.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      begin = resolveBegin(begin, this.size);\n\t      end = resolveEnd(end, this.size);\n\t      if (end <= begin) {\n\t        return new Range(0, 0);\n\t      }\n\t      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n\t    };\n\t\n\t    Range.prototype.indexOf = function(searchValue) {\n\t      var offsetValue = searchValue - this._start;\n\t      if (offsetValue % this._step === 0) {\n\t        var index = offsetValue / this._step;\n\t        if (index >= 0 && index < this.size) {\n\t          return index\n\t        }\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Range.prototype.lastIndexOf = function(searchValue) {\n\t      return this.indexOf(searchValue);\n\t    };\n\t\n\t    Range.prototype.__iterate = function(fn, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t        value += reverse ? -step : step;\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Range.prototype.__iterator = function(type, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var v = value;\n\t        value += reverse ? -step : step;\n\t        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n\t      });\n\t    };\n\t\n\t    Range.prototype.equals = function(other) {\n\t      return other instanceof Range ?\n\t        this._start === other._start &&\n\t        this._end === other._end &&\n\t        this._step === other._step :\n\t        deepEqual(this, other);\n\t    };\n\t\n\t\n\t  var EMPTY_RANGE;\n\t\n\t  createClass(Collection, Iterable);\n\t    function Collection() {\n\t      throw TypeError('Abstract');\n\t    }\n\t\n\t\n\t  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\t\n\t  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\t\n\t  createClass(SetCollection, Collection);function SetCollection() {}\n\t\n\t\n\t  Collection.Keyed = KeyedCollection;\n\t  Collection.Indexed = IndexedCollection;\n\t  Collection.Set = SetCollection;\n\t\n\t  var imul =\n\t    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n\t    Math.imul :\n\t    function imul(a, b) {\n\t      a = a | 0; // int\n\t      b = b | 0; // int\n\t      var c = a & 0xffff;\n\t      var d = b & 0xffff;\n\t      // Shift by 0 fixes the sign on the high part.\n\t      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n\t    };\n\t\n\t  // v8 has an optimization for storing 31-bit signed numbers.\n\t  // Values which have either 00 or 11 as the high order bits qualify.\n\t  // This function drops the highest order bit in a signed number, maintaining\n\t  // the sign bit.\n\t  function smi(i32) {\n\t    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n\t  }\n\t\n\t  function hash(o) {\n\t    if (o === false || o === null || o === undefined) {\n\t      return 0;\n\t    }\n\t    if (typeof o.valueOf === 'function') {\n\t      o = o.valueOf();\n\t      if (o === false || o === null || o === undefined) {\n\t        return 0;\n\t      }\n\t    }\n\t    if (o === true) {\n\t      return 1;\n\t    }\n\t    var type = typeof o;\n\t    if (type === 'number') {\n\t      if (o !== o || o === Infinity) {\n\t        return 0;\n\t      }\n\t      var h = o | 0;\n\t      if (h !== o) {\n\t        h ^= o * 0xFFFFFFFF;\n\t      }\n\t      while (o > 0xFFFFFFFF) {\n\t        o /= 0xFFFFFFFF;\n\t        h ^= o;\n\t      }\n\t      return smi(h);\n\t    }\n\t    if (type === 'string') {\n\t      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n\t    }\n\t    if (typeof o.hashCode === 'function') {\n\t      return o.hashCode();\n\t    }\n\t    if (type === 'object') {\n\t      return hashJSObj(o);\n\t    }\n\t    if (typeof o.toString === 'function') {\n\t      return hashString(o.toString());\n\t    }\n\t    throw new Error('Value type ' + type + ' cannot be hashed.');\n\t  }\n\t\n\t  function cachedHashString(string) {\n\t    var hash = stringHashCache[string];\n\t    if (hash === undefined) {\n\t      hash = hashString(string);\n\t      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t        STRING_HASH_CACHE_SIZE = 0;\n\t        stringHashCache = {};\n\t      }\n\t      STRING_HASH_CACHE_SIZE++;\n\t      stringHashCache[string] = hash;\n\t    }\n\t    return hash;\n\t  }\n\t\n\t  // http://jsperf.com/hashing-strings\n\t  function hashString(string) {\n\t    // This is the hash from JVM\n\t    // The hash code for a string is computed as\n\t    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n\t    // where s[i] is the ith character of the string and n is the length of\n\t    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n\t    // (exclusive) by dropping high bits.\n\t    var hash = 0;\n\t    for (var ii = 0; ii < string.length; ii++) {\n\t      hash = 31 * hash + string.charCodeAt(ii) | 0;\n\t    }\n\t    return smi(hash);\n\t  }\n\t\n\t  function hashJSObj(obj) {\n\t    var hash;\n\t    if (usingWeakMap) {\n\t      hash = weakMap.get(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = obj[UID_HASH_KEY];\n\t    if (hash !== undefined) {\n\t      return hash;\n\t    }\n\t\n\t    if (!canDefineProperty) {\n\t      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t\n\t      hash = getIENodeHash(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = ++objHashUID;\n\t    if (objHashUID & 0x40000000) {\n\t      objHashUID = 0;\n\t    }\n\t\n\t    if (usingWeakMap) {\n\t      weakMap.set(obj, hash);\n\t    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n\t      throw new Error('Non-extensible objects are not allowed as keys.');\n\t    } else if (canDefineProperty) {\n\t      Object.defineProperty(obj, UID_HASH_KEY, {\n\t        'enumerable': false,\n\t        'configurable': false,\n\t        'writable': false,\n\t        'value': hash\n\t      });\n\t    } else if (obj.propertyIsEnumerable !== undefined &&\n\t               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n\t      // Since we can't define a non-enumerable property on the object\n\t      // we'll hijack one of the less-used non-enumerable properties to\n\t      // save our hash on it. Since this is a function it will not show up in\n\t      // `JSON.stringify` which is what we want.\n\t      obj.propertyIsEnumerable = function() {\n\t        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n\t      };\n\t      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n\t    } else if (obj.nodeType !== undefined) {\n\t      // At this point we couldn't get the IE `uniqueID` to use as a hash\n\t      // and we couldn't use a non-enumerable property to exploit the\n\t      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n\t      // itself.\n\t      obj[UID_HASH_KEY] = hash;\n\t    } else {\n\t      throw new Error('Unable to set a non-enumerable property on object.');\n\t    }\n\t\n\t    return hash;\n\t  }\n\t\n\t  // Get references to ES5 object methods.\n\t  var isExtensible = Object.isExtensible;\n\t\n\t  // True if Object.defineProperty works as expected. IE8 fails this test.\n\t  var canDefineProperty = (function() {\n\t    try {\n\t      Object.defineProperty({}, '@', {});\n\t      return true;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }());\n\t\n\t  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n\t  // and avoid memory leaks from the IE cloneNode bug.\n\t  function getIENodeHash(node) {\n\t    if (node && node.nodeType > 0) {\n\t      switch (node.nodeType) {\n\t        case 1: // Element\n\t          return node.uniqueID;\n\t        case 9: // Document\n\t          return node.documentElement && node.documentElement.uniqueID;\n\t      }\n\t    }\n\t  }\n\t\n\t  // If possible, use a WeakMap.\n\t  var usingWeakMap = typeof WeakMap === 'function';\n\t  var weakMap;\n\t  if (usingWeakMap) {\n\t    weakMap = new WeakMap();\n\t  }\n\t\n\t  var objHashUID = 0;\n\t\n\t  var UID_HASH_KEY = '__immutablehash__';\n\t  if (typeof Symbol === 'function') {\n\t    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n\t  }\n\t\n\t  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n\t  var STRING_HASH_CACHE_MAX_SIZE = 255;\n\t  var STRING_HASH_CACHE_SIZE = 0;\n\t  var stringHashCache = {};\n\t\n\t  function assertNotInfinite(size) {\n\t    invariant(\n\t      size !== Infinity,\n\t      'Cannot perform this action with an infinite size.'\n\t    );\n\t  }\n\t\n\t  createClass(Map, KeyedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Map(value) {\n\t      return value === null || value === undefined ? emptyMap() :\n\t        isMap(value) && !isOrdered(value) ? value :\n\t        emptyMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n\t      return emptyMap().withMutations(function(map ) {\n\t        for (var i = 0; i < keyValues.length; i += 2) {\n\t          if (i + 1 >= keyValues.length) {\n\t            throw new Error('Missing value for key: ' + keyValues[i]);\n\t          }\n\t          map.set(keyValues[i], keyValues[i + 1]);\n\t        }\n\t      });\n\t    };\n\t\n\t    Map.prototype.toString = function() {\n\t      return this.__toString('Map {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Map.prototype.get = function(k, notSetValue) {\n\t      return this._root ?\n\t        this._root.get(0, undefined, k, notSetValue) :\n\t        notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Map.prototype.set = function(k, v) {\n\t      return updateMap(this, k, v);\n\t    };\n\t\n\t    Map.prototype.setIn = function(keyPath, v) {\n\t      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n\t    };\n\t\n\t    Map.prototype.remove = function(k) {\n\t      return updateMap(this, k, NOT_SET);\n\t    };\n\t\n\t    Map.prototype.deleteIn = function(keyPath) {\n\t      return this.updateIn(keyPath, function()  {return NOT_SET});\n\t    };\n\t\n\t    Map.prototype.update = function(k, notSetValue, updater) {\n\t      return arguments.length === 1 ?\n\t        k(this) :\n\t        this.updateIn([k], notSetValue, updater);\n\t    };\n\t\n\t    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n\t      if (!updater) {\n\t        updater = notSetValue;\n\t        notSetValue = undefined;\n\t      }\n\t      var updatedValue = updateInDeepMap(\n\t        this,\n\t        forceIterator(keyPath),\n\t        notSetValue,\n\t        updater\n\t      );\n\t      return updatedValue === NOT_SET ? undefined : updatedValue;\n\t    };\n\t\n\t    Map.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._root = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyMap();\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Map.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, undefined, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, merger, iters);\n\t    };\n\t\n\t    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.merge === 'function' ?\n\t          m.merge.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.mergeDeep === 'function' ?\n\t          m.mergeDeep.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator));\n\t    };\n\t\n\t    Map.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Map.prototype.withMutations = function(fn) {\n\t      var mutable = this.asMutable();\n\t      fn(mutable);\n\t      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n\t    };\n\t\n\t    Map.prototype.asMutable = function() {\n\t      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n\t    };\n\t\n\t    Map.prototype.asImmutable = function() {\n\t      return this.__ensureOwner();\n\t    };\n\t\n\t    Map.prototype.wasAltered = function() {\n\t      return this.__altered;\n\t    };\n\t\n\t    Map.prototype.__iterator = function(type, reverse) {\n\t      return new MapIterator(this, type, reverse);\n\t    };\n\t\n\t    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      this._root && this._root.iterate(function(entry ) {\n\t        iterations++;\n\t        return fn(entry[1], entry[0], this$0);\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t\n\t    Map.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeMap(this.size, this._root, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isMap(maybeMap) {\n\t    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n\t  }\n\t\n\t  Map.isMap = isMap;\n\t\n\t  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\t\n\t  var MapPrototype = Map.prototype;\n\t  MapPrototype[IS_MAP_SENTINEL] = true;\n\t  MapPrototype[DELETE] = MapPrototype.remove;\n\t  MapPrototype.removeIn = MapPrototype.deleteIn;\n\t\n\t\n\t  // #pragma Trie Nodes\n\t\n\t\n\t\n\t    function ArrayMapNode(ownerID, entries) {\n\t      this.ownerID = ownerID;\n\t      this.entries = entries;\n\t    }\n\t\n\t    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && entries.length === 1) {\n\t        return; // undefined\n\t      }\n\t\n\t      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t        return createNodes(ownerID, entries, key, value);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new ArrayMapNode(ownerID, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.bitmap = bitmap;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n\t      var bitmap = this.bitmap;\n\t      return (bitmap & bit) === 0 ? notSetValue :\n\t        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n\t    };\n\t\n\t    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var bit = 1 << keyHashFrag;\n\t      var bitmap = this.bitmap;\n\t      var exists = (bitmap & bit) !== 0;\n\t\n\t      if (!exists && value === NOT_SET) {\n\t        return this;\n\t      }\n\t\n\t      var idx = popCount(bitmap & (bit - 1));\n\t      var nodes = this.nodes;\n\t      var node = exists ? nodes[idx] : undefined;\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n\t      }\n\t\n\t      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t        return nodes[idx ^ 1];\n\t      }\n\t\n\t      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t        return newNode;\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n\t      var newNodes = exists ? newNode ?\n\t        setIn(nodes, idx, newNode, isEditable) :\n\t        spliceOut(nodes, idx, isEditable) :\n\t        spliceIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.bitmap = newBitmap;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashArrayMapNode(ownerID, count, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.count = count;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var node = this.nodes[idx];\n\t      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n\t    };\n\t\n\t    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var removed = value === NOT_SET;\n\t      var nodes = this.nodes;\n\t      var node = nodes[idx];\n\t\n\t      if (removed && !node) {\n\t        return this;\n\t      }\n\t\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      var newCount = this.count;\n\t      if (!node) {\n\t        newCount++;\n\t      } else if (!newNode) {\n\t        newCount--;\n\t        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t          return packNodes(ownerID, nodes, newCount, idx);\n\t        }\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.count = newCount;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new HashArrayMapNode(ownerID, newCount, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashCollisionNode(ownerID, keyHash, entries) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entries = entries;\n\t    }\n\t\n\t    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t\n\t      var removed = value === NOT_SET;\n\t\n\t      if (keyHash !== this.keyHash) {\n\t        if (removed) {\n\t          return this;\n\t        }\n\t        SetRef(didAlter);\n\t        SetRef(didChangeSize);\n\t        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n\t      }\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && len === 2) {\n\t        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function ValueNode(ownerID, keyHash, entry) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entry = entry;\n\t    }\n\t\n\t    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n\t    };\n\t\n\t    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t      var keyMatch = is(key, this.entry[0]);\n\t      if (keyMatch ? value === this.entry[1] : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t\n\t      if (removed) {\n\t        SetRef(didChangeSize);\n\t        return; // undefined\n\t      }\n\t\n\t      if (keyMatch) {\n\t        if (ownerID && ownerID === this.ownerID) {\n\t          this.entry[1] = value;\n\t          return this;\n\t        }\n\t        return new ValueNode(ownerID, this.keyHash, [key, value]);\n\t      }\n\t\n\t      SetRef(didChangeSize);\n\t      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n\t    };\n\t\n\t\n\t\n\t  // #pragma Iterators\n\t\n\t  ArrayMapNode.prototype.iterate =\n\t  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n\t    var entries = this.entries;\n\t    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n\t      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  BitmapIndexedNode.prototype.iterate =\n\t  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n\t    var nodes = this.nodes;\n\t    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n\t      var node = nodes[reverse ? maxIndex - ii : ii];\n\t      if (node && node.iterate(fn, reverse) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  ValueNode.prototype.iterate = function (fn, reverse) {\n\t    return fn(this.entry);\n\t  }\n\t\n\t  createClass(MapIterator, Iterator);\n\t\n\t    function MapIterator(map, type, reverse) {\n\t      this._type = type;\n\t      this._reverse = reverse;\n\t      this._stack = map._root && mapIteratorFrame(map._root);\n\t    }\n\t\n\t    MapIterator.prototype.next = function() {\n\t      var type = this._type;\n\t      var stack = this._stack;\n\t      while (stack) {\n\t        var node = stack.node;\n\t        var index = stack.index++;\n\t        var maxIndex;\n\t        if (node.entry) {\n\t          if (index === 0) {\n\t            return mapIteratorValue(type, node.entry);\n\t          }\n\t        } else if (node.entries) {\n\t          maxIndex = node.entries.length - 1;\n\t          if (index <= maxIndex) {\n\t            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n\t          }\n\t        } else {\n\t          maxIndex = node.nodes.length - 1;\n\t          if (index <= maxIndex) {\n\t            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n\t            if (subNode) {\n\t              if (subNode.entry) {\n\t                return mapIteratorValue(type, subNode.entry);\n\t              }\n\t              stack = this._stack = mapIteratorFrame(subNode, stack);\n\t            }\n\t            continue;\n\t          }\n\t        }\n\t        stack = this._stack = this._stack.__prev;\n\t      }\n\t      return iteratorDone();\n\t    };\n\t\n\t\n\t  function mapIteratorValue(type, entry) {\n\t    return iteratorValue(type, entry[0], entry[1]);\n\t  }\n\t\n\t  function mapIteratorFrame(node, prev) {\n\t    return {\n\t      node: node,\n\t      index: 0,\n\t      __prev: prev\n\t    };\n\t  }\n\t\n\t  function makeMap(size, root, ownerID, hash) {\n\t    var map = Object.create(MapPrototype);\n\t    map.size = size;\n\t    map._root = root;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_MAP;\n\t  function emptyMap() {\n\t    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n\t  }\n\t\n\t  function updateMap(map, k, v) {\n\t    var newRoot;\n\t    var newSize;\n\t    if (!map._root) {\n\t      if (v === NOT_SET) {\n\t        return map;\n\t      }\n\t      newSize = 1;\n\t      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n\t    } else {\n\t      var didChangeSize = MakeRef(CHANGE_LENGTH);\n\t      var didAlter = MakeRef(DID_ALTER);\n\t      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n\t      if (!didAlter.value) {\n\t        return map;\n\t      }\n\t      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n\t    }\n\t    if (map.__ownerID) {\n\t      map.size = newSize;\n\t      map._root = newRoot;\n\t      map.__hash = undefined;\n\t      map.__altered = true;\n\t      return map;\n\t    }\n\t    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n\t  }\n\t\n\t  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t    if (!node) {\n\t      if (value === NOT_SET) {\n\t        return node;\n\t      }\n\t      SetRef(didAlter);\n\t      SetRef(didChangeSize);\n\t      return new ValueNode(ownerID, keyHash, [key, value]);\n\t    }\n\t    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n\t  }\n\t\n\t  function isLeafNode(node) {\n\t    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n\t  }\n\t\n\t  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n\t    if (node.keyHash === keyHash) {\n\t      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n\t    }\n\t\n\t    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n\t    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t\n\t    var newNode;\n\t    var nodes = idx1 === idx2 ?\n\t      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n\t      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\t\n\t    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n\t  }\n\t\n\t  function createNodes(ownerID, entries, key, value) {\n\t    if (!ownerID) {\n\t      ownerID = new OwnerID();\n\t    }\n\t    var node = new ValueNode(ownerID, hash(key), [key, value]);\n\t    for (var ii = 0; ii < entries.length; ii++) {\n\t      var entry = entries[ii];\n\t      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n\t    }\n\t    return node;\n\t  }\n\t\n\t  function packNodes(ownerID, nodes, count, excluding) {\n\t    var bitmap = 0;\n\t    var packedII = 0;\n\t    var packedNodes = new Array(count);\n\t    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t      var node = nodes[ii];\n\t      if (node !== undefined && ii !== excluding) {\n\t        bitmap |= bit;\n\t        packedNodes[packedII++] = node;\n\t      }\n\t    }\n\t    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n\t  }\n\t\n\t  function expandNodes(ownerID, nodes, bitmap, including, node) {\n\t    var count = 0;\n\t    var expandedNodes = new Array(SIZE);\n\t    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n\t    }\n\t    expandedNodes[including] = node;\n\t    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n\t  }\n\t\n\t  function mergeIntoMapWith(map, merger, iterables) {\n\t    var iters = [];\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = KeyedIterable(value);\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    return mergeIntoCollectionWith(map, merger, iters);\n\t  }\n\t\n\t  function deepMerger(existing, value, key) {\n\t    return existing && existing.mergeDeep && isIterable(value) ?\n\t      existing.mergeDeep(value) :\n\t      is(existing, value) ? existing : value;\n\t  }\n\t\n\t  function deepMergerWith(merger) {\n\t    return function(existing, value, key)  {\n\t      if (existing && existing.mergeDeepWith && isIterable(value)) {\n\t        return existing.mergeDeepWith(merger, value);\n\t      }\n\t      var nextValue = merger(existing, value, key);\n\t      return is(existing, nextValue) ? existing : nextValue;\n\t    };\n\t  }\n\t\n\t  function mergeIntoCollectionWith(collection, merger, iters) {\n\t    iters = iters.filter(function(x ) {return x.size !== 0});\n\t    if (iters.length === 0) {\n\t      return collection;\n\t    }\n\t    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n\t      return collection.constructor(iters[0]);\n\t    }\n\t    return collection.withMutations(function(collection ) {\n\t      var mergeIntoMap = merger ?\n\t        function(value, key)  {\n\t          collection.update(key, NOT_SET, function(existing )\n\t            {return existing === NOT_SET ? value : merger(existing, value, key)}\n\t          );\n\t        } :\n\t        function(value, key)  {\n\t          collection.set(key, value);\n\t        }\n\t      for (var ii = 0; ii < iters.length; ii++) {\n\t        iters[ii].forEach(mergeIntoMap);\n\t      }\n\t    });\n\t  }\n\t\n\t  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n\t    var isNotSet = existing === NOT_SET;\n\t    var step = keyPathIter.next();\n\t    if (step.done) {\n\t      var existingValue = isNotSet ? notSetValue : existing;\n\t      var newValue = updater(existingValue);\n\t      return newValue === existingValue ? existing : newValue;\n\t    }\n\t    invariant(\n\t      isNotSet || (existing && existing.set),\n\t      'invalid keyPath'\n\t    );\n\t    var key = step.value;\n\t    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n\t    var nextUpdated = updateInDeepMap(\n\t      nextExisting,\n\t      keyPathIter,\n\t      notSetValue,\n\t      updater\n\t    );\n\t    return nextUpdated === nextExisting ? existing :\n\t      nextUpdated === NOT_SET ? existing.remove(key) :\n\t      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n\t  }\n\t\n\t  function popCount(x) {\n\t    x = x - ((x >> 1) & 0x55555555);\n\t    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\t    x = (x + (x >> 4)) & 0x0f0f0f0f;\n\t    x = x + (x >> 8);\n\t    x = x + (x >> 16);\n\t    return x & 0x7f;\n\t  }\n\t\n\t  function setIn(array, idx, val, canEdit) {\n\t    var newArray = canEdit ? array : arrCopy(array);\n\t    newArray[idx] = val;\n\t    return newArray;\n\t  }\n\t\n\t  function spliceIn(array, idx, val, canEdit) {\n\t    var newLen = array.length + 1;\n\t    if (canEdit && idx + 1 === newLen) {\n\t      array[idx] = val;\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        newArray[ii] = val;\n\t        after = -1;\n\t      } else {\n\t        newArray[ii] = array[ii + after];\n\t      }\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  function spliceOut(array, idx, canEdit) {\n\t    var newLen = array.length - 1;\n\t    if (canEdit && idx === newLen) {\n\t      array.pop();\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        after = 1;\n\t      }\n\t      newArray[ii] = array[ii + after];\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n\t  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n\t  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\t\n\t  createClass(List, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function List(value) {\n\t      var empty = emptyList();\n\t      if (value === null || value === undefined) {\n\t        return empty;\n\t      }\n\t      if (isList(value)) {\n\t        return value;\n\t      }\n\t      var iter = IndexedIterable(value);\n\t      var size = iter.size;\n\t      if (size === 0) {\n\t        return empty;\n\t      }\n\t      assertNotInfinite(size);\n\t      if (size > 0 && size < SIZE) {\n\t        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n\t      }\n\t      return empty.withMutations(function(list ) {\n\t        list.setSize(size);\n\t        iter.forEach(function(v, i)  {return list.set(i, v)});\n\t      });\n\t    }\n\t\n\t    List.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    List.prototype.toString = function() {\n\t      return this.__toString('List [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    List.prototype.get = function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      if (index >= 0 && index < this.size) {\n\t        index += this._origin;\n\t        var node = listNodeFor(this, index);\n\t        return node && node.array[index & MASK];\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    List.prototype.set = function(index, value) {\n\t      return updateList(this, index, value);\n\t    };\n\t\n\t    List.prototype.remove = function(index) {\n\t      return !this.has(index) ? this :\n\t        index === 0 ? this.shift() :\n\t        index === this.size - 1 ? this.pop() :\n\t        this.splice(index, 1);\n\t    };\n\t\n\t    List.prototype.insert = function(index, value) {\n\t      return this.splice(index, 0, value);\n\t    };\n\t\n\t    List.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = this._origin = this._capacity = 0;\n\t        this._level = SHIFT;\n\t        this._root = this._tail = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyList();\n\t    };\n\t\n\t    List.prototype.push = function(/*...values*/) {\n\t      var values = arguments;\n\t      var oldSize = this.size;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, 0, oldSize + values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(oldSize + ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.pop = function() {\n\t      return setListBounds(this, 0, -1);\n\t    };\n\t\n\t    List.prototype.unshift = function(/*...values*/) {\n\t      var values = arguments;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, -values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.shift = function() {\n\t      return setListBounds(this, 1);\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    List.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, undefined, arguments);\n\t    };\n\t\n\t    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, merger, iters);\n\t    };\n\t\n\t    List.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    List.prototype.setSize = function(size) {\n\t      return setListBounds(this, 0, size);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    List.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      if (wholeSlice(begin, end, size)) {\n\t        return this;\n\t      }\n\t      return setListBounds(\n\t        this,\n\t        resolveBegin(begin, size),\n\t        resolveEnd(end, size)\n\t      );\n\t    };\n\t\n\t    List.prototype.__iterator = function(type, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      return new Iterator(function()  {\n\t        var value = values();\n\t        return value === DONE ?\n\t          iteratorDone() :\n\t          iteratorValue(type, index++, value);\n\t      });\n\t    };\n\t\n\t    List.prototype.__iterate = function(fn, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      var value;\n\t      while ((value = values()) !== DONE) {\n\t        if (fn(value, index++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return index;\n\t    };\n\t\n\t    List.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        return this;\n\t      }\n\t      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isList(maybeList) {\n\t    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n\t  }\n\t\n\t  List.isList = isList;\n\t\n\t  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\t\n\t  var ListPrototype = List.prototype;\n\t  ListPrototype[IS_LIST_SENTINEL] = true;\n\t  ListPrototype[DELETE] = ListPrototype.remove;\n\t  ListPrototype.setIn = MapPrototype.setIn;\n\t  ListPrototype.deleteIn =\n\t  ListPrototype.removeIn = MapPrototype.removeIn;\n\t  ListPrototype.update = MapPrototype.update;\n\t  ListPrototype.updateIn = MapPrototype.updateIn;\n\t  ListPrototype.mergeIn = MapPrototype.mergeIn;\n\t  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  ListPrototype.withMutations = MapPrototype.withMutations;\n\t  ListPrototype.asMutable = MapPrototype.asMutable;\n\t  ListPrototype.asImmutable = MapPrototype.asImmutable;\n\t  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t\n\t    function VNode(array, ownerID) {\n\t      this.array = array;\n\t      this.ownerID = ownerID;\n\t    }\n\t\n\t    // TODO: seems like these methods are very similar\n\t\n\t    VNode.prototype.removeBefore = function(ownerID, level, index) {\n\t      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var originIndex = (index >>> level) & MASK;\n\t      if (originIndex >= this.array.length) {\n\t        return new VNode([], ownerID);\n\t      }\n\t      var removingFirst = originIndex === 0;\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[originIndex];\n\t        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && removingFirst) {\n\t          return this;\n\t        }\n\t      }\n\t      if (removingFirst && !newChild) {\n\t        return this;\n\t      }\n\t      var editable = editableVNode(this, ownerID);\n\t      if (!removingFirst) {\n\t        for (var ii = 0; ii < originIndex; ii++) {\n\t          editable.array[ii] = undefined;\n\t        }\n\t      }\n\t      if (newChild) {\n\t        editable.array[originIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t    VNode.prototype.removeAfter = function(ownerID, level, index) {\n\t      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var sizeIndex = ((index - 1) >>> level) & MASK;\n\t      if (sizeIndex >= this.array.length) {\n\t        return this;\n\t      }\n\t\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[sizeIndex];\n\t        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n\t          return this;\n\t        }\n\t      }\n\t\n\t      var editable = editableVNode(this, ownerID);\n\t      editable.array.splice(sizeIndex + 1);\n\t      if (newChild) {\n\t        editable.array[sizeIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t\n\t\n\t  var DONE = {};\n\t\n\t  function iterateList(list, reverse) {\n\t    var left = list._origin;\n\t    var right = list._capacity;\n\t    var tailPos = getTailOffset(right);\n\t    var tail = list._tail;\n\t\n\t    return iterateNodeOrLeaf(list._root, list._level, 0);\n\t\n\t    function iterateNodeOrLeaf(node, level, offset) {\n\t      return level === 0 ?\n\t        iterateLeaf(node, offset) :\n\t        iterateNode(node, level, offset);\n\t    }\n\t\n\t    function iterateLeaf(node, offset) {\n\t      var array = offset === tailPos ? tail && tail.array : node && node.array;\n\t      var from = offset > left ? 0 : left - offset;\n\t      var to = right - offset;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        if (from === to) {\n\t          return DONE;\n\t        }\n\t        var idx = reverse ? --to : from++;\n\t        return array && array[idx];\n\t      };\n\t    }\n\t\n\t    function iterateNode(node, level, offset) {\n\t      var values;\n\t      var array = node && node.array;\n\t      var from = offset > left ? 0 : (left - offset) >> level;\n\t      var to = ((right - offset) >> level) + 1;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        do {\n\t          if (values) {\n\t            var value = values();\n\t            if (value !== DONE) {\n\t              return value;\n\t            }\n\t            values = null;\n\t          }\n\t          if (from === to) {\n\t            return DONE;\n\t          }\n\t          var idx = reverse ? --to : from++;\n\t          values = iterateNodeOrLeaf(\n\t            array && array[idx], level - SHIFT, offset + (idx << level)\n\t          );\n\t        } while (true);\n\t      };\n\t    }\n\t  }\n\t\n\t  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n\t    var list = Object.create(ListPrototype);\n\t    list.size = capacity - origin;\n\t    list._origin = origin;\n\t    list._capacity = capacity;\n\t    list._level = level;\n\t    list._root = root;\n\t    list._tail = tail;\n\t    list.__ownerID = ownerID;\n\t    list.__hash = hash;\n\t    list.__altered = false;\n\t    return list;\n\t  }\n\t\n\t  var EMPTY_LIST;\n\t  function emptyList() {\n\t    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n\t  }\n\t\n\t  function updateList(list, index, value) {\n\t    index = wrapIndex(list, index);\n\t\n\t    if (index !== index) {\n\t      return list;\n\t    }\n\t\n\t    if (index >= list.size || index < 0) {\n\t      return list.withMutations(function(list ) {\n\t        index < 0 ?\n\t          setListBounds(list, index).set(0, value) :\n\t          setListBounds(list, 0, index + 1).set(index, value)\n\t      });\n\t    }\n\t\n\t    index += list._origin;\n\t\n\t    var newTail = list._tail;\n\t    var newRoot = list._root;\n\t    var didAlter = MakeRef(DID_ALTER);\n\t    if (index >= getTailOffset(list._capacity)) {\n\t      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n\t    } else {\n\t      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n\t    }\n\t\n\t    if (!didAlter.value) {\n\t      return list;\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n\t  }\n\t\n\t  function updateVNode(node, ownerID, level, index, value, didAlter) {\n\t    var idx = (index >>> level) & MASK;\n\t    var nodeHas = node && idx < node.array.length;\n\t    if (!nodeHas && value === undefined) {\n\t      return node;\n\t    }\n\t\n\t    var newNode;\n\t\n\t    if (level > 0) {\n\t      var lowerNode = node && node.array[idx];\n\t      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n\t      if (newLowerNode === lowerNode) {\n\t        return node;\n\t      }\n\t      newNode = editableVNode(node, ownerID);\n\t      newNode.array[idx] = newLowerNode;\n\t      return newNode;\n\t    }\n\t\n\t    if (nodeHas && node.array[idx] === value) {\n\t      return node;\n\t    }\n\t\n\t    SetRef(didAlter);\n\t\n\t    newNode = editableVNode(node, ownerID);\n\t    if (value === undefined && idx === newNode.array.length - 1) {\n\t      newNode.array.pop();\n\t    } else {\n\t      newNode.array[idx] = value;\n\t    }\n\t    return newNode;\n\t  }\n\t\n\t  function editableVNode(node, ownerID) {\n\t    if (ownerID && node && ownerID === node.ownerID) {\n\t      return node;\n\t    }\n\t    return new VNode(node ? node.array.slice() : [], ownerID);\n\t  }\n\t\n\t  function listNodeFor(list, rawIndex) {\n\t    if (rawIndex >= getTailOffset(list._capacity)) {\n\t      return list._tail;\n\t    }\n\t    if (rawIndex < 1 << (list._level + SHIFT)) {\n\t      var node = list._root;\n\t      var level = list._level;\n\t      while (node && level > 0) {\n\t        node = node.array[(rawIndex >>> level) & MASK];\n\t        level -= SHIFT;\n\t      }\n\t      return node;\n\t    }\n\t  }\n\t\n\t  function setListBounds(list, begin, end) {\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      end = end | 0;\n\t    }\n\t    var owner = list.__ownerID || new OwnerID();\n\t    var oldOrigin = list._origin;\n\t    var oldCapacity = list._capacity;\n\t    var newOrigin = oldOrigin + begin;\n\t    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n\t    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n\t      return list;\n\t    }\n\t\n\t    // If it's going to end after it starts, it's empty.\n\t    if (newOrigin >= newCapacity) {\n\t      return list.clear();\n\t    }\n\t\n\t    var newLevel = list._level;\n\t    var newRoot = list._root;\n\t\n\t    // New origin might need creating a higher root.\n\t    var offsetShift = 0;\n\t    while (newOrigin + offsetShift < 0) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t      offsetShift += 1 << newLevel;\n\t    }\n\t    if (offsetShift) {\n\t      newOrigin += offsetShift;\n\t      oldOrigin += offsetShift;\n\t      newCapacity += offsetShift;\n\t      oldCapacity += offsetShift;\n\t    }\n\t\n\t    var oldTailOffset = getTailOffset(oldCapacity);\n\t    var newTailOffset = getTailOffset(newCapacity);\n\t\n\t    // New size might need creating a higher root.\n\t    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t    }\n\t\n\t    // Locate or create the new tail.\n\t    var oldTail = list._tail;\n\t    var newTail = newTailOffset < oldTailOffset ?\n\t      listNodeFor(list, newCapacity - 1) :\n\t      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\t\n\t    // Merge Tail into tree.\n\t    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n\t      newRoot = editableVNode(newRoot, owner);\n\t      var node = newRoot;\n\t      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n\t        var idx = (oldTailOffset >>> level) & MASK;\n\t        node = node.array[idx] = editableVNode(node.array[idx], owner);\n\t      }\n\t      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n\t    }\n\t\n\t    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n\t    if (newCapacity < oldCapacity) {\n\t      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n\t    }\n\t\n\t    // If the new origin is within the tail, then we do not need a root.\n\t    if (newOrigin >= newTailOffset) {\n\t      newOrigin -= newTailOffset;\n\t      newCapacity -= newTailOffset;\n\t      newLevel = SHIFT;\n\t      newRoot = null;\n\t      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\t\n\t    // Otherwise, if the root has been trimmed, garbage collect.\n\t    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n\t      offsetShift = 0;\n\t\n\t      // Identify the new top root node of the subtree of the old root.\n\t      while (newRoot) {\n\t        var beginIndex = (newOrigin >>> newLevel) & MASK;\n\t        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n\t          break;\n\t        }\n\t        if (beginIndex) {\n\t          offsetShift += (1 << newLevel) * beginIndex;\n\t        }\n\t        newLevel -= SHIFT;\n\t        newRoot = newRoot.array[beginIndex];\n\t      }\n\t\n\t      // Trim the new sides of the new root.\n\t      if (newRoot && newOrigin > oldOrigin) {\n\t        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n\t      }\n\t      if (newRoot && newTailOffset < oldTailOffset) {\n\t        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n\t      }\n\t      if (offsetShift) {\n\t        newOrigin -= offsetShift;\n\t        newCapacity -= offsetShift;\n\t      }\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list.size = newCapacity - newOrigin;\n\t      list._origin = newOrigin;\n\t      list._capacity = newCapacity;\n\t      list._level = newLevel;\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n\t  }\n\t\n\t  function mergeIntoListWith(list, merger, iterables) {\n\t    var iters = [];\n\t    var maxSize = 0;\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = IndexedIterable(value);\n\t      if (iter.size > maxSize) {\n\t        maxSize = iter.size;\n\t      }\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    if (maxSize > list.size) {\n\t      list = list.setSize(maxSize);\n\t    }\n\t    return mergeIntoCollectionWith(list, merger, iters);\n\t  }\n\t\n\t  function getTailOffset(size) {\n\t    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n\t  }\n\t\n\t  createClass(OrderedMap, Map);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedMap(value) {\n\t      return value === null || value === undefined ? emptyOrderedMap() :\n\t        isOrderedMap(value) ? value :\n\t        emptyOrderedMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    OrderedMap.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedMap.prototype.toString = function() {\n\t      return this.__toString('OrderedMap {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    OrderedMap.prototype.get = function(k, notSetValue) {\n\t      var index = this._map.get(k);\n\t      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    OrderedMap.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._map.clear();\n\t        this._list.clear();\n\t        return this;\n\t      }\n\t      return emptyOrderedMap();\n\t    };\n\t\n\t    OrderedMap.prototype.set = function(k, v) {\n\t      return updateOrderedMap(this, k, v);\n\t    };\n\t\n\t    OrderedMap.prototype.remove = function(k) {\n\t      return updateOrderedMap(this, k, NOT_SET);\n\t    };\n\t\n\t    OrderedMap.prototype.wasAltered = function() {\n\t      return this._map.wasAltered() || this._list.wasAltered();\n\t    };\n\t\n\t    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._list.__iterate(\n\t        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n\t        reverse\n\t      );\n\t    };\n\t\n\t    OrderedMap.prototype.__iterator = function(type, reverse) {\n\t      return this._list.fromEntrySeq().__iterator(type, reverse);\n\t    };\n\t\n\t    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      var newList = this._list.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        this._list = newList;\n\t        return this;\n\t      }\n\t      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isOrderedMap(maybeOrderedMap) {\n\t    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n\t  }\n\t\n\t  OrderedMap.isOrderedMap = isOrderedMap;\n\t\n\t  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n\t  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\t\n\t\n\t\n\t  function makeOrderedMap(map, list, ownerID, hash) {\n\t    var omap = Object.create(OrderedMap.prototype);\n\t    omap.size = map ? map.size : 0;\n\t    omap._map = map;\n\t    omap._list = list;\n\t    omap.__ownerID = ownerID;\n\t    omap.__hash = hash;\n\t    return omap;\n\t  }\n\t\n\t  var EMPTY_ORDERED_MAP;\n\t  function emptyOrderedMap() {\n\t    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n\t  }\n\t\n\t  function updateOrderedMap(omap, k, v) {\n\t    var map = omap._map;\n\t    var list = omap._list;\n\t    var i = map.get(k);\n\t    var has = i !== undefined;\n\t    var newMap;\n\t    var newList;\n\t    if (v === NOT_SET) { // removed\n\t      if (!has) {\n\t        return omap;\n\t      }\n\t      if (list.size >= SIZE && list.size >= map.size * 2) {\n\t        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n\t        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n\t        if (omap.__ownerID) {\n\t          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n\t        }\n\t      } else {\n\t        newMap = map.remove(k);\n\t        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n\t      }\n\t    } else {\n\t      if (has) {\n\t        if (v === list.get(i)[1]) {\n\t          return omap;\n\t        }\n\t        newMap = map;\n\t        newList = list.set(i, [k, v]);\n\t      } else {\n\t        newMap = map.set(k, list.size);\n\t        newList = list.set(list.size, [k, v]);\n\t      }\n\t    }\n\t    if (omap.__ownerID) {\n\t      omap.size = newMap.size;\n\t      omap._map = newMap;\n\t      omap._list = newList;\n\t      omap.__hash = undefined;\n\t      return omap;\n\t    }\n\t    return makeOrderedMap(newMap, newList);\n\t  }\n\t\n\t  createClass(ToKeyedSequence, KeyedSeq);\n\t    function ToKeyedSequence(indexed, useKeys) {\n\t      this._iter = indexed;\n\t      this._useKeys = useKeys;\n\t      this.size = indexed.size;\n\t    }\n\t\n\t    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n\t      return this._iter.get(key, notSetValue);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.has = function(key) {\n\t      return this._iter.has(key);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.valueSeq = function() {\n\t      return this._iter.valueSeq();\n\t    };\n\t\n\t    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n\t      var reversedSequence = reverseFactory(this, true);\n\t      if (!this._useKeys) {\n\t        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n\t      }\n\t      return reversedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n\t      var mappedSequence = mapFactory(this, mapper, context);\n\t      if (!this._useKeys) {\n\t        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n\t      }\n\t      return mappedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var ii;\n\t      return this._iter.__iterate(\n\t        this._useKeys ?\n\t          function(v, k)  {return fn(v, k, this$0)} :\n\t          ((ii = reverse ? resolveSize(this) : 0),\n\t            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n\t        reverse\n\t      );\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n\t      if (this._useKeys) {\n\t        return this._iter.__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var ii = reverse ? resolveSize(this) : 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n\t      });\n\t    };\n\t\n\t  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(ToIndexedSequence, IndexedSeq);\n\t    function ToIndexedSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToIndexedSequence.prototype.includes = function(value) {\n\t      return this._iter.includes(value);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, iterations++, step.value, step)\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(ToSetSequence, SetSeq);\n\t    function ToSetSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToSetSequence.prototype.has = function(key) {\n\t      return this._iter.includes(key);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, step.value, step.value, step);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(FromEntriesSequence, KeyedSeq);\n\t    function FromEntriesSequence(entries) {\n\t      this._iter = entries;\n\t      this.size = entries.size;\n\t    }\n\t\n\t    FromEntriesSequence.prototype.entrySeq = function() {\n\t      return this._iter.toSeq();\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(entry ) {\n\t        // Check if entry exists first so array access doesn't throw for holes\n\t        // in the parent iteration.\n\t        if (entry) {\n\t          validateEntry(entry);\n\t          var indexedIterable = isIterable(entry);\n\t          return fn(\n\t            indexedIterable ? entry.get(1) : entry[1],\n\t            indexedIterable ? entry.get(0) : entry[0],\n\t            this$0\n\t          );\n\t        }\n\t      }, reverse);\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          // Check if entry exists first so array access doesn't throw for holes\n\t          // in the parent iteration.\n\t          if (entry) {\n\t            validateEntry(entry);\n\t            var indexedIterable = isIterable(entry);\n\t            return iteratorValue(\n\t              type,\n\t              indexedIterable ? entry.get(0) : entry[0],\n\t              indexedIterable ? entry.get(1) : entry[1],\n\t              step\n\t            );\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t\n\t  ToIndexedSequence.prototype.cacheResult =\n\t  ToKeyedSequence.prototype.cacheResult =\n\t  ToSetSequence.prototype.cacheResult =\n\t  FromEntriesSequence.prototype.cacheResult =\n\t    cacheResultThrough;\n\t\n\t\n\t  function flipFactory(iterable) {\n\t    var flipSequence = makeSequence(iterable);\n\t    flipSequence._iter = iterable;\n\t    flipSequence.size = iterable.size;\n\t    flipSequence.flip = function()  {return iterable};\n\t    flipSequence.reverse = function () {\n\t      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n\t      reversedSequence.flip = function()  {return iterable.reverse()};\n\t      return reversedSequence;\n\t    };\n\t    flipSequence.has = function(key ) {return iterable.includes(key)};\n\t    flipSequence.includes = function(key ) {return iterable.has(key)};\n\t    flipSequence.cacheResult = cacheResultThrough;\n\t    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n\t    }\n\t    flipSequence.__iteratorUncached = function(type, reverse) {\n\t      if (type === ITERATE_ENTRIES) {\n\t        var iterator = iterable.__iterator(type, reverse);\n\t        return new Iterator(function()  {\n\t          var step = iterator.next();\n\t          if (!step.done) {\n\t            var k = step.value[0];\n\t            step.value[0] = step.value[1];\n\t            step.value[1] = k;\n\t          }\n\t          return step;\n\t        });\n\t      }\n\t      return iterable.__iterator(\n\t        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n\t        reverse\n\t      );\n\t    }\n\t    return flipSequence;\n\t  }\n\t\n\t\n\t  function mapFactory(iterable, mapper, context) {\n\t    var mappedSequence = makeSequence(iterable);\n\t    mappedSequence.size = iterable.size;\n\t    mappedSequence.has = function(key ) {return iterable.has(key)};\n\t    mappedSequence.get = function(key, notSetValue)  {\n\t      var v = iterable.get(key, NOT_SET);\n\t      return v === NOT_SET ?\n\t        notSetValue :\n\t        mapper.call(context, v, key, iterable);\n\t    };\n\t    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(\n\t        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n\t        reverse\n\t      );\n\t    }\n\t    mappedSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var key = entry[0];\n\t        return iteratorValue(\n\t          type,\n\t          key,\n\t          mapper.call(context, entry[1], key, iterable),\n\t          step\n\t        );\n\t      });\n\t    }\n\t    return mappedSequence;\n\t  }\n\t\n\t\n\t  function reverseFactory(iterable, useKeys) {\n\t    var reversedSequence = makeSequence(iterable);\n\t    reversedSequence._iter = iterable;\n\t    reversedSequence.size = iterable.size;\n\t    reversedSequence.reverse = function()  {return iterable};\n\t    if (iterable.flip) {\n\t      reversedSequence.flip = function () {\n\t        var flipSequence = flipFactory(iterable);\n\t        flipSequence.reverse = function()  {return iterable.flip()};\n\t        return flipSequence;\n\t      };\n\t    }\n\t    reversedSequence.get = function(key, notSetValue) \n\t      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n\t    reversedSequence.has = function(key )\n\t      {return iterable.has(useKeys ? key : -1 - key)};\n\t    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n\t    reversedSequence.cacheResult = cacheResultThrough;\n\t    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n\t    };\n\t    reversedSequence.__iterator =\n\t      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n\t    return reversedSequence;\n\t  }\n\t\n\t\n\t  function filterFactory(iterable, predicate, context, useKeys) {\n\t    var filterSequence = makeSequence(iterable);\n\t    if (useKeys) {\n\t      filterSequence.has = function(key ) {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n\t      };\n\t      filterSequence.get = function(key, notSetValue)  {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n\t          v : notSetValue;\n\t      };\n\t    }\n\t    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t    filterSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          var key = entry[0];\n\t          var value = entry[1];\n\t          if (predicate.call(context, value, key, iterable)) {\n\t            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n\t          }\n\t        }\n\t      });\n\t    }\n\t    return filterSequence;\n\t  }\n\t\n\t\n\t  function countByFactory(iterable, grouper, context) {\n\t    var groups = Map().asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        0,\n\t        function(a ) {return a + 1}\n\t      );\n\t    });\n\t    return groups.asImmutable();\n\t  }\n\t\n\t\n\t  function groupByFactory(iterable, grouper, context) {\n\t    var isKeyedIter = isKeyed(iterable);\n\t    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n\t      );\n\t    });\n\t    var coerce = iterableClass(iterable);\n\t    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n\t  }\n\t\n\t\n\t  function sliceFactory(iterable, begin, end, useKeys) {\n\t    var originalSize = iterable.size;\n\t\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      if (end === Infinity) {\n\t        end = originalSize;\n\t      } else {\n\t        end = end | 0;\n\t      }\n\t    }\n\t\n\t    if (wholeSlice(begin, end, originalSize)) {\n\t      return iterable;\n\t    }\n\t\n\t    var resolvedBegin = resolveBegin(begin, originalSize);\n\t    var resolvedEnd = resolveEnd(end, originalSize);\n\t\n\t    // begin or end will be NaN if they were provided as negative numbers and\n\t    // this iterable's size is unknown. In that case, cache first so there is\n\t    // a known size and these do not resolve to NaN.\n\t    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n\t      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n\t    }\n\t\n\t    // Note: resolvedEnd is undefined when the original sequence's length is\n\t    // unknown and this slice did not supply an end and should contain all\n\t    // elements after resolvedBegin.\n\t    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n\t    var resolvedSize = resolvedEnd - resolvedBegin;\n\t    var sliceSize;\n\t    if (resolvedSize === resolvedSize) {\n\t      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n\t    }\n\t\n\t    var sliceSeq = makeSequence(iterable);\n\t\n\t    // If iterable.size is undefined, the size of the realized sliceSeq is\n\t    // unknown at this point unless the number of items to slice is 0\n\t    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\t\n\t    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n\t      sliceSeq.get = function (index, notSetValue) {\n\t        index = wrapIndex(this, index);\n\t        return index >= 0 && index < sliceSize ?\n\t          iterable.get(index + resolvedBegin, notSetValue) :\n\t          notSetValue;\n\t      }\n\t    }\n\t\n\t    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (sliceSize === 0) {\n\t        return 0;\n\t      }\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var skipped = 0;\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k)  {\n\t        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n\t                 iterations !== sliceSize;\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t\n\t    sliceSeq.__iteratorUncached = function(type, reverse) {\n\t      if (sliceSize !== 0 && reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      // Don't bother instantiating parent iterator if taking 0.\n\t      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n\t      var skipped = 0;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (skipped++ < resolvedBegin) {\n\t          iterator.next();\n\t        }\n\t        if (++iterations > sliceSize) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (useKeys || type === ITERATE_VALUES) {\n\t          return step;\n\t        } else if (type === ITERATE_KEYS) {\n\t          return iteratorValue(type, iterations - 1, undefined, step);\n\t        } else {\n\t          return iteratorValue(type, iterations - 1, step.value[1], step);\n\t        }\n\t      });\n\t    }\n\t\n\t    return sliceSeq;\n\t  }\n\t\n\t\n\t  function takeWhileFactory(iterable, predicate, context) {\n\t    var takeSequence = makeSequence(iterable);\n\t    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c) \n\t        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n\t      );\n\t      return iterations;\n\t    };\n\t    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterating = true;\n\t      return new Iterator(function()  {\n\t        if (!iterating) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var k = entry[0];\n\t        var v = entry[1];\n\t        if (!predicate.call(context, v, k, this$0)) {\n\t          iterating = false;\n\t          return iteratorDone();\n\t        }\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return takeSequence;\n\t  }\n\t\n\t\n\t  function skipWhileFactory(iterable, predicate, context, useKeys) {\n\t    var skipSequence = makeSequence(iterable);\n\t    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var skipping = true;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step, k, v;\n\t        do {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            if (useKeys || type === ITERATE_VALUES) {\n\t              return step;\n\t            } else if (type === ITERATE_KEYS) {\n\t              return iteratorValue(type, iterations++, undefined, step);\n\t            } else {\n\t              return iteratorValue(type, iterations++, step.value[1], step);\n\t            }\n\t          }\n\t          var entry = step.value;\n\t          k = entry[0];\n\t          v = entry[1];\n\t          skipping && (skipping = predicate.call(context, v, k, this$0));\n\t        } while (skipping);\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return skipSequence;\n\t  }\n\t\n\t\n\t  function concatFactory(iterable, values) {\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var iters = [iterable].concat(values).map(function(v ) {\n\t      if (!isIterable(v)) {\n\t        v = isKeyedIterable ?\n\t          keyedSeqFromValue(v) :\n\t          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n\t      } else if (isKeyedIterable) {\n\t        v = KeyedIterable(v);\n\t      }\n\t      return v;\n\t    }).filter(function(v ) {return v.size !== 0});\n\t\n\t    if (iters.length === 0) {\n\t      return iterable;\n\t    }\n\t\n\t    if (iters.length === 1) {\n\t      var singleton = iters[0];\n\t      if (singleton === iterable ||\n\t          isKeyedIterable && isKeyed(singleton) ||\n\t          isIndexed(iterable) && isIndexed(singleton)) {\n\t        return singleton;\n\t      }\n\t    }\n\t\n\t    var concatSeq = new ArraySeq(iters);\n\t    if (isKeyedIterable) {\n\t      concatSeq = concatSeq.toKeyedSeq();\n\t    } else if (!isIndexed(iterable)) {\n\t      concatSeq = concatSeq.toSetSeq();\n\t    }\n\t    concatSeq = concatSeq.flatten(true);\n\t    concatSeq.size = iters.reduce(\n\t      function(sum, seq)  {\n\t        if (sum !== undefined) {\n\t          var size = seq.size;\n\t          if (size !== undefined) {\n\t            return sum + size;\n\t          }\n\t        }\n\t      },\n\t      0\n\t    );\n\t    return concatSeq;\n\t  }\n\t\n\t\n\t  function flattenFactory(iterable, depth, useKeys) {\n\t    var flatSequence = makeSequence(iterable);\n\t    flatSequence.__iterateUncached = function(fn, reverse) {\n\t      var iterations = 0;\n\t      var stopped = false;\n\t      function flatDeep(iter, currentDepth) {var this$0 = this;\n\t        iter.__iterate(function(v, k)  {\n\t          if ((!depth || currentDepth < depth) && isIterable(v)) {\n\t            flatDeep(v, currentDepth + 1);\n\t          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n\t            stopped = true;\n\t          }\n\t          return !stopped;\n\t        }, reverse);\n\t      }\n\t      flatDeep(iterable, 0);\n\t      return iterations;\n\t    }\n\t    flatSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(type, reverse);\n\t      var stack = [];\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (iterator) {\n\t          var step = iterator.next();\n\t          if (step.done !== false) {\n\t            iterator = stack.pop();\n\t            continue;\n\t          }\n\t          var v = step.value;\n\t          if (type === ITERATE_ENTRIES) {\n\t            v = v[1];\n\t          }\n\t          if ((!depth || stack.length < depth) && isIterable(v)) {\n\t            stack.push(iterator);\n\t            iterator = v.__iterator(type, reverse);\n\t          } else {\n\t            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n\t          }\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    }\n\t    return flatSequence;\n\t  }\n\t\n\t\n\t  function flatMapFactory(iterable, mapper, context) {\n\t    var coerce = iterableClass(iterable);\n\t    return iterable.toSeq().map(\n\t      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n\t    ).flatten(true);\n\t  }\n\t\n\t\n\t  function interposeFactory(iterable, separator) {\n\t    var interposedSequence = makeSequence(iterable);\n\t    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n\t    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k) \n\t        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n\t        fn(v, iterations++, this$0) !== false},\n\t        reverse\n\t      );\n\t      return iterations;\n\t    };\n\t    interposedSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      var step;\n\t      return new Iterator(function()  {\n\t        if (!step || iterations % 2) {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t        }\n\t        return iterations % 2 ?\n\t          iteratorValue(type, iterations++, separator) :\n\t          iteratorValue(type, iterations++, step.value, step);\n\t      });\n\t    };\n\t    return interposedSequence;\n\t  }\n\t\n\t\n\t  function sortFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var index = 0;\n\t    var entries = iterable.toSeq().map(\n\t      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n\t    ).toArray();\n\t    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n\t      isKeyedIterable ?\n\t      function(v, i)  { entries[i].length = 2; } :\n\t      function(v, i)  { entries[i] = v[1]; }\n\t    );\n\t    return isKeyedIterable ? KeyedSeq(entries) :\n\t      isIndexed(iterable) ? IndexedSeq(entries) :\n\t      SetSeq(entries);\n\t  }\n\t\n\t\n\t  function maxFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    if (mapper) {\n\t      var entry = iterable.toSeq()\n\t        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n\t        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n\t      return entry && entry[0];\n\t    } else {\n\t      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n\t    }\n\t  }\n\t\n\t  function maxCompare(comparator, a, b) {\n\t    var comp = comparator(b, a);\n\t    // b is considered the new max if the comparator declares them equal, but\n\t    // they are not equal and b is in fact a nullish value.\n\t    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n\t  }\n\t\n\t\n\t  function zipWithFactory(keyIter, zipper, iters) {\n\t    var zipSequence = makeSequence(keyIter);\n\t    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n\t    // Note: this a generic base implementation of __iterate in terms of\n\t    // __iterator which may be more generically useful in the future.\n\t    zipSequence.__iterate = function(fn, reverse) {\n\t      /* generic:\n\t      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        iterations++;\n\t        if (fn(step.value[1], step.value[0], this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t      */\n\t      // indexed:\n\t      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        if (fn(step.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t    zipSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterators = iters.map(function(i )\n\t        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n\t      );\n\t      var iterations = 0;\n\t      var isDone = false;\n\t      return new Iterator(function()  {\n\t        var steps;\n\t        if (!isDone) {\n\t          steps = iterators.map(function(i ) {return i.next()});\n\t          isDone = steps.some(function(s ) {return s.done});\n\t        }\n\t        if (isDone) {\n\t          return iteratorDone();\n\t        }\n\t        return iteratorValue(\n\t          type,\n\t          iterations++,\n\t          zipper.apply(null, steps.map(function(s ) {return s.value}))\n\t        );\n\t      });\n\t    };\n\t    return zipSequence\n\t  }\n\t\n\t\n\t  // #pragma Helper Functions\n\t\n\t  function reify(iter, seq) {\n\t    return isSeq(iter) ? seq : iter.constructor(seq);\n\t  }\n\t\n\t  function validateEntry(entry) {\n\t    if (entry !== Object(entry)) {\n\t      throw new TypeError('Expected [K, V] tuple: ' + entry);\n\t    }\n\t  }\n\t\n\t  function resolveSize(iter) {\n\t    assertNotInfinite(iter.size);\n\t    return ensureSize(iter);\n\t  }\n\t\n\t  function iterableClass(iterable) {\n\t    return isKeyed(iterable) ? KeyedIterable :\n\t      isIndexed(iterable) ? IndexedIterable :\n\t      SetIterable;\n\t  }\n\t\n\t  function makeSequence(iterable) {\n\t    return Object.create(\n\t      (\n\t        isKeyed(iterable) ? KeyedSeq :\n\t        isIndexed(iterable) ? IndexedSeq :\n\t        SetSeq\n\t      ).prototype\n\t    );\n\t  }\n\t\n\t  function cacheResultThrough() {\n\t    if (this._iter.cacheResult) {\n\t      this._iter.cacheResult();\n\t      this.size = this._iter.size;\n\t      return this;\n\t    } else {\n\t      return Seq.prototype.cacheResult.call(this);\n\t    }\n\t  }\n\t\n\t  function defaultComparator(a, b) {\n\t    return a > b ? 1 : a < b ? -1 : 0;\n\t  }\n\t\n\t  function forceIterator(keyPath) {\n\t    var iter = getIterator(keyPath);\n\t    if (!iter) {\n\t      // Array might not be iterable in this environment, so we need a fallback\n\t      // to our wrapped type.\n\t      if (!isArrayLike(keyPath)) {\n\t        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n\t      }\n\t      iter = getIterator(Iterable(keyPath));\n\t    }\n\t    return iter;\n\t  }\n\t\n\t  createClass(Record, KeyedCollection);\n\t\n\t    function Record(defaultValues, name) {\n\t      var hasInitialized;\n\t\n\t      var RecordType = function Record(values) {\n\t        if (values instanceof RecordType) {\n\t          return values;\n\t        }\n\t        if (!(this instanceof RecordType)) {\n\t          return new RecordType(values);\n\t        }\n\t        if (!hasInitialized) {\n\t          hasInitialized = true;\n\t          var keys = Object.keys(defaultValues);\n\t          setProps(RecordTypePrototype, keys);\n\t          RecordTypePrototype.size = keys.length;\n\t          RecordTypePrototype._name = name;\n\t          RecordTypePrototype._keys = keys;\n\t          RecordTypePrototype._defaultValues = defaultValues;\n\t        }\n\t        this._map = Map(values);\n\t      };\n\t\n\t      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n\t      RecordTypePrototype.constructor = RecordType;\n\t\n\t      return RecordType;\n\t    }\n\t\n\t    Record.prototype.toString = function() {\n\t      return this.__toString(recordName(this) + ' {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Record.prototype.has = function(k) {\n\t      return this._defaultValues.hasOwnProperty(k);\n\t    };\n\t\n\t    Record.prototype.get = function(k, notSetValue) {\n\t      if (!this.has(k)) {\n\t        return notSetValue;\n\t      }\n\t      var defaultVal = this._defaultValues[k];\n\t      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Record.prototype.clear = function() {\n\t      if (this.__ownerID) {\n\t        this._map && this._map.clear();\n\t        return this;\n\t      }\n\t      var RecordType = this.constructor;\n\t      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n\t    };\n\t\n\t    Record.prototype.set = function(k, v) {\n\t      if (!this.has(k)) {\n\t        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n\t      }\n\t      if (this._map && !this._map.has(k)) {\n\t        var defaultVal = this._defaultValues[k];\n\t        if (v === defaultVal) {\n\t          return this;\n\t        }\n\t      }\n\t      var newMap = this._map && this._map.set(k, v);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.remove = function(k) {\n\t      if (!this.has(k)) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.remove(k);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n\t    };\n\t\n\t    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n\t    };\n\t\n\t    Record.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap, ownerID);\n\t    };\n\t\n\t\n\t  var RecordPrototype = Record.prototype;\n\t  RecordPrototype[DELETE] = RecordPrototype.remove;\n\t  RecordPrototype.deleteIn =\n\t  RecordPrototype.removeIn = MapPrototype.removeIn;\n\t  RecordPrototype.merge = MapPrototype.merge;\n\t  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n\t  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n\t  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n\t  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n\t  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  RecordPrototype.setIn = MapPrototype.setIn;\n\t  RecordPrototype.update = MapPrototype.update;\n\t  RecordPrototype.updateIn = MapPrototype.updateIn;\n\t  RecordPrototype.withMutations = MapPrototype.withMutations;\n\t  RecordPrototype.asMutable = MapPrototype.asMutable;\n\t  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t\n\t  function makeRecord(likeRecord, map, ownerID) {\n\t    var record = Object.create(Object.getPrototypeOf(likeRecord));\n\t    record._map = map;\n\t    record.__ownerID = ownerID;\n\t    return record;\n\t  }\n\t\n\t  function recordName(record) {\n\t    return record._name || record.constructor.name || 'Record';\n\t  }\n\t\n\t  function setProps(prototype, names) {\n\t    try {\n\t      names.forEach(setProp.bind(undefined, prototype));\n\t    } catch (error) {\n\t      // Object.defineProperty failed. Probably IE8.\n\t    }\n\t  }\n\t\n\t  function setProp(prototype, name) {\n\t    Object.defineProperty(prototype, name, {\n\t      get: function() {\n\t        return this.get(name);\n\t      },\n\t      set: function(value) {\n\t        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n\t        this.set(name, value);\n\t      }\n\t    });\n\t  }\n\t\n\t  createClass(Set, SetCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Set(value) {\n\t      return value === null || value === undefined ? emptySet() :\n\t        isSet(value) && !isOrdered(value) ? value :\n\t        emptySet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    Set.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Set.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    Set.prototype.toString = function() {\n\t      return this.__toString('Set {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Set.prototype.has = function(value) {\n\t      return this._map.has(value);\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Set.prototype.add = function(value) {\n\t      return updateSet(this, this._map.set(value, true));\n\t    };\n\t\n\t    Set.prototype.remove = function(value) {\n\t      return updateSet(this, this._map.remove(value));\n\t    };\n\t\n\t    Set.prototype.clear = function() {\n\t      return updateSet(this, this._map.clear());\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n\t      iters = iters.filter(function(x ) {return x.size !== 0});\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n\t        return this.constructor(iters[0]);\n\t      }\n\t      return this.withMutations(function(set ) {\n\t        for (var ii = 0; ii < iters.length; ii++) {\n\t          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n\t        }\n\t      });\n\t    };\n\t\n\t    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (iters.some(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.merge = function() {\n\t      return this.union.apply(this, arguments);\n\t    };\n\t\n\t    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.union.apply(this, iters);\n\t    };\n\t\n\t    Set.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator));\n\t    };\n\t\n\t    Set.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    Set.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n\t    };\n\t\n\t    Set.prototype.__iterator = function(type, reverse) {\n\t      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n\t    };\n\t\n\t    Set.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return this.__make(newMap, ownerID);\n\t    };\n\t\n\t\n\t  function isSet(maybeSet) {\n\t    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n\t  }\n\t\n\t  Set.isSet = isSet;\n\t\n\t  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\t\n\t  var SetPrototype = Set.prototype;\n\t  SetPrototype[IS_SET_SENTINEL] = true;\n\t  SetPrototype[DELETE] = SetPrototype.remove;\n\t  SetPrototype.mergeDeep = SetPrototype.merge;\n\t  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n\t  SetPrototype.withMutations = MapPrototype.withMutations;\n\t  SetPrototype.asMutable = MapPrototype.asMutable;\n\t  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t  SetPrototype.__empty = emptySet;\n\t  SetPrototype.__make = makeSet;\n\t\n\t  function updateSet(set, newMap) {\n\t    if (set.__ownerID) {\n\t      set.size = newMap.size;\n\t      set._map = newMap;\n\t      return set;\n\t    }\n\t    return newMap === set._map ? set :\n\t      newMap.size === 0 ? set.__empty() :\n\t      set.__make(newMap);\n\t  }\n\t\n\t  function makeSet(map, ownerID) {\n\t    var set = Object.create(SetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_SET;\n\t  function emptySet() {\n\t    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n\t  }\n\t\n\t  createClass(OrderedSet, Set);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedSet(value) {\n\t      return value === null || value === undefined ? emptyOrderedSet() :\n\t        isOrderedSet(value) ? value :\n\t        emptyOrderedSet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    OrderedSet.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedSet.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    OrderedSet.prototype.toString = function() {\n\t      return this.__toString('OrderedSet {', '}');\n\t    };\n\t\n\t\n\t  function isOrderedSet(maybeOrderedSet) {\n\t    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n\t  }\n\t\n\t  OrderedSet.isOrderedSet = isOrderedSet;\n\t\n\t  var OrderedSetPrototype = OrderedSet.prototype;\n\t  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t  OrderedSetPrototype.__empty = emptyOrderedSet;\n\t  OrderedSetPrototype.__make = makeOrderedSet;\n\t\n\t  function makeOrderedSet(map, ownerID) {\n\t    var set = Object.create(OrderedSetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_ORDERED_SET;\n\t  function emptyOrderedSet() {\n\t    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n\t  }\n\t\n\t  createClass(Stack, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Stack(value) {\n\t      return value === null || value === undefined ? emptyStack() :\n\t        isStack(value) ? value :\n\t        emptyStack().unshiftAll(value);\n\t    }\n\t\n\t    Stack.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Stack.prototype.toString = function() {\n\t      return this.__toString('Stack [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Stack.prototype.get = function(index, notSetValue) {\n\t      var head = this._head;\n\t      index = wrapIndex(this, index);\n\t      while (head && index--) {\n\t        head = head.next;\n\t      }\n\t      return head ? head.value : notSetValue;\n\t    };\n\t\n\t    Stack.prototype.peek = function() {\n\t      return this._head && this._head.value;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Stack.prototype.push = function(/*...values*/) {\n\t      if (arguments.length === 0) {\n\t        return this;\n\t      }\n\t      var newSize = this.size + arguments.length;\n\t      var head = this._head;\n\t      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n\t        head = {\n\t          value: arguments[ii],\n\t          next: head\n\t        };\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pushAll = function(iter) {\n\t      iter = IndexedIterable(iter);\n\t      if (iter.size === 0) {\n\t        return this;\n\t      }\n\t      assertNotInfinite(iter.size);\n\t      var newSize = this.size;\n\t      var head = this._head;\n\t      iter.reverse().forEach(function(value ) {\n\t        newSize++;\n\t        head = {\n\t          value: value,\n\t          next: head\n\t        };\n\t      });\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pop = function() {\n\t      return this.slice(1);\n\t    };\n\t\n\t    Stack.prototype.unshift = function(/*...values*/) {\n\t      return this.push.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.unshiftAll = function(iter) {\n\t      return this.pushAll(iter);\n\t    };\n\t\n\t    Stack.prototype.shift = function() {\n\t      return this.pop.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._head = undefined;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyStack();\n\t    };\n\t\n\t    Stack.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      var resolvedBegin = resolveBegin(begin, this.size);\n\t      var resolvedEnd = resolveEnd(end, this.size);\n\t      if (resolvedEnd !== this.size) {\n\t        // super.slice(begin, end);\n\t        return IndexedCollection.prototype.slice.call(this, begin, end);\n\t      }\n\t      var newSize = this.size - resolvedBegin;\n\t      var head = this._head;\n\t      while (resolvedBegin--) {\n\t        head = head.next;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Stack.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeStack(this.size, this._head, ownerID, this.__hash);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    Stack.prototype.__iterate = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterate(fn);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      while (node) {\n\t        if (fn(node.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t        node = node.next;\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    Stack.prototype.__iterator = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterator(type);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      return new Iterator(function()  {\n\t        if (node) {\n\t          var value = node.value;\n\t          node = node.next;\n\t          return iteratorValue(type, iterations++, value);\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    };\n\t\n\t\n\t  function isStack(maybeStack) {\n\t    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n\t  }\n\t\n\t  Stack.isStack = isStack;\n\t\n\t  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\t\n\t  var StackPrototype = Stack.prototype;\n\t  StackPrototype[IS_STACK_SENTINEL] = true;\n\t  StackPrototype.withMutations = MapPrototype.withMutations;\n\t  StackPrototype.asMutable = MapPrototype.asMutable;\n\t  StackPrototype.asImmutable = MapPrototype.asImmutable;\n\t  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t  function makeStack(size, head, ownerID, hash) {\n\t    var map = Object.create(StackPrototype);\n\t    map.size = size;\n\t    map._head = head;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_STACK;\n\t  function emptyStack() {\n\t    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n\t  }\n\t\n\t  /**\n\t   * Contributes additional methods to a constructor\n\t   */\n\t  function mixin(ctor, methods) {\n\t    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n\t    Object.keys(methods).forEach(keyCopier);\n\t    Object.getOwnPropertySymbols &&\n\t      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n\t    return ctor;\n\t  }\n\t\n\t  Iterable.Iterator = Iterator;\n\t\n\t  mixin(Iterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toArray: function() {\n\t      assertNotInfinite(this.size);\n\t      var array = new Array(this.size || 0);\n\t      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n\t      return array;\n\t    },\n\t\n\t    toIndexedSeq: function() {\n\t      return new ToIndexedSequence(this);\n\t    },\n\t\n\t    toJS: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toJSON: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, true);\n\t    },\n\t\n\t    toMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Map(this.toKeyedSeq());\n\t    },\n\t\n\t    toObject: function() {\n\t      assertNotInfinite(this.size);\n\t      var object = {};\n\t      this.__iterate(function(v, k)  { object[k] = v; });\n\t      return object;\n\t    },\n\t\n\t    toOrderedMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedMap(this.toKeyedSeq());\n\t    },\n\t\n\t    toOrderedSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Set(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSetSeq: function() {\n\t      return new ToSetSequence(this);\n\t    },\n\t\n\t    toSeq: function() {\n\t      return isIndexed(this) ? this.toIndexedSeq() :\n\t        isKeyed(this) ? this.toKeyedSeq() :\n\t        this.toSetSeq();\n\t    },\n\t\n\t    toStack: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Stack(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toList: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return List(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t\n\t    // ### Common JavaScript methods and properties\n\t\n\t    toString: function() {\n\t      return '[Iterable]';\n\t    },\n\t\n\t    __toString: function(head, tail) {\n\t      if (this.size === 0) {\n\t        return head + tail;\n\t      }\n\t      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    concat: function() {var values = SLICE$0.call(arguments, 0);\n\t      return reify(this, concatFactory(this, values));\n\t    },\n\t\n\t    includes: function(searchValue) {\n\t      return this.some(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    entries: function() {\n\t      return this.__iterator(ITERATE_ENTRIES);\n\t    },\n\t\n\t    every: function(predicate, context) {\n\t      assertNotInfinite(this.size);\n\t      var returnValue = true;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (!predicate.call(context, v, k, c)) {\n\t          returnValue = false;\n\t          return false;\n\t        }\n\t      });\n\t      return returnValue;\n\t    },\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, true));\n\t    },\n\t\n\t    find: function(predicate, context, notSetValue) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[1] : notSetValue;\n\t    },\n\t\n\t    forEach: function(sideEffect, context) {\n\t      assertNotInfinite(this.size);\n\t      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n\t    },\n\t\n\t    join: function(separator) {\n\t      assertNotInfinite(this.size);\n\t      separator = separator !== undefined ? '' + separator : ',';\n\t      var joined = '';\n\t      var isFirst = true;\n\t      this.__iterate(function(v ) {\n\t        isFirst ? (isFirst = false) : (joined += separator);\n\t        joined += v !== null && v !== undefined ? v.toString() : '';\n\t      });\n\t      return joined;\n\t    },\n\t\n\t    keys: function() {\n\t      return this.__iterator(ITERATE_KEYS);\n\t    },\n\t\n\t    map: function(mapper, context) {\n\t      return reify(this, mapFactory(this, mapper, context));\n\t    },\n\t\n\t    reduce: function(reducer, initialReduction, context) {\n\t      assertNotInfinite(this.size);\n\t      var reduction;\n\t      var useFirst;\n\t      if (arguments.length < 2) {\n\t        useFirst = true;\n\t      } else {\n\t        reduction = initialReduction;\n\t      }\n\t      this.__iterate(function(v, k, c)  {\n\t        if (useFirst) {\n\t          useFirst = false;\n\t          reduction = v;\n\t        } else {\n\t          reduction = reducer.call(context, reduction, v, k, c);\n\t        }\n\t      });\n\t      return reduction;\n\t    },\n\t\n\t    reduceRight: function(reducer, initialReduction, context) {\n\t      var reversed = this.toKeyedSeq().reverse();\n\t      return reversed.reduce.apply(reversed, arguments);\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, true));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, true));\n\t    },\n\t\n\t    some: function(predicate, context) {\n\t      return !this.every(not(predicate), context);\n\t    },\n\t\n\t    sort: function(comparator) {\n\t      return reify(this, sortFactory(this, comparator));\n\t    },\n\t\n\t    values: function() {\n\t      return this.__iterator(ITERATE_VALUES);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    butLast: function() {\n\t      return this.slice(0, -1);\n\t    },\n\t\n\t    isEmpty: function() {\n\t      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n\t    },\n\t\n\t    count: function(predicate, context) {\n\t      return ensureSize(\n\t        predicate ? this.toSeq().filter(predicate, context) : this\n\t      );\n\t    },\n\t\n\t    countBy: function(grouper, context) {\n\t      return countByFactory(this, grouper, context);\n\t    },\n\t\n\t    equals: function(other) {\n\t      return deepEqual(this, other);\n\t    },\n\t\n\t    entrySeq: function() {\n\t      var iterable = this;\n\t      if (iterable._cache) {\n\t        // We cache as an entries array, so we can just return the cache!\n\t        return new ArraySeq(iterable._cache);\n\t      }\n\t      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n\t      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n\t      return entriesSequence;\n\t    },\n\t\n\t    filterNot: function(predicate, context) {\n\t      return this.filter(not(predicate), context);\n\t    },\n\t\n\t    findEntry: function(predicate, context, notSetValue) {\n\t      var found = notSetValue;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          found = [k, v];\n\t          return false;\n\t        }\n\t      });\n\t      return found;\n\t    },\n\t\n\t    findKey: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry && entry[0];\n\t    },\n\t\n\t    findLast: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastEntry: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastKey: function(predicate, context) {\n\t      return this.toKeyedSeq().reverse().findKey(predicate, context);\n\t    },\n\t\n\t    first: function() {\n\t      return this.find(returnTrue);\n\t    },\n\t\n\t    flatMap: function(mapper, context) {\n\t      return reify(this, flatMapFactory(this, mapper, context));\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, true));\n\t    },\n\t\n\t    fromEntrySeq: function() {\n\t      return new FromEntriesSequence(this);\n\t    },\n\t\n\t    get: function(searchKey, notSetValue) {\n\t      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n\t    },\n\t\n\t    getIn: function(searchKeyPath, notSetValue) {\n\t      var nested = this;\n\t      // Note: in an ES6 environment, we would prefer:\n\t      // for (var key of searchKeyPath) {\n\t      var iter = forceIterator(searchKeyPath);\n\t      var step;\n\t      while (!(step = iter.next()).done) {\n\t        var key = step.value;\n\t        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n\t        if (nested === NOT_SET) {\n\t          return notSetValue;\n\t        }\n\t      }\n\t      return nested;\n\t    },\n\t\n\t    groupBy: function(grouper, context) {\n\t      return groupByFactory(this, grouper, context);\n\t    },\n\t\n\t    has: function(searchKey) {\n\t      return this.get(searchKey, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    hasIn: function(searchKeyPath) {\n\t      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    isSubset: function(iter) {\n\t      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n\t      return this.every(function(value ) {return iter.includes(value)});\n\t    },\n\t\n\t    isSuperset: function(iter) {\n\t      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n\t      return iter.isSubset(this);\n\t    },\n\t\n\t    keyOf: function(searchValue) {\n\t      return this.findKey(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    keySeq: function() {\n\t      return this.toSeq().map(keyMapper).toIndexedSeq();\n\t    },\n\t\n\t    last: function() {\n\t      return this.toSeq().reverse().first();\n\t    },\n\t\n\t    lastKeyOf: function(searchValue) {\n\t      return this.toKeyedSeq().reverse().keyOf(searchValue);\n\t    },\n\t\n\t    max: function(comparator) {\n\t      return maxFactory(this, comparator);\n\t    },\n\t\n\t    maxBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator, mapper);\n\t    },\n\t\n\t    min: function(comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n\t    },\n\t\n\t    minBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n\t    },\n\t\n\t    rest: function() {\n\t      return this.slice(1);\n\t    },\n\t\n\t    skip: function(amount) {\n\t      return this.slice(Math.max(0, amount));\n\t    },\n\t\n\t    skipLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, true));\n\t    },\n\t\n\t    skipUntil: function(predicate, context) {\n\t      return this.skipWhile(not(predicate), context);\n\t    },\n\t\n\t    sortBy: function(mapper, comparator) {\n\t      return reify(this, sortFactory(this, comparator, mapper));\n\t    },\n\t\n\t    take: function(amount) {\n\t      return this.slice(0, Math.max(0, amount));\n\t    },\n\t\n\t    takeLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().take(amount).reverse());\n\t    },\n\t\n\t    takeWhile: function(predicate, context) {\n\t      return reify(this, takeWhileFactory(this, predicate, context));\n\t    },\n\t\n\t    takeUntil: function(predicate, context) {\n\t      return this.takeWhile(not(predicate), context);\n\t    },\n\t\n\t    valueSeq: function() {\n\t      return this.toIndexedSeq();\n\t    },\n\t\n\t\n\t    // ### Hashable Object\n\t\n\t    hashCode: function() {\n\t      return this.__hash || (this.__hash = hashIterable(this));\n\t    }\n\t\n\t\n\t    // ### Internal\n\t\n\t    // abstract __iterate(fn, reverse)\n\t\n\t    // abstract __iterator(type, reverse)\n\t  });\n\t\n\t  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  var IterablePrototype = Iterable.prototype;\n\t  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n\t  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n\t  IterablePrototype.__toJS = IterablePrototype.toArray;\n\t  IterablePrototype.__toStringMapper = quoteString;\n\t  IterablePrototype.inspect =\n\t  IterablePrototype.toSource = function() { return this.toString(); };\n\t  IterablePrototype.chain = IterablePrototype.flatMap;\n\t  IterablePrototype.contains = IterablePrototype.includes;\n\t\n\t  mixin(KeyedIterable, {\n\t\n\t    // ### More sequential methods\n\t\n\t    flip: function() {\n\t      return reify(this, flipFactory(this));\n\t    },\n\t\n\t    mapEntries: function(mapper, context) {var this$0 = this;\n\t      var iterations = 0;\n\t      return reify(this,\n\t        this.toSeq().map(\n\t          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n\t        ).fromEntrySeq()\n\t      );\n\t    },\n\t\n\t    mapKeys: function(mapper, context) {var this$0 = this;\n\t      return reify(this,\n\t        this.toSeq().flip().map(\n\t          function(k, v)  {return mapper.call(context, k, v, this$0)}\n\t        ).flip()\n\t      );\n\t    }\n\t\n\t  });\n\t\n\t  var KeyedIterablePrototype = KeyedIterable.prototype;\n\t  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n\t  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n\t  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n\t  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\t\n\t\n\t\n\t  mixin(IndexedIterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, false);\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, false));\n\t    },\n\t\n\t    findIndex: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    indexOf: function(searchValue) {\n\t      var key = this.keyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    lastIndexOf: function(searchValue) {\n\t      var key = this.lastKeyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, false));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, false));\n\t    },\n\t\n\t    splice: function(index, removeNum /*, ...values*/) {\n\t      var numArgs = arguments.length;\n\t      removeNum = Math.max(removeNum | 0, 0);\n\t      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n\t        return this;\n\t      }\n\t      // If index is negative, it should resolve relative to the size of the\n\t      // collection. However size may be expensive to compute if not cached, so\n\t      // only call count() if the number is in fact negative.\n\t      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n\t      var spliced = this.slice(0, index);\n\t      return reify(\n\t        this,\n\t        numArgs === 1 ?\n\t          spliced :\n\t          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n\t      );\n\t    },\n\t\n\t\n\t    // ### More collection methods\n\t\n\t    findLastIndex: function(predicate, context) {\n\t      var entry = this.findLastEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    first: function() {\n\t      return this.get(0);\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, false));\n\t    },\n\t\n\t    get: function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      return (index < 0 || (this.size === Infinity ||\n\t          (this.size !== undefined && index > this.size))) ?\n\t        notSetValue :\n\t        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n\t    },\n\t\n\t    has: function(index) {\n\t      index = wrapIndex(this, index);\n\t      return index >= 0 && (this.size !== undefined ?\n\t        this.size === Infinity || index < this.size :\n\t        this.indexOf(index) !== -1\n\t      );\n\t    },\n\t\n\t    interpose: function(separator) {\n\t      return reify(this, interposeFactory(this, separator));\n\t    },\n\t\n\t    interleave: function(/*...iterables*/) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n\t      var interleaved = zipped.flatten(true);\n\t      if (zipped.size) {\n\t        interleaved.size = zipped.size * iterables.length;\n\t      }\n\t      return reify(this, interleaved);\n\t    },\n\t\n\t    keySeq: function() {\n\t      return Range(0, this.size);\n\t    },\n\t\n\t    last: function() {\n\t      return this.get(-1);\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, false));\n\t    },\n\t\n\t    zip: function(/*, ...iterables */) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n\t    },\n\t\n\t    zipWith: function(zipper/*, ...iterables */) {\n\t      var iterables = arrCopy(arguments);\n\t      iterables[0] = this;\n\t      return reify(this, zipWithFactory(this, zipper, iterables));\n\t    }\n\t\n\t  });\n\t\n\t  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n\t  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t\n\t  mixin(SetIterable, {\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    get: function(value, notSetValue) {\n\t      return this.has(value) ? value : notSetValue;\n\t    },\n\t\n\t    includes: function(value) {\n\t      return this.has(value);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    keySeq: function() {\n\t      return this.valueSeq();\n\t    }\n\t\n\t  });\n\t\n\t  SetIterable.prototype.has = IterablePrototype.includes;\n\t  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\t\n\t\n\t  // Mixin subclasses\n\t\n\t  mixin(KeyedSeq, KeyedIterable.prototype);\n\t  mixin(IndexedSeq, IndexedIterable.prototype);\n\t  mixin(SetSeq, SetIterable.prototype);\n\t\n\t  mixin(KeyedCollection, KeyedIterable.prototype);\n\t  mixin(IndexedCollection, IndexedIterable.prototype);\n\t  mixin(SetCollection, SetIterable.prototype);\n\t\n\t\n\t  // #pragma Helper functions\n\t\n\t  function keyMapper(v, k) {\n\t    return k;\n\t  }\n\t\n\t  function entryMapper(v, k) {\n\t    return [k, v];\n\t  }\n\t\n\t  function not(predicate) {\n\t    return function() {\n\t      return !predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function neg(predicate) {\n\t    return function() {\n\t      return -predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function quoteString(value) {\n\t    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n\t  }\n\t\n\t  function defaultZipper() {\n\t    return arrCopy(arguments);\n\t  }\n\t\n\t  function defaultNegComparator(a, b) {\n\t    return a < b ? 1 : a > b ? -1 : 0;\n\t  }\n\t\n\t  function hashIterable(iterable) {\n\t    if (iterable.size === Infinity) {\n\t      return 0;\n\t    }\n\t    var ordered = isOrdered(iterable);\n\t    var keyed = isKeyed(iterable);\n\t    var h = ordered ? 1 : 0;\n\t    var size = iterable.__iterate(\n\t      keyed ?\n\t        ordered ?\n\t          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n\t          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n\t        ordered ?\n\t          function(v ) { h = 31 * h + hash(v) | 0; } :\n\t          function(v ) { h = h + hash(v) | 0; }\n\t    );\n\t    return murmurHashOfSize(size, h);\n\t  }\n\t\n\t  function murmurHashOfSize(size, h) {\n\t    h = imul(h, 0xCC9E2D51);\n\t    h = imul(h << 15 | h >>> -15, 0x1B873593);\n\t    h = imul(h << 13 | h >>> -13, 5);\n\t    h = (h + 0xE6546B64 | 0) ^ size;\n\t    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n\t    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n\t    h = smi(h ^ h >>> 16);\n\t    return h;\n\t  }\n\t\n\t  function hashMerge(a, b) {\n\t    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n\t  }\n\t\n\t  var Immutable = {\n\t\n\t    Iterable: Iterable,\n\t\n\t    Seq: Seq,\n\t    Collection: Collection,\n\t    Map: Map,\n\t    OrderedMap: OrderedMap,\n\t    List: List,\n\t    Stack: Stack,\n\t    Set: Set,\n\t    OrderedSet: OrderedSet,\n\t\n\t    Record: Record,\n\t    Range: Range,\n\t    Repeat: Repeat,\n\t\n\t    is: is,\n\t    fromJS: fromJS\n\t\n\t  };\n\t\n\t  return Immutable;\n\t\n\t}));\n\n/***/ },\n/* 141 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = downloadState;\n\texports.downloadBegin = downloadBegin;\n\texports.downloadSuccess = downloadSuccess;\n\texports.downloadError = downloadError;\n\texports.download = download;\n\t\n\tvar _immutable = __webpack_require__(140);\n\t\n\tvar _networks = __webpack_require__(139);\n\t\n\tvar DOWNLOAD_BEGIN = 'DOWNLOAD_BEGIN';\n\tvar DOWNLOAD_SUCCESS = 'DOWNLOAD_SUCCESS';\n\tvar DOWNLOAD_ERROR = 'DOWNLOAD_ERROR';\n\t\n\tvar defaultState = (0, _immutable.Map)({\n\t  downloading: false,\n\t  error: null\n\t});\n\t\n\tfunction downloadState() {\n\t  var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];\n\t  var action = arguments[1];\n\t\n\t  switch (action.type) {\n\t    case DOWNLOAD_BEGIN:\n\t      return state.merge({\n\t        downloading: true\n\t      });\n\t    case DOWNLOAD_SUCCESS:\n\t      return state.merge({\n\t        downloading: false\n\t      });\n\t    case DOWNLOAD_ERROR:\n\t      return state.merge({\n\t        downloading: false,\n\t        error: action.error\n\t      });\n\t    default:\n\t      return state;\n\t  }\n\t}\n\t\n\t/*Set the downloading flag*/\n\tfunction downloadBegin() {\n\t  return { type: DOWNLOAD_BEGIN };\n\t}\n\t\n\t/*Send network to the networks store and remove the downloading flag*/\n\tfunction downloadSuccess(networkUrl, data) {\n\t  return function (dispatch) {\n\t    dispatch((0, _networks.addNetwork)(networkUrl, data));\n\t    dispatch({ type: DOWNLOAD_SUCCESS });\n\t  };\n\t}\n\t\n\t/*Set an error field if a download did not complete successfully*/\n\tfunction downloadError(error) {\n\t  return { type: DOWNLOAD_ERROR, error: error };\n\t}\n\t\n\t/*Download the network from the given url*/\n\tfunction download(networkUrl) {\n\t  var headers = {\n\t    'Accept': 'application/json',\n\t    'Content-Type': 'application/json'\n\t  };\n\t  return function (dispatch) {\n\t    return fetch(networkUrl, {\n\t      method: 'get',\n\t      headers: headers\n\t    }).then(function (response) {\n\t      if (response.status >= 200 && response.status < 300) {\n\t        response.json().then(function (data) {\n\t          return dispatch(downloadSuccess(networkUrl, data));\n\t        });\n\t      } else {\n\t        var error = new Error(response);\n\t        error.response = response;\n\t        dispatch(downloadError(error));\n\t        throw error;\n\t      }\n\t    }).catch(function (error) {\n\t      window.alert('Network ' + networkUrl + ' download failed, reason:', error);\n\t    });\n\t  };\n\t}\n\n/***/ },\n/* 142 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(143);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(145)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./component.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./component.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 143 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(144)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 144 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 145 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** CyNetworkViewer.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 772489307a94644d460b\n **/","import {bindActionCreators} from 'redux'\nimport {connect} from 'react-redux'\n\nimport CyNetworkViewer from './component/CyNetworkViewer'\n\nimport * as networkActions from './store/networks.js'\nimport * as networkDownloadActions from './store/networkDownload.js'\n\nrequire(\"./style/component.scss\")\n\nfunction mapStateToProps(state) {\n  return {\n    networks: state.cy_network.networks,\n    networkDownload: state.cy_network.networkDownload\n  }\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    downloadActions: bindActionCreators(networkDownloadActions, dispatch),\n    networkActions: bindActionCreators(networkActions, dispatch)\n  }\n}\n\nconst component = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(CyNetworkViewer)\n\nconst storeName = 'cy_network_viewer'\nconst store = {}\n\nexport {\n  component,\n  storeName,\n  store\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/CyNetworkViewer.js\n **/","'use strict';\n\nexports.__esModule = true;\nexports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;\n\nvar _createStore = require('./createStore');\n\nvar _createStore2 = _interopRequireDefault(_createStore);\n\nvar _combineReducers = require('./combineReducers');\n\nvar _combineReducers2 = _interopRequireDefault(_combineReducers);\n\nvar _bindActionCreators = require('./bindActionCreators');\n\nvar _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);\n\nvar _applyMiddleware = require('./applyMiddleware');\n\nvar _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);\n\nvar _compose = require('./compose');\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nvar _warning = require('./utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== 'production', warn the user.\n*/\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  (0, _warning2[\"default\"])('You are currently using minified code outside of NODE_ENV === \\'production\\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexports.createStore = _createStore2[\"default\"];\nexports.combineReducers = _combineReducers2[\"default\"];\nexports.bindActionCreators = _bindActionCreators2[\"default\"];\nexports.applyMiddleware = _applyMiddleware2[\"default\"];\nexports.compose = _compose2[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/index.js\n ** module id = 1\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports.ActionTypes = undefined;\nexports[\"default\"] = createStore;\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = exports.ActionTypes = {\n  INIT: '@@redux/INIT'\n};\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [initialState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nfunction createStore(reducer, initialState, enhancer) {\n  var _ref2;\n\n  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = initialState;\n    initialState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, initialState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = initialState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!(0, _isPlainObject2[\"default\"])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i]();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/zenparsing/es-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[_symbolObservable2[\"default\"]] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[_symbolObservable2[\"default\"]] = observable, _ref2;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/createStore.js\n ** module id = 3\n ** module chunks = 0\n **/","var getPrototype = require('./_getPrototype'),\n    isHostObject = require('./_isHostObject'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object,\n *  else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) ||\n      objectToString.call(value) != objectTag || isHostObject(value)) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nmodule.exports = isPlainObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/isPlainObject.js\n ** module id = 4\n ** module chunks = 0\n **/","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetPrototype = Object.getPrototypeOf;\n\n/**\n * Gets the `[[Prototype]]` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {null|Object} Returns the `[[Prototype]]`.\n */\nfunction getPrototype(value) {\n  return nativeGetPrototype(Object(value));\n}\n\nmodule.exports = getPrototype;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/_getPrototype.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\nmodule.exports = isHostObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/_isHostObject.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/isObjectLike.js\n ** module id = 7\n ** module chunks = 0\n **/","/* global window */\n'use strict';\n\nmodule.exports = require('./ponyfill')(global || window || this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/symbol-observable/index.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/symbol-observable/ponyfill.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = combineReducers;\n\nvar _createStore = require('./createStore');\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _warning = require('./utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\n  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!(0, _isPlainObject2[\"default\"])(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key);\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerSanity(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var sanityError;\n  try {\n    assertReducerSanity(finalReducers);\n  } catch (e) {\n    sanityError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var action = arguments[1];\n\n    if (sanityError) {\n      throw sanityError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);\n      if (warningMessage) {\n        (0, _warning2[\"default\"])(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var i = 0; i < finalReducerKeys.length; i++) {\n      var key = finalReducerKeys[i];\n      var reducer = finalReducers[key];\n      var previousStateForKey = state[key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/combineReducers.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = warning;\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/warning.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = bindActionCreators;\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/bindActionCreators.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports[\"default\"] = applyMiddleware;\n\nvar _compose = require('./compose');\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, initialState, enhancer) {\n      var store = createStore(reducer, initialState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = _compose2[\"default\"].apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/applyMiddleware.js\n ** module id = 13\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = compose;\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  } else {\n    var _ret = function () {\n      var last = funcs[funcs.length - 1];\n      var rest = funcs.slice(0, -1);\n      return {\n        v: function v() {\n          return rest.reduceRight(function (composed, f) {\n            return f(composed);\n          }, last.apply(undefined, arguments));\n        }\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/compose.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports.connect = exports.Provider = undefined;\n\nvar _Provider = require('./components/Provider');\n\nvar _Provider2 = _interopRequireDefault(_Provider);\n\nvar _connect = require('./components/connect');\n\nvar _connect2 = _interopRequireDefault(_connect);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nexports.Provider = _Provider2[\"default\"];\nexports.connect = _connect2[\"default\"];\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-redux/lib/index.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = undefined;\n\nvar _react = require('react');\n\nvar _storeShape = require('../utils/storeShape');\n\nvar _storeShape2 = _interopRequireDefault(_storeShape);\n\nvar _warning = require('../utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar didWarnAboutReceivingStore = false;\nfunction warnAboutReceivingStore() {\n  if (didWarnAboutReceivingStore) {\n    return;\n  }\n  didWarnAboutReceivingStore = true;\n\n  (0, _warning2[\"default\"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');\n}\n\nvar Provider = function (_Component) {\n  _inherits(Provider, _Component);\n\n  Provider.prototype.getChildContext = function getChildContext() {\n    return { store: this.store };\n  };\n\n  function Provider(props, context) {\n    _classCallCheck(this, Provider);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));\n\n    _this.store = props.store;\n    return _this;\n  }\n\n  Provider.prototype.render = function render() {\n    var children = this.props.children;\n\n    return _react.Children.only(children);\n  };\n\n  return Provider;\n}(_react.Component);\n\nexports[\"default\"] = Provider;\n\nif (process.env.NODE_ENV !== 'production') {\n  Provider.prototype.componentWillReceiveProps = function (nextProps) {\n    var store = this.store;\n    var nextStore = nextProps.store;\n\n    if (store !== nextStore) {\n      warnAboutReceivingStore();\n    }\n  };\n}\n\nProvider.propTypes = {\n  store: _storeShape2[\"default\"].isRequired,\n  children: _react.PropTypes.element.isRequired\n};\nProvider.childContextTypes = {\n  store: _storeShape2[\"default\"].isRequired\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-redux/lib/components/Provider.js\n ** module id = 16\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_17__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"React\"\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\n\nvar _react = require('react');\n\nexports[\"default\"] = _react.PropTypes.shape({\n  subscribe: _react.PropTypes.func.isRequired,\n  dispatch: _react.PropTypes.func.isRequired,\n  getState: _react.PropTypes.func.isRequired\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-redux/lib/utils/storeShape.js\n ** module id = 18\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = warning;\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that you can use this stack\n    // to find the callsite that caused this warning to fire.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-redux/lib/utils/warning.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.__esModule = true;\nexports[\"default\"] = connect;\n\nvar _react = require('react');\n\nvar _storeShape = require('../utils/storeShape');\n\nvar _storeShape2 = _interopRequireDefault(_storeShape);\n\nvar _shallowEqual = require('../utils/shallowEqual');\n\nvar _shallowEqual2 = _interopRequireDefault(_shallowEqual);\n\nvar _wrapActionCreators = require('../utils/wrapActionCreators');\n\nvar _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);\n\nvar _warning = require('../utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _hoistNonReactStatics = require('hoist-non-react-statics');\n\nvar _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar defaultMapStateToProps = function defaultMapStateToProps(state) {\n  return {};\n}; // eslint-disable-line no-unused-vars\nvar defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {\n  return { dispatch: dispatch };\n};\nvar defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {\n  return _extends({}, parentProps, stateProps, dispatchProps);\n};\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nvar errorObject = { value: null };\nfunction tryCatch(fn, ctx) {\n  try {\n    return fn.apply(ctx);\n  } catch (e) {\n    errorObject.value = e;\n    return errorObject;\n  }\n}\n\n// Helps track hot reloading.\nvar nextVersion = 0;\n\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n  var shouldSubscribe = Boolean(mapStateToProps);\n  var mapState = mapStateToProps || defaultMapStateToProps;\n\n  var mapDispatch = undefined;\n  if (typeof mapDispatchToProps === 'function') {\n    mapDispatch = mapDispatchToProps;\n  } else if (!mapDispatchToProps) {\n    mapDispatch = defaultMapDispatchToProps;\n  } else {\n    mapDispatch = (0, _wrapActionCreators2[\"default\"])(mapDispatchToProps);\n  }\n\n  var finalMergeProps = mergeProps || defaultMergeProps;\n  var _options$pure = options.pure;\n  var pure = _options$pure === undefined ? true : _options$pure;\n  var _options$withRef = options.withRef;\n  var withRef = _options$withRef === undefined ? false : _options$withRef;\n\n  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;\n\n  // Helps track hot reloading.\n  var version = nextVersion++;\n\n  return function wrapWithConnect(WrappedComponent) {\n    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';\n\n    function checkStateShape(props, methodName) {\n      if (!(0, _isPlainObject2[\"default\"])(props)) {\n        (0, _warning2[\"default\"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));\n      }\n    }\n\n    function computeMergedProps(stateProps, dispatchProps, parentProps) {\n      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);\n      if (process.env.NODE_ENV !== 'production') {\n        checkStateShape(mergedProps, 'mergeProps');\n      }\n      return mergedProps;\n    }\n\n    var Connect = function (_Component) {\n      _inherits(Connect, _Component);\n\n      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {\n        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;\n      };\n\n      function Connect(props, context) {\n        _classCallCheck(this, Connect);\n\n        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));\n\n        _this.version = version;\n        _this.store = props.store || context.store;\n\n        (0, _invariant2[\"default\"])(_this.store, 'Could not find \"store\" in either the context or ' + ('props of \"' + connectDisplayName + '\". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass \"store\" as a prop to \"' + connectDisplayName + '\".'));\n\n        var storeState = _this.store.getState();\n        _this.state = { storeState: storeState };\n        _this.clearCache();\n        return _this;\n      }\n\n      Connect.prototype.computeStateProps = function computeStateProps(store, props) {\n        if (!this.finalMapStateToProps) {\n          return this.configureFinalMapState(store, props);\n        }\n\n        var state = store.getState();\n        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkStateShape(stateProps, 'mapStateToProps');\n        }\n        return stateProps;\n      };\n\n      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {\n        var mappedState = mapState(store.getState(), props);\n        var isFactory = typeof mappedState === 'function';\n\n        this.finalMapStateToProps = isFactory ? mappedState : mapState;\n        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;\n\n        if (isFactory) {\n          return this.computeStateProps(store, props);\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkStateShape(mappedState, 'mapStateToProps');\n        }\n        return mappedState;\n      };\n\n      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {\n        if (!this.finalMapDispatchToProps) {\n          return this.configureFinalMapDispatch(store, props);\n        }\n\n        var dispatch = store.dispatch;\n\n        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkStateShape(dispatchProps, 'mapDispatchToProps');\n        }\n        return dispatchProps;\n      };\n\n      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {\n        var mappedDispatch = mapDispatch(store.dispatch, props);\n        var isFactory = typeof mappedDispatch === 'function';\n\n        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;\n        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;\n\n        if (isFactory) {\n          return this.computeDispatchProps(store, props);\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkStateShape(mappedDispatch, 'mapDispatchToProps');\n        }\n        return mappedDispatch;\n      };\n\n      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {\n        var nextStateProps = this.computeStateProps(this.store, this.props);\n        if (this.stateProps && (0, _shallowEqual2[\"default\"])(nextStateProps, this.stateProps)) {\n          return false;\n        }\n\n        this.stateProps = nextStateProps;\n        return true;\n      };\n\n      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {\n        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);\n        if (this.dispatchProps && (0, _shallowEqual2[\"default\"])(nextDispatchProps, this.dispatchProps)) {\n          return false;\n        }\n\n        this.dispatchProps = nextDispatchProps;\n        return true;\n      };\n\n      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {\n        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);\n        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2[\"default\"])(nextMergedProps, this.mergedProps)) {\n          return false;\n        }\n\n        this.mergedProps = nextMergedProps;\n        return true;\n      };\n\n      Connect.prototype.isSubscribed = function isSubscribed() {\n        return typeof this.unsubscribe === 'function';\n      };\n\n      Connect.prototype.trySubscribe = function trySubscribe() {\n        if (shouldSubscribe && !this.unsubscribe) {\n          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));\n          this.handleChange();\n        }\n      };\n\n      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {\n        if (this.unsubscribe) {\n          this.unsubscribe();\n          this.unsubscribe = null;\n        }\n      };\n\n      Connect.prototype.componentDidMount = function componentDidMount() {\n        this.trySubscribe();\n      };\n\n      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n        if (!pure || !(0, _shallowEqual2[\"default\"])(nextProps, this.props)) {\n          this.haveOwnPropsChanged = true;\n        }\n      };\n\n      Connect.prototype.componentWillUnmount = function componentWillUnmount() {\n        this.tryUnsubscribe();\n        this.clearCache();\n      };\n\n      Connect.prototype.clearCache = function clearCache() {\n        this.dispatchProps = null;\n        this.stateProps = null;\n        this.mergedProps = null;\n        this.haveOwnPropsChanged = true;\n        this.hasStoreStateChanged = true;\n        this.haveStatePropsBeenPrecalculated = false;\n        this.statePropsPrecalculationError = null;\n        this.renderedElement = null;\n        this.finalMapDispatchToProps = null;\n        this.finalMapStateToProps = null;\n      };\n\n      Connect.prototype.handleChange = function handleChange() {\n        if (!this.unsubscribe) {\n          return;\n        }\n\n        var storeState = this.store.getState();\n        var prevStoreState = this.state.storeState;\n        if (pure && prevStoreState === storeState) {\n          return;\n        }\n\n        if (pure && !this.doStatePropsDependOnOwnProps) {\n          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);\n          if (!haveStatePropsChanged) {\n            return;\n          }\n          if (haveStatePropsChanged === errorObject) {\n            this.statePropsPrecalculationError = errorObject.value;\n          }\n          this.haveStatePropsBeenPrecalculated = true;\n        }\n\n        this.hasStoreStateChanged = true;\n        this.setState({ storeState: storeState });\n      };\n\n      Connect.prototype.getWrappedInstance = function getWrappedInstance() {\n        (0, _invariant2[\"default\"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');\n\n        return this.refs.wrappedInstance;\n      };\n\n      Connect.prototype.render = function render() {\n        var haveOwnPropsChanged = this.haveOwnPropsChanged;\n        var hasStoreStateChanged = this.hasStoreStateChanged;\n        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;\n        var statePropsPrecalculationError = this.statePropsPrecalculationError;\n        var renderedElement = this.renderedElement;\n\n        this.haveOwnPropsChanged = false;\n        this.hasStoreStateChanged = false;\n        this.haveStatePropsBeenPrecalculated = false;\n        this.statePropsPrecalculationError = null;\n\n        if (statePropsPrecalculationError) {\n          throw statePropsPrecalculationError;\n        }\n\n        var shouldUpdateStateProps = true;\n        var shouldUpdateDispatchProps = true;\n        if (pure && renderedElement) {\n          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;\n          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;\n        }\n\n        var haveStatePropsChanged = false;\n        var haveDispatchPropsChanged = false;\n        if (haveStatePropsBeenPrecalculated) {\n          haveStatePropsChanged = true;\n        } else if (shouldUpdateStateProps) {\n          haveStatePropsChanged = this.updateStatePropsIfNeeded();\n        }\n        if (shouldUpdateDispatchProps) {\n          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();\n        }\n\n        var haveMergedPropsChanged = true;\n        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {\n          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();\n        } else {\n          haveMergedPropsChanged = false;\n        }\n\n        if (!haveMergedPropsChanged && renderedElement) {\n          return renderedElement;\n        }\n\n        if (withRef) {\n          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {\n            ref: 'wrappedInstance'\n          }));\n        } else {\n          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);\n        }\n\n        return this.renderedElement;\n      };\n\n      return Connect;\n    }(_react.Component);\n\n    Connect.displayName = connectDisplayName;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.contextTypes = {\n      store: _storeShape2[\"default\"]\n    };\n    Connect.propTypes = {\n      store: _storeShape2[\"default\"]\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      Connect.prototype.componentWillUpdate = function componentWillUpdate() {\n        if (this.version === version) {\n          return;\n        }\n\n        // We are hot reloading!\n        this.version = version;\n        this.trySubscribe();\n        this.clearCache();\n      };\n    }\n\n    return (0, _hoistNonReactStatics2[\"default\"])(Connect, WrappedComponent);\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-redux/lib/components/connect.js\n ** module id = 20\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = shallowEqual;\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  var hasOwn = Object.prototype.hasOwnProperty;\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-redux/lib/utils/shallowEqual.js\n ** module id = 21\n ** module chunks = 0\n **/","'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = wrapActionCreators;\n\nvar _redux = require('redux');\n\nfunction wrapActionCreators(actionCreators) {\n  return function (dispatch) {\n    return (0, _redux.bindActionCreators)(actionCreators, dispatch);\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-redux/lib/utils/wrapActionCreators.js\n ** module id = 22\n ** module chunks = 0\n **/","/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    arguments: true,\n    arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n        var keys = Object.getOwnPropertyNames(sourceComponent);\n\n        /* istanbul ignore else */\n        if (isGetOwnPropertySymbolsAvailable) {\n            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n                try {\n                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n                } catch (error) {\n\n                }\n            }\n        }\n    }\n\n    return targetComponent;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/hoist-non-react-statics/index.js\n ** module id = 23\n ** module chunks = 0\n **/","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/invariant/browser.js\n ** module id = 24\n ** module chunks = 0\n **/","import React from 'react'\nimport CytoscapeRenderer from './CytoscapeRenderer'\n\nexport default class CyNetworkViewer extends React.Component {\n\n  static defaultProps = {\n    style: {\n      height: '100%',\n      width: '100%'\n    },\n    networkUrl: '',\n    renderOptions: {}\n  };\n\n  componentWillMount() {\n    this.props.downloadActions.downloadBegin()\n    this.props.downloadActions.download(this.props.networkUrl)\n  }\n\n  render() {\n    var renderer;\n    if (!this.props.networkDownload.get('downloading')) {\n      const network = this.props.networks.get(this.props.networkUrl)\n      renderer = <CytoscapeRenderer\n        networkData={network}\n        renderOptions={this.props.renderOptions}\n      />\n    } else {\n      console.log(\"Network is downloading...\")\n      renderer = <div/>\n    }\n    return (\n      <div style={this.props.style}>\n        {renderer}\n      </div>\n    )\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/component/CyNetworkViewer.jsx\n **/","import React from \"react\"\nimport cytoscape from \"cytoscape\"\nimport {DEF_VISUAL_STYLE} from \"./VisualStyle\"\n\n// TODO: consolidate Cytoscape-dependent tags\nconst CYTOSCAPE_TAG = 'cy';\n\n// Original position will be used when layout is positions are available\nconst DEF_LAYOUT = 'preset';\n\n// Layout to be used when there is no layout information\nconst DEF_NO_LAYOUT = 'cose';\n\n\nclass CytoscapeRenderer extends React.Component {\n\n  updateCyjs() {\n    console.log('* Cytoscape.js is rendering new network...');\n\n    let network = this.props.networkData.toJS()\n\n    let visualStyle = DEF_VISUAL_STYLE\n    let layout = DEF_LAYOUT\n\n    if (visualStyle === undefined || visualStyle === null) {\n      visualStyle = DEF_VISUAL_STYLE\n      layout = DEF_NO_LAYOUT\n    }\n\n\n    this.cy = cytoscape(\n      Object.assign(\n        this.props.renderOptions,\n        {\n          container: document.getElementById(CYTOSCAPE_TAG),\n          elements: network.elements,\n          style: visualStyle,\n          layout: {\n            name: layout\n          }\n\n        }));\n  }\n\n  componentDidMount() {\n    this.updateCyjs();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (nextProps.networkData.equals(this.props.networkData)) {\n      console.log(\"Network unchanged, not updating cytoscapejs\");\n      return false;\n    }\n    console.log(\"Network changed, updating cytoscapejs\")\n    return true;\n  }\n\n  render() {\n    return (\n      <div class=\"network-widget\" style={{height: '100%', width: '100%'}}>\n        <div id={CYTOSCAPE_TAG} style={{height: '100%', width: '100%'}}></div>\n      </div>\n    )\n  }\n}\n\nexport default CytoscapeRenderer\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/component/CytoscapeRenderer.jsx\n **/","'use strict';\n\nrequire('./-preamble');\n\nvar window = require( './window' );\nvar is = require( './is' );\nvar Core = require( './core' );\nvar extension = require( './extension' );\nvar registerJquery = require( './jquery-plugin' );\nvar Stylesheet = require( './stylesheet' );\nvar Thread = require( './thread' );\nvar Fabric = require( './fabric' );\n\nvar cytoscape = function( options ){ // jshint ignore:line\n  // if no options specified, use default\n  if( options === undefined ){\n    options = {};\n  }\n\n  // create instance\n  if( is.plainObject( options ) ){\n    return new Core( options );\n  }\n\n  // allow for registration of extensions\n  else if( is.string( options ) ){\n    return extension.apply( extension, arguments );\n  }\n};\n\n// replaced by build system\ncytoscape.version = require('./version.json');\n\n// try to register w/ jquery\nif( window && window.jQuery ){\n  registerJquery( window.jQuery, cytoscape );\n}\n\n// expose register api\ncytoscape.registerJquery = function( jQuery ){\n  registerJquery( jQuery, cytoscape );\n};\n\n// expose public apis (mostly for extensions)\ncytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\ncytoscape.thread = cytoscape.Thread = Thread;\ncytoscape.fabric = cytoscape.Fabric = Fabric;\n\nmodule.exports = cytoscape;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/index.js\n ** module id = 27\n ** module chunks = 0\n **/","\n/*!\n\nCytoscape.js {{VERSION}} (MIT licensed)\n\nCopyright (c) The Cytoscape Consortium\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the “Software”), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\n'use strict';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/-preamble.js\n ** module id = 28\n ** module chunks = 0\n **/","module.exports = ( typeof window === 'undefined' ? null : window );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/window.js\n ** module id = 29\n ** module chunks = 0\n **/","'use strict';\n\nvar window = require( './window' );\nvar navigator = window ? window.navigator : null;\n\nvar typeofstr = typeof '';\nvar typeofobj = typeof {};\nvar typeoffn = typeof function(){};\nvar typeofhtmlele = typeof HTMLElement;\n\nvar instanceStr = function( obj ){\n  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;\n};\n\nvar is = {\n  defined: function( obj ){\n    return obj != null; // not undefined or null\n  },\n\n  string: function( obj ){\n    return obj != null && typeof obj == typeofstr;\n  },\n\n  fn: function( obj ){\n    return obj != null && typeof obj === typeoffn;\n  },\n\n  array: function( obj ){\n    return Array.isArray ? Array.isArray( obj ) : obj != null && obj instanceof Array;\n  },\n\n  plainObject: function( obj ){\n    return obj != null && typeof obj === typeofobj && !is.array( obj ) && obj.constructor === Object;\n  },\n\n  object: function( obj ){\n    return obj != null && typeof obj === typeofobj;\n  },\n\n  number: function( obj ){\n    return obj != null && typeof obj === typeof 1 && !isNaN( obj );\n  },\n\n  integer: function( obj ){\n    return is.number( obj ) && Math.floor( obj ) === obj;\n  },\n\n  bool: function( obj ){\n    return obj != null && typeof obj === typeof true;\n  },\n\n  htmlElement: function( obj ){\n    if( 'undefined' === typeofhtmlele ){\n      return undefined;\n    } else {\n      return null != obj && obj instanceof HTMLElement;\n    }\n  },\n\n  elementOrCollection: function( obj ){\n    return is.element( obj ) || is.collection( obj );\n  },\n\n  element: function( obj ){\n    return instanceStr( obj ) === 'collection' && obj._private.single;\n  },\n\n  collection: function( obj ){\n    return instanceStr( obj ) === 'collection' && !obj._private.single;\n  },\n\n  core: function( obj ){\n    return instanceStr( obj ) === 'core';\n  },\n\n  style: function( obj ){\n    return instanceStr( obj ) === 'style';\n  },\n\n  stylesheet: function( obj ){\n    return instanceStr( obj ) === 'stylesheet';\n  },\n\n  event: function( obj ){\n    return instanceStr( obj ) === 'event';\n  },\n\n  thread: function( obj ){\n    return instanceStr( obj ) === 'thread';\n  },\n\n  fabric: function( obj ){\n    return instanceStr( obj ) === 'fabric';\n  },\n\n  emptyString: function( obj ){\n    if( obj === undefined || obj === null ){ // null is empty\n      return true;\n    } else if( obj === '' || obj.match( /^\\s+$/ ) ){\n      return true; // empty string is empty\n    }\n\n    return false; // otherwise, we don't know what we've got\n  },\n\n  nonemptyString: function( obj ){\n    if( obj && is.string( obj ) && obj !== '' && !obj.match( /^\\s+$/ ) ){\n      return true;\n    }\n\n    return false;\n  },\n\n  domElement: function( obj ){\n    if( typeof HTMLElement === 'undefined' ){\n      return false; // we're not in a browser so it doesn't matter\n    } else {\n      return obj instanceof HTMLElement;\n    }\n  },\n\n  boundingBox: function( obj ){\n    return is.plainObject( obj ) &&\n      is.number( obj.x1 ) && is.number( obj.x2 ) &&\n      is.number( obj.y1 ) && is.number( obj.y2 )\n    ;\n  },\n\n  promise: function( obj ){\n    return is.object( obj ) && is.fn( obj.then );\n  },\n\n  touch: function(){\n    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );\n  },\n\n  gecko: function(){\n    return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);\n  },\n\n  webkit: function(){\n    return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);\n  },\n\n  chromium: function(){\n    return typeof chrome !== 'undefined';\n  },\n\n  khtml: function(){\n    return navigator && navigator.vendor.match( /kde/i ); // probably a better way to detect this...\n  },\n\n  khtmlEtc: function(){\n    return is.khtml() || is.webkit() || is.chromium();\n  },\n\n  ms: function(){\n    return navigator && navigator.userAgent.match( /msie|trident|edge/i ); // probably a better way to detect this...\n  },\n\n  windows: function(){\n    return navigator && navigator.appVersion.match( /Win/i );\n  },\n\n  mac: function(){\n    return navigator && navigator.appVersion.match( /Mac/i );\n  },\n\n  linux: function(){\n    return navigator && navigator.appVersion.match( /Linux/i );\n  },\n\n  unix: function(){\n    return navigator && navigator.appVersion.match( /X11/i );\n  }\n};\n\nmodule.exports = is;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/is.js\n ** module id = 30\n ** module chunks = 0\n **/","'use strict';\n\nvar window = require( '../window' );\nvar util = require( '../util' );\nvar Collection = require( '../collection' );\nvar is = require( '../is' );\nvar Promise = require( '../promise' );\nvar define = require( '../define' );\n\nvar Core = function( opts ){\n  var cy = this;\n\n  opts = util.extend( {}, opts );\n\n  var container = opts.container;\n\n  // allow for passing a wrapped jquery object\n  // e.g. cytoscape({ container: $('#cy') })\n  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){\n    container = container[0];\n  }\n\n  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n  reg = reg || {};\n\n  if( reg && reg.cy ){\n    reg.cy.destroy();\n\n    reg = {}; // old instance => replace reg completely\n  }\n\n  var readies = reg.readies = reg.readies || [];\n\n  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy\n  reg.cy = cy;\n\n  var head = window !== undefined && container !== undefined && !opts.headless;\n  var options = opts;\n  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );\n  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );\n\n  var defVal = function( def, val, altVal ){\n    if( val !== undefined ){\n      return val;\n    } else if( altVal !== undefined ){\n      return altVal;\n    } else {\n      return def;\n    }\n  };\n\n  var _p = this._private = {\n    container: container, // html dom ele container\n    ready: false, // whether ready has been triggered\n    initrender: false, // has initrender has been triggered\n    options: options, // cached options\n    elements: new Collection( this ), // elements in the graph\n    listeners: [], // list of listeners\n    aniEles: new Collection( this ), // elements being animated\n    scratch: {}, // scratch object for core\n    layout: null,\n    renderer: null,\n    notificationsEnabled: true, // whether notifications are sent to the renderer\n    minZoom: 1e-50,\n    maxZoom: 1e50,\n    zoomingEnabled: defVal( true, options.zoomingEnabled ),\n    userZoomingEnabled: defVal( true, options.userZoomingEnabled ),\n    panningEnabled: defVal( true, options.panningEnabled ),\n    userPanningEnabled: defVal( true, options.userPanningEnabled ),\n    boxSelectionEnabled: defVal( true, options.boxSelectionEnabled ),\n    autolock: defVal( false, options.autolock, options.autolockNodes ),\n    autoungrabify: defVal( false, options.autoungrabify, options.autoungrabifyNodes ),\n    autounselectify: defVal( false, options.autounselectify ),\n    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n    zoom: is.number( options.zoom ) ? options.zoom : 1,\n    pan: {\n      x: is.plainObject( options.pan ) && is.number( options.pan.x ) ? options.pan.x : 0,\n      y: is.plainObject( options.pan ) && is.number( options.pan.y ) ? options.pan.y : 0\n    },\n    animation: { // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    hasCompoundNodes: false\n  };\n\n  // set selection type\n  var selType = options.selectionType;\n  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){\n    // then set default\n\n    _p.selectionType = 'single';\n  } else {\n    _p.selectionType = selType;\n  }\n\n  // init zoom bounds\n  if( is.number( options.minZoom ) && is.number( options.maxZoom ) && options.minZoom < options.maxZoom ){\n    _p.minZoom = options.minZoom;\n    _p.maxZoom = options.maxZoom;\n  } else if( is.number( options.minZoom ) && options.maxZoom === undefined ){\n    _p.minZoom = options.minZoom;\n  } else if( is.number( options.maxZoom ) && options.minZoom === undefined ){\n    _p.maxZoom = options.maxZoom;\n  }\n\n  var loadExtData = function( extData, next ){\n    var anyIsPromise = extData.some( is.promise );\n\n    if( anyIsPromise ){\n      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init\n    } else {\n      next( extData ); // exec synchronously for convenience\n    }\n  };\n\n  // create the renderer\n  cy.initRenderer( util.extend( {\n    hideEdgesOnViewport: options.hideEdgesOnViewport,\n    textureOnViewport: options.textureOnViewport,\n    wheelSensitivity: is.number( options.wheelSensitivity ) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,\n    motionBlur: options.motionBlur === undefined ? false : options.motionBlur, // off by default\n    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,\n    pixelRatio: is.number( options.pixelRatio ) && options.pixelRatio > 0 ? options.pixelRatio : undefined,\n    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,\n    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold\n  }, options.renderer ) );\n\n  loadExtData([ options.style, options.elements ], function( thens ){\n    var initStyle = thens[0];\n    var initEles = thens[1];\n\n    // init style\n    if( _p.styleEnabled ){\n      cy.setStyle( initStyle );\n    }\n\n    // trigger the passed function for the `initrender` event\n    if( options.initrender ){\n      cy.on( 'initrender', options.initrender );\n      cy.on( 'initrender', function(){\n        _p.initrender = true;\n      } );\n    }\n\n    // initial load\n    cy.load( initEles, function(){ // onready\n      cy.startAnimationLoop();\n      _p.ready = true;\n\n      // if a ready callback is specified as an option, the bind it\n      if( is.fn( options.ready ) ){\n        cy.on( 'ready', options.ready );\n      }\n\n      // bind all the ready handlers registered before creating this instance\n      for( var i = 0; i < readies.length; i++ ){\n        var fn = readies[ i ];\n        cy.on( 'ready', fn );\n      }\n      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\n      cy.trigger( 'ready' );\n    }, options.done );\n\n  } );\n};\n\nvar corefn = Core.prototype; // short alias\n\nutil.extend( corefn, {\n  instanceString: function(){\n    return 'core';\n  },\n\n  isReady: function(){\n    return this._private.ready;\n  },\n\n  ready: function( fn ){\n    if( this.isReady() ){\n      this.trigger( 'ready', [], fn ); // just calls fn as though triggered via ready event\n    } else {\n      this.on( 'ready', fn );\n    }\n\n    return this;\n  },\n\n  initrender: function(){\n    return this._private.initrender;\n  },\n\n  destroy: function(){\n    var cy = this;\n\n    cy.stopAnimationLoop();\n\n    cy.notify( { type: 'destroy' } ); // destroy the renderer\n\n    var domEle = cy.container();\n    if( domEle ){\n      domEle._cyreg = null;\n\n      while( domEle.childNodes.length > 0 ){\n        domEle.removeChild( domEle.childNodes[0] );\n      }\n    }\n\n    return cy;\n  },\n\n  hasElementWithId: function( id ){\n    return this._private.elements.hasElementWithId( id );\n  },\n\n  getElementById: function( id ){\n    return this._private.elements.getElementById( id );\n  },\n\n  selectionType: function(){\n    return this._private.selectionType;\n  },\n\n  hasCompoundNodes: function(){\n    return this._private.hasCompoundNodes;\n  },\n\n  headless: function(){\n    return this._private.options.renderer.name === 'null';\n  },\n\n  styleEnabled: function(){\n    return this._private.styleEnabled;\n  },\n\n  addToPool: function( eles ){\n    this._private.elements.merge( eles );\n\n    return this; // chaining\n  },\n\n  removeFromPool: function( eles ){\n    this._private.elements.unmerge( eles );\n\n    return this;\n  },\n\n  container: function(){\n    return this._private.container;\n  },\n\n  options: function(){\n    return util.copy( this._private.options );\n  },\n\n  json: function( obj ){\n    var cy = this;\n    var _p = cy._private;\n    var eles = cy.mutableElements();\n\n    if( is.plainObject( obj ) ){ // set\n\n      cy.startBatch();\n\n      if( obj.elements ){\n        var idInJson = {};\n\n        var updateEles = function( jsons, gr ){\n          for( var i = 0; i < jsons.length; i++ ){\n            var json = jsons[ i ];\n            var id = json.data.id;\n            var ele = cy.getElementById( id );\n\n            idInJson[ id ] = true;\n\n            if( ele.length !== 0 ){ // existing element should be updated\n              ele.json( json );\n            } else { // otherwise should be added\n              if( gr ){\n                cy.add( util.extend( { group: gr }, json ) );\n              } else {\n                cy.add( json );\n              }\n            }\n          }\n        };\n\n        if( is.array( obj.elements ) ){ // elements: []\n          updateEles( obj.elements );\n\n        } else { // elements: { nodes: [], edges: [] }\n          var grs = [ 'nodes', 'edges' ];\n          for( var i = 0; i < grs.length; i++ ){\n            var gr = grs[ i ];\n            var elements = obj.elements[ gr ];\n\n            if( is.array( elements ) ){\n              updateEles( elements, gr );\n            }\n          }\n        }\n\n        // elements not specified in json should be removed\n        eles.stdFilter( function( ele ){\n          return !idInJson[ ele.id() ];\n        } ).remove();\n      }\n\n      if( obj.style ){\n        cy.style( obj.style );\n      }\n\n      if( obj.zoom != null && obj.zoom !== _p.zoom ){\n        cy.zoom( obj.zoom );\n      }\n\n      if( obj.pan ){\n        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){\n          cy.pan( obj.pan );\n        }\n      }\n\n      var fields = [\n        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',\n        'panningEnabled', 'userPanningEnabled',\n        'boxSelectionEnabled',\n        'autolock', 'autoungrabify', 'autounselectify'\n      ];\n\n      for( var i = 0; i < fields.length; i++ ){\n        var f = fields[ i ];\n\n        if( obj[ f ] != null ){\n          cy[ f ]( obj[ f ] );\n        }\n      }\n\n      cy.endBatch();\n\n      return this; // chaining\n    } else if( obj === undefined ){ // get\n      var json = {};\n\n      json.elements = {};\n      eles.forEach( function( ele ){\n        var group = ele.group();\n\n        if( !json.elements[ group ] ){\n          json.elements[ group ] = [];\n        }\n\n        json.elements[ group ].push( ele.json() );\n      } );\n\n      if( this._private.styleEnabled ){\n        json.style = cy.style().json();\n      }\n\n      json.zoomingEnabled = cy._private.zoomingEnabled;\n      json.userZoomingEnabled = cy._private.userZoomingEnabled;\n      json.zoom = cy._private.zoom;\n      json.minZoom = cy._private.minZoom;\n      json.maxZoom = cy._private.maxZoom;\n      json.panningEnabled = cy._private.panningEnabled;\n      json.userPanningEnabled = cy._private.userPanningEnabled;\n      json.pan = util.copy( cy._private.pan );\n      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;\n      json.renderer = util.copy( cy._private.options.renderer );\n      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;\n      json.textureOnViewport = cy._private.options.textureOnViewport;\n      json.wheelSensitivity = cy._private.options.wheelSensitivity;\n      json.motionBlur = cy._private.options.motionBlur;\n\n      return json;\n    }\n  },\n\n  scratch: define.data( {\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true\n  } ),\n\n  removeScratch: define.removeData( {\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true\n  } )\n\n} );\n\n[\n  require( './add-remove' ),\n  require( './animation' ),\n  require( './events' ),\n  require( './export' ),\n  require( './layout' ),\n  require( './notification' ),\n  require( './renderer' ),\n  require( './search' ),\n  require( './style' ),\n  require( './viewport' )\n].forEach( function( props ){\n  util.extend( corefn, props );\n} );\n\nmodule.exports = Core;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/index.js\n ** module id = 31\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar math = require( '../math' );\n\nvar util = {\n\n  trueify: function(){ return true; },\n\n  falsify: function(){ return false; },\n\n  zeroify: function(){ return 0; },\n\n  noop: function(){},\n\n  /* jshint ignore:start */\n  error: function( msg ){\n    if( console.error ){\n      console.error.apply( console, arguments );\n\n      if( console.trace ){ console.trace(); }\n    } else {\n      console.log.apply( console, arguments );\n\n      if( console.trace ){ console.trace(); }\n    }\n  },\n  /* jshint ignore:end */\n\n  clone: function( obj ){\n    return this.extend( {}, obj );\n  },\n\n  // gets a shallow copy of the argument\n  copy: function( obj ){\n    if( obj == null ){\n      return obj;\n    } if( is.array( obj ) ){\n      return obj.slice();\n    } else if( is.plainObject( obj ) ){\n      return this.clone( obj );\n    } else {\n      return obj;\n    }\n  },\n\n  uuid: function(\n      a,b                // placeholders\n  ){\n      for(               // loop :)\n          b=a='';        // b - result , a - numeric variable\n          a++<36;        //\n          b+=a*51&52  // if \"a\" is not 9 or 14 or 19 or 24\n                      ?  //  return a random number or 4\n             (\n               a^15      // if \"a\" is not 15\n                  ?      // genetate a random number from 0 to 15\n               8^Math.random()*\n               (a^20?16:4)  // unless \"a\" is 20, in which case a random number from 8 to 11\n                  :\n               4            //  otherwise 4\n               ).toString(16)\n                      :\n             '-'            //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n          );\n      return b;\n  }\n\n};\n\nutil.makeBoundingBox = math.makeBoundingBox.bind( math );\n\nutil._staticEmptyObject = {};\n\nutil.staticEmptyObject = function(){\n  return util._staticEmptyObject;\n};\n\nutil.extend = Object.assign != null ? Object.assign : function( tgt ){\n  var args = arguments;\n\n  for( var i = 1; i < args.length; i++ ){\n    var obj = args[ i ];\n\n    if( !obj ){ continue; }\n\n    var keys = Object.keys( obj );\n\n    for( var j = 0; j < keys.length; j++ ){\n      var k = keys[j];\n\n      tgt[ k ] = obj[ k ];\n    }\n  }\n\n  return tgt;\n};\n\nutil.default = function( val, def ){\n  if( val === undefined ){\n    return def;\n  } else {\n    return val;\n  }\n};\n\nutil.removeFromArray = function( arr, ele, manyCopies ){\n  for( var i = arr.length; i >= 0; i-- ){\n    if( arr[i] === ele ){\n      arr.splice( i, 1 );\n\n      if( !manyCopies ){ break; }\n    }\n  }\n};\n\nutil.clearArray = function( arr ){\n  arr.splice( 0, arr.length );\n};\n\nutil.getPrefixedProperty = function( obj, propName, prefix ){\n  if( prefix ){\n    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  return obj[ propName ];\n};\n\nutil.setPrefixedProperty = function( obj, propName, prefix, value ){\n  if( prefix ){\n    propName = this.prependCamel( prefix, propName ); // e.g. (labelWidth, source) => sourceLabelWidth\n  }\n\n  obj[ propName ] = value;\n};\n\n[\n  require( './colors' ),\n  require( './maps' ),\n  { memoize: require( './memoize' ) },\n  require( './regex' ),\n  require( './strings' ),\n  require( './timing' )\n].forEach( function( req ){\n  util.extend( util, req );\n} );\n\nmodule.exports = util;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/util/index.js\n ** module id = 32\n ** module chunks = 0\n **/","'use strict';\n\nvar math = {};\n\nmath.arePositionsSame = function( p1, p2 ){\n  return p1.x === p2.x && p1.y === p2.y;\n};\n\nmath.copyPosition = function( p ){\n  return { x: p.x, y: p.y };\n};\n\nmath.array2point = function( arr ){\n  return {\n    x: arr[0],\n    y: arr[1]\n  };\n};\n\nmath.deg2rad = function( deg ){\n  return Math.PI * deg / 180;\n};\n\nmath.log2 = Math.log2 || function( n ){\n  return Math.log( n ) / Math.log( 2 );\n};\n\nmath.signum = function( x ){\n  if( x > 0 ){\n    return 1;\n  } else if( x < 0 ){\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nmath.dist = function( p1, p2 ){\n  return Math.sqrt( math.sqdist( p1, p2 ) );\n};\n\nmath.sqdist = function( p1, p2 ){\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n\n  return dx * dx + dy * dy;\n};\n\n// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves\nmath.qbezierAt = function( p0, p1, p2, t ){\n  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n};\n\nmath.qbezierPtAt = function( p0, p1, p2, t ){\n  return {\n    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),\n    y: math.qbezierAt( p0.y, p1.y, p2.y, t )\n  };\n};\n\nmath.lineAt = function( p0, p1, t, d ){\n  var vec = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n\n  var vecDist = math.dist( p0, p1 );\n\n  var normVec = {\n    x: vec.x / vecDist,\n    y: vec.y / vecDist\n  };\n\n  t = t == null ? 0 : t;\n\n  var d = d != null ? d : t * vecDist;\n\n  return {\n    x: p0.x + normVec.x * d,\n    y: p0.y + normVec.y * d\n  };\n};\n\nmath.lineAtDist = function( p0, p1, d ){\n  return math.lineAt( p0, p1, undefined, d );\n};\n\n// get angle at A via cosine law\nmath.triangleAngle = function( A, B, C ){\n  var a = math.dist( B, C );\n  var b = math.dist( A, C );\n  var c = math.dist( A, B );\n\n  return Math.acos( (a*a + b*b - c*c)/(2*a*b) );\n};\n\nmath.bound = function( min, val, max ){\n  return Math.max( min, Math.min( max, val ) );\n};\n\n// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\nmath.makeBoundingBox = function( bb ){\n  if( bb == null ){\n    return {\n      x1: Infinity,\n      y1: Infinity,\n      x2: -Infinity,\n      y2: -Infinity,\n      w: 0,\n      h: 0\n    };\n  } else if( bb.x1 != null && bb.y1 != null ){\n    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x2,\n        y2: bb.y2,\n        w: bb.x2 - bb.x1,\n        h: bb.y2 - bb.y1\n      };\n    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){\n      return {\n        x1: bb.x1,\n        y1: bb.y1,\n        x2: bb.x1 + bb.w,\n        y2: bb.y1 + bb.h,\n        w: bb.w,\n        h: bb.h\n      };\n    }\n  }\n};\n\nmath.updateBoundingBox = function( bb1, bb2 ){\n  // update bb1 with bb2 bounds\n\n  bb1.x1 = Math.min( bb1.x1, bb2.x1 );\n  bb1.x2 = Math.max( bb1.x2, bb2.x2 );\n  bb1.w = bb1.x2 - bb1.x1;\n\n  bb1.y1 = Math.min( bb1.y1, bb2.y1 );\n  bb1.y2 = Math.max( bb1.y2, bb2.y2 );\n  bb1.h = bb1.y2 - bb1.y1;\n};\n\nmath.expandBoundingBox = function( bb, padding ){\n  bb.x1 -= padding;\n  bb.x2 += padding;\n  bb.y1 -= padding;\n  bb.y2 += padding;\n  bb.w = bb.x2 - bb.x1;\n  bb.h = bb.y2 - bb.y1;\n\n  return bb;\n};\n\nmath.boundingBoxesIntersect = function( bb1, bb2 ){\n  // case: one bb to right of other\n  if( bb1.x1 > bb2.x2 ){ return false; }\n  if( bb2.x1 > bb1.x2 ){ return false; }\n\n  // case: one bb to left of other\n  if( bb1.x2 < bb2.x1 ){ return false; }\n  if( bb2.x2 < bb1.x1 ){ return false; }\n\n  // case: one bb above other\n  if( bb1.y2 < bb2.y1 ){ return false; }\n  if( bb2.y2 < bb1.y1 ){ return false; }\n\n  // case: one bb below other\n  if( bb1.y1 > bb2.y2 ){ return false; }\n  if( bb2.y1 > bb1.y2 ){ return false; }\n\n  // otherwise, must have some overlap\n  return true;\n};\n\nmath.inBoundingBox = function( bb, x, y ){\n  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n};\n\nmath.pointInBoundingBox = function( bb, pt ){\n  return this.inBoundingBox( bb, pt.x, pt.y );\n};\n\nmath.boundingBoxInBoundingBox = function( bb1, bb2 ){\n  return (\n       math.inBoundingBox( bb1, bb2.x1, bb2.y1 )\n    && math.inBoundingBox( bb1, bb2.x2, bb2.y2 )\n  );\n};\n\nmath.roundRectangleIntersectLine = function(\n  x, y, nodeX, nodeY, width, height, padding ){\n\n  var cornerRadius = this.getRoundRectangleRadius( width, height );\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n\n  // Check intersections with straight line segments\n  var straightLineIntersections;\n\n  // Top segment, left to right\n  {\n    var topStartX = nodeX - halfWidth + cornerRadius - padding;\n    var topStartY = nodeY - halfHeight - padding;\n    var topEndX = nodeX + halfWidth - cornerRadius + padding;\n    var topEndY = topStartY;\n\n    straightLineIntersections = this.finiteLinesIntersect(\n      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false );\n\n    if( straightLineIntersections.length > 0 ){\n      return straightLineIntersections;\n    }\n  }\n\n  // Right segment, top to bottom\n  {\n    var rightStartX = nodeX + halfWidth + padding;\n    var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n    var rightEndX = rightStartX;\n    var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n\n    straightLineIntersections = this.finiteLinesIntersect(\n      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false );\n\n    if( straightLineIntersections.length > 0 ){\n      return straightLineIntersections;\n    }\n  }\n\n  // Bottom segment, left to right\n  {\n    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n    var bottomStartY = nodeY + halfHeight + padding;\n    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n    var bottomEndY = bottomStartY;\n\n    straightLineIntersections = this.finiteLinesIntersect(\n      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false );\n\n    if( straightLineIntersections.length > 0 ){\n      return straightLineIntersections;\n    }\n  }\n\n  // Left segment, top to bottom\n  {\n    var leftStartX = nodeX - halfWidth - padding;\n    var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n    var leftEndX = leftStartX;\n    var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n\n    straightLineIntersections = this.finiteLinesIntersect(\n      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false );\n\n    if( straightLineIntersections.length > 0 ){\n      return straightLineIntersections;\n    }\n  }\n\n  // Check intersections with arc segments\n  var arcIntersections;\n\n  // Top Left\n  {\n    var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = this.intersectLineCircle(\n      x, y, nodeX, nodeY,\n      topLeftCenterX, topLeftCenterY, cornerRadius + padding );\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if( arcIntersections.length > 0\n      && arcIntersections[0] <= topLeftCenterX\n      && arcIntersections[1] <= topLeftCenterY ){\n      return [ arcIntersections[0], arcIntersections[1] ];\n    }\n  }\n\n  // Top Right\n  {\n    var topRightCenterX = nodeX + halfWidth - cornerRadius;\n    var topRightCenterY = nodeY - halfHeight + cornerRadius;\n    arcIntersections = this.intersectLineCircle(\n      x, y, nodeX, nodeY,\n      topRightCenterX, topRightCenterY, cornerRadius + padding );\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if( arcIntersections.length > 0\n      && arcIntersections[0] >= topRightCenterX\n      && arcIntersections[1] <= topRightCenterY ){\n      return [ arcIntersections[0], arcIntersections[1] ];\n    }\n  }\n\n  // Bottom Right\n  {\n    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = this.intersectLineCircle(\n      x, y, nodeX, nodeY,\n      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding );\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if( arcIntersections.length > 0\n      && arcIntersections[0] >= bottomRightCenterX\n      && arcIntersections[1] >= bottomRightCenterY ){\n      return [ arcIntersections[0], arcIntersections[1] ];\n    }\n  }\n\n  // Bottom Left\n  {\n    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n    arcIntersections = this.intersectLineCircle(\n      x, y, nodeX, nodeY,\n      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding );\n\n    // Ensure the intersection is on the desired quarter of the circle\n    if( arcIntersections.length > 0\n      && arcIntersections[0] <= bottomLeftCenterX\n      && arcIntersections[1] >= bottomLeftCenterY ){\n      return [ arcIntersections[0], arcIntersections[1] ];\n    }\n  }\n\n  return []; // if nothing\n};\n\nmath.inLineVicinity = function( x, y, lx1, ly1, lx2, ly2, tolerance ){\n  var t = tolerance;\n\n  var x1 = Math.min( lx1, lx2 );\n  var x2 = Math.max( lx1, lx2 );\n  var y1 = Math.min( ly1, ly2 );\n  var y2 = Math.max( ly1, ly2 );\n\n  return x1 - t <= x && x <= x2 + t\n    && y1 - t <= y && y <= y2 + t;\n};\n\nmath.inBezierVicinity = function(\n  x, y, x1, y1, x2, y2, x3, y3, tolerance ){\n\n  var bb = {\n    x1: Math.min( x1, x3, x2 ) - tolerance,\n    x2: Math.max( x1, x3, x2 ) + tolerance,\n    y1: Math.min( y1, y3, y2 ) - tolerance,\n    y2: Math.max( y1, y3, y2 ) + tolerance\n  };\n\n  // if outside the rough bounding box for the bezier, then it can't be a hit\n  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){\n    // console.log('bezier out of rough bb')\n    return false;\n  } else {\n    // console.log('do more expensive check');\n    return true;\n  }\n\n};\n\nmath.solveCubic = function( a, b, c, d, result ){\n\n  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n  // r is the real component, i is the imaginary component\n\n  // An implementation of the Cardano method from the year 1545\n  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n\n  b /= a;\n  c /= a;\n  d /= a;\n\n  var discriminant, q, r, dum1, s, t, term1, r13;\n\n  q = (3.0 * c - (b * b)) / 9.0;\n  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n  r /= 54.0;\n\n  discriminant = q * q * q + r * r;\n  result[1] = 0;\n  term1 = (b / 3.0);\n\n  if( discriminant > 0 ){\n    s = r + Math.sqrt( discriminant );\n    s = ((s < 0) ? -Math.pow( -s, (1.0 / 3.0) ) : Math.pow( s, (1.0 / 3.0) ));\n    t = r - Math.sqrt( discriminant );\n    t = ((t < 0) ? -Math.pow( -t, (1.0 / 3.0) ) : Math.pow( t, (1.0 / 3.0) ));\n    result[0] = -term1 + s + t;\n    term1 += (s + t) / 2.0;\n    result[4] = result[2] = -term1;\n    term1 = Math.sqrt( 3.0 ) * (-t + s) / 2;\n    result[3] = term1;\n    result[5] = -term1;\n    return;\n  }\n\n  result[5] = result[3] = 0;\n\n  if( discriminant === 0 ){\n    r13 = ((r < 0) ? -Math.pow( -r, (1.0 / 3.0) ) : Math.pow( r, (1.0 / 3.0) ));\n    result[0] = -term1 + 2.0 * r13;\n    result[4] = result[2] = -(r13 + term1);\n    return;\n  }\n\n  q = -q;\n  dum1 = q * q * q;\n  dum1 = Math.acos( r / Math.sqrt( dum1 ) );\n  r13 = 2.0 * Math.sqrt( q );\n  result[0] = -term1 + r13 * Math.cos( dum1 / 3.0 );\n  result[2] = -term1 + r13 * Math.cos( (dum1 + 2.0 * Math.PI) / 3.0 );\n  result[4] = -term1 + r13 * Math.cos( (dum1 + 4.0 * Math.PI) / 3.0 );\n\n  return;\n};\n\nmath.sqdistToQuadraticBezier = function(\n  x, y, x1, y1, x2, y2, x3, y3 ){\n\n  // Find minimum distance by using the minimum of the distance\n  // function between the given point and the curve\n\n  // This gives the coefficients of the resulting cubic equation\n  // whose roots tell us where a possible minimum is\n  // (Coefficients are divided by 4)\n\n  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3\n    + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n\n  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3\n    + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n\n  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x\n    + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n\n  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x\n    + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n\n  // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\n  var roots = [];\n\n  // Use the cubic solving algorithm\n  this.solveCubic( a, b, c, d, roots );\n\n  var zeroThreshold = 0.0000001;\n\n  var params = [];\n\n  for( var index = 0; index < 6; index += 2 ){\n    if( Math.abs( roots[ index + 1] ) < zeroThreshold\n        && roots[ index ] >= 0\n        && roots[ index ] <= 1.0 ){\n      params.push( roots[ index ] );\n    }\n  }\n\n  params.push( 1.0 );\n  params.push( 0.0 );\n\n  var minDistanceSquared = -1;\n  var closestParam;\n\n  var curX, curY, distSquared;\n  for( var i = 0; i < params.length; i++ ){\n    curX = Math.pow( 1.0 - params[ i ], 2.0 ) * x1\n      + 2.0 * (1 - params[ i ]) * params[ i ] * x2\n      + params[ i ] * params[ i ] * x3;\n\n    curY = Math.pow( 1 - params[ i ], 2.0 ) * y1\n      + 2 * (1.0 - params[ i ]) * params[ i ] * y2\n      + params[ i ] * params[ i ] * y3;\n\n    distSquared = Math.pow( curX - x, 2 ) + Math.pow( curY - y, 2 );\n    // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n    if( minDistanceSquared >= 0 ){\n      if( distSquared < minDistanceSquared ){\n        minDistanceSquared = distSquared;\n        closestParam = params[ i ];\n      }\n    } else {\n      minDistanceSquared = distSquared;\n      closestParam = params[ i ];\n    }\n  }\n\n  return minDistanceSquared;\n};\n\nmath.sqdistToFiniteLine = function( x, y, x1, y1, x2, y2 ){\n  var offset = [ x - x1, y - y1 ];\n  var line = [ x2 - x1, y2 - y1 ];\n\n  var lineSq = line[0] * line[0] + line[1] * line[1];\n  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n\n  var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n  var adjSq = dotProduct * dotProduct / lineSq;\n\n  if( dotProduct < 0 ){\n    return hypSq;\n  }\n\n  if( adjSq > lineSq ){\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n  }\n\n  return hypSq - adjSq;\n};\n\nmath.pointInsidePolygonPoints = function( x, y, points ){\n  var x1, y1, x2, y2;\n  var y3;\n\n  // Intersect with vertical line through (x, y)\n  var up = 0;\n  var down = 0;\n  for( var i = 0; i < points.length / 2; i++ ){\n\n    x1 = points[ i * 2];\n    y1 = points[ i * 2 + 1];\n\n    if( i + 1 < points.length / 2 ){\n      x2 = points[ (i + 1) * 2];\n      y2 = points[ (i + 1) * 2 + 1];\n    } else {\n      x2 = points[ (i + 1 - points.length / 2) * 2];\n      y2 = points[ (i + 1 - points.length / 2) * 2 + 1];\n    }\n\n    if( x1 == x && x2 == x ){\n\n    } else if( (x1 >= x && x >= x2)\n      || (x1 <= x && x <= x2) ){\n\n      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n\n      if( y3 > y ){\n        up++;\n      }\n\n      if( y3 < y ){\n        down++;\n      }\n\n    } else {\n      continue;\n    }\n\n  }\n\n  if( up % 2 === 0 ){\n    return false;\n  } else {\n    return true;\n  }\n};\n\nmath.pointInsidePolygon = function(\n  x, y, basePoints, centerX, centerY, width, height, direction, padding ){\n\n  //var direction = arguments[6];\n  var transformedPoints = new Array( basePoints.length );\n\n  // Gives negative angle\n  var angle;\n\n  if( direction[0] != null ){\n    angle = Math.atan( direction[1] / direction[0] );\n\n    if( direction[0] < 0 ){\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n  } else {\n    angle = direction;\n  }\n\n  var cos = Math.cos( -angle );\n  var sin = Math.sin( -angle );\n\n  //    console.log(\"base: \" + basePoints);\n  for( var i = 0; i < transformedPoints.length / 2; i++ ){\n    transformedPoints[ i * 2] =\n      width / 2 * (basePoints[ i * 2] * cos\n        - basePoints[ i * 2 + 1] * sin);\n\n    transformedPoints[ i * 2 + 1] =\n      height / 2 * (basePoints[ i * 2 + 1] * cos\n        + basePoints[ i * 2] * sin);\n\n    transformedPoints[ i * 2] += centerX;\n    transformedPoints[ i * 2 + 1] += centerY;\n  }\n\n  var points;\n\n  if( padding > 0 ){\n    var expandedLineSet = this.expandPolygon(\n      transformedPoints,\n      -padding );\n\n    points = this.joinLines( expandedLineSet );\n  } else {\n    points = transformedPoints;\n  }\n\n  return math.pointInsidePolygonPoints( x, y, points );\n};\n\nmath.joinLines = function( lineSet ){\n\n  var vertices = new Array( lineSet.length / 2 );\n\n  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n\n  for( var i = 0; i < lineSet.length / 4; i++ ){\n    currentLineStartX = lineSet[ i * 4];\n    currentLineStartY = lineSet[ i * 4 + 1];\n    currentLineEndX = lineSet[ i * 4 + 2];\n    currentLineEndY = lineSet[ i * 4 + 3];\n\n    if( i < lineSet.length / 4 - 1 ){\n      nextLineStartX = lineSet[ (i + 1) * 4];\n      nextLineStartY = lineSet[ (i + 1) * 4 + 1];\n      nextLineEndX = lineSet[ (i + 1) * 4 + 2];\n      nextLineEndY = lineSet[ (i + 1) * 4 + 3];\n    } else {\n      nextLineStartX = lineSet[0];\n      nextLineStartY = lineSet[1];\n      nextLineEndX = lineSet[2];\n      nextLineEndY = lineSet[3];\n    }\n\n    var intersection = this.finiteLinesIntersect(\n      currentLineStartX, currentLineStartY,\n      currentLineEndX, currentLineEndY,\n      nextLineStartX, nextLineStartY,\n      nextLineEndX, nextLineEndY,\n      true );\n\n    vertices[ i * 2] = intersection[0];\n    vertices[ i * 2 + 1] = intersection[1];\n  }\n\n  return vertices;\n};\n\nmath.expandPolygon = function( points, pad ){\n\n  var expandedLineSet = new Array( points.length * 2 );\n\n  var currentPointX, currentPointY, nextPointX, nextPointY;\n\n  for( var i = 0; i < points.length / 2; i++ ){\n    currentPointX = points[ i * 2];\n    currentPointY = points[ i * 2 + 1];\n\n    if( i < points.length / 2 - 1 ){\n      nextPointX = points[ (i + 1) * 2];\n      nextPointY = points[ (i + 1) * 2 + 1];\n    } else {\n      nextPointX = points[0];\n      nextPointY = points[1];\n    }\n\n    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n\n    // Assume CCW polygon winding\n\n    var offsetX = (nextPointY - currentPointY);\n    var offsetY = -(nextPointX - currentPointX);\n\n    // Normalize\n    var offsetLength = Math.sqrt( offsetX * offsetX + offsetY * offsetY );\n    var normalizedOffsetX = offsetX / offsetLength;\n    var normalizedOffsetY = offsetY / offsetLength;\n\n    expandedLineSet[ i * 4] = currentPointX + normalizedOffsetX * pad;\n    expandedLineSet[ i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n    expandedLineSet[ i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n    expandedLineSet[ i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n  }\n\n  return expandedLineSet;\n};\n\nmath.intersectLineEllipse = function(\n  x, y, centerX, centerY, ellipseWradius, ellipseHradius ){\n\n  var dispX = centerX - x;\n  var dispY = centerY - y;\n\n  dispX /= ellipseWradius;\n  dispY /= ellipseHradius;\n\n  var len = Math.sqrt( dispX * dispX + dispY * dispY );\n\n  var newLength = len - 1;\n\n  if( newLength < 0 ){\n    return [];\n  }\n\n  var lenProportion = newLength / len;\n\n  return [ (centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y ];\n};\n\n// Returns intersections of increasing distance from line's start point\nmath.intersectLineCircle = function(\n  x1, y1, x2, y2, centerX, centerY, radius ){\n\n  // Calculate d, direction vector of line\n  var d = [ x2 - x1, y2 - y1 ]; // Direction vector of line\n  var c = [ centerX, centerY ]; // Center of circle\n  var f = [ x1 - centerX, y1 - centerY ];\n\n  var a = d[0] * d[0] + d[1] * d[1];\n  var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;\n\n  var discriminant = b * b - 4 * a * c;\n\n  if( discriminant < 0 ){\n    return [];\n  }\n\n  var t1 = (-b + Math.sqrt( discriminant )) / (2 * a);\n  var t2 = (-b - Math.sqrt( discriminant )) / (2 * a);\n\n  var tMin = Math.min( t1, t2 );\n  var tMax = Math.max( t1, t2 );\n  var inRangeParams = [];\n\n  if( tMin >= 0 && tMin <= 1 ){\n    inRangeParams.push( tMin );\n  }\n\n  if( tMax >= 0 && tMax <= 1 ){\n    inRangeParams.push( tMax );\n  }\n\n  if( inRangeParams.length === 0 ){\n    return [];\n  }\n\n  var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n  var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n\n  if( inRangeParams.length > 1 ){\n\n    if( inRangeParams[0] == inRangeParams[1] ){\n      return [ nearIntersectionX, nearIntersectionY ];\n    } else {\n\n      var farIntersectionX = inRangeParams[1] * d[0] + x1;\n      var farIntersectionY = inRangeParams[1] * d[1] + y1;\n\n      return [ nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY ];\n    }\n\n  } else {\n    return [ nearIntersectionX, nearIntersectionY ];\n  }\n\n};\n\nmath.findCircleNearPoint = function( centerX, centerY,\n  radius, farX, farY ){\n\n  var displacementX = farX - centerX;\n  var displacementY = farY - centerY;\n  var distance = Math.sqrt( displacementX * displacementX\n    + displacementY * displacementY );\n\n  var unitDisplacementX = displacementX / distance;\n  var unitDisplacementY = displacementY / distance;\n\n  return [ centerX + unitDisplacementX * radius,\n    centerY + unitDisplacementY * radius ];\n};\n\nmath.findMaxSqDistanceToOrigin = function( points ){\n  var maxSqDistance = 0.000001;\n  var sqDistance;\n\n  for( var i = 0; i < points.length / 2; i++ ){\n\n    sqDistance = points[ i * 2] * points[ i * 2]\n      + points[ i * 2 + 1] * points[ i * 2 + 1];\n\n    if( sqDistance > maxSqDistance ){\n      maxSqDistance = sqDistance;\n    }\n  }\n\n  return maxSqDistance;\n};\n\nmath.finiteLinesIntersect = function(\n  x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines ){\n\n  var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n  var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n  var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n  if( u_b !== 0 ){\n    var ua = ua_t / u_b;\n    var ub = ub_t / u_b;\n\n    if( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ){\n      return [ x1 + ua * (x2 - x1), y1 + ua * (y2 - y1) ];\n\n    } else {\n      if( !infiniteLines ){\n        return [];\n      } else {\n        return [ x1 + ua * (x2 - x1), y1 + ua * (y2 - y1) ];\n      }\n    }\n  } else {\n    if( ua_t === 0 || ub_t === 0 ){\n\n      // Parallel, coincident lines. Check if overlap\n\n      // Check endpoint of second line\n      if( [ x1, x2, x4 ].sort()[1] === x4 ){\n        return [ x4, y4 ];\n      }\n\n      // Check start point of second line\n      if( [ x1, x2, x3 ].sort()[1] === x3 ){\n        return [ x3, y3 ];\n      }\n\n      // Endpoint of first line\n      if( [ x3, x4, x2 ].sort()[1] === x2 ){\n        return [ x2, y2 ];\n      }\n\n      return [];\n    } else {\n\n      // Parallel, non-coincident\n      return [];\n    }\n  }\n};\n\nmath.polygonIntersectLine = function(\n  x, y, basePoints, centerX, centerY, width, height, padding ){\n\n  var intersections = [];\n  var intersection;\n\n  var transformedPoints = new Array( basePoints.length );\n\n  for( var i = 0; i < transformedPoints.length / 2; i++ ){\n    transformedPoints[ i * 2] = basePoints[ i * 2] * width + centerX;\n    transformedPoints[ i * 2 + 1] = basePoints[ i * 2 + 1] * height + centerY;\n  }\n\n  var points;\n\n  if( padding > 0 ){\n    var expandedLineSet = math.expandPolygon(\n      transformedPoints,\n      -padding );\n\n    points = math.joinLines( expandedLineSet );\n  } else {\n    points = transformedPoints;\n  }\n  // var points = transformedPoints;\n\n  var currentX, currentY, nextX, nextY;\n\n  for( var i = 0; i < points.length / 2; i++ ){\n\n    currentX = points[ i * 2];\n    currentY = points[ i * 2 + 1];\n\n    if( i < points.length / 2 - 1 ){\n      nextX = points[ (i + 1) * 2];\n      nextY = points[ (i + 1) * 2 + 1];\n    } else {\n      nextX = points[0];\n      nextY = points[1];\n    }\n\n    intersection = this.finiteLinesIntersect(\n      x, y, centerX, centerY,\n      currentX, currentY,\n      nextX, nextY );\n\n    if( intersection.length !== 0 ){\n      intersections.push( intersection[0], intersection[1] );\n    }\n  }\n\n  return intersections;\n};\n\nmath.shortenIntersection = function(\n  intersection, offset, amount ){\n\n  var disp = [ intersection[0] - offset[0], intersection[1] - offset[1] ];\n\n  var length = Math.sqrt( disp[0] * disp[0] + disp[1] * disp[1] );\n\n  var lenRatio = (length - amount) / length;\n\n  if( lenRatio < 0 ){\n    lenRatio = 0.00001;\n  }\n\n  return [ offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1] ];\n};\n\nmath.generateUnitNgonPointsFitToSquare = function( sides, rotationRadians ){\n  var points = math.generateUnitNgonPoints( sides, rotationRadians );\n  points = math.fitPolygonToSquare( points );\n\n  return points;\n};\n\nmath.fitPolygonToSquare = function( points ){\n  var x, y;\n  var sides = points.length / 2;\n  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n\n  for( var i = 0; i < sides; i++ ){\n    x = points[2 * i ];\n    y = points[2 * i + 1];\n\n    minX = Math.min( minX, x );\n    maxX = Math.max( maxX, x );\n    minY = Math.min( minY, y );\n    maxY = Math.max( maxY, y );\n  }\n\n  // stretch factors\n  var sx = 2 / (maxX - minX);\n  var sy = 2 / (maxY - minY);\n\n  for( var i = 0; i < sides; i++ ){\n    x = points[2 * i ] = points[2 * i ] * sx;\n    y = points[2 * i + 1] = points[2 * i + 1] * sy;\n\n    minX = Math.min( minX, x );\n    maxX = Math.max( maxX, x );\n    minY = Math.min( minY, y );\n    maxY = Math.max( maxY, y );\n  }\n\n  if( minY < -1 ){\n    for( var i = 0; i < sides; i++ ){\n      y = points[2 * i + 1] = points[2 * i + 1] + (-1 - minY);\n    }\n  }\n\n  return points;\n};\n\nmath.generateUnitNgonPoints = function( sides, rotationRadians ){\n\n  var increment = 1.0 / sides * 2 * Math.PI;\n  var startAngle = sides % 2 === 0 ?\n    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n  //    console.log(nodeShapes['square']);\n  startAngle += rotationRadians;\n\n  var points = new Array( sides * 2 );\n\n  var currentAngle, x, y;\n  for( var i = 0; i < sides; i++ ){\n    currentAngle = i * increment + startAngle;\n\n    x = points[2 * i ] = Math.cos( currentAngle );// * (1 + i/2);\n    y = points[2 * i + 1] = Math.sin( -currentAngle );//  * (1 + i/2);\n  }\n\n  return points;\n};\n\nmath.getRoundRectangleRadius = function( width, height ){\n\n  // Set the default radius, unless half of width or height is smaller than default\n  return Math.min( width / 4, height / 4, 8 );\n};\n\nmodule.exports = math;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/math.js\n ** module id = 33\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\n\nmodule.exports = {\n  // get [r, g, b] from #abc or #aabbcc\n  hex2tuple: function( hex ){\n    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== '#' ){ return; }\n\n    var shortHex = hex.length === 4;\n    var r, g, b;\n    var base = 16;\n\n    if( shortHex ){\n      r = parseInt( hex[1] + hex[1], base );\n      g = parseInt( hex[2] + hex[2], base );\n      b = parseInt( hex[3] + hex[3], base );\n    } else {\n      r = parseInt( hex[1] + hex[2], base );\n      g = parseInt( hex[3] + hex[4], base );\n      b = parseInt( hex[5] + hex[6], base );\n    }\n\n    return [ r, g, b ];\n  },\n\n  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n  hsl2tuple: function( hsl ){\n    var ret;\n    var h, s, l, a, r, g, b;\n    function hue2rgb( p, q, t ){\n      if( t < 0 ) t += 1;\n      if( t > 1 ) t -= 1;\n      if( t < 1 / 6 ) return p + (q - p) * 6 * t;\n      if( t < 1 / 2 ) return q;\n      if( t < 2 / 3 ) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n\n    var m = new RegExp( '^' + this.regex.hsla + '$' ).exec( hsl );\n    if( m ){\n\n      // get hue\n      h = parseInt( m[1] );\n      if( h < 0 ){\n        h = ( 360 - (-1 * h % 360) ) % 360;\n      } else if( h > 360 ){\n        h = h % 360;\n      }\n      h /= 360; // normalise on [0, 1]\n\n      s = parseFloat( m[2] );\n      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]\n      s = s / 100; // normalise on [0, 1]\n\n      l = parseFloat( m[3] );\n      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]\n      l = l / 100; // normalise on [0, 1]\n\n      a = m[4];\n      if( a !== undefined ){\n        a = parseFloat( a );\n\n        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]\n      }\n\n      // now, convert to rgb\n      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n      if( s === 0 ){\n        r = g = b = Math.round( l * 255 ); // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = Math.round( 255 * hue2rgb( p, q, h + 1 / 3 ) );\n        g = Math.round( 255 * hue2rgb( p, q, h ) );\n        b = Math.round( 255 * hue2rgb( p, q, h - 1 / 3 ) );\n      }\n\n      ret = [ r, g, b, a ];\n    }\n\n    return ret;\n  },\n\n  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n  rgb2tuple: function( rgb ){\n    var ret;\n\n    var m = new RegExp( '^' + this.regex.rgba + '$' ).exec( rgb );\n    if( m ){\n      ret = [];\n\n      var isPct = [];\n      for( var i = 1; i <= 3; i++ ){\n        var channel = m[ i ];\n\n        if( channel[ channel.length - 1 ] === '%' ){\n          isPct[ i ] = true;\n        }\n        channel = parseFloat( channel );\n\n        if( isPct[ i ] ){\n          channel = channel / 100 * 255; // normalise to [0, 255]\n        }\n\n        if( channel < 0 || channel > 255 ){ return; } // invalid channel value\n\n        ret.push( Math.floor( channel ) );\n      }\n\n      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n      var allArePct = isPct[1] && isPct[2] && isPct[3];\n      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is\n\n      var alpha = m[4];\n      if( alpha !== undefined ){\n        alpha = parseFloat( alpha );\n\n        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value\n\n        ret.push( alpha );\n      }\n    }\n\n    return ret;\n  },\n\n  colorname2tuple: function( color ){\n    return this.colors[ color.toLowerCase() ];\n  },\n\n  color2tuple: function( color ){\n    return ( is.array( color ) ? color : null )\n      || this.colorname2tuple( color )\n      || this.hex2tuple( color )\n      || this.rgb2tuple( color )\n      || this.hsl2tuple( color );\n  },\n\n  colors: {\n    // special colour names\n    transparent: [0, 0, 0, 0], // NB alpha === 0\n\n    // regular colours\n    aliceblue: [ 240, 248, 255 ],\n    antiquewhite: [ 250, 235, 215 ],\n    aqua: [0, 255, 255 ],\n    aquamarine: [ 127, 255, 212 ],\n    azure: [ 240, 255, 255 ],\n    beige: [ 245, 245, 220 ],\n    bisque: [ 255, 228, 196 ],\n    black: [0, 0, 0],\n    blanchedalmond: [ 255, 235, 205 ],\n    blue: [0, 0, 255 ],\n    blueviolet: [ 138, 43, 226 ],\n    brown: [ 165, 42, 42 ],\n    burlywood: [ 222, 184, 135 ],\n    cadetblue: [ 95, 158, 160 ],\n    chartreuse: [ 127, 255, 0],\n    chocolate: [ 210, 105, 30 ],\n    coral: [ 255, 127, 80 ],\n    cornflowerblue: [ 100, 149, 237 ],\n    cornsilk: [ 255, 248, 220 ],\n    crimson: [ 220, 20, 60 ],\n    cyan: [0, 255, 255 ],\n    darkblue: [0, 0, 139 ],\n    darkcyan: [0, 139, 139 ],\n    darkgoldenrod: [ 184, 134, 11 ],\n    darkgray: [ 169, 169, 169 ],\n    darkgreen: [0, 100, 0],\n    darkgrey: [ 169, 169, 169 ],\n    darkkhaki: [ 189, 183, 107 ],\n    darkmagenta: [ 139, 0, 139 ],\n    darkolivegreen: [ 85, 107, 47 ],\n    darkorange: [ 255, 140, 0],\n    darkorchid: [ 153, 50, 204 ],\n    darkred: [ 139, 0, 0],\n    darksalmon: [ 233, 150, 122 ],\n    darkseagreen: [ 143, 188, 143 ],\n    darkslateblue: [ 72, 61, 139 ],\n    darkslategray: [ 47, 79, 79 ],\n    darkslategrey: [ 47, 79, 79 ],\n    darkturquoise: [0, 206, 209 ],\n    darkviolet: [ 148, 0, 211 ],\n    deeppink: [ 255, 20, 147 ],\n    deepskyblue: [0, 191, 255 ],\n    dimgray: [ 105, 105, 105 ],\n    dimgrey: [ 105, 105, 105 ],\n    dodgerblue: [ 30, 144, 255 ],\n    firebrick: [ 178, 34, 34 ],\n    floralwhite: [ 255, 250, 240 ],\n    forestgreen: [ 34, 139, 34 ],\n    fuchsia: [ 255, 0, 255 ],\n    gainsboro: [ 220, 220, 220 ],\n    ghostwhite: [ 248, 248, 255 ],\n    gold: [ 255, 215, 0],\n    goldenrod: [ 218, 165, 32 ],\n    gray: [ 128, 128, 128 ],\n    grey: [ 128, 128, 128 ],\n    green: [0, 128, 0],\n    greenyellow: [ 173, 255, 47 ],\n    honeydew: [ 240, 255, 240 ],\n    hotpink: [ 255, 105, 180 ],\n    indianred: [ 205, 92, 92 ],\n    indigo: [ 75, 0, 130 ],\n    ivory: [ 255, 255, 240 ],\n    khaki: [ 240, 230, 140 ],\n    lavender: [ 230, 230, 250 ],\n    lavenderblush: [ 255, 240, 245 ],\n    lawngreen: [ 124, 252, 0],\n    lemonchiffon: [ 255, 250, 205 ],\n    lightblue: [ 173, 216, 230 ],\n    lightcoral: [ 240, 128, 128 ],\n    lightcyan: [ 224, 255, 255 ],\n    lightgoldenrodyellow: [ 250, 250, 210 ],\n    lightgray: [ 211, 211, 211 ],\n    lightgreen: [ 144, 238, 144 ],\n    lightgrey: [ 211, 211, 211 ],\n    lightpink: [ 255, 182, 193 ],\n    lightsalmon: [ 255, 160, 122 ],\n    lightseagreen: [ 32, 178, 170 ],\n    lightskyblue: [ 135, 206, 250 ],\n    lightslategray: [ 119, 136, 153 ],\n    lightslategrey: [ 119, 136, 153 ],\n    lightsteelblue: [ 176, 196, 222 ],\n    lightyellow: [ 255, 255, 224 ],\n    lime: [0, 255, 0],\n    limegreen: [ 50, 205, 50 ],\n    linen: [ 250, 240, 230 ],\n    magenta: [ 255, 0, 255 ],\n    maroon: [ 128, 0, 0],\n    mediumaquamarine: [ 102, 205, 170 ],\n    mediumblue: [0, 0, 205 ],\n    mediumorchid: [ 186, 85, 211 ],\n    mediumpurple: [ 147, 112, 219 ],\n    mediumseagreen: [ 60, 179, 113 ],\n    mediumslateblue: [ 123, 104, 238 ],\n    mediumspringgreen: [0, 250, 154 ],\n    mediumturquoise: [ 72, 209, 204 ],\n    mediumvioletred: [ 199, 21, 133 ],\n    midnightblue: [ 25, 25, 112 ],\n    mintcream: [ 245, 255, 250 ],\n    mistyrose: [ 255, 228, 225 ],\n    moccasin: [ 255, 228, 181 ],\n    navajowhite: [ 255, 222, 173 ],\n    navy: [0, 0, 128 ],\n    oldlace: [ 253, 245, 230 ],\n    olive: [ 128, 128, 0],\n    olivedrab: [ 107, 142, 35 ],\n    orange: [ 255, 165, 0],\n    orangered: [ 255, 69, 0],\n    orchid: [ 218, 112, 214 ],\n    palegoldenrod: [ 238, 232, 170 ],\n    palegreen: [ 152, 251, 152 ],\n    paleturquoise: [ 175, 238, 238 ],\n    palevioletred: [ 219, 112, 147 ],\n    papayawhip: [ 255, 239, 213 ],\n    peachpuff: [ 255, 218, 185 ],\n    peru: [ 205, 133, 63 ],\n    pink: [ 255, 192, 203 ],\n    plum: [ 221, 160, 221 ],\n    powderblue: [ 176, 224, 230 ],\n    purple: [ 128, 0, 128 ],\n    red: [ 255, 0, 0],\n    rosybrown: [ 188, 143, 143 ],\n    royalblue: [ 65, 105, 225 ],\n    saddlebrown: [ 139, 69, 19 ],\n    salmon: [ 250, 128, 114 ],\n    sandybrown: [ 244, 164, 96 ],\n    seagreen: [ 46, 139, 87 ],\n    seashell: [ 255, 245, 238 ],\n    sienna: [ 160, 82, 45 ],\n    silver: [ 192, 192, 192 ],\n    skyblue: [ 135, 206, 235 ],\n    slateblue: [ 106, 90, 205 ],\n    slategray: [ 112, 128, 144 ],\n    slategrey: [ 112, 128, 144 ],\n    snow: [ 255, 250, 250 ],\n    springgreen: [0, 255, 127 ],\n    steelblue: [ 70, 130, 180 ],\n    tan: [ 210, 180, 140 ],\n    teal: [0, 128, 128 ],\n    thistle: [ 216, 191, 216 ],\n    tomato: [ 255, 99, 71 ],\n    turquoise: [ 64, 224, 208 ],\n    violet: [ 238, 130, 238 ],\n    wheat: [ 245, 222, 179 ],\n    white: [ 255, 255, 255 ],\n    whitesmoke: [ 245, 245, 245 ],\n    yellow: [ 255, 255, 0],\n    yellowgreen: [ 154, 205, 50 ]\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/util/colors.js\n ** module id = 34\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\n\nmodule.exports = {\n  // has anything been set in the map\n  mapEmpty: function( map ){\n    var empty = true;\n\n    if( map != null ){\n      return Object.keys( map ).length === 0;\n    }\n\n    return empty;\n  },\n\n  // pushes to the array at the end of a map (map may not be built)\n  pushMap: function( options ){\n    var array = this.getMap( options );\n\n    if( array == null ){ // if empty, put initial array\n      this.setMap( this.extend( {}, options, {\n        value: [ options.value ]\n      } ) );\n    } else {\n      array.push( options.value );\n    }\n  },\n\n  // sets the value in a map (map may not be built)\n  setMap: function( options ){\n    var obj = options.map;\n    var key;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for( var i = 0; i < l; i++ ){\n      var key = keys[ i ];\n\n      if( is.plainObject( key ) ){\n        this.error( 'Tried to set map with object key' );\n      }\n\n      if( i < keys.length - 1 ){\n\n        // extend the map if necessary\n        if( obj[ key ] == null ){\n          obj[ key ] = {};\n        }\n\n        obj = obj[ key ];\n      } else {\n        // set the value\n        obj[ key ] = options.value;\n      }\n    }\n  },\n\n  // gets the value in a map even if it's not built in places\n  getMap: function( options ){\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for( var i = 0; i < l; i++ ){\n      var key = keys[ i ];\n\n      if( is.plainObject( key ) ){\n        this.error( 'Tried to get map with object key' );\n      }\n\n      obj = obj[ key ];\n\n      if( obj == null ){\n        return obj;\n      }\n    }\n\n    return obj;\n  },\n\n  // deletes the entry in the map\n  deleteMap: function( options ){\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    var keepChildren = options.keepChildren;\n\n    for( var i = 0; i < l; i++ ){\n      var key = keys[ i ];\n\n      if( is.plainObject( key ) ){\n        this.error( 'Tried to delete map with object key' );\n      }\n\n      var lastKey = i === options.keys.length - 1;\n      if( lastKey ){\n\n        if( keepChildren ){ // then only delete child fields not in keepChildren\n          var children = Object.keys( obj );\n\n          for( var j = 0; j < children.length; j++ ){\n            var child = children[j];\n\n            if( !keepChildren[ child ] ){\n              obj[ child ] = undefined;\n            }\n          }\n        } else {\n          obj[ key ] = undefined;\n        }\n\n      } else {\n        obj = obj[ key ];\n      }\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/util/maps.js\n ** module id = 35\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function memoize( fn, keyFn ){\n  var cache = {};\n\n  if( !keyFn ){\n    keyFn = function(){\n      if( arguments.length === 1 ){\n        return arguments[0];\n      } else if( arguments.length === 0 ){\n        return 'undefined';\n      }\n\n      var args = [];\n\n      for( var i = 0; i < arguments.length; i++ ){\n        args.push( arguments[ i ] );\n      }\n\n      return args.join( '$' );\n    };\n  }\n\n  return function memoizedFn(){\n    var self = this;\n    var args = arguments;\n    var ret;\n    var k = keyFn.apply( self, args );\n\n    if( !(ret = cache[ k ]) ){\n      ret = cache[ k ] = fn.apply( self, args );\n    }\n\n    return ret;\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/util/memoize.js\n ** module id = 36\n ** module chunks = 0\n **/","'use strict';\n\nvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\n\nvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\nvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n\nvar hex3 = '\\\\#[0-9a-fA-F]{3}';\nvar hex6 = '\\\\#[0-9a-fA-F]{6}';\n\nmodule.exports = {\n  regex: {\n    number: number,\n    rgba: rgba,\n    rgbaNoBackRefs: rgbaNoBackRefs,\n    hsla: hsla,\n    hslaNoBackRefs: hslaNoBackRefs,\n    hex3: hex3,\n    hex6: hex6\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/util/regex.js\n ** module id = 37\n ** module chunks = 0\n **/","'use strict';\n\nvar memoize = require( './memoize' );\nvar is = require( '../is' );\n\nmodule.exports = {\n\n  camel2dash: memoize( function( str ){\n    return str.replace( /([A-Z])/g, function( v ){\n      return '-' + v.toLowerCase();\n    } );\n  } ),\n\n  dash2camel: memoize( function( str ){\n    return str.replace( /(-\\w)/g, function( v ){\n      return v[1].toUpperCase();\n    } );\n  } ),\n\n  prependCamel: memoize( function( prefix, str ){\n    return prefix + str[0].toUpperCase() + str.substring(1);\n  }, function( prefix, str ){\n    return prefix + '$' + str;\n  } ),\n\n  capitalize: function( str ){\n    if( is.emptyString( str ) ){\n      return str;\n    }\n\n    return str.charAt( 0 ).toUpperCase() + str.substring( 1 );\n  }\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/util/strings.js\n ** module id = 38\n ** module chunks = 0\n **/","'use strict';\n\nvar window = require( '../window' );\nvar is = require( '../is' );\nvar performance = window ? window.performance : null;\n\nvar util = {};\n\nvar raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||\n      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );\n\nraf = raf || function( fn ){\n  if( fn ){\n    setTimeout( function(){\n      fn( pnow() );\n    }, 1000 / 60 );\n  }\n};\n\nutil.requestAnimationFrame = function( fn ){\n  raf( fn );\n};\n\nvar pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };\n\nutil.performanceNow = pnow;\n\n// ported lodash throttle function\nutil.throttle = function( func, wait, options ){\n  var leading = true,\n      trailing = true;\n\n  if( options === false ){\n    leading = false;\n  } else if( is.plainObject( options ) ){\n    leading = 'leading' in options ? options.leading : leading;\n    trailing = 'trailing' in options ? options.trailing : trailing;\n  }\n  options = options || {};\n  options.leading = leading;\n  options.maxWait = wait;\n  options.trailing = trailing;\n\n  return util.debounce( func, wait, options );\n};\n\nutil.now = function(){\n  return Date.now();\n};\n\nutil.debounce = function( func, wait, options ){ // ported lodash debounce function\n  var util = this;\n  var args,\n      maxTimeoutId,\n      result,\n      stamp,\n      thisArg,\n      timeoutId,\n      trailingCall,\n      lastCalled = 0,\n      maxWait = false,\n      trailing = true;\n\n  if( !is.fn( func ) ){\n    return;\n  }\n  wait = Math.max( 0, wait ) || 0;\n  if( options === true ){\n    var leading = true;\n    trailing = false;\n  } else if( is.plainObject( options ) ){\n    leading = options.leading;\n    maxWait = 'maxWait' in options && (Math.max( wait, options.maxWait ) || 0);\n    trailing = 'trailing' in options ? options.trailing : trailing;\n  }\n  var delayed = function(){\n    var remaining = wait - (util.now() - stamp);\n    if( remaining <= 0 ){\n      if( maxTimeoutId ){\n        clearTimeout( maxTimeoutId );\n      }\n      var isCalled = trailingCall;\n      maxTimeoutId = timeoutId = trailingCall = undefined;\n      if( isCalled ){\n        lastCalled = util.now();\n        result = func.apply( thisArg, args );\n        if( !timeoutId && !maxTimeoutId ){\n          args = thisArg = null;\n        }\n      }\n    } else {\n      timeoutId = setTimeout( delayed, remaining );\n    }\n  };\n\n  var maxDelayed = function(){\n    if( timeoutId ){\n      clearTimeout( timeoutId );\n    }\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n    if( trailing || (maxWait !== wait) ){\n      lastCalled = util.now();\n      result = func.apply( thisArg, args );\n      if( !timeoutId && !maxTimeoutId ){\n        args = thisArg = null;\n      }\n    }\n  };\n\n  return function(){\n    args = arguments;\n    stamp = util.now();\n    thisArg = this;\n    trailingCall = trailing && (timeoutId || !leading);\n\n    if( maxWait === false ){\n      var leadingCall = leading && !timeoutId;\n    } else {\n      if( !maxTimeoutId && !leading ){\n        lastCalled = stamp;\n      }\n      var remaining = maxWait - (stamp - lastCalled),\n          isCalled = remaining <= 0;\n\n      if( isCalled ){\n        if( maxTimeoutId ){\n          maxTimeoutId = clearTimeout( maxTimeoutId );\n        }\n        lastCalled = stamp;\n        result = func.apply( thisArg, args );\n      }\n      else if( !maxTimeoutId ){\n        maxTimeoutId = setTimeout( maxDelayed, remaining );\n      }\n    }\n    if( isCalled && timeoutId ){\n      timeoutId = clearTimeout( timeoutId );\n    }\n    else if( !timeoutId && wait !== maxWait ){\n      timeoutId = setTimeout( delayed, wait );\n    }\n    if( leadingCall ){\n      isCalled = true;\n      result = func.apply( thisArg, args );\n    }\n    if( isCalled && !timeoutId && !maxTimeoutId ){\n      args = thisArg = null;\n    }\n    return result;\n  };\n};\n\nmodule.exports = util;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/util/timing.js\n ** module id = 39\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar is = require( '../is' );\n\nvar Element = require( './element' );\n\n// factory for generating edge ids when no id is specified for a new element\nvar idFactory = {\n  generate: function( cy, element, tryThisId ){\n    var id = tryThisId != null ? tryThisId : util.uuid();\n\n    while( cy.hasElementWithId( id ) ){\n      id = util.uuid();\n    }\n\n    return id;\n  }\n};\n\n// represents a set of nodes, edges, or both together\nvar Collection = function( cy, elements, options ){\n  if( cy === undefined || !is.core( cy ) ){\n    util.error( 'A collection must have a reference to the core' );\n    return;\n  }\n\n  var ids = {};\n  var indexes = {};\n  var createdElements = false;\n\n  if( !elements ){\n    elements = [];\n  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){\n    createdElements = true;\n\n    // make elements from json and restore all at once later\n    var eles = [];\n    var elesIds = {};\n\n    for( var i = 0, l = elements.length; i < l; i++ ){\n      var json = elements[ i ];\n\n      if( json.data == null ){\n        json.data = {};\n      }\n\n      var data = json.data;\n\n      // make sure newly created elements have valid ids\n      if( data.id == null ){\n        data.id = idFactory.generate( cy, json );\n      } else if( cy.hasElementWithId( data.id ) || elesIds[ data.id ] ){\n        continue; // can't create element if prior id already exists\n      }\n\n      var ele = new Element( cy, json, false );\n      eles.push( ele );\n      elesIds[ data.id ] = true;\n    }\n\n    elements = eles;\n  }\n\n  this.length = 0;\n\n  for( var i = 0, l = elements.length; i < l; i++ ){\n    var element = elements[ i ];\n    if( !element ){  continue; }\n\n    var id = element._private.data.id;\n\n    if( !options || (options.unique && !ids[ id ] ) ){\n      ids[ id ] = element;\n      indexes[ id ] = this.length;\n\n      this[ this.length ] = element;\n      this.length++;\n    }\n  }\n\n  this._private = {\n    cy: cy,\n    ids: ids,\n    indexes: indexes\n  };\n\n  // restore the elements if we created them from json\n  if( createdElements ){\n    this.restore();\n  }\n};\n\n// Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\nvar elesfn = Element.prototype = Collection.prototype;\n\nelesfn.instanceString = function(){\n  return 'collection';\n};\n\nelesfn.spawn = function( cy, eles, opts ){\n  if( !is.core( cy ) ){ // cy is optional\n    opts = eles;\n    eles = cy;\n    cy = this.cy();\n  }\n\n  return new Collection( cy, eles, opts );\n};\n\nelesfn.spawnSelf = function(){\n  return this.spawn( this );\n};\n\nelesfn.cy = function(){\n  return this._private.cy;\n};\n\nelesfn.element = function(){\n  return this[0];\n};\n\nelesfn.collection = function(){\n  if( is.collection( this ) ){\n    return this;\n  } else { // an element\n    return new Collection( this._private.cy, [ this ] );\n  }\n};\n\nelesfn.unique = function(){\n  return new Collection( this._private.cy, this, { unique: true } );\n};\n\nelesfn.hasElementWithId = function( id ){\n  return !!this._private.ids[ id ];\n};\n\nelesfn.getElementById = function( id ){\n  var cy = this._private.cy;\n  var ele = this._private.ids[ id ];\n\n  return ele ? ele : new Collection( cy ); // get ele or empty collection\n};\n\nelesfn.poolIndex = function(){\n  var cy = this._private.cy;\n  var eles = cy._private.elements;\n  var id = this._private.data.id;\n\n  return eles._private.indexes[ id ];\n},\n\nelesfn.json = function( obj ){\n  var ele = this.element();\n  var cy = this.cy();\n\n  if( ele == null && obj ){ return this; } // can't set to no eles\n\n  if( ele == null ){ return undefined; } // can't get from no eles\n\n  var p = ele._private;\n\n  if( is.plainObject( obj ) ){ // set\n\n    cy.startBatch();\n\n    if( obj.data ){\n      ele.data( obj.data );\n    }\n\n    if( obj.position ){\n      ele.position( obj.position );\n    }\n\n    // ignore group -- immutable\n\n    var checkSwitch = function( k, trueFnName, falseFnName ){\n      var obj_k = obj[ k ];\n\n      if( obj_k != null && obj_k !== p[ k ] ){\n        if( obj_k ){\n          ele[ trueFnName ]();\n        } else {\n          ele[ falseFnName ]();\n        }\n      }\n    };\n\n    checkSwitch( 'removed', 'remove', 'restore' );\n\n    checkSwitch( 'selected', 'select', 'unselect' );\n\n    checkSwitch( 'selectable', 'selectify', 'unselectify' );\n\n    checkSwitch( 'locked', 'lock', 'unlock' );\n\n    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );\n\n    if( obj.classes != null ){\n      ele.classes( obj.classes );\n    }\n\n    cy.endBatch();\n\n    return this;\n\n  } else if( obj === undefined ){ // get\n\n    var json = {\n      data: util.copy( p.data ),\n      position: util.copy( p.position ),\n      group: p.group,\n      removed: p.removed,\n      selected: p.selected,\n      selectable: p.selectable,\n      locked: p.locked,\n      grabbable: p.grabbable,\n      classes: null\n    };\n\n    json.classes = Object.keys( p.classes ).filter(function( cls ){\n      return p.classes[cls];\n    }).join(' ');\n\n    return json;\n  }\n};\n\nelesfn.jsons = function(){\n  var jsons = [];\n\n  for( var i = 0; i < this.length; i++ ){\n    var ele = this[ i ];\n    var json = ele.json();\n\n    jsons.push( json );\n  }\n\n  return jsons;\n};\n\nelesfn.clone = function(){\n  var cy = this.cy();\n  var elesArr = [];\n\n  for( var i = 0; i < this.length; i++ ){\n    var ele = this[ i ];\n    var json = ele.json();\n    var clone = new Element( cy, json, false ); // NB no restore\n\n    elesArr.push( clone );\n  }\n\n  return new Collection( cy, elesArr );\n};\nelesfn.copy = elesfn.clone;\n\nelesfn.restore = function( notifyRenderer ){\n  var self = this;\n  var cy = self.cy();\n  var cy_p = cy._private;\n\n  if( notifyRenderer === undefined ){\n    notifyRenderer = true;\n  }\n\n  // create arrays of nodes and edges, since we need to\n  // restore the nodes first\n  var nodes = [];\n  var edges = [];\n  var elements;\n  for( var i = 0, l = self.length; i < l; i++ ){\n    var ele = self[ i ];\n\n    if( !ele.removed() ){\n      // don't need to handle this ele\n      continue;\n    }\n\n    // keep nodes first in the array and edges after\n    if( ele.isNode() ){ // put to front of array if node\n      nodes.push( ele );\n    } else { // put to end of array if edge\n      edges.push( ele );\n    }\n  }\n\n  elements = nodes.concat( edges );\n\n  var i;\n  var removeFromElements = function(i){\n    elements.splice( i, 1 );\n    i--;\n  };\n\n  // now, restore each element\n  for( i = 0, l = elements.length; i < l; i++ ){\n    var ele = elements[ i ];\n\n    var _private = ele._private;\n    var data = _private.data;\n\n    // the traversal cache should start fresh when ele is added\n    _private.traversalCache = null;\n\n    // set id and validate\n    if( data.id === undefined ){\n      data.id = idFactory.generate( cy, ele );\n\n    } else if( is.number( data.id ) ){\n      data.id = '' + data.id; // now it's a string\n\n    } else if( is.emptyString( data.id ) || !is.string( data.id ) ){\n      util.error( 'Can not create element with invalid string ID `' + data.id + '`' );\n\n      // can't create element if it has empty string as id or non-string id\n      removeFromElements(i);\n      continue;\n    } else if( cy.hasElementWithId( data.id ) ){\n      util.error( 'Can not create second element with ID `' + data.id + '`' );\n\n      // can't create element if one already has that id\n      removeFromElements(i);\n      continue;\n    }\n\n    var id = data.id; // id is finalised, now let's keep a ref\n\n    if( ele.isNode() ){ // extra checks for nodes\n      var node = ele;\n      var pos = _private.position;\n\n      // make sure the nodes have a defined position\n\n      if( pos.x == null ){\n        pos.x = 0;\n      }\n\n      if( pos.y == null ){\n        pos.y = 0;\n      }\n    }\n\n    if( ele.isEdge() ){ // extra checks for edges\n\n      var edge = ele;\n      var fields = [ 'source', 'target' ];\n      var fieldsLength = fields.length;\n      var badSourceOrTarget = false;\n      for( var j = 0; j < fieldsLength; j++ ){\n\n        var field = fields[ j ];\n        var val = data[ field ];\n\n        if( is.number( val ) ){\n          val = data[ field ] = '' + data[ field ]; // now string\n        }\n\n        if( val == null || val === '' ){\n          // can't create if source or target is not defined properly\n          util.error( 'Can not create edge `' + id + '` with unspecified ' + field );\n          badSourceOrTarget = true;\n        } else if( !cy.hasElementWithId( val ) ){\n          // can't create edge if one of its nodes doesn't exist\n          util.error( 'Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`' );\n          badSourceOrTarget = true;\n        }\n      }\n\n      if( badSourceOrTarget ){ removeFromElements(i); continue; } // can't create this\n\n      var src = cy.getElementById( data.source );\n      var tgt = cy.getElementById( data.target );\n\n      src._private.edges.push( edge );\n      tgt._private.edges.push( edge );\n\n      edge._private.source = src;\n      edge._private.target = tgt;\n    } // if is edge\n\n    // create mock ids / indexes maps for element so it can be used like collections\n    _private.ids = {};\n    _private.ids[ id ] = ele;\n    _private.indexes = {};\n    _private.indexes[ id ] = ele;\n\n    _private.removed = false;\n    cy.addToPool( ele );\n  } // for each element\n\n  // do compound node sanity checks\n  for( var i = 0; i < nodes.length; i++ ){ // each node\n    var node = nodes[ i ];\n    var data = node._private.data;\n\n    if( is.number( data.parent ) ){ // then automake string\n      data.parent = '' + data.parent;\n    }\n\n    var parentId = data.parent;\n\n    var specifiedParent = parentId != null;\n\n    if( specifiedParent ){\n      var parent = cy.getElementById( parentId );\n\n      if( parent.empty() ){\n        // non-existant parent; just remove it\n        data.parent = undefined;\n      } else {\n        var selfAsParent = false;\n        var ancestor = parent;\n        while( !ancestor.empty() ){\n          if( node.same( ancestor ) ){\n            // mark self as parent and remove from data\n            selfAsParent = true;\n            data.parent = undefined; // remove parent reference\n\n            // exit or we loop forever\n            break;\n          }\n\n          ancestor = ancestor.parent();\n        }\n\n        if( !selfAsParent ){\n          // connect with children\n          parent[0]._private.children.push( node );\n          node._private.parent = parent[0];\n\n          // let the core know we have a compound graph\n          cy_p.hasCompoundNodes = true;\n        }\n      } // else\n    } // if specified parent\n  } // for each node\n\n  if( elements.length > 0 ){\n    var restored = new Collection( cy, elements );\n\n    for( var i = 0; i < restored.length; i++ ){\n      var ele = restored[i];\n\n      if( ele.isNode() ){ continue; }\n\n      // adding an edge invalidates the traversal caches for the parallel edges\n      var pedges = ele.parallelEdges();\n      for( var j = 0; j < pedges.length; j++ ){\n        pedges[j]._private.traversalCache = null;\n      }\n\n      // adding an edge invalidates the traversal cache for the connected nodes\n      ele.source()[0]._private.traversalCache = null;\n      ele.target()[0]._private.traversalCache = null;\n    }\n\n    var toUpdateStyle;\n\n    if( cy_p.hasCompoundNodes ){\n      toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );\n    } else {\n      toUpdateStyle = restored;\n    }\n\n    toUpdateStyle.updateStyle( notifyRenderer );\n\n    if( notifyRenderer ){\n      restored.rtrigger( 'add' );\n    } else {\n      restored.trigger( 'add' );\n    }\n  }\n\n  return self; // chainability\n};\n\nelesfn.removed = function(){\n  var ele = this[0];\n  return ele && ele._private.removed;\n};\n\nelesfn.inside = function(){\n  var ele = this[0];\n  return ele && !ele._private.removed;\n};\n\nelesfn.remove = function( notifyRenderer ){\n  var self = this;\n  var removed = [];\n  var elesToRemove = [];\n  var elesToRemoveIds = {};\n  var cy = self._private.cy;\n\n  if( notifyRenderer === undefined ){\n    notifyRenderer = true;\n  }\n\n  // add connected edges\n  function addConnectedEdges( node ){\n    var edges = node._private.edges;\n    for( var i = 0; i < edges.length; i++ ){\n      add( edges[ i ] );\n    }\n  }\n\n\n  // add descendant nodes\n  function addChildren( node ){\n    var children = node._private.children;\n\n    for( var i = 0; i < children.length; i++ ){\n      add( children[ i ] );\n    }\n  }\n\n  function add( ele ){\n    var alreadyAdded =  elesToRemoveIds[ ele.id() ];\n    if( alreadyAdded ){\n      return;\n    } else {\n      elesToRemoveIds[ ele.id() ] = true;\n    }\n\n    if( ele.isNode() ){\n      elesToRemove.push( ele ); // nodes are removed last\n\n      addConnectedEdges( ele );\n      addChildren( ele );\n    } else {\n      elesToRemove.unshift( ele ); // edges are removed first\n    }\n  }\n\n  // make the list of elements to remove\n  // (may be removing more than specified due to connected edges etc)\n\n  for( var i = 0, l = self.length; i < l; i++ ){\n    var ele = self[ i ];\n\n    add( ele );\n  }\n\n  function removeEdgeRef( node, edge ){\n    var connectedEdges = node._private.edges;\n\n    util.removeFromArray( connectedEdges, edge );\n\n    // removing an edges invalidates the traversal cache for its nodes\n    node._private.traversalCache = null;\n  }\n\n  function removeParallelRefs( edge ){\n    // removing an edge invalidates the traversal caches for the parallel edges\n    var pedges = edge.parallelEdges();\n    for( var j = 0; j < pedges.length; j++ ){\n      pedges[j]._private.traversalCache = null;\n    }\n  }\n\n  var alteredParents = [];\n  alteredParents.ids = {};\n\n  function removeChildRef( parent, ele ){\n    ele = ele[0];\n    parent = parent[0];\n\n    var children = parent._private.children;\n    var pid = parent.id();\n\n    util.removeFromArray( children, ele );\n\n    if( !alteredParents.ids[ pid ] ){\n      alteredParents.ids[ pid ] = true;\n      alteredParents.push( parent );\n    }\n  }\n\n  // remove from core pool\n  cy.removeFromPool( elesToRemove );\n\n  for( var i = 0; i < elesToRemove.length; i++ ){\n    var ele = elesToRemove[ i ];\n\n    // mark as removed\n    ele._private.removed = true;\n\n    // add to list of removed elements\n    removed.push( ele );\n\n    if( ele.isEdge() ){ // remove references to this edge in its connected nodes\n      var src = ele.source()[0];\n      var tgt = ele.target()[0];\n\n      removeEdgeRef( src, ele );\n      removeEdgeRef( tgt, ele );\n      removeParallelRefs( ele );\n\n    } else { // remove reference to parent\n      var parent = ele.parent();\n\n      if( parent.length !== 0 ){\n        removeChildRef( parent, ele );\n      }\n    }\n  }\n\n  // check to see if we have a compound graph or not\n  var elesStillInside = cy._private.elements;\n  cy._private.hasCompoundNodes = false;\n  for( var i = 0; i < elesStillInside.length; i++ ){\n    var ele = elesStillInside[ i ];\n\n    if( ele.isParent() ){\n      cy._private.hasCompoundNodes = true;\n      break;\n    }\n  }\n\n  var removedElements = new Collection( this.cy(), removed );\n  if( removedElements.size() > 0 ){\n    // must manually notify since trigger won't do this automatically once removed\n\n    if( notifyRenderer ){\n      this.cy().notify( {\n        type: 'remove',\n        eles: removedElements\n      } );\n    }\n\n    removedElements.trigger( 'remove' );\n  }\n\n  // the parents who were modified by the removal need their style updated\n  for( var i = 0; i < alteredParents.length; i++ ){\n    var ele = alteredParents[ i ];\n\n    if( !ele.removed() ){\n      ele.updateStyle();\n    }\n  }\n\n  return new Collection( cy, removed );\n};\n\nelesfn.move = function( struct ){\n  var cy = this._private.cy;\n\n  if( struct.source !== undefined || struct.target !== undefined ){\n    var srcId = struct.source;\n    var tgtId = struct.target;\n    var srcExists = cy.hasElementWithId( srcId );\n    var tgtExists = cy.hasElementWithId( tgtId );\n\n    if( srcExists || tgtExists ){\n      var jsons = this.jsons();\n\n      this.remove();\n\n      for( var i = 0; i < jsons.length; i++ ){\n        var json = jsons[ i ];\n\n        if( json.group === 'edges' ){\n          if( srcExists ){ json.data.source = srcId; }\n          if( tgtExists ){ json.data.target = tgtId; }\n        }\n      }\n\n      return cy.add( jsons );\n    }\n\n  } else if( struct.parent !== undefined ){ // move node to new parent\n    var parentId = struct.parent;\n    var parentExists = parentId === null || cy.hasElementWithId( parentId );\n\n    if( parentExists ){\n      var jsons = this.jsons();\n      var descs = this.descendants();\n      var descsEtc = descs.union( descs.union( this ).connectedEdges() );\n\n      this.remove(); // NB: also removes descendants and their connected edges\n\n      for( var i = 0; i < this.length; i++ ){\n        var json = jsons[ i ];\n\n        if( json.group === 'nodes' ){\n          json.data.parent = parentId === null ? undefined : parentId;\n        }\n      }\n\n      return cy.add( jsons ).union( descsEtc.restore() );\n    }\n  }\n\n  return this; // if nothing done\n};\n\n[\n  require( './algorithms' ),\n  require( './animation' ),\n  require( './class' ),\n  require( './comparators' ),\n  require( './compounds' ),\n  require( './data' ),\n  require( './degree' ),\n  require( './dimensions' ),\n  require( './events' ),\n  require( './filter' ),\n  require( './group' ),\n  require( './index' ),\n  require( './iteration' ),\n  require( './layout' ),\n  require( './style' ),\n  require( './switch-functions' ),\n  require( './traversing' )\n].forEach( function( props ){\n  util.extend( elesfn, props );\n} );\n\nmodule.exports = Collection;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/index.js\n ** module id = 40\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar is = require( '../is' );\n\n// represents a node or an edge\nvar Element = function( cy, params, restore ){\n  var self = this;\n  restore = (restore === undefined || restore ? true : false);\n\n  if( cy === undefined || params === undefined || !is.core( cy ) ){\n    util.error( 'An element must have a core reference and parameters set' );\n    return;\n  }\n\n  var group = params.group;\n\n  // try to automatically infer the group if unspecified\n  if( group == null ){\n    if( params.data && params.data.source != null && params.data.target != null ){\n      group = 'edges';\n    } else {\n      group = 'nodes';\n    }\n  }\n\n  // validate group\n  if( group !== 'nodes' && group !== 'edges' ){\n    util.error( 'An element must be of type `nodes` or `edges`; you specified `' + group + '`' );\n    return;\n  }\n\n  // make the element array-like, just like a collection\n  this.length = 1;\n  this[0] = this;\n\n  // NOTE: when something is added here, add also to ele.json()\n  this._private = {\n    cy: cy,\n    single: true, // indicates this is an element\n    data: params.data || {}, // data object\n    position: params.position || {}, // (x, y) position pair\n    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value\n    autoHeight: undefined,\n    listeners: [], // array of bound listeners\n    group: group, // string; 'nodes' or 'edges'\n    style: {}, // properties as set by the style\n    rstyle: {}, // properties for style sent from the renderer to the core\n    styleCxts: [], // applied style contexts from the styler\n    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)\n    selected: params.selected ? true : false, // whether it's selected\n    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable\n    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)\n    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately\n    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed\n    active: false, // whether the element is active from user interaction\n    classes: {}, // map ( className => true )\n    animation: { // object for currently-running animations\n      current: [],\n      queue: []\n    },\n    rscratch: {}, // object in which the renderer can store information\n    scratch: params.scratch || {}, // scratch objects\n    edges: [], // array of connected edges\n    children: [], // array of children\n    traversalCache: {} // cache of output of traversal functions\n  };\n\n  // renderedPosition overrides if specified\n  if( params.renderedPosition ){\n    var rpos = params.renderedPosition;\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n\n    this._private.position = {\n      x: (rpos.x - pan.x) / zoom,\n      y: (rpos.y - pan.y) / zoom\n    };\n  }\n\n  if( is.string( params.classes ) ){\n    var classes = params.classes.split( /\\s+/ );\n    for( var i = 0, l = classes.length; i < l; i++ ){\n      var cls = classes[ i ];\n      if( !cls || cls === '' ){ continue; }\n\n      self._private.classes[ cls ] = true;\n    }\n  }\n\n  if( params.style || params.css ){\n    cy.style().applyBypass( this, params.style || params.css );\n  }\n\n  if( restore === undefined || restore ){\n    this.restore();\n  }\n\n};\n\nmodule.exports = Element;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/element.js\n ** module id = 41\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\n\nvar elesfn = {};\n\n[\n  require( './bfs-dfs' ),\n  require( './dijkstra' ),\n  require( './kruskal' ),\n  require( './a-star' ),\n  require( './floyd-warshall' ),\n  require( './bellman-ford' ),\n  require( './kerger-stein' ),\n  require( './page-rank' ),\n  require( './degree-centrality' ),\n  require( './closeness-centrality' ),\n  require( './betweenness-centrality' )\n].forEach( function( props ){\n  util.extend( elesfn, props );\n} );\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/index.js\n ** module id = 42\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\n\nvar defineSearch = function( params ){\n  params = {\n    bfs: params.bfs || !params.dfs,\n    dfs: params.dfs || !params.bfs\n  };\n\n  // from pseudocode on wikipedia\n  return function searchFn( roots, fn, directed ){\n    var options;\n    var std;\n    var thisArg;\n    if( is.plainObject( roots ) && !is.elementOrCollection( roots ) ){\n      options = roots;\n      roots = options.roots || options.root;\n      fn = options.visit;\n      directed = options.directed;\n      std = options.std;\n      thisArg = options.thisArg;\n    }\n\n    directed = arguments.length === 2 && !is.fn( fn ) ? fn : directed;\n    fn = is.fn( fn ) ? fn : function(){};\n\n    var cy = this._private.cy;\n    var v = roots = is.string( roots ) ? this.filter( roots ) : roots;\n    var Q = [];\n    var connectedNodes = [];\n    var connectedBy = {};\n    var id2depth = {};\n    var V = {};\n    var j = 0;\n    var found;\n    var nodes = this.nodes();\n    var edges = this.edges();\n\n    // enqueue v\n    for( var i = 0; i < v.length; i++ ){\n      if( v[ i ].isNode() ){\n        Q.unshift( v[ i ] );\n\n        if( params.bfs ){\n          V[ v[ i ].id() ] = true;\n\n          connectedNodes.push( v[ i ] );\n        }\n\n        id2depth[ v[ i ].id() ] = 0;\n      }\n    }\n\n    while( Q.length !== 0 ){\n      var v = params.bfs ? Q.shift() : Q.pop();\n\n      if( params.dfs ){\n        if( V[ v.id() ] ){ continue; }\n\n        V[ v.id() ] = true;\n\n        connectedNodes.push( v );\n      }\n\n      var depth = id2depth[ v.id() ];\n      var prevEdge = connectedBy[ v.id() ];\n      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];\n      var ret;\n\n      if( std ){\n        ret = fn.call( thisArg, v, prevEdge, prevNode, j++, depth );\n      } else {\n        ret = fn.call( v, j++, depth, v, prevEdge, prevNode );\n      }\n\n      if( ret === true ){\n        found = v;\n        break;\n      }\n\n      if( ret === false ){\n        break;\n      }\n\n      var vwEdges = v.connectedEdges( directed ? function(){ return this.data( 'source' ) === v.id(); } : undefined ).intersect( edges );\n      for( var i = 0; i < vwEdges.length; i++ ){\n        var e = vwEdges[ i ];\n        var w = e.connectedNodes( function(){ return this.id() !== v.id(); } ).intersect( nodes );\n\n        if( w.length !== 0 && !V[ w.id() ] ){\n          w = w[0];\n\n          Q.push( w );\n\n          if( params.bfs ){\n            V[ w.id() ] = true;\n\n            connectedNodes.push( w );\n          }\n\n          connectedBy[ w.id() ] = e;\n\n          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;\n        }\n      }\n\n    }\n\n    var connectedEles = [];\n\n    for( var i = 0; i < connectedNodes.length; i++ ){\n      var node = connectedNodes[ i ];\n      var edge = connectedBy[ node.id() ];\n\n      if( edge ){\n        connectedEles.push( edge );\n      }\n\n      connectedEles.push( node );\n    }\n\n    return {\n      path: cy.collection( connectedEles, { unique: true } ),\n      found: cy.collection( found )\n    };\n  };\n};\n\n// search, spanning trees, etc\nvar elesfn = ({\n  breadthFirstSearch: defineSearch( { bfs: true } ),\n  depthFirstSearch: defineSearch( { dfs: true } )\n});\n\n// nice, short mathemathical alias\nelesfn.bfs = elesfn.breadthFirstSearch;\nelesfn.dfs = elesfn.depthFirstSearch;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/bfs-dfs.js\n ** module id = 43\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\nvar Heap = require( '../../heap' );\n\nvar elesfn = ({\n\n  dijkstra: function( root, weightFn, directed ){\n    var options;\n    if( is.plainObject( root ) && !is.elementOrCollection( root ) ){\n      options = root;\n      root = options.root;\n      weightFn = options.weight;\n      directed = options.directed;\n    }\n\n    var cy = this._private.cy;\n    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\n    var source = is.string( root ) ? this.filter( root )[0] : root[0];\n    var dist = {};\n    var prev = {};\n    var knownDist = {};\n\n    var edges = this.edges().filter( function(){ return !this.isLoop(); } );\n    var nodes = this.nodes();\n\n    var getDist = function( node ){\n      return dist[ node.id() ];\n    };\n\n    var setDist = function( node, d ){\n      dist[ node.id() ] = d;\n\n      Q.updateItem( node );\n    };\n\n    var Q = new Heap( function( a, b ){\n      return getDist( a ) - getDist( b );\n    } );\n\n    for( var i = 0; i < nodes.length; i++ ){\n      var node = nodes[ i ];\n\n      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;\n      Q.push( node );\n    }\n\n    var distBetween = function( u, v ){\n      var uvs = ( directed ? u.edgesTo( v ) : u.edgesWith( v ) ).intersect( edges );\n      var smallestDistance = Infinity;\n      var smallestEdge;\n\n      for( var i = 0; i < uvs.length; i++ ){\n        var edge = uvs[ i ];\n        var weight = weightFn.apply( edge, [ edge ] );\n\n        if( weight < smallestDistance || !smallestEdge ){\n          smallestDistance = weight;\n          smallestEdge = edge;\n        }\n      }\n\n      return {\n        edge: smallestEdge,\n        dist: smallestDistance\n      };\n    };\n\n    while( Q.size() > 0 ){\n      var u = Q.pop();\n      var smalletsDist = getDist( u );\n      var uid = u.id();\n\n      knownDist[ uid ] = smalletsDist;\n\n      if( smalletsDist === Math.Infinite ){\n        break;\n      }\n\n      var neighbors = u.neighborhood().intersect( nodes );\n      for( var i = 0; i < neighbors.length; i++ ){\n        var v = neighbors[ i ];\n        var vid = v.id();\n        var vDist = distBetween( u, v );\n\n        var alt = smalletsDist + vDist.dist;\n\n        if( alt < getDist( v ) ){\n          setDist( v, alt );\n\n          prev[ vid ] = {\n            node: u,\n            edge: vDist.edge\n          };\n        }\n      } // for\n    } // while\n\n    return {\n      distanceTo: function( node ){\n        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];\n\n        return knownDist[ target.id() ];\n      },\n\n      pathTo: function( node ){\n        var target = is.string( node ) ? nodes.filter( node )[0] : node[0];\n        var S = [];\n        var u = target;\n\n        if( target.length > 0 ){\n          S.unshift( target );\n\n          while( prev[ u.id() ] ){\n            var p = prev[ u.id() ];\n\n            S.unshift( p.edge );\n            S.unshift( p.node );\n\n            u = p.node;\n          }\n        }\n\n        return cy.collection( S );\n      }\n    };\n  }\n});\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/dijkstra.js\n ** module id = 44\n ** module chunks = 0\n **/","/*!\nPorted by Xueqiao Xu <xueqiaoxu@gmail.com>;\n\nPSF LICENSE AGREEMENT FOR PYTHON 2.7.2\n\n1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or Organization (“Licensee”) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.\n2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSF’s License Agreement and PSF’s notice of copyright, i.e., “Copyright © 2001-2012 Python Software Foundation; All Rights Reserved” are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.\n3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.\n4. PSF is making Python 2.7.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.\n5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\n6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.\n7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.\n8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.\n*/\n\n'use strict';\n/* jshint ignore:start */\n\n// Generated by CoffeeScript 1.8.0\n(function(){\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function( x, y ){\n    if( x < y ){\n      return -1;\n    }\n    if( x > y ){\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n\n  If x is already in a, insert it to the right of the rightmost x.\n\n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function( a, x, lo, hi, cmp ){\n    var mid;\n    if( lo == null ){\n      lo = 0;\n    }\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    if( lo < 0 ){\n      throw new Error( 'lo must be non-negative' );\n    }\n    if( hi == null ){\n      hi = a.length;\n    }\n    while( lo < hi ){\n      mid = floor( (lo + hi) / 2 );\n      if( cmp( x, a[ mid ] ) < 0 ){\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply( a, [ lo, lo - lo ].concat( x ) ), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function( array, item, cmp ){\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    array.push( item );\n    return _siftdown( array, 0, array.length - 1, cmp );\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function( array, cmp ){\n    var lastelt, returnitem;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if( array.length ){\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup( array, 0, cmp );\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n\n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function( array, item, cmp ){\n    var returnitem;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup( array, 0, cmp );\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function( array, item, cmp ){\n    var _ref;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    if( array.length && cmp( array[0], item ) < 0 ){\n      _ref = [ array[0], item ], item = _ref[0], array[0] = _ref[1];\n      _siftup( array, 0, cmp );\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function( array, cmp ){\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    _ref1 = (function(){\n      _results1 = [];\n      for( var _j = 0, _ref = floor( array.length / 2 ); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j-- ){ _results1.push( _j ); }\n      return _results1;\n    }).apply( this ).reverse();\n    _results = [];\n    for( _i = 0, _len = _ref1.length; _i < _len; _i++ ){\n      i = _ref1[ _i ];\n      _results.push( _siftup( array, i, cmp ) );\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function( array, item, cmp ){\n    var pos;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf( item );\n    if( pos === -1 ){\n      return;\n    }\n    _siftdown( array, 0, pos, cmp );\n    return _siftup( array, pos, cmp );\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function( array, n, cmp ){\n    var elem, result, _i, _len, _ref;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    result = array.slice( 0, n );\n    if( !result.length ){\n      return result;\n    }\n    heapify( result, cmp );\n    _ref = array.slice( n );\n    for( _i = 0, _len = _ref.length; _i < _len; _i++ ){\n      elem = _ref[ _i ];\n      heappushpop( result, elem, cmp );\n    }\n    return result.sort( cmp ).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function( array, n, cmp ){\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    if( n * 10 <= array.length ){\n      result = array.slice( 0, n ).sort( cmp );\n      if( !result.length ){\n        return result;\n      }\n      los = result[ result.length - 1];\n      _ref = array.slice( n );\n      for( _i = 0, _len = _ref.length; _i < _len; _i++ ){\n        elem = _ref[ _i ];\n        if( cmp( elem, los ) < 0 ){\n          insort( result, elem, 0, null, cmp );\n          result.pop();\n          los = result[ result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify( array, cmp );\n    _results = [];\n    for( i = _j = 0, _ref1 = min( n, array.length ); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j ){\n      _results.push( heappop( array, cmp ) );\n    }\n    return _results;\n  };\n\n  _siftdown = function( array, startpos, pos, cmp ){\n    var newitem, parent, parentpos;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    newitem = array[ pos ];\n    while( pos > startpos ){\n      parentpos = (pos - 1) >> 1;\n      parent = array[ parentpos ];\n      if( cmp( newitem, parent ) < 0 ){\n        array[ pos ] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[ pos ] = newitem;\n  };\n\n  _siftup = function( array, pos, cmp ){\n    var childpos, endpos, newitem, rightpos, startpos;\n    if( cmp == null ){\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[ pos ];\n    childpos = 2 * pos + 1;\n    while( childpos < endpos ){\n      rightpos = childpos + 1;\n      if( rightpos < endpos && !(cmp( array[ childpos ], array[ rightpos ] ) < 0) ){\n        childpos = rightpos;\n      }\n      array[ pos ] = array[ childpos ];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[ pos ] = newitem;\n    return _siftdown( array, startpos, pos, cmp );\n  };\n\n  Heap = (function(){\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap( cmp ){\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function( x ){\n      return heappush( this.nodes, x, this.cmp );\n    };\n\n    Heap.prototype.pop = function(){\n      return heappop( this.nodes, this.cmp );\n    };\n\n    Heap.prototype.peek = function(){\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function( x ){\n      return this.nodes.indexOf( x ) !== -1;\n    };\n\n    Heap.prototype.replace = function( x ){\n      return heapreplace( this.nodes, x, this.cmp );\n    };\n\n    Heap.prototype.pushpop = function( x ){\n      return heappushpop( this.nodes, x, this.cmp );\n    };\n\n    Heap.prototype.heapify = function(){\n      return heapify( this.nodes, this.cmp );\n    };\n\n    Heap.prototype.updateItem = function( x ){\n      return updateItem( this.nodes, x, this.cmp );\n    };\n\n    Heap.prototype.clear = function(){\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function(){\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function(){\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function(){\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice( 0 );\n      return heap;\n    };\n\n    Heap.prototype.toArray = function(){\n      return this.nodes.slice( 0 );\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function( root, factory ){\n    if( typeof define === 'function' && define.amd ){\n      return define( [], factory );\n    } else if( typeof exports === 'object' ){\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })( this, function(){\n    return Heap;\n  } );\n\n}).call( this );\n\n/* jshint ignore:end */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/heap.js\n ** module id = 45\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\n\n// search, spanning trees, etc\nvar elesfn = ({\n\n  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n  // implemented from pseudocode from wikipedia\n  kruskal: function( weightFn ){\n    var cy = this.cy();\n\n    weightFn = is.fn( weightFn ) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\n    function findSet( ele ){\n      for( var i = 0; i < forest.length; i++ ){\n        var eles = forest[ i ];\n\n        if( eles.anySame( ele ) ){\n          return {\n            eles: eles,\n            index: i\n          };\n        }\n      }\n    }\n\n    var A = cy.collection( cy, [] );\n    var forest = [];\n    var nodes = this.nodes();\n\n    for( var i = 0; i < nodes.length; i++ ){\n      forest.push( nodes[ i ].collection() );\n    }\n\n    var edges = this.edges();\n    var S = edges.toArray().sort( function( a, b ){\n      var weightA = weightFn.call( a, a );\n      var weightB = weightFn.call( b, b );\n\n      return weightA - weightB;\n    } );\n\n    for( var i = 0; i < S.length; i++ ){\n      var edge = S[ i ];\n      var u = edge.source()[0];\n      var v = edge.target()[0];\n      var setU = findSet( u );\n      var setV = findSet( v );\n\n      if( setU.index !== setV.index ){\n        A = A.add( edge );\n\n        // combine forests for u and v\n        forest[ setU.index ] = setU.eles.add( setV.eles );\n        forest.splice( setV.index, 1 );\n      }\n    }\n\n    return nodes.add( A );\n  }\n});\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/kruskal.js\n ** module id = 46\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\n\nvar elesfn = ({\n\n  // Implemented from pseudocode from wikipedia\n  aStar: function( options ){\n    var eles = this;\n\n    options = options || {};\n\n    // Reconstructs the path from Start to End, acumulating the result in pathAcum\n    var reconstructPath = function( start, end, cameFromMap, pathAcum ){\n      // Base case\n      if( start == end ){\n        pathAcum.push( cy.getElementById( end ) );\n        return pathAcum;\n      }\n\n      if( end in cameFromMap ){\n        // We know which node is before the last one\n        var previous = cameFromMap[ end ];\n        var previousEdge = cameFromEdge[ end ];\n\n        pathAcum.push( cy.getElementById( end ) );\n        pathAcum.push( cy.getElementById( previousEdge ) );\n\n\n        return reconstructPath( start,\n                     previous,\n                     cameFromMap,\n                     pathAcum );\n      }\n\n      // We should not reach here!\n      return undefined;\n    };\n\n    // Returns the index of the element in openSet which has minimum fScore\n    var findMin = function( openSet, fScore ){\n      if( openSet.length === 0 ){\n        // Should never be the case\n        return undefined;\n      }\n      var minPos = 0;\n      var tempScore = fScore[ openSet[0] ];\n      for( var i = 1; i < openSet.length; i++ ){\n        var s = fScore[ openSet[ i ] ];\n        if( s < tempScore ){\n          tempScore = s;\n          minPos = i;\n        }\n      }\n      return minPos;\n    };\n\n    var cy = this._private.cy;\n\n    // root - mandatory!\n    if( options != null && options.root != null ){\n      var source = is.string( options.root ) ?\n        // use it as a selector, e.g. \"#rootID\n        this.filter( options.root )[0] :\n        options.root[0];\n    } else {\n      return undefined;\n    }\n\n    // goal - mandatory!\n    if( options.goal != null ){\n      var target = is.string( options.goal ) ?\n        // use it as a selector, e.g. \"#goalID\n        this.filter( options.goal )[0] :\n        options.goal[0];\n    } else {\n      return undefined;\n    }\n\n    // Heuristic function - optional\n    if( options.heuristic != null && is.fn( options.heuristic ) ){\n      var heuristic = options.heuristic;\n    } else {\n      var heuristic = function(){ return 0; }; // use constant if unspecified\n    }\n\n    // Weight function - optional\n    if( options.weight != null && is.fn( options.weight ) ){\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function( e ){return 1;};\n    }\n\n    // directed - optional\n    if( options.directed != null ){\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var closedSet = [];\n    var openSet = [ source.id() ];\n    var cameFrom = {};\n    var cameFromEdge = {};\n    var gScore = {};\n    var fScore = {};\n\n    gScore[ source.id() ] = 0;\n    fScore[ source.id() ] = heuristic( source );\n\n    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n    var nodes = this.nodes();\n\n    // Counter\n    var steps = 0;\n\n    // Main loop\n    while( openSet.length > 0 ){\n      var minPos = findMin( openSet, fScore );\n      var cMin = cy.getElementById( openSet[ minPos ] );\n      steps++;\n\n      // If we've found our goal, then we are done\n      if( cMin.id() == target.id() ){\n        var rPath = reconstructPath( source.id(), target.id(), cameFrom, [] );\n        rPath.reverse();\n        return {\n          found: true,\n          distance: gScore[ cMin.id() ],\n          path: eles.spawn( rPath ),\n          steps: steps\n        };\n      }\n\n      // Add cMin to processed nodes\n      closedSet.push( cMin.id() );\n      // Remove cMin from boundary nodes\n      openSet.splice( minPos, 1 );\n\n      // Update scores for neighbors of cMin\n      // Take into account if graph is directed or not\n      var vwEdges = cMin.connectedEdges();\n      if( directed ){ vwEdges = vwEdges.stdFilter( function( ele ){ return ele.data( 'source' ) === cMin.id(); } ); }\n      vwEdges = vwEdges.intersect( edges );\n\n      for( var i = 0; i < vwEdges.length; i++ ){\n        var e = vwEdges[ i ];\n        var w = e.connectedNodes().stdFilter( function( n ){ return n.id() !== cMin.id(); } ).intersect( nodes );\n\n        // if node is in closedSet, ignore it\n        if( closedSet.indexOf( w.id() ) != -1 ){\n          continue;\n        }\n\n        // New tentative score for node w\n        var tempScore = gScore[ cMin.id() ] + weightFn.apply( e, [ e ] );\n\n        // Update gScore for node w if:\n        //   w not present in openSet\n        // OR\n        //   tentative gScore is less than previous value\n\n        // w not in openSet\n        if( openSet.indexOf( w.id() ) == -1 ){\n          gScore[ w.id() ] = tempScore;\n          fScore[ w.id() ] = tempScore + heuristic( w );\n          openSet.push( w.id() ); // Add node to openSet\n          cameFrom[ w.id() ] = cMin.id();\n          cameFromEdge[ w.id() ] = e.id();\n          continue;\n        }\n        // w already in openSet, but with greater gScore\n        if( tempScore < gScore[ w.id() ] ){\n          gScore[ w.id() ] = tempScore;\n          fScore[ w.id() ] = tempScore + heuristic( w );\n          cameFrom[ w.id() ] = cMin.id();\n        }\n\n      } // End of neighbors update\n\n    } // End of main loop\n\n    // If we've reached here, then we've not reached our goal\n    return {\n      found: false,\n      distance: undefined,\n      path: undefined,\n      steps: steps\n    };\n  }\n\n}); // elesfn\n\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/a-star.js\n ** module id = 47\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\n\nvar elesfn = ({\n\n  // Implemented from pseudocode from wikipedia\n  floydWarshall: function( options ){\n    options = options || {};\n\n    var cy = this.cy();\n\n    // Weight function - optional\n    if( options.weight != null && is.fn( options.weight ) ){\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function( e ){return 1;};\n    }\n\n    // directed - optional\n    if( options.directed != null ){\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n\n    // mapping: node id -> position in nodes array\n    var id2position = {};\n    for( var i = 0; i < numNodes; i++ ){\n      id2position[ nodes[ i ].id() ] = i;\n    }\n\n    // Initialize distance matrix\n    var dist = [];\n    for( var i = 0; i < numNodes; i++ ){\n      var newRow = new Array( numNodes );\n      for( var j = 0; j < numNodes; j++ ){\n        if( i == j ){\n          newRow[ j ] = 0;\n        } else {\n          newRow[ j ] = Infinity;\n        }\n      }\n      dist.push( newRow );\n    }\n\n    // Initialize matrix used for path reconstruction\n    // Initialize distance matrix\n    var next = [];\n    var edgeNext = [];\n\n    var initMatrix = function( next ){\n      for( var i = 0; i < numNodes; i++ ){\n        var newRow = new Array( numNodes );\n        for( var j = 0; j < numNodes; j++ ){\n          newRow[ j ] = undefined;\n        }\n        next.push( newRow );\n      }\n    };\n\n    initMatrix( next );\n    initMatrix( edgeNext );\n\n    // Process edges\n    for( var i = 0; i < edges.length ; i++ ){\n      var sourceIndex = id2position[ edges[ i ].source().id() ];\n      var targetIndex = id2position[ edges[ i ].target().id() ];\n      var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );\n\n      // Check if already process another edge between same 2 nodes\n      if( dist[ sourceIndex ][ targetIndex ] > weight ){\n        dist[ sourceIndex ][ targetIndex ] = weight;\n        next[ sourceIndex ][ targetIndex ] = targetIndex;\n        edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];\n      }\n    }\n\n    // If undirected graph, process 'reversed' edges\n    if( !directed ){\n      for( var i = 0; i < edges.length ; i++ ){\n        var sourceIndex = id2position[ edges[ i ].target().id() ];\n        var targetIndex = id2position[ edges[ i ].source().id() ];\n        var weight = weightFn.apply( edges[ i ], [ edges[ i ] ] );\n\n        // Check if already process another edge between same 2 nodes\n        if( dist[ sourceIndex ][ targetIndex ] > weight ){\n          dist[ sourceIndex ][ targetIndex ] = weight;\n          next[ sourceIndex ][ targetIndex ] = targetIndex;\n          edgeNext[ sourceIndex ][ targetIndex ] = edges[ i ];\n        }\n      }\n    }\n\n    // Main loop\n    for( var k = 0; k < numNodes; k++ ){\n      for( var i = 0; i < numNodes; i++ ){\n        for( var j = 0; j < numNodes; j++ ){\n          if( dist[ i ][ k ] + dist[ k ][ j ] < dist[ i ][ j ] ){\n            dist[ i ][ j ] = dist[ i ][ k ] + dist[ k ][ j ];\n            next[ i ][ j ] = next[ i ][ k ];\n          }\n        }\n      }\n    }\n\n    // Build result object\n    var position2id = [];\n    for( var i = 0; i < numNodes; i++ ){\n      position2id.push( nodes[ i ].id() );\n    }\n\n    var res = {\n      distance: function( from, to ){\n        if( is.string( from ) ){\n          // from is a selector string\n          var fromId = (cy.filter( from )[0]).id();\n        } else {\n          // from is a node\n          var fromId = from.id();\n        }\n\n        if( is.string( to ) ){\n          // to is a selector string\n          var toId = (cy.filter( to )[0]).id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n\n        return dist[ id2position[ fromId ] ][ id2position[ toId ] ];\n      },\n\n      path: function( from, to ){\n        var reconstructPathAux = function( from, to, next, position2id, edgeNext ){\n          if( from === to ){\n            return cy.getElementById( position2id[ from ] );\n          }\n          if( next[ from ][ to ] === undefined ){\n            return undefined;\n          }\n\n          var path = [ cy.getElementById( position2id[ from ] ) ];\n          var prev = from;\n          while( from !== to ){\n            prev = from;\n            from = next[ from ][ to ];\n\n            var edge = edgeNext[ prev ][ from ];\n            path.push( edge );\n\n            path.push( cy.getElementById( position2id[ from ] ) );\n          }\n          return path;\n        };\n\n        if( is.string( from ) ){\n          // from is a selector string\n          var fromId = (cy.filter( from )[0]).id();\n        } else {\n          // from is a node\n          var fromId = from.id();\n        }\n\n        if( is.string( to ) ){\n          // to is a selector string\n          var toId = (cy.filter( to )[0]).id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n\n        var pathArr = reconstructPathAux( id2position[ fromId ],\n                      id2position[ toId ],\n                      next,\n                      position2id,\n                      edgeNext );\n\n        return cy.collection( pathArr );\n      }\n    };\n\n    return res;\n\n  } // floydWarshall\n\n}); // elesfn\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/floyd-warshall.js\n ** module id = 48\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\nvar util = require( '../../util' );\n\nvar elesfn = ({\n\n  // Implemented from pseudocode from wikipedia\n  bellmanFord: function( options ){\n    var eles = this;\n\n    options = options || {};\n\n    // Weight function - optional\n    if( options.weight != null && is.fn( options.weight ) ){\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function( e ){return 1;};\n    }\n\n    // directed - optional\n    if( options.directed != null ){\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    // root - mandatory!\n    if( options.root != null ){\n      if( is.string( options.root ) ){\n        // use it as a selector, e.g. \"#rootID\n        var source = this.filter( options.root )[0];\n      } else {\n        var source = options.root[0];\n      }\n    } else {\n      return undefined;\n    }\n\n    var cy = this._private.cy;\n    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n\n    // mapping: node id -> position in nodes array\n    var id2position = {};\n    for( var i = 0; i < numNodes; i++ ){\n      id2position[ nodes[ i ].id() ] = i;\n    }\n\n    // Initializations\n    var cost = [];\n    var predecessor = [];\n    var predEdge = [];\n\n    for( var i = 0; i < numNodes; i++ ){\n      if( nodes[ i ].id() === source.id() ){\n        cost[ i ] = 0;\n      } else {\n        cost[ i ] = Infinity;\n      }\n      predecessor[ i ] = undefined;\n    }\n\n    // Edges relaxation\n    var flag = false;\n    for( var i = 1; i < numNodes; i++ ){\n      flag = false;\n      for( var e = 0; e < edges.length; e++ ){\n        var sourceIndex = id2position[ edges[ e ].source().id() ];\n        var targetIndex = id2position[ edges[ e ].target().id() ];\n        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );\n\n        var temp = cost[ sourceIndex ] + weight;\n        if( temp < cost[ targetIndex ] ){\n          cost[ targetIndex ] = temp;\n          predecessor[ targetIndex ] = sourceIndex;\n          predEdge[ targetIndex ] = edges[ e ];\n          flag = true;\n        }\n\n        // If undirected graph, we need to take into account the 'reverse' edge\n        if( !directed ){\n          var temp = cost[ targetIndex ] + weight;\n          if( temp < cost[ sourceIndex ] ){\n            cost[ sourceIndex ] = temp;\n            predecessor[ sourceIndex ] = targetIndex;\n            predEdge[ sourceIndex ] = edges[ e ];\n            flag = true;\n          }\n        }\n      }\n\n      if( !flag ){\n        break;\n      }\n    }\n\n    if( flag ){\n      // Check for negative weight cycles\n      for( var e = 0; e < edges.length; e++ ){\n        var sourceIndex = id2position[ edges[ e ].source().id() ];\n        var targetIndex = id2position[ edges[ e ].target().id() ];\n        var weight = weightFn.apply( edges[ e ], [ edges[ e ] ] );\n\n        if( cost[ sourceIndex ] + weight < cost[ targetIndex ] ){\n          util.error( 'Graph contains a negative weight cycle for Bellman-Ford' );\n          return { pathTo: undefined,\n               distanceTo: undefined,\n               hasNegativeWeightCycle: true};\n        }\n      }\n    }\n\n    // Build result object\n    var position2id = [];\n    for( var i = 0; i < numNodes; i++ ){\n      position2id.push( nodes[ i ].id() );\n    }\n\n\n    var res = {\n      distanceTo: function( to ){\n        if( is.string( to ) ){\n          // to is a selector string\n          var toId = (cy.filter( to )[0]).id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n\n        return cost[ id2position[ toId ] ];\n      },\n\n      pathTo: function( to ){\n\n        var reconstructPathAux = function( predecessor, fromPos, toPos, position2id, acumPath, predEdge ){\n          for( ;; ){\n            // Add toId to path\n            acumPath.push( cy.getElementById( position2id[ toPos ] ) );\n            acumPath.push( predEdge[ toPos ] );\n\n            if( fromPos === toPos ){\n              // reached starting node\n              return acumPath;\n            }\n\n            // If no path exists, discart acumulated path and return undefined\n            var predPos = predecessor[ toPos ];\n            if( typeof predPos === 'undefined' ){\n              return undefined;\n            }\n\n            toPos = predPos;\n          }\n\n        };\n\n        if( is.string( to ) ){\n          // to is a selector string\n          var toId = (cy.filter( to )[0]).id();\n        } else {\n          // to is a node\n          var toId = to.id();\n        }\n        var path = [];\n\n        // This returns a reversed path\n        var res =  reconstructPathAux( predecessor,\n                      id2position[ source.id() ],\n                      id2position[ toId ],\n                      position2id,\n                      path,\n                      predEdge );\n\n        // Get it in the correct order and return it\n        if( res != null ){\n          res.reverse();\n        }\n\n        return eles.spawn( res );\n      },\n\n      hasNegativeWeightCycle: false\n    };\n\n    return res;\n\n  } // bellmanFord\n\n}); // elesfn\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/bellman-ford.js\n ** module id = 49\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\n\nvar elesfn = ({\n\n  // Computes the minimum cut of an undirected graph\n  // Returns the correct answer with high probability\n  kargerStein: function( options ){\n    var eles = this;\n\n    options = options || {};\n\n    // Function which colapses 2 (meta) nodes into one\n    // Updates the remaining edge lists\n    // Receives as a paramater the edge which causes the collapse\n    var colapse = function( edgeIndex, nodeMap, remainingEdges ){\n      var edgeInfo = remainingEdges[ edgeIndex ];\n      var sourceIn = edgeInfo[1];\n      var targetIn = edgeInfo[2];\n      var partition1 = nodeMap[ sourceIn ];\n      var partition2 = nodeMap[ targetIn ];\n\n      // Delete all edges between partition1 and partition2\n      var newEdges = remainingEdges.filter( function( edge ){\n        if( nodeMap[ edge[1] ] === partition1 && nodeMap[ edge[2] ] === partition2 ){\n          return false;\n        }\n        if( nodeMap[ edge[1] ] === partition2 && nodeMap[ edge[2] ] === partition1 ){\n          return false;\n        }\n        return true;\n      } );\n\n      // All edges pointing to partition2 should now point to partition1\n      for( var i = 0; i < newEdges.length; i++ ){\n        var edge = newEdges[ i ];\n        if( edge[1] === partition2 ){ // Check source\n          newEdges[ i ] = edge.slice( 0 );\n          newEdges[ i ][1] = partition1;\n        } else if( edge[2] === partition2 ){ // Check target\n          newEdges[ i ] = edge.slice( 0 );\n          newEdges[ i ][2] = partition1;\n        }\n      }\n\n      // Move all nodes from partition2 to partition1\n      for( var i = 0; i < nodeMap.length; i++ ){\n        if( nodeMap[ i ] === partition2 ){\n          nodeMap[ i ] = partition1;\n        }\n      }\n\n      return newEdges;\n    };\n\n\n    // Contracts a graph until we reach a certain number of meta nodes\n    var contractUntil = function( metaNodeMap,\n                   remainingEdges,\n                   size,\n                   sizeLimit ){\n      // Stop condition\n      if( size <= sizeLimit ){\n        return remainingEdges;\n      }\n\n      // Choose an edge randomly\n      var edgeIndex = Math.floor( (Math.random() * remainingEdges.length) );\n\n      // Colapse graph based on edge\n      var newEdges = colapse( edgeIndex, metaNodeMap, remainingEdges );\n\n      return contractUntil( metaNodeMap,\n                 newEdges,\n                 size - 1,\n                 sizeLimit );\n    };\n\n    var cy = this._private.cy;\n    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n    var numEdges = edges.length;\n    var numIter = Math.ceil( Math.pow( Math.log( numNodes ) / Math.LN2, 2 ) );\n    var stopSize = Math.floor( numNodes / Math.sqrt( 2 ) );\n\n    if( numNodes < 2 ){\n      util.error( 'At least 2 nodes are required for Karger-Stein algorithm' );\n      return undefined;\n    }\n\n    // Create numerical identifiers for each node\n    // mapping: node id -> position in nodes array\n    // for reverse mapping, simply use nodes array\n    var id2position = {};\n    for( var i = 0; i < numNodes; i++ ){\n      id2position[ nodes[ i ].id() ] = i;\n    }\n\n    // Now store edge destination as indexes\n    // Format for each edge (edge index, source node index, target node index)\n    var edgeIndexes = [];\n    for( var i = 0; i < numEdges; i++ ){\n      var e = edges[ i ];\n      edgeIndexes.push( [ i, id2position[ e.source().id() ], id2position[ e.target().id() ] ] );\n    }\n\n    // We will store the best cut found here\n    var minCutSize = Infinity;\n    var minCut;\n\n    // Initial meta node partition\n    var originalMetaNode = [];\n    for( var i = 0; i < numNodes; i++ ){\n      originalMetaNode.push( i );\n    }\n\n    // Main loop\n    for( var iter = 0; iter <= numIter; iter++ ){\n      // Create new meta node partition\n      var metaNodeMap = originalMetaNode.slice( 0 );\n\n      // Contract until stop point (stopSize nodes)\n      var edgesState = contractUntil( metaNodeMap, edgeIndexes, numNodes, stopSize );\n\n      // Create a copy of the colapsed nodes state\n      var metaNodeMap2 = metaNodeMap.slice( 0 );\n\n      // Run 2 iterations starting in the stop state\n      var res1 = contractUntil( metaNodeMap, edgesState, stopSize, 2 );\n      var res2 = contractUntil( metaNodeMap2, edgesState, stopSize, 2 );\n\n      // Is any of the 2 results the best cut so far?\n      if( res1.length <= res2.length && res1.length < minCutSize ){\n        minCutSize = res1.length;\n        minCut = [ res1, metaNodeMap ];\n      } else if( res2.length <= res1.length && res2.length < minCutSize ){\n        minCutSize = res2.length;\n        minCut = [ res2, metaNodeMap2 ];\n      }\n    } // end of main loop\n\n\n    // Construct result\n    var resEdges = (minCut[0]).map( function( e ){ return edges[ e[0] ]; } );\n    var partition1 = [];\n    var partition2 = [];\n\n    // traverse metaNodeMap for best cut\n    var witnessNodePartition = minCut[1][0];\n    for( var i = 0; i < minCut[1].length; i++ ){\n      var partitionId = minCut[1][ i ];\n      if( partitionId === witnessNodePartition ){\n        partition1.push( nodes[ i ] );\n      } else {\n        partition2.push( nodes[ i ] );\n      }\n    }\n\n    var ret = {\n      cut: eles.spawn( cy, resEdges ),\n      partition1: eles.spawn( partition1 ),\n      partition2: eles.spawn( partition2 )\n    };\n\n    return ret;\n  }\n}); // elesfn\n\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/kerger-stein.js\n ** module id = 50\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\n\nvar elesfn = ({\n\n  pageRank: function( options ){\n    options = options || {};\n\n    var normalizeVector = function( vector ){\n      var length = vector.length;\n\n      // First, get sum of all elements\n      var total = 0;\n      for( var i = 0; i < length; i++ ){\n        total += vector[ i ];\n      }\n\n      // Now, divide each by the sum of all elements\n      for( var i = 0; i < length; i++ ){\n        vector[ i ] = vector[ i ] / total;\n      }\n    };\n\n    // dampingFactor - optional\n    if( options != null &&\n      options.dampingFactor != null ){\n      var dampingFactor = options.dampingFactor;\n    } else {\n      var dampingFactor = 0.8; // Default damping factor\n    }\n\n    // desired precision - optional\n    if( options != null &&\n      options.precision != null ){\n      var epsilon = options.precision;\n    } else {\n      var epsilon = 0.000001; // Default precision\n    }\n\n    // Max number of iterations - optional\n    if( options != null &&\n      options.iterations != null ){\n      var numIter = options.iterations;\n    } else {\n      var numIter = 200; // Default number of iterations\n    }\n\n    // Weight function - optional\n    if( options != null &&\n      options.weight != null &&\n      is.fn( options.weight ) ){\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function( e ){return 1;};\n    }\n\n    var cy = this._private.cy;\n    var edges = this.edges().stdFilter( function( e ){ return !e.isLoop(); } );\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n    var numEdges = edges.length;\n\n    // Create numerical identifiers for each node\n    // mapping: node id -> position in nodes array\n    // for reverse mapping, simply use nodes array\n    var id2position = {};\n    for( var i = 0; i < numNodes; i++ ){\n      id2position[ nodes[ i ].id() ] = i;\n    }\n\n    // Construct transposed adjacency matrix\n    // First lets have a zeroed matrix of the right size\n    // We'll also keep track of the sum of each column\n    var matrix = [];\n    var columnSum = [];\n    var additionalProb = (1 - dampingFactor) / numNodes;\n\n    // Create null matric\n    for( var i = 0; i < numNodes; i++ ){\n      var newRow = [];\n      for( var j = 0; j < numNodes; j++ ){\n        newRow.push( 0.0 );\n      }\n      matrix.push( newRow );\n      columnSum.push( 0.0 );\n    }\n\n    // Now, process edges\n    for( var i = 0; i < numEdges; i++ ){\n      var edge = edges[ i ];\n      var s = id2position[ edge.source().id() ];\n      var t = id2position[ edge.target().id() ];\n      var w = weightFn.apply( edge, [ edge ] );\n\n      // Update matrix\n      matrix[ t ][ s ] += w;\n\n      // Update column sum\n      columnSum[ s ] += w;\n    }\n\n    // Add additional probability based on damping factor\n    // Also, take into account columns that have sum = 0\n    var p = 1.0 / numNodes + additionalProb; // Shorthand\n    // Traverse matrix, column by column\n    for( var j = 0; j < numNodes; j++ ){\n      if( columnSum[ j ] === 0 ){\n        // No 'links' out from node jth, assume equal probability for each possible node\n        for( var i = 0; i < numNodes; i++ ){\n          matrix[ i ][ j ] = p;\n        }\n      } else {\n        // Node jth has outgoing link, compute normalized probabilities\n        for( var i = 0; i < numNodes; i++ ){\n          matrix[ i ][ j ] = matrix[ i ][ j ] / columnSum[ j ] + additionalProb;\n        }\n      }\n    }\n\n    // Compute dominant eigenvector using power method\n    var eigenvector = [];\n    var nullVector = [];\n    var previous;\n\n    // Start with a vector of all 1's\n    // Also, initialize a null vector which will be used as shorthand\n    for( var i = 0; i < numNodes; i++ ){\n      eigenvector.push( 1.0 );\n      nullVector.push( 0.0 );\n    }\n\n    for( var iter = 0; iter < numIter; iter++ ){\n      // New array with all 0's\n      var temp = nullVector.slice( 0 );\n\n      // Multiply matrix with previous result\n      for( var i = 0; i < numNodes; i++ ){\n        for( var j = 0; j < numNodes; j++ ){\n          temp[ i ] += matrix[ i ][ j ] * eigenvector[ j ];\n        }\n      }\n\n      normalizeVector( temp );\n      previous = eigenvector;\n      eigenvector = temp;\n\n      var diff = 0;\n      // Compute difference (squared module) of both vectors\n      for( var i = 0; i < numNodes; i++ ){\n        diff += Math.pow( previous[ i ] - eigenvector[ i ], 2 );\n      }\n\n      // If difference is less than the desired threshold, stop iterating\n      if( diff < epsilon ){\n        break;\n      }\n    }\n\n    // Construct result\n    var res = {\n      rank: function( node ){\n        if( is.string( node ) ){\n          // is a selector string\n          var nodeId = (cy.filter( node )[0]).id();\n        } else {\n          // is a node object\n          var nodeId = node.id();\n        }\n        return eigenvector[ id2position[ nodeId ] ];\n      }\n    };\n\n\n    return res;\n  } // pageRank\n\n}); // elesfn\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/page-rank.js\n ** module id = 51\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\nvar util = require( '../../util' );\n\nvar elesfn = ({\n\n  degreeCentralityNormalized: function( options ){\n    options = options || {};\n\n    var cy = this.cy();\n\n    // directed - optional\n    if( options.directed != null ){\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var nodes = this.nodes();\n    var numNodes = nodes.length;\n\n    if( !directed ){\n      var degrees = {};\n      var maxDegree = 0;\n\n      for( var i = 0; i < numNodes; i++ ){\n        var node = nodes[ i ];\n        // add current node to the current options object and call degreeCentrality\n        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );\n        if( maxDegree < currDegree.degree )\n          maxDegree = currDegree.degree;\n\n        degrees[ node.id() ] = currDegree.degree;\n      }\n\n      return {\n        degree: function( node ){\n          if( is.string( node ) ){\n            // from is a selector string\n            var node = (cy.filter( node )[0]).id();\n          } else {\n            // from is a node\n            var node = node.id();\n          }\n\n          return degrees[ node ] / maxDegree;\n        }\n      };\n    } else {\n      var indegrees = {};\n      var outdegrees = {};\n      var maxIndegree = 0;\n      var maxOutdegree = 0;\n\n      for( var i = 0; i < numNodes; i++ ){\n        var node = nodes[ i ];\n        // add current node to the current options object and call degreeCentrality\n        var currDegree = this.degreeCentrality( util.extend( {}, options, {root: node} ) );\n\n        if( maxIndegree < currDegree.indegree )\n          maxIndegree = currDegree.indegree;\n\n        if( maxOutdegree < currDegree.outdegree )\n          maxOutdegree = currDegree.outdegree;\n\n        indegrees[ node.id() ] = currDegree.indegree;\n        outdegrees[ node.id() ] = currDegree.outdegree;\n      }\n\n      return {\n        indegree: function( node ){\n          if( is.string( node ) ){\n            // from is a selector string\n            var node = (cy.filter( node )[0]).id();\n          } else {\n            // from is a node\n            var node = node.id();\n          }\n\n          return indegrees[ node ] / maxIndegree;\n        },\n        outdegree: function( node ){\n          if( is.string( node ) ){\n            // from is a selector string\n            var node = (cy.filter( node )[0]).id();\n          } else {\n            // from is a node\n            var node = node.id();\n          }\n\n          return outdegrees[ node ] / maxOutdegree;\n        }\n\n      };\n    }\n\n  }, // degreeCentralityNormalized\n\n  // Implemented from the algorithm in Opsahl's paper\n  // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n  // check the heading 2 \"Degree\"\n  degreeCentrality: function( options ){\n    options = options || {};\n\n    var callingEles = this;\n\n    // root - mandatory!\n    if( options != null && options.root != null ){\n      var root = is.string( options.root ) ? this.filter( options.root )[0] : options.root[0];\n    } else {\n      return undefined;\n    }\n\n    // weight - optional\n    if( options.weight != null && is.fn( options.weight ) ){\n      var weightFn = options.weight;\n    } else {\n      // If not specified, assume each edge has equal weight (1)\n      var weightFn = function( e ){\n        return 1;\n      };\n    }\n\n    // directed - optional\n    if( options.directed != null ){\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    // alpha - optional\n    if( options.alpha != null && is.number( options.alpha ) ){\n      var alpha = options.alpha;\n    } else {\n      alpha = 0;\n    }\n\n\n    if( !directed ){\n      var connEdges = root.connectedEdges().intersection( callingEles );\n      var k = connEdges.length;\n      var s = 0;\n\n      // Now, sum edge weights\n      for( var i = 0; i < connEdges.length; i++ ){\n        var edge = connEdges[ i ];\n        s += weightFn.apply( edge, [ edge ] );\n      }\n\n      return {\n        degree: Math.pow( k, 1 - alpha ) * Math.pow( s, alpha )\n      };\n    } else {\n      var incoming = root.connectedEdges( 'edge[target = \"' + root.id() + '\"]' ).intersection( callingEles );\n      var outgoing = root.connectedEdges( 'edge[source = \"' + root.id() + '\"]' ).intersection( callingEles );\n      var k_in = incoming.length;\n      var k_out = outgoing.length;\n      var s_in = 0;\n      var s_out = 0;\n\n      // Now, sum incoming edge weights\n      for( var i = 0; i < incoming.length; i++ ){\n        var edge = incoming[ i ];\n        s_in += weightFn.apply( edge, [ edge ] );\n      }\n\n      // Now, sum outgoing edge weights\n      for( var i = 0; i < outgoing.length; i++ ){\n        var edge = outgoing[ i ];\n        s_out += weightFn.apply( edge, [ edge ] );\n      }\n\n      return {\n        indegree: Math.pow( k_in, 1 - alpha ) * Math.pow( s_in, alpha ),\n        outdegree: Math.pow( k_out, 1 - alpha ) * Math.pow( s_out, alpha )\n      };\n    }\n  } // degreeCentrality\n\n}); // elesfn\n\n// nice, short mathemathical alias\nelesfn.dc = elesfn.degreeCentrality;\nelesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/degree-centrality.js\n ** module id = 52\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\n\nvar elesfn = ({\n\n  closenessCentralityNormalized: function( options ){\n    options = options || {};\n\n    var cy = this.cy();\n\n    var harmonic = options.harmonic;\n    if( harmonic === undefined ){\n      harmonic = true;\n    }\n\n    var closenesses = {};\n    var maxCloseness = 0;\n    var nodes = this.nodes();\n    var fw = this.floydWarshall( { weight: options.weight, directed: options.directed } );\n\n    // Compute closeness for every node and find the maximum closeness\n    for( var i = 0; i < nodes.length; i++ ){\n      var currCloseness = 0;\n      for( var j = 0; j < nodes.length; j++ ){\n        if( i != j ){\n          var d = fw.distance( nodes[ i ], nodes[ j ] );\n\n          if( harmonic ){\n            currCloseness += 1 / d;\n          } else {\n            currCloseness += d;\n          }\n        }\n      }\n\n      if( !harmonic ){\n        currCloseness = 1 / currCloseness;\n      }\n\n      if( maxCloseness < currCloseness ){\n        maxCloseness = currCloseness;\n      }\n\n      closenesses[ nodes[ i ].id() ] = currCloseness;\n    }\n\n    return {\n      closeness: function( node ){\n        if( is.string( node ) ){\n          // from is a selector string\n          var node = (cy.filter( node )[0]).id();\n        } else {\n          // from is a node\n          var node = node.id();\n        }\n\n        return closenesses[ node ] / maxCloseness;\n      }\n    };\n  },\n\n  // Implemented from pseudocode from wikipedia\n  closenessCentrality: function( options ){\n    options = options || {};\n\n    // root - mandatory!\n    if( options.root != null ){\n      if( is.string( options.root ) ){\n        // use it as a selector, e.g. \"#rootID\n        var root = this.filter( options.root )[0];\n      } else {\n        var root = options.root[0];\n      }\n    } else {\n      return undefined;\n    }\n\n    // weight - optional\n    if( options.weight != null && is.fn( options.weight ) ){\n      var weight = options.weight;\n    } else {\n      var weight = function(){return 1;};\n    }\n\n    // directed - optional\n    if( options.directed != null && is.bool( options.directed ) ){\n      var directed = options.directed;\n    } else {\n      var directed = false;\n    }\n\n    var harmonic = options.harmonic;\n    if( harmonic === undefined ){\n      harmonic = true;\n    }\n\n    // we need distance from this node to every other node\n    var dijkstra = this.dijkstra( {\n      root: root,\n      weight: weight,\n      directed: directed\n    } );\n    var totalDistance = 0;\n\n    var nodes = this.nodes();\n    for( var i = 0; i < nodes.length; i++ ){\n      if( nodes[ i ].id() != root.id() ){\n        var d = dijkstra.distanceTo( nodes[ i ] );\n\n        if( harmonic ){\n          totalDistance += 1 / d;\n        } else {\n          totalDistance += d;\n        }\n      }\n    }\n\n    return harmonic ? totalDistance : 1 / totalDistance;\n  } // closenessCentrality\n\n}); // elesfn\n\n// nice, short mathemathical alias\nelesfn.cc = elesfn.closenessCentrality;\nelesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/closeness-centrality.js\n ** module id = 53\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../is' );\nvar Heap = require( '../../heap' );\n\nvar elesfn = ({\n\n  // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n  betweennessCentrality: function( options ){\n    options = options || {};\n\n    // Weight - optional\n    var weighted, weightFn;\n    if( is.fn( options.weight ) ){\n      weightFn = options.weight;\n      weighted = true;\n    } else {\n      weighted = false;\n    }\n\n    // Directed - default false\n    var directed = options.directed != null ? options.directed : false;\n\n    var cy = this._private.cy;\n\n    // starting\n    var V = this.nodes();\n    var A = {};\n    var _C = {};\n    var max;\n    var C = {\n      set: function( key, val ){\n        _C[ key ] = val;\n\n        if( val > max ){ max = val; }\n      },\n\n      get: function( key ){ return _C[ key ]; }\n    };\n\n    // A contains the neighborhoods of every node\n    for( var i = 0; i < V.length; i++ ){\n      var v = V[ i ];\n      var vid = v.id();\n\n      if( directed ){\n        A[ vid ] = v.outgoers().nodes(); // get outgoers of every node\n      } else {\n        A[ vid ] = v.openNeighborhood().nodes(); // get neighbors of every node\n      }\n\n      C.set( vid, 0 );\n    }\n\n    for( var s = 0; s < V.length; s++ ){\n      var sid = V[s].id();\n      var S = []; // stack\n      var P = {};\n      var g = {};\n      var d = {};\n      var Q = new Heap(function( a, b ){\n        return d[a] - d[b];\n      }); // queue\n\n      // init dictionaries\n      for( var i = 0; i < V.length; i++ ){\n        var vid = V[ i ].id();\n\n        P[ vid ] = [];\n        g[ vid ] = 0;\n        d[ vid ] = Infinity;\n      }\n\n      g[ sid ] = 1; // sigma\n      d[ sid ] = 0; // distance to s\n\n      Q.push( sid );\n\n      while( !Q.empty() ){\n        var v = Q.pop();\n\n        S.push( v );\n\n        if( weighted ){\n          for( var j = 0; j < A[v].length; j++ ){\n            var w = A[v][j];\n            var vEle = cy.getElementById( v );\n\n            var edge;\n            if( vEle.edgesTo( w ).length > 0 ){\n              edge = vEle.edgesTo( w )[0];\n            } else {\n              edge = w.edgesTo( vEle )[0];\n            }\n\n            var edgeWeight = weightFn.apply( edge, [ edge ] );\n\n            w = w.id();\n\n            if( d[w] > d[v] + edgeWeight ){\n              d[w] = d[v] + edgeWeight;\n\n              if( Q.nodes.indexOf( w ) < 0 ){ //if w is not in Q\n                Q.push( w );\n              } else { // update position if w is in Q\n                Q.updateItem( w );\n              }\n\n              g[w] = 0;\n              P[w] = [];\n            }\n\n            if( d[w] == d[v] + edgeWeight ){\n              g[w] = g[w] + g[v];\n              P[w].push( v );\n            }\n          }\n        } else {\n          for( var j = 0; j < A[v].length; j++ ){\n            var w = A[v][j].id();\n\n            if( d[w] == Infinity ){\n              Q.push( w );\n\n              d[w] = d[v] + 1;\n            }\n\n            if( d[w] == d[v] + 1 ){\n              g[w] = g[w] + g[v];\n              P[w].push( v );\n            }\n          }\n        }\n      }\n\n      var e = {};\n      for( var i = 0; i < V.length; i++ ){\n        e[ V[ i ].id() ] = 0;\n      }\n\n      while( S.length > 0 ){\n        var w = S.pop();\n\n        for( var j = 0; j < P[w].length; j++ ){\n          var v = P[w][j];\n\n          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);\n\n          if( w != V[s].id() ){\n            C.set( w, C.get( w ) + e[w] );\n          }\n        }\n      }\n    }\n\n    var ret = {\n      betweenness: function( node ){\n        if( is.string( node ) ){\n          var node = cy.filter( node ).id();\n        } else {\n          var node = node.id();\n        }\n\n        return C.get( node );\n      },\n\n      betweennessNormalized: function( node ){\n        if( is.string( node ) ){\n          var node = cy.filter( node ).id();\n        } else {\n          var node = node.id();\n        }\n\n        return C.get( node ) / max;\n      }\n    };\n\n    // alias\n    ret.betweennessNormalised = ret.betweennessNormalized;\n\n    return ret;\n  } // betweennessCentrality\n\n}); // elesfn\n\n// nice, short mathemathical alias\nelesfn.bc = elesfn.betweennessCentrality;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/algorithms/betweenness-centrality.js\n ** module id = 54\n ** module chunks = 0\n **/","'use strict';\n\nvar define = require( '../define' );\n\nvar elesfn = ({\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop()\n});\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/animation.js\n ** module id = 55\n ** module chunks = 0\n **/","'use strict';\n\n// use this module to cherry pick functions into your prototype\n// (useful for functions shared between the core and collections, for example)\n\n// e.g.\n// var foo = define.foo({ /* params... */ })\n\nvar util = require( './util' );\nvar is = require( './is' );\nvar Selector = require( './selector' );\nvar Promise = require( './promise' );\nvar Event = require( './event' );\nvar Animation = require( './animation' );\n\nvar define = {\n\n  // access data field\n  data: function( params ){\n    var defaults = {\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: false,\n      allowSetting: false,\n      allowGetting: false,\n      settingEvent: 'data',\n      settingTriggersEvent: false,\n      triggerFnName: 'trigger',\n      immutableKeys: {}, // key => true if immutable\n      updateStyle: false,\n      onSet: function( self ){},\n      canSet: function( self ){ return true; }\n    };\n    params = util.extend( {}, defaults, params );\n\n    return function dataImpl( name, value ){\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var single = selfIsArrayLike ? self[0] : self;\n\n      // .data('foo', ...)\n      if( is.string( name ) ){ // set or get property\n\n        // .data('foo')\n        if( p.allowGetting && value === undefined ){ // get\n\n          var ret;\n          if( single ){\n            ret = single._private[ p.field ][ name ];\n          }\n          return ret;\n\n        // .data('foo', 'bar')\n        } else if( p.allowSetting && value !== undefined ){ // set\n          var valid = !p.immutableKeys[ name ];\n          if( valid ){\n            for( var i = 0, l = all.length; i < l; i++ ){\n              if( p.canSet( all[ i ] ) ){\n                all[ i ]._private[ p.field ][ name ] = value;\n              }\n            }\n\n            // update mappers if asked\n            if( p.updateStyle ){ self.updateStyle(); }\n\n            // call onSet callback\n            p.onSet( self );\n\n            if( p.settingTriggersEvent ){\n              self[ p.triggerFnName ]( p.settingEvent );\n            }\n          }\n        }\n\n      // .data({ 'foo': 'bar' })\n      } else if( p.allowSetting && is.plainObject( name ) ){ // extend\n        var obj = name;\n        var k, v;\n        var keys = Object.keys( obj );\n\n        for( var i = 0; i < keys.length; i++ ){\n          k = keys[ i ];\n          v = obj[ k ];\n\n          var valid = !p.immutableKeys[ k ];\n          if( valid ){\n            for( var j = 0; j < all.length; j++ ){\n              var ele = all[j];\n\n              if( p.canSet( ele ) ){\n                ele._private[ p.field ][ k ] = v;\n              }\n            }\n          }\n        }\n\n        // update mappers if asked\n        if( p.updateStyle ){ self.updateStyle(); }\n\n        // call onSet callback\n        p.onSet( self );\n\n        if( p.settingTriggersEvent ){\n          self[ p.triggerFnName ]( p.settingEvent );\n        }\n\n      // .data(function(){ ... })\n      } else if( p.allowBinding && is.fn( name ) ){ // bind to event\n        var fn = name;\n        self.on( p.bindingEvent, fn );\n\n      // .data()\n      } else if( p.allowGetting && name === undefined ){ // get whole object\n        var ret;\n        if( single ){\n          ret = single._private[ p.field ];\n        }\n        return ret;\n      }\n\n      return self; // maintain chainability\n    }; // function\n  }, // data\n\n  // remove data field\n  removeData: function( params ){\n    var defaults = {\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: false,\n      immutableKeys: {} // key => true if immutable\n    };\n    params = util.extend( {}, defaults, params );\n\n    return function removeDataImpl( names ){\n      var p = params;\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n\n      // .removeData('foo bar')\n      if( is.string( names ) ){ // then get the list of keys, and delete them\n        var keys = names.split( /\\s+/ );\n        var l = keys.length;\n\n        for( var i = 0; i < l; i++ ){ // delete each non-empty key\n          var key = keys[ i ];\n          if( is.emptyString( key ) ){ continue; }\n\n          var valid = !p.immutableKeys[ key ]; // not valid if immutable\n          if( valid ){\n            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n              all[ i_a ]._private[ p.field ][ key ] = undefined;\n            }\n          }\n        }\n\n        if( p.triggerEvent ){\n          self[ p.triggerFnName ]( p.event );\n        }\n\n      // .removeData()\n      } else if( names === undefined ){ // then delete all keys\n\n        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n          var _privateFields = all[ i_a ]._private[ p.field ];\n          var keys = Object.keys( _privateFields );\n\n          for( var i = 0; i < keys.length; i++ ){\n            var key = keys[i];\n            var validKeyToDelete = !p.immutableKeys[ key ];\n\n            if( validKeyToDelete ){\n              _privateFields[ key ] = undefined;\n            }\n          }\n        }\n\n        if( p.triggerEvent ){\n          self[ p.triggerFnName ]( p.event );\n        }\n      }\n\n      return self; // maintain chaining\n    }; // function\n  }, // removeData\n\n  // event function reusable stuff\n  event: {\n    regex: /(\\w+)(\\.(?:\\w+|\\*))?/, // regex for matching event strings (e.g. \"click.namespace\")\n    universalNamespace: '.*', // matches as if no namespace specified and prevents users from unbinding accidentally\n    optionalTypeRegex: /(\\w+)?(\\.(?:\\w+|\\*))?/,\n    falseCallback: function(){ return false; }\n  },\n\n  // event binding\n  on: function( params ){\n    var defaults = {\n      unbindSelfOnTrigger: false,\n      unbindAllBindersOnTrigger: false\n    };\n    params = util.extend( {}, defaults, params );\n\n    return function onImpl( events, selector, data, callback ){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var eventsIsString = is.string( events );\n      var p = params;\n\n      if( is.plainObject( selector ) ){ // selector is actually data\n        callback = data;\n        data = selector;\n        selector = undefined;\n      } else if( is.fn( selector ) || selector === false ){ // selector is actually callback\n        callback = selector;\n        data = undefined;\n        selector = undefined;\n      }\n\n      if( is.fn( data ) || data === false ){ // data is actually callback\n        callback = data;\n        data = undefined;\n      }\n\n      // if there isn't a callback, we can't really do anything\n      // (can't speak for mapped events arg version)\n      if( !(is.fn( callback ) || callback === false) && eventsIsString ){\n        return self; // maintain chaining\n      }\n\n      if( eventsIsString ){ // then convert to map\n        var map = {};\n        map[ events ] = callback;\n        events = map;\n      }\n\n      var keys = Object.keys( events );\n\n      for( var k = 0; k < keys.length; k++ ){\n        var evts = keys[k];\n\n        callback = events[ evts ];\n        if( callback === false ){\n          callback = define.event.falseCallback;\n        }\n\n        if( !is.fn( callback ) ){ continue; }\n\n        evts = evts.split( /\\s+/ );\n        for( var i = 0; i < evts.length; i++ ){\n          var evt = evts[ i ];\n          if( is.emptyString( evt ) ){ continue; }\n\n          var match = evt.match( define.event.regex ); // type[.namespace]\n\n          if( match ){\n            var type = match[1];\n            var namespace = match[2] ? match[2] : undefined;\n\n            var listener = {\n              callback: callback, // callback to run\n              data: data, // extra data in eventObj.data\n              delegated: selector ? true : false, // whether the evt is delegated\n              selector: selector, // the selector to match for delegated events\n              selObj: new Selector( selector ), // cached selector object to save rebuilding\n              type: type, // the event type (e.g. 'click')\n              namespace: namespace, // the event namespace (e.g. \".foo\")\n              unbindSelfOnTrigger: p.unbindSelfOnTrigger,\n              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,\n              binders: all // who bound together\n            };\n\n            for( var j = 0; j < all.length; j++ ){\n              var _p = all[ j ]._private = all[ j ]._private || {};\n\n              _p.listeners = _p.listeners || [];\n              _p.listeners.push( listener );\n            }\n          }\n        } // for events array\n      } // for events map\n\n      return self; // maintain chaining\n    }; // function\n  }, // on\n\n  eventAliasesOn: function( proto ){\n    var p = proto;\n\n    p.addListener = p.listen = p.bind = p.on;\n    p.removeListener = p.unlisten = p.unbind = p.off;\n    p.emit = p.trigger;\n\n    // this is just a wrapper alias of .on()\n    p.pon = p.promiseOn = function( events, selector ){\n      var self = this;\n      var args = Array.prototype.slice.call( arguments, 0 );\n\n      return new Promise( function( resolve, reject ){\n        var callback = function( e ){\n          self.off.apply( self, offArgs );\n\n          resolve( e );\n        };\n\n        var onArgs = args.concat( [ callback ] );\n        var offArgs = onArgs.concat( [] );\n\n        self.on.apply( self, onArgs );\n      } );\n    };\n  },\n\n  off: function offImpl( params ){\n    var defaults = {\n    };\n    params = util.extend( {}, defaults, params );\n\n    return function( events, selector, callback ){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var eventsIsString = is.string( events );\n\n      if( arguments.length === 0 ){ // then unbind all\n\n        for( var i = 0; i < all.length; i++ ){\n          all[ i ]._private = all[ i ]._private || {};\n\n          _p.listeners = [];\n        }\n\n        return self; // maintain chaining\n      }\n\n      if( is.fn( selector ) || selector === false ){ // selector is actually callback\n        callback = selector;\n        selector = undefined;\n      }\n\n      if( eventsIsString ){ // then convert to map\n        var map = {};\n        map[ events ] = callback;\n        events = map;\n      }\n\n      var keys = Object.keys( events );\n\n      for( var k = 0; k < keys.length; k++ ){\n        var evts = keys[k];\n\n        callback = events[ evts ];\n\n        if( callback === false ){\n          callback = define.event.falseCallback;\n        }\n\n        evts = evts.split( /\\s+/ );\n        for( var h = 0; h < evts.length; h++ ){\n          var evt = evts[ h ];\n          if( is.emptyString( evt ) ){ continue; }\n\n          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]\n          if( match ){\n            var type = match[1] ? match[1] : undefined;\n            var namespace = match[2] ? match[2] : undefined;\n\n            for( var i = 0; i < all.length; i++ ){ //\n              var _p = all[ i ]._private = all[ i ]._private || {};\n              var listeners = _p.listeners = _p.listeners || [];\n\n              for( var j = 0; j < listeners.length; j++ ){\n                var listener = listeners[ j ];\n                var nsMatches = !namespace || namespace === listener.namespace;\n                var typeMatches = !type || listener.type === type;\n                var cbMatches = !callback || callback === listener.callback;\n                var listenerMatches = nsMatches && typeMatches && cbMatches;\n\n                // delete listener if it matches\n                if( listenerMatches ){\n                  listeners.splice( j, 1 );\n                  j--;\n                }\n              } // for listeners\n            } // for all\n          } // if match\n        } // for events array\n\n      } // for events map\n\n      return self; // maintain chaining\n    }; // function\n  }, // off\n\n  trigger: function( params ){\n    var defaults = {};\n    params = util.extend( {}, defaults, params );\n\n    return function triggerImpl( events, extraParams, fnToTrigger ){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var eventsIsString = is.string( events );\n      var eventsIsObject = is.plainObject( events );\n      var eventsIsEvent = is.event( events );\n      var _p = this._private = this._private || {};\n      var cy = _p.cy || ( is.core( this ) ? this : null );\n      var hasCompounds = cy ? cy.hasCompoundNodes() : false;\n\n      if( eventsIsString ){ // then make a plain event object for each event name\n        var evts = events.split( /\\s+/ );\n        events = [];\n\n        for( var i = 0; i < evts.length; i++ ){\n          var evt = evts[ i ];\n          if( is.emptyString( evt ) ){ continue; }\n\n          var match = evt.match( define.event.regex ); // type[.namespace]\n          var type = match[1];\n          var namespace = match[2] ? match[2] : undefined;\n\n          events.push( {\n            type: type,\n            namespace: namespace\n          } );\n        }\n      } else if( eventsIsObject ){ // put in length 1 array\n        var eventArgObj = events;\n\n        events = [ eventArgObj ];\n      }\n\n      if( extraParams ){\n        if( !is.array( extraParams ) ){ // make sure extra params are in an array if specified\n          extraParams = [ extraParams ];\n        }\n      } else { // otherwise, we've got nothing\n        extraParams = [];\n      }\n\n      for( var i = 0; i < events.length; i++ ){ // trigger each event in order\n        var evtObj = events[ i ];\n\n        for( var j = 0; j < all.length; j++ ){ // for each\n          var triggerer = all[ j ];\n          var _p = triggerer._private = triggerer._private || {};\n          var listeners = _p.listeners = _p.listeners || [];\n          var triggererIsElement = is.element( triggerer );\n          var bubbleUp = triggererIsElement || params.layout;\n\n          // create the event for this element from the event object\n          var evt;\n\n          if( eventsIsEvent ){ // then just get the object\n            evt = evtObj;\n\n            evt.cyTarget = evt.cyTarget || triggerer;\n            evt.cy = evt.cy || cy;\n\n          } else { // then we have to make one\n            evt = new Event( evtObj, {\n              cyTarget: triggerer,\n              cy: cy,\n              namespace: evtObj.namespace\n            } );\n          }\n\n          // if a layout was specified, then put it in the typed event\n          if( evtObj.layout ){\n            evt.layout = evtObj.layout;\n          }\n\n          // if triggered by layout, put in event\n          if( params.layout ){\n            evt.layout = triggerer;\n          }\n\n          // create a rendered position based on the passed position\n          if( evt.cyPosition ){\n            var pos = evt.cyPosition;\n            var zoom = cy.zoom();\n            var pan = cy.pan();\n\n            evt.cyRenderedPosition = {\n              x: pos.x * zoom + pan.x,\n              y: pos.y * zoom + pan.y\n            };\n          }\n\n          if( fnToTrigger ){ // then override the listeners list with just the one we specified\n            listeners = [ {\n              namespace: evt.namespace,\n              type: evt.type,\n              callback: fnToTrigger\n            } ];\n          }\n\n          for( var k = 0; k < listeners.length; k++ ){ // check each listener\n            var lis = listeners[ k ];\n            var nsMatches = !lis.namespace || lis.namespace === evt.namespace || lis.namespace === define.event.universalNamespace;\n            var typeMatches = lis.type === evt.type;\n            var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && is.element( evt.cyTarget ) && lis.selObj.matches( evt.cyTarget ) ) : (true); // we're not going to validate the hierarchy; that's too expensive\n            var listenerMatches = nsMatches && typeMatches && targetMatches;\n\n            if( listenerMatches ){ // then trigger it\n              var args = [ evt ];\n              args = args.concat( extraParams ); // add extra params to args list\n\n              if( lis.data ){ // add on data plugged into binding\n                evt.data = lis.data;\n              } else { // or clear it in case the event obj is reused\n                evt.data = undefined;\n              }\n\n              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener\n                listeners.splice( k, 1 );\n                k--;\n              }\n\n              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders\n                var binders = lis.binders;\n                for( var l = 0; l < binders.length; l++ ){\n                  var binder = binders[ l ];\n                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it\n\n                  var binderListeners = binder._private.listeners;\n                  for( var m = 0; m < binderListeners.length; m++ ){\n                    var binderListener = binderListeners[ m ];\n\n                    if( binderListener === lis ){ // delete listener from list\n                      binderListeners.splice( m, 1 );\n                      m--;\n                    }\n                  }\n                }\n              }\n\n              // run the callback\n              var context = lis.delegated ? evt.cyTarget : triggerer;\n              var ret = lis.callback.apply( context, args );\n\n              if( ret === false || evt.isPropagationStopped() ){\n                // then don't bubble\n                bubbleUp = false;\n\n                if( ret === false ){\n                  // returning false is a shorthand for stopping propagation and preventing the def. action\n                  evt.stopPropagation();\n                  evt.preventDefault();\n                }\n              }\n            } // if listener matches\n          } // for each listener\n\n          // bubble up event for elements\n          if( bubbleUp ){\n            var parent = hasCompounds ? triggerer._private.parent : null;\n            var hasParent = parent != null && parent.length !== 0;\n\n            if( hasParent ){ // then bubble up to parent\n              parent = parent[0];\n              parent.trigger( evt );\n            } else { // otherwise, bubble up to the core\n              cy.trigger( evt );\n            }\n          }\n\n        } // for each of all\n      } // for each event\n\n      return self; // maintain chaining\n    }; // function\n  }, // trigger\n\n  animated: function( fnParams ){\n    var defaults = {};\n    fnParams = util.extend( {}, defaults, fnParams );\n\n    return function animatedImpl(){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if( !cy.styleEnabled() ){ return false; }\n\n      var ele = all[0];\n\n      if( ele ){\n        return ele._private.animation.current.length > 0;\n      }\n    };\n  }, // animated\n\n  clearQueue: function( fnParams ){\n    var defaults = {};\n    fnParams = util.extend( {}, defaults, fnParams );\n\n    return function clearQueueImpl(){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      for( var i = 0; i < all.length; i++ ){\n        var ele = all[ i ];\n        ele._private.animation.queue = [];\n      }\n\n      return this;\n    };\n  }, // clearQueue\n\n  delay: function( fnParams ){\n    var defaults = {};\n    fnParams = util.extend( {}, defaults, fnParams );\n\n    return function delayImpl( time, complete ){\n      var cy = this._private.cy || this;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      return this.animate( {\n        delay: time,\n        duration: time,\n        complete: complete\n      } );\n    };\n  }, // delay\n\n  delayAnimation: function( fnParams ){\n    var defaults = {};\n    fnParams = util.extend( {}, defaults, fnParams );\n\n    return function delayAnimationImpl( time, complete ){\n      var cy = this._private.cy || this;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      return this.animation( {\n        delay: time,\n        duration: time,\n        complete: complete\n      } );\n    };\n  }, // delay\n\n  animation: function( fnParams ){\n    var defaults = {};\n    fnParams = util.extend( {}, defaults, fnParams );\n\n    return function animationImpl( properties, params ){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var cy = this._private.cy || this;\n      var isCore = !selfIsArrayLike;\n      var isEles = !isCore;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      var style = cy.style();\n\n      properties = util.extend( {}, properties, params );\n\n      if( properties.duration === undefined ){\n        properties.duration = 400;\n      }\n\n      switch( properties.duration ){\n      case 'slow':\n        properties.duration = 600;\n        break;\n      case 'fast':\n        properties.duration = 200;\n        break;\n      }\n\n      var propertiesEmpty = Object.keys( properties ).length === 0;\n\n      if( propertiesEmpty ){\n        return new Animation( all[0], properties ); // nothing to animate\n      }\n\n      if( isEles ){\n        properties.style = style.getPropsList( properties.style || properties.css );\n\n        properties.css = undefined;\n      }\n\n      if( properties.renderedPosition && isEles ){\n        var rpos = properties.renderedPosition;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n\n        properties.position = {\n          x: ( rpos.x - pan.x ) / zoom,\n          y: ( rpos.y - pan.y ) / zoom\n        };\n      }\n\n      // override pan w/ panBy if set\n      if( properties.panBy && isCore ){\n        var panBy = properties.panBy;\n        var cyPan = cy.pan();\n\n        properties.pan = {\n          x: cyPan.x + panBy.x,\n          y: cyPan.y + panBy.y\n        };\n      }\n\n      // override pan w/ center if set\n      var center = properties.center || properties.centre;\n      if( center && isCore ){\n        var centerPan = cy.getCenterPan( center.eles, properties.zoom );\n\n        if( centerPan ){\n          properties.pan = centerPan;\n        }\n      }\n\n      // override pan & zoom w/ fit if set\n      if( properties.fit && isCore ){\n        var fit = properties.fit;\n        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );\n\n        if( fitVp ){\n          properties.pan = fitVp.pan;\n          properties.zoom = fitVp.zoom;\n        }\n      }\n\n      return new Animation( all[0], properties );\n    };\n  }, // animate\n\n  animate: function( fnParams ){\n    var defaults = {};\n    fnParams = util.extend( {}, defaults, fnParams );\n\n    return function animateImpl( properties, params ){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      if( params ){\n        properties = util.extend( {}, properties, params );\n      }\n\n      // manually hook and run the animation\n      for( var i = 0; i < all.length; i++ ){\n        var ele = all[ i ];\n        var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n\n        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );\n\n        ani.play();\n      }\n\n      return this; // chaining\n    };\n  }, // animate\n\n  stop: function( fnParams ){\n    var defaults = {};\n    fnParams = util.extend( {}, defaults, fnParams );\n\n    return function stopImpl( clearQueue, jumpToEnd ){\n      var self = this;\n      var selfIsArrayLike = self.length !== undefined;\n      var all = selfIsArrayLike ? self : [ self ]; // put in array if not array-like\n      var cy = this._private.cy || this;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      for( var i = 0; i < all.length; i++ ){\n        var ele = all[ i ];\n        var _p = ele._private;\n        var anis = _p.animation.current;\n\n        for( var j = 0; j < anis.length; j++ ){\n          var ani = anis[ j ];\n          var ani_p = ani._private;\n\n          if( jumpToEnd ){\n            // next iteration of the animation loop, the animation\n            // will go straight to the end and be removed\n            ani_p.duration = 0;\n          }\n        }\n\n        // clear the queue of future animations\n        if( clearQueue ){\n          _p.animation.queue = [];\n        }\n\n        if( !jumpToEnd ){\n          _p.animation.current = [];\n        }\n      }\n\n      // we have to notify (the animation loop doesn't do it for us on `stop`)\n      cy.notify( {\n        eles: this,\n        type: 'draw'\n      } );\n\n      return this;\n    };\n  } // stop\n\n}; // define\n\nmodule.exports = define;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/define.js\n ** module id = 56\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( './is' );\nvar util = require( './util' );\n\nvar Selector = function( selector ){\n\n  if( !(this instanceof Selector) ){\n    return new Selector( selector );\n  }\n\n  var self = this;\n\n  self._private = {\n    selectorText: null,\n    invalid: true\n  };\n\n  // storage for parsed queries\n  var newQuery = function(){\n    return {\n      classes: [],\n      colonSelectors: [],\n      data: [],\n      group: null,\n      ids: [],\n      meta: [],\n\n      // fake selectors\n      collection: null, // a collection to match against\n      filter: null, // filter function\n\n      // these are defined in the upward direction rather than down (e.g. child)\n      // because we need to go up in Selector.filter()\n      parent: null, // parent query obj\n      ancestor: null, // ancestor query obj\n      subject: null, // defines subject in compound query (subject query obj; points to self if subject)\n\n      // use these only when subject has been defined\n      child: null,\n      descendant: null\n    };\n  };\n\n  if( !selector || ( is.string( selector ) && selector.match( /^\\s*$/ ) ) ){\n\n    self.length = 0;\n\n  } else if( selector === '*' || selector === 'edge' || selector === 'node' ){\n\n    // make single, group-only selectors cheap to make and cheap to filter\n\n    self[0] = newQuery();\n    self[0].group = selector === '*' ? selector : selector + 's';\n    self[0].groupOnly = true;\n    self._private.invalid = false;\n    self._private.selectorText = selector;\n    self.length = 1;\n\n  } else if( is.elementOrCollection( selector ) ){\n\n    var collection = selector.collection();\n\n    self[0] = newQuery();\n    self[0].collection = collection;\n    self.length = 1;\n\n  } else if( is.fn( selector ) ){\n\n    self[0] = newQuery();\n    self[0].filter = selector;\n    self.length = 1;\n\n  } else if( is.string( selector ) ){\n\n    // the current subject in the query\n    var currentSubject = null;\n\n    // tokens in the query language\n    var tokens = {\n      metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]', // chars we need to escape in var names, etc\n      comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=', // binary comparison op (used in data selectors)\n      boolOp: '\\\\?|\\\\!|\\\\^', // boolean (unary) operators (used in data selectors)\n      string: '\"(?:\\\\\\\\\"|[^\"])+\"' + '|' + \"'(?:\\\\\\\\'|[^'])+'\", // string literals (used in data selectors) -- doublequotes | singlequotes\n      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)\n      separator: '\\\\s*,\\\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n      descendant: '\\\\s+',\n      child: '\\\\s+>\\\\s+',\n      subject: '\\\\$'\n    };\n    tokens.variable = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name\n    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n    tokens.className = tokens.variable; // a class name (follows variable conventions)\n    tokens.id = tokens.variable; // an element id (follows variable conventions)\n\n    // when a token like a variable has escaped meta characters, we need to clean the backslashes out\n    // so that values get compared properly in Selector.filter()\n    var cleanMetaChars = function( str ){\n      return str.replace( new RegExp( '\\\\\\\\(' + tokens.metaChar + ')', 'g' ), function( match, $1, offset, original ){\n        return $1;\n      } );\n    };\n\n    // add @ variants to comparatorOp\n    var ops = tokens.comparatorOp.split( '|' );\n    for( var i = 0; i < ops.length; i++ ){\n      var op = ops[ i ];\n      tokens.comparatorOp += '|@' + op;\n    }\n\n    // add ! variants to comparatorOp\n    var ops = tokens.comparatorOp.split( '|' );\n    for( var i = 0; i < ops.length; i++ ){\n      var op = ops[ i ];\n\n      if( op.indexOf( '!' ) >= 0 ){ continue; } // skip ops that explicitly contain !\n      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined\n\n      tokens.comparatorOp += '|\\\\!' + op;\n    }\n\n    // NOTE: add new expression syntax here to have it recognised by the parser;\n    // - a query contains all adjacent (i.e. no separator in between) expressions;\n    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;\n    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward\n    // - when you add something here, also add to Selector.toString()\n    var exprs = [\n      {\n        name: 'group',\n        query: true,\n        regex: '(node|edge|\\\\*)',\n        populate: function( group ){\n          this.group = group === '*' ? group : group + 's';\n        }\n      },\n\n      {\n        name: 'state',\n        query: true,\n        // NB: if one colon selector is a substring of another from its start, place the longer one first\n        // e.g. :foobar|:foo\n        regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',\n        populate: function( state ){\n          this.colonSelectors.push( state );\n        }\n      },\n\n      {\n        name: 'id',\n        query: true,\n        regex: '\\\\#(' + tokens.id + ')',\n        populate: function( id ){\n          this.ids.push( cleanMetaChars( id ) );\n        }\n      },\n\n      {\n        name: 'className',\n        query: true,\n        regex: '\\\\.(' + tokens.className + ')',\n        populate: function( className ){\n          this.classes.push( cleanMetaChars( className ) );\n        }\n      },\n\n      {\n        name: 'dataExists',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n        populate: function( variable ){\n          this.data.push( {\n            field: cleanMetaChars( variable )\n          } );\n        }\n      },\n\n      {\n        name: 'dataCompare',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n        populate: function( variable, comparatorOp, value ){\n          var valueIsString = new RegExp( '^' + tokens.string + '$' ).exec( value ) != null;\n\n          if( valueIsString ){\n            value = value.substring( 1, value.length - 1 );\n          } else {\n            value = parseFloat( value );\n          }\n\n          this.data.push( {\n            field: cleanMetaChars( variable ),\n            operator: comparatorOp,\n            value: value\n          } );\n        }\n      },\n\n      {\n        name: 'dataBool',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n        populate: function( boolOp, variable ){\n          this.data.push( {\n            field: cleanMetaChars( variable ),\n            operator: boolOp\n          } );\n        }\n      },\n\n      {\n        name: 'metaCompare',\n        query: true,\n        regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n        populate: function( meta, comparatorOp, number ){\n          this.meta.push( {\n            field: cleanMetaChars( meta ),\n            operator: comparatorOp,\n            value: parseFloat( number )\n          } );\n        }\n      },\n\n      {\n        name: 'nextQuery',\n        separator: true,\n        regex: tokens.separator,\n        populate: function(){\n          // go on to next query\n          self[ ++i ] = newQuery();\n          currentSubject = null;\n        }\n      },\n\n      {\n        name: 'child',\n        separator: true,\n        regex: tokens.child,\n        populate: function(){\n          // this query is the parent of the following query\n          var childQuery = newQuery();\n          childQuery.parent = this;\n          childQuery.subject = currentSubject;\n\n          // we're now populating the child query with expressions that follow\n          self[ i ] = childQuery;\n        }\n      },\n\n      {\n        name: 'descendant',\n        separator: true,\n        regex: tokens.descendant,\n        populate: function(){\n          // this query is the ancestor of the following query\n          var descendantQuery = newQuery();\n          descendantQuery.ancestor = this;\n          descendantQuery.subject = currentSubject;\n\n          // we're now populating the descendant query with expressions that follow\n          self[ i ] = descendantQuery;\n        }\n      },\n\n      {\n        name: 'subject',\n        modifier: true,\n        regex: tokens.subject,\n        populate: function(){\n          if( currentSubject != null && this.subject != this ){\n            util.error( 'Redefinition of subject in selector `' + selector + '`' );\n            return false;\n          }\n\n          currentSubject = this;\n          this.subject = this;\n        }\n\n      }\n    ];\n\n    self._private.selectorText = selector;\n    var remaining = selector;\n    var i = 0;\n\n    // of all the expressions, find the first match in the remaining text\n    var consumeExpr = function( expectation ){\n      var expr;\n      var match;\n      var name;\n\n      for( var j = 0; j < exprs.length; j++ ){\n        var e = exprs[ j ];\n        var n = e.name;\n\n        // ignore this expression if it doesn't meet the expectation function\n        if( is.fn( expectation ) && !expectation( n, e ) ){ continue; }\n\n        var m = remaining.match( new RegExp( '^' + e.regex ) );\n\n        if( m != null ){\n          match = m;\n          expr = e;\n          name = n;\n\n          var consumed = m[0];\n          remaining = remaining.substring( consumed.length );\n\n          break; // we've consumed one expr, so we can return now\n        }\n      }\n\n      return {\n        expr: expr,\n        match: match,\n        name: name\n      };\n    };\n\n    // consume all leading whitespace\n    var consumeWhitespace = function(){\n      var match = remaining.match( /^\\s+/ );\n\n      if( match ){\n        var consumed = match[0];\n        remaining = remaining.substring( consumed.length );\n      }\n    };\n\n    self[0] = newQuery(); // get started\n\n    consumeWhitespace(); // get rid of leading whitespace\n    for( ;; ){\n      var check = consumeExpr();\n\n      if( check.expr == null ){\n        util.error( 'The selector `' + selector + '`is invalid' );\n        return;\n      } else {\n        var args = [];\n        for( var j = 1; j < check.match.length; j++ ){\n          args.push( check.match[ j ] );\n        }\n\n        // let the token populate the selector object (i.e. in self[i])\n        var ret = check.expr.populate.apply( self[ i ], args );\n\n        if( ret === false ){ return; } // exit if population failed\n      }\n\n      // we're done when there's nothing left to parse\n      if( remaining.match( /^\\s*$/ ) ){\n        break;\n      }\n    }\n\n    self.length = i + 1;\n\n    // adjust references for subject\n    for( var j = 0; j < self.length; j++ ){\n      var query = self[ j ];\n\n      if( query.subject != null ){\n        // go up the tree until we reach the subject\n        for( ;; ){\n          if( query.subject == query ){ break; } // done if subject is self\n\n          if( query.parent != null ){ // swap parent/child reference\n            var parent = query.parent;\n            var child = query;\n\n            child.parent = null;\n            parent.child = child;\n\n            query = parent; // go up the tree\n          } else if( query.ancestor != null ){ // swap ancestor/descendant\n            var ancestor = query.ancestor;\n            var descendant = query;\n\n            descendant.ancestor = null;\n            ancestor.descendant = descendant;\n\n            query = ancestor; // go up the tree\n          } else {\n            util.error( 'When adjusting references for the selector `' + query + '`, neither parent nor ancestor was found' );\n            break;\n          }\n        } // for\n\n        self[ j ] = query.subject; // subject should be the root query\n      } // if\n    } // for\n\n  } else {\n    util.error( 'A selector must be created from a string; found ' + selector );\n    return;\n  }\n\n  self._private.invalid = false;\n\n};\n\nvar selfn = Selector.prototype;\n\nselfn.size = function(){\n  return this.length;\n};\n\nselfn.eq = function( i ){\n  return this[ i ];\n};\n\nvar queryMatches = function( query, ele ){\n  var ele_p = ele._private;\n\n  // make single group-only selectors really cheap to check since they're the most common ones\n  if( query.groupOnly ){\n    return query.group === '*' || query.group === ele_p.group;\n  }\n\n  // check group\n  if( query.group != null && query.group != '*' && query.group != ele_p.group ){\n    return false;\n  }\n\n  var cy = ele.cy();\n\n  // check colon selectors\n  var allColonSelectorsMatch = true;\n  for( var k = 0; k < query.colonSelectors.length; k++ ){\n    var sel = query.colonSelectors[ k ];\n\n    switch( sel ){\n      case ':selected':\n        allColonSelectorsMatch = ele.selected();\n        break;\n      case ':unselected':\n        allColonSelectorsMatch = !ele.selected();\n        break;\n      case ':selectable':\n        allColonSelectorsMatch = ele.selectable();\n        break;\n      case ':unselectable':\n        allColonSelectorsMatch = !ele.selectable();\n        break;\n      case ':locked':\n        allColonSelectorsMatch = ele.locked();\n        break;\n      case ':unlocked':\n        allColonSelectorsMatch = !ele.locked();\n        break;\n      case ':visible':\n        allColonSelectorsMatch = ele.visible();\n        break;\n      case ':hidden':\n        allColonSelectorsMatch = !ele.visible();\n        break;\n      case ':transparent':\n        allColonSelectorsMatch = ele.transparent();\n        break;\n      case ':grabbed':\n        allColonSelectorsMatch = ele.grabbed();\n        break;\n      case ':free':\n        allColonSelectorsMatch = !ele.grabbed();\n        break;\n      case ':removed':\n        allColonSelectorsMatch = ele.removed();\n        break;\n      case ':inside':\n        allColonSelectorsMatch = !ele.removed();\n        break;\n      case ':grabbable':\n        allColonSelectorsMatch = ele.grabbable();\n        break;\n      case ':ungrabbable':\n        allColonSelectorsMatch = !ele.grabbable();\n        break;\n      case ':animated':\n        allColonSelectorsMatch = ele.animated();\n        break;\n      case ':unanimated':\n        allColonSelectorsMatch = !ele.animated();\n        break;\n      case ':parent':\n        allColonSelectorsMatch = ele.isNode() && ele.children().nonempty();\n        break;\n      case ':child':\n      case ':nonorphan':\n        allColonSelectorsMatch = ele.isNode() && ele.parent().nonempty();\n        break;\n      case ':orphan':\n        allColonSelectorsMatch = ele.isNode() && ele.parent().empty();\n        break;\n      case ':loop':\n        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) === ele.data( 'target' );\n        break;\n      case ':simple':\n        allColonSelectorsMatch = ele.isEdge() && ele.data( 'source' ) !== ele.data( 'target' );\n        break;\n      case ':active':\n        allColonSelectorsMatch = ele.active();\n        break;\n      case ':inactive':\n        allColonSelectorsMatch = !ele.active();\n        break;\n      case ':touch':\n        allColonSelectorsMatch = is.touch();\n        break;\n      case ':backgrounding':\n        allColonSelectorsMatch = ele.backgrounding();\n        break;\n      case ':nonbackgrounding':\n        allColonSelectorsMatch = !ele.backgrounding();\n        break;\n    }\n\n    if( !allColonSelectorsMatch ) break;\n  }\n  if( !allColonSelectorsMatch ) return false;\n\n  // check id\n  var allIdsMatch = true;\n  for( var k = 0; k < query.ids.length; k++ ){\n    var id = query.ids[ k ];\n    var actualId = ele_p.data.id;\n\n    allIdsMatch = allIdsMatch && (id == actualId);\n\n    if( !allIdsMatch ) break;\n  }\n  if( !allIdsMatch ) return false;\n\n  // check classes\n  var allClassesMatch = true;\n  for( var k = 0; k < query.classes.length; k++ ){\n    var cls = query.classes[ k ];\n\n    allClassesMatch = allClassesMatch && ele.hasClass( cls );\n\n    if( !allClassesMatch ) break;\n  }\n  if( !allClassesMatch ) return false;\n\n  // generic checking for data/metadata\n  var operandsMatch = function( params ){\n    var allDataMatches = true;\n    for( var k = 0; k < query[ params.name ].length; k++ ){\n      var data = query[ params.name ][ k ];\n      var operator = data.operator;\n      var value = data.value;\n      var field = data.field;\n      var matches;\n\n      if( operator != null && value != null ){\n\n        var fieldVal = params.fieldValue( field );\n        var fieldStr = !is.string( fieldVal ) && !is.number( fieldVal ) ? '' : '' + fieldVal;\n        var valStr = '' + value;\n\n        var caseInsensitive = false;\n        if( operator.indexOf( '@' ) >= 0 ){\n          fieldStr = fieldStr.toLowerCase();\n          valStr = valStr.toLowerCase();\n\n          operator = operator.replace( '@', '' );\n          caseInsensitive = true;\n        }\n\n        var notExpr = false;\n        if( operator.indexOf( '!' ) >= 0 ){\n          operator = operator.replace( '!', '' );\n          notExpr = true;\n        }\n\n        // if we're doing a case insensitive comparison, then we're using a STRING comparison\n        // even if we're comparing numbers\n        if( caseInsensitive ){\n          value = valStr.toLowerCase();\n          fieldVal = fieldStr.toLowerCase();\n        }\n\n        var isIneqCmp = false;\n\n        switch( operator ){\n        case '*=':\n          matches = fieldStr.indexOf( valStr ) >= 0;\n          break;\n        case '$=':\n          matches = fieldStr.indexOf( valStr, fieldStr.length - valStr.length ) >= 0;\n          break;\n        case '^=':\n          matches = fieldStr.indexOf( valStr ) === 0;\n          break;\n        case '=':\n          matches = fieldVal === value;\n          break;\n        case '>':\n          isIneqCmp = true;\n          matches = fieldVal > value;\n          break;\n        case '>=':\n          isIneqCmp = true;\n          matches = fieldVal >= value;\n          break;\n        case '<':\n          isIneqCmp = true;\n          matches = fieldVal < value;\n          break;\n        case '<=':\n          isIneqCmp = true;\n          matches = fieldVal <= value;\n          break;\n        default:\n          matches = false;\n          break;\n        }\n\n        // apply the not op, but null vals for inequalities should always stay non-matching\n        if( notExpr && ( fieldVal != null || !isIneqCmp ) ){\n          matches = !matches;\n        }\n      } else if( operator != null ){\n        switch( operator ){\n        case '?':\n          matches = params.fieldTruthy( field );\n          break;\n        case '!':\n          matches = !params.fieldTruthy( field );\n          break;\n        case '^':\n          matches = params.fieldUndefined( field );\n          break;\n        }\n      } else {\n        matches = !params.fieldUndefined( field );\n      }\n\n      if( !matches ){\n        allDataMatches = false;\n        break;\n      }\n    } // for\n\n    return allDataMatches;\n  }; // operandsMatch\n\n  // check data matches\n  var allDataMatches = operandsMatch( {\n    name: 'data',\n    fieldValue: function( field ){\n      return ele_p.data[ field ];\n    },\n    fieldUndefined: function( field ){\n      return ele_p.data[ field ] === undefined;\n    },\n    fieldTruthy: function( field ){\n      if( ele_p.data[ field ] ){\n        return true;\n      }\n      return false;\n    }\n  } );\n\n  if( !allDataMatches ){\n    return false;\n  }\n\n  // check metadata matches\n  var allMetaMatches = operandsMatch( {\n    name: 'meta',\n    fieldValue: function( field ){\n      return ele[ field ]();\n    },\n    fieldUndefined: function( field ){\n      return ele[ field ]() == null;\n    },\n    fieldTruthy: function( field ){\n      if( ele[ field ]() ){\n        return true;\n      }\n      return false;\n    }\n  } );\n\n  if( !allMetaMatches ){\n    return false;\n  }\n\n  // check collection\n  if( query.collection != null ){\n    var matchesAny = query.collection.hasElementWithId( ele.id() );\n\n    if( !matchesAny ){\n      return false;\n    }\n  }\n\n  // check filter function\n  if( query.filter != null && ele.collection().filter( query.filter ).size() === 0 ){\n    return false;\n  }\n\n  // check parent/child relations\n  var confirmRelations = function( query, eles ){\n    if( query != null ){\n      var matches = false;\n\n      if( !cy.hasCompoundNodes() ){\n        return false;\n      }\n\n      eles = eles(); // save cycles if query == null\n\n      // query must match for at least one element (may be recursive)\n      for( var i = 0; i < eles.length; i++ ){\n        if( queryMatches( query, eles[ i ] ) ){\n          matches = true;\n          break;\n        }\n      }\n\n      return matches;\n    } else {\n      return true;\n    }\n  };\n\n  if( !confirmRelations( query.parent, function(){\n    return ele.parent();\n  } ) ){ return false; }\n\n  if( !confirmRelations( query.ancestor, function(){\n    return ele.parents();\n  } ) ){ return false; }\n\n  if( !confirmRelations( query.child, function(){\n    return ele.children();\n  } ) ){ return false; }\n\n  if( !confirmRelations( query.descendant, function(){\n    return ele.descendants();\n  } ) ){ return false; }\n\n  // we've reached the end, so we've matched everything for this query\n  return true;\n}; // queryMatches\n\n// filter an existing collection\nselfn.filter = function( collection ){\n  var self = this;\n  var cy = collection.cy();\n\n  // don't bother trying if it's invalid\n  if( self._private.invalid ){\n    return cy.collection();\n  }\n\n  var selectorFunction = function( i, element ){\n    for( var j = 0; j < self.length; j++ ){\n      var query = self[ j ];\n\n      if( queryMatches( query, element ) ){\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  if( self._private.selectorText == null ){\n    selectorFunction = function(){ return true; };\n  }\n\n  var filteredCollection = collection.filter( selectorFunction );\n\n  return filteredCollection;\n}; // filter\n\n// does selector match a single element?\nselfn.matches = function( ele ){\n  var self = this;\n\n  // don't bother trying if it's invalid\n  if( self._private.invalid ){\n    return false;\n  }\n\n  for( var j = 0; j < self.length; j++ ){\n    var query = self[ j ];\n\n    if( queryMatches( query, ele ) ){\n      return true;\n    }\n  }\n\n  return false;\n}; // filter\n\n// ith query to string\nselfn.toString = selfn.selector = function(){\n\n  var str = '';\n\n  var clean = function( obj, isValue ){\n    if( is.string( obj ) ){\n      return isValue ? '\"' + obj + '\"' : obj;\n    }\n    return '';\n  };\n\n  var queryToString = function( query ){\n    var str = '';\n\n    if( query.subject === query ){\n      str += '$';\n    }\n\n    var group = clean( query.group );\n    str += group.substring( 0, group.length - 1 );\n\n    for( var j = 0; j < query.data.length; j++ ){\n      var data = query.data[ j ];\n\n      if( data.value ){\n        str += '[' + data.field + clean( data.operator ) + clean( data.value, true ) + ']';\n      } else {\n        str += '[' + clean( data.operator ) + data.field + ']';\n      }\n    }\n\n    for( var j = 0; j < query.meta.length; j++ ){\n      var meta = query.meta[ j ];\n      str += '[[' + meta.field + clean( meta.operator ) + clean( meta.value, true ) + ']]';\n    }\n\n    for( var j = 0; j < query.colonSelectors.length; j++ ){\n      var sel = query.colonSelectors[ i ];\n      str += sel;\n    }\n\n    for( var j = 0; j < query.ids.length; j++ ){\n      var sel = '#' + query.ids[ i ];\n      str += sel;\n    }\n\n    for( var j = 0; j < query.classes.length; j++ ){\n      var sel = '.' + query.classes[ j ];\n      str += sel;\n    }\n\n    if( query.parent != null ){\n      str = queryToString( query.parent ) + ' > ' + str;\n    }\n\n    if( query.ancestor != null ){\n      str = queryToString( query.ancestor ) + ' ' + str;\n    }\n\n    if( query.child != null ){\n      str += ' > ' + queryToString( query.child );\n    }\n\n    if( query.descendant != null ){\n      str += ' ' + queryToString( query.descendant );\n    }\n\n    return str;\n  };\n\n  for( var i = 0; i < this.length; i++ ){\n    var query = this[ i ];\n\n    str += queryToString( query );\n\n    if( this.length > 1 && i < this.length - 1 ){\n      str += ', ';\n    }\n  }\n\n  return str;\n};\n\nmodule.exports = Selector;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/selector.js\n ** module id = 57\n ** module chunks = 0\n **/","/*!\nEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\nCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\nLicensed under The MIT License (http://opensource.org/licenses/MIT)\n*/\n\n'use strict';\n\n/*  promise states [Promises/A+ 2.1]  */\nvar STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */\nvar STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */\nvar STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */\n\n/*  promise object constructor  */\nvar api = function( executor ){\n  /*  optionally support non-constructor/plain-function call  */\n  if( !(this instanceof api) )\n    return new api( executor );\n\n  /*  initialize object  */\n  this.id           = 'Thenable/1.0.7';\n  this.state        = STATE_PENDING; /*  initial state  */\n  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */\n  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */\n  this.onFulfilled  = [];            /*  initial handlers  */\n  this.onRejected   = [];            /*  initial handlers  */\n\n  /*  provide optional information-hiding proxy  */\n  this.proxy = {\n    then: this.then.bind( this )\n  };\n\n  /*  support optional executor function  */\n  if( typeof executor === 'function' )\n    executor.call( this, this.fulfill.bind( this ), this.reject.bind( this ) );\n};\n\n/*  promise API methods  */\napi.prototype = {\n  /*  promise resolving methods  */\n  fulfill: function( value ){ return deliver( this, STATE_FULFILLED, 'fulfillValue', value ); },\n  reject:  function( value ){ return deliver( this, STATE_REJECTED,  'rejectReason', value ); },\n\n  /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n  then: function( onFulfilled, onRejected ){\n    var curr = this;\n    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */\n    curr.onFulfilled.push(\n      resolver( onFulfilled, next, 'fulfill' ) );             /*  [Promises/A+ 2.2.2/2.2.6]  */\n    curr.onRejected.push(\n      resolver( onRejected,  next, 'reject' ) );             /*  [Promises/A+ 2.2.3/2.2.6]  */\n    execute( curr );\n    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */\n  }\n};\n\n/*  deliver an action  */\nvar deliver = function( curr, state, name, value ){\n  if( curr.state === STATE_PENDING ){\n    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n    curr[ name ] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n    execute( curr );\n  }\n  return curr;\n};\n\n/*  execute all handlers  */\nvar execute = function( curr ){\n  if( curr.state === STATE_FULFILLED )\n    execute_handlers( curr, 'onFulfilled', curr.fulfillValue );\n  else if( curr.state === STATE_REJECTED )\n    execute_handlers( curr, 'onRejected',  curr.rejectReason );\n};\n\n/*  execute particular set of handlers  */\nvar execute_handlers = function( curr, name, value ){\n  /* global setImmediate: true */\n  /* global setTimeout: true */\n\n  /*  short-circuit processing  */\n  if( curr[ name ].length === 0 )\n    return;\n\n  /*  iterate over all handlers, exactly once  */\n  var handlers = curr[ name ];\n  curr[ name ] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n  var func = function(){\n    for( var i = 0; i < handlers.length; i++ )\n      handlers[ i ]( value );                                  /*  [Promises/A+ 2.2.5]  */\n  };\n\n  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */\n  if( typeof setImmediate === 'function' )\n    setImmediate( func );\n  else\n    setTimeout( func, 0 );\n};\n\n/*  generate a resolver function  */\nvar resolver = function( cb, next, method ){\n  return function( value ){\n    if( typeof cb !== 'function' )                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n      next[ method ].call( next, value );                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n    else {\n      var result;\n      try { result = cb( value ); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n      catch( e ){\n        next.reject( e );                                  /*  [Promises/A+ 2.2.7.2]  */\n        return;\n      }\n      resolve( next, result );                               /*  [Promises/A+ 2.2.7.1]  */\n    }\n  };\n};\n\n/*  \"Promise Resolution Procedure\"  */                           /*  [Promises/A+ 2.3]  */\nvar resolve = function( promise, x ){\n  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */\n  if( promise === x || promise.proxy === x ){\n    promise.reject( new TypeError( 'cannot resolve promise with itself' ) );\n    return;\n  }\n\n  /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */\n  var then;\n  if( (typeof x === 'object' && x !== null) || typeof x === 'function' ){\n    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */\n    catch( e ){\n      promise.reject( e );                                   /*  [Promises/A+ 2.3.3.2]  */\n      return;\n    }\n  }\n\n  /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */\n  if( typeof then === 'function' ){\n    var resolved = false;\n    try {\n      /*  call retrieved \"then\" method */                  /*  [Promises/A+ 2.3.3.3]  */\n      then.call( x,\n        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */\n        function( y ){\n          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */\n          if( y === x )                                 /*  [Promises/A+ 3.6]  */\n            promise.reject( new TypeError( 'circular thenable chain' ) );\n          else\n            resolve( promise, y );\n        },\n\n        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */\n        function( r ){\n          if( resolved ) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */\n          promise.reject( r );\n        }\n      );\n    }\n    catch( e ){\n      if( !resolved )                                       /*  [Promises/A+ 2.3.3.3.3]  */\n        promise.reject( e );                               /*  [Promises/A+ 2.3.3.3.4]  */\n    }\n    return;\n  }\n\n  /*  handle other values  */\n  promise.fulfill( x );                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n};\n\n// so we always have Promise.all()\napi.all = function( ps ){\n  return new api(function( resolveAll, rejectAll ){\n    var vals = new Array( ps.length );\n    var doneCount = 0;\n\n    var fulfill = function( i, val ){\n      vals[ i ] = val;\n      doneCount++;\n\n      if( doneCount === ps.length ){\n        resolveAll( vals );\n      }\n    };\n\n    for( var i = 0; i < ps.length; i++ ){\n      (function( i ){\n        var p = ps[i];\n        var isPromise = p != null && p.then != null;\n\n        if( isPromise ){\n          p.then( function( val ){\n            fulfill( i, val );\n          }, function( err ){\n            rejectAll( err );\n          } );\n        } else {\n          var val = p;\n          fulfill( i, val );\n        }\n      })( i );\n    }\n\n  } );\n};\n\napi.resolve = function( val ){\n  return new api(function( resolve, reject ){ resolve( val ); });\n};\n\napi.reject = function( val ){\n  return new api(function( resolve, reject ){ reject( val ); });\n};\n\nmodule.exports = typeof Promise !== 'undefined' ? Promise : api;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/promise.js\n ** module id = 58\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/timers-browserify/main.js\n ** module id = 59\n ** module chunks = 0\n **/","'use strict';\n\n/*!\nEvent object based on jQuery events, MIT license\n\nhttps://jquery.org/license/\nhttps://tldrlegal.com/license/mit-license\nhttps://github.com/jquery/jquery/blob/master/src/event.js\n*/\n\nvar Event = function( src, props ){\n  // Allow instantiation without the 'new' keyword\n  if( !(this instanceof Event) ){\n    return new Event( src, props );\n  }\n\n  // Event object\n  if( src && src.type ){\n    this.originalEvent = src;\n    this.type = src.type;\n\n    // Events bubbling up the document may have been marked as prevented\n    // by a handler lower down the tree; reflect the correct value.\n    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;\n\n  // Event type\n  } else {\n    this.type = src;\n  }\n\n  // Put explicitly provided properties onto the event object\n  if( props ){\n    // util.extend( this, props );\n\n    // more efficient to manually copy fields we use\n    this.type = props.type !== undefined ? props.type : this.type;\n    this.cy = props.cy;\n    this.cyTarget = props.cyTarget;\n    this.cyPosition = props.cyPosition;\n    this.cyRenderedPosition = props.cyRenderedPosition;\n    this.namespace = props.namespace;\n    this.layout = props.layout;\n    this.data = props.data;\n    this.message = props.message;\n  }\n\n  // Create a timestamp if incoming event doesn't have one\n  this.timeStamp = src && src.timeStamp || Date.now();\n};\n\nfunction returnFalse(){\n  return false;\n}\n\nfunction returnTrue(){\n  return true;\n}\n\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n  instanceString: function(){\n    return 'event';\n  },\n\n  preventDefault: function(){\n    this.isDefaultPrevented = returnTrue;\n\n    var e = this.originalEvent;\n    if( !e ){\n      return;\n    }\n\n    // if preventDefault exists run it on the original event\n    if( e.preventDefault ){\n      e.preventDefault();\n    }\n  },\n\n  stopPropagation: function(){\n    this.isPropagationStopped = returnTrue;\n\n    var e = this.originalEvent;\n    if( !e ){\n      return;\n    }\n\n    // if stopPropagation exists run it on the original event\n    if( e.stopPropagation ){\n      e.stopPropagation();\n    }\n  },\n\n  stopImmediatePropagation: function(){\n    this.isImmediatePropagationStopped = returnTrue;\n    this.stopPropagation();\n  },\n\n  isDefaultPrevented: returnFalse,\n  isPropagationStopped: returnFalse,\n  isImmediatePropagationStopped: returnFalse\n};\n\nmodule.exports = Event;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/event.js\n ** module id = 60\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( './util' );\nvar is = require( './is' );\nvar Promise = require( './promise' );\n\nvar Animation = function( target, opts, opts2 ){\n  if( !(this instanceof Animation) ){\n    return new Animation( target, opts, opts2 );\n  }\n\n  var _p = this._private = util.extend( {\n    duration: 1000\n  }, opts, opts2 );\n\n  _p.target = target;\n  _p.style = _p.style || _p.css;\n  _p.started = false;\n  _p.playing = false;\n  _p.hooked = false;\n  _p.applying = false;\n  _p.progress = 0;\n  _p.completes = [];\n  _p.frames = [];\n\n  if( _p.complete && is.fn( _p.complete ) ){\n    _p.completes.push( _p.complete );\n  }\n\n  // for future timeline/animations impl\n  this.length = 1;\n  this[0] = this;\n};\n\nvar anifn = Animation.prototype;\n\nutil.extend( anifn, {\n\n  instanceString: function(){ return 'animation'; },\n\n  hook: function(){\n    var _p = this._private;\n\n    if( !_p.hooked ){\n      // add to target's animation queue\n      var q;\n      var tAni = _p.target._private.animation;\n      if( _p.queue ){\n        q = tAni.queue;\n      } else {\n        q = tAni.current;\n      }\n      q.push( this );\n\n      // add to the animation loop pool\n      if( is.elementOrCollection( _p.target ) ){\n        _p.target.cy().addToAnimationPool( _p.target );\n      }\n\n      _p.hooked = true;\n    }\n\n    return this;\n  },\n\n  play: function(){\n    var _p = this._private;\n\n    // autorewind\n    if( _p.progress === 1 ){\n      _p.progress = 0;\n    }\n\n    _p.playing = true;\n    _p.started = false; // needs to be started by animation loop\n    _p.stopped = false;\n\n    this.hook();\n\n    // the animation loop will start the animation...\n\n    return this;\n  },\n\n  playing: function(){\n    return this._private.playing;\n  },\n\n  apply: function(){\n    var _p = this._private;\n\n    _p.applying = true;\n    _p.started = false; // needs to be started by animation loop\n    _p.stopped = false;\n\n    this.hook();\n\n    // the animation loop will apply the animation at this progress\n\n    return this;\n  },\n\n  applying: function(){\n    return this._private.applying;\n  },\n\n  pause: function(){\n    var _p = this._private;\n\n    _p.playing = false;\n    _p.started = false;\n\n    return this;\n  },\n\n  stop: function(){\n    var _p = this._private;\n\n    _p.playing = false;\n    _p.started = false;\n    _p.stopped = true; // to be removed from animation queues\n\n    return this;\n  },\n\n  rewind: function(){\n    return this.progress( 0 );\n  },\n\n  fastforward: function(){\n    return this.progress( 1 );\n  },\n\n  time: function( t ){\n    var _p = this._private;\n\n    if( t === undefined ){\n      return _p.progress * _p.duration;\n    } else {\n      return this.progress( t / _p.duration );\n    }\n  },\n\n  progress: function( p ){\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n\n    if( p === undefined ){\n      return _p.progress;\n    } else {\n      if( wasPlaying ){\n        this.pause();\n      }\n\n      _p.progress = p;\n      _p.started = false;\n\n      if( wasPlaying ){\n        this.play();\n      }\n    }\n\n    return this;\n  },\n\n  completed: function(){\n    return this._private.progress === 1;\n  },\n\n  reverse: function(){\n    var _p = this._private;\n    var wasPlaying = _p.playing;\n\n    if( wasPlaying ){\n      this.pause();\n    }\n\n    _p.progress = 1 - _p.progress;\n    _p.started = false;\n\n    var swap = function( a, b ){\n      var _pa = _p[ a ];\n\n      _p[ a ] = _p[ b ];\n      _p[ b ] = _pa;\n    };\n\n    swap( 'zoom', 'startZoom' );\n    swap( 'pan', 'startPan' );\n    swap( 'position', 'startPosition' );\n\n    // swap styles\n    for( var i = 0; i < _p.style.length; i++ ){\n      var prop = _p.style[ i ];\n      var name = prop.name;\n      var startStyleProp = _p.startStyle[ name ];\n\n      _p.startStyle[ name ] = prop;\n      _p.style[ i ] = startStyleProp;\n    }\n\n    if( wasPlaying ){\n      this.play();\n    }\n\n    return this;\n  },\n\n  promise: function( type ){\n    var _p = this._private;\n\n    var arr;\n\n    switch( type ){\n      case 'frame':\n        arr = _p.frames;\n        break;\n      default:\n      case 'complete':\n      case 'completed':\n        arr = _p.completes;\n    }\n\n    return new Promise( function( resolve, reject ){\n      arr.push( function(){\n        resolve();\n      } );\n    } );\n  }\n\n} );\n\nanifn.complete = anifn.completed;\n\nmodule.exports = Animation;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/animation.js\n ** module id = 61\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\n\nvar elesfn = ({\n  classes: function( classes ){\n    classes = classes.match( /\\S+/g ) || [];\n    var self = this;\n    var changed = [];\n    var classesMap = {};\n\n    // fill in classes map\n    for( var i = 0; i < classes.length; i++ ){\n      var cls = classes[ i ];\n\n      classesMap[ cls ] = true;\n    }\n\n    // check and update each ele\n    for( var j = 0; j < self.length; j++ ){\n      var ele = self[ j ];\n      var _p = ele._private;\n      var eleClasses = _p.classes;\n      var changedEle = false;\n\n      // check if ele has all of the passed classes\n      for( var i = 0; i < classes.length; i++ ){\n        var cls = classes[ i ];\n        var eleHasClass = eleClasses[ cls ];\n\n        if( !eleHasClass ){\n          changedEle = true;\n          break;\n        }\n      }\n\n      // check if ele has classes outside of those passed\n      if( !changedEle ){\n        var classes = Object.keys( eleClasses );\n\n        for( var i = 0; i < classes.length; i++ ){\n          var eleCls = classes[i];\n          var eleHasClass = eleClasses[ eleCls ];\n          var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function\n\n          if( eleHasClass && !specdClass ){\n            changedEle = true;\n            break;\n          }\n        }\n      }\n\n      if( changedEle ){\n        _p.classes = util.copy( classesMap );\n\n        changed.push( ele );\n      }\n    }\n\n    // trigger update style on those eles that had class changes\n    if( changed.length > 0 ){\n      this.spawn( changed )\n        .updateStyle()\n        .trigger( 'class' )\n      ;\n    }\n\n    return self;\n  },\n\n  addClass: function( classes ){\n    return this.toggleClass( classes, true );\n  },\n\n  hasClass: function( className ){\n    var ele = this[0];\n    return ( ele != null && ele._private.classes[ className ] ) ? true : false;\n  },\n\n  toggleClass: function( classesStr, toggle ){\n    var classes = classesStr.match( /\\S+/g ) || [];\n    var self = this;\n    var changed = []; // eles who had classes changed\n\n    for( var i = 0, il = self.length; i < il; i++ ){\n      var ele = self[ i ];\n      var changedEle = false;\n\n      for( var j = 0; j < classes.length; j++ ){\n        var cls = classes[ j ];\n        var eleClasses = ele._private.classes;\n        var hasClass = eleClasses[ cls ];\n        var shouldAdd = toggle || (toggle === undefined && !hasClass);\n\n        if( shouldAdd ){\n          eleClasses[ cls ] = true;\n\n          if( !hasClass && !changedEle ){\n            changed.push( ele );\n            changedEle = true;\n          }\n        } else { // then remove\n          eleClasses[ cls ] = false;\n\n          if( hasClass && !changedEle ){\n            changed.push( ele );\n            changedEle = true;\n          }\n        }\n\n      } // for j classes\n    } // for i eles\n\n    // trigger update style on those eles that had class changes\n    if( changed.length > 0 ){\n      this.spawn( changed )\n        .updateStyle()\n        .trigger( 'class' )\n      ;\n    }\n\n    return self;\n  },\n\n  removeClass: function( classes ){\n    return this.toggleClass( classes, false );\n  },\n\n  flashClass: function( classes, duration ){\n    var self = this;\n\n    if( duration == null ){\n      duration = 250;\n    } else if( duration === 0 ){\n      return self; // nothing to do really\n    }\n\n    self.addClass( classes );\n    setTimeout( function(){\n      self.removeClass( classes );\n    }, duration );\n\n    return self;\n  }\n});\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/class.js\n ** module id = 62\n ** module chunks = 0\n **/","'use strict';\n\nvar elesfn = ({\n  allAre: function( selector ){\n    return this.filter( selector ).length === this.length;\n  },\n\n  is: function( selector ){\n    return this.filter( selector ).length > 0;\n  },\n\n  some: function( fn, thisArg ){\n    for( var i = 0; i < this.length; i++ ){\n      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );\n\n      if( ret ){\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  every: function( fn, thisArg ){\n    for( var i = 0; i < this.length; i++ ){\n      var ret = !thisArg ? fn( this[ i ], i, this ) : fn.apply( thisArg, [ this[ i ], i, this ] );\n\n      if( !ret ){\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  same: function( collection ){\n    collection = this.cy().collection( collection );\n\n    // cheap extra check\n    if( this.length !== collection.length ){\n      return false;\n    }\n\n    return this.intersect( collection ).length === this.length;\n  },\n\n  anySame: function( collection ){\n    collection = this.cy().collection( collection );\n\n    return this.intersect( collection ).length > 0;\n  },\n\n  allAreNeighbors: function( collection ){\n    collection = this.cy().collection( collection );\n\n    return this.neighborhood().intersect( collection ).length === collection.length;\n  }\n});\n\nelesfn.allAreNeighbours = elesfn.allAreNeighbors;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/comparators.js\n ** module id = 63\n ** module chunks = 0\n **/","'use strict';\n\nvar elesfn = ({\n  parent: function( selector ){\n    var parents = [];\n    var cy = this._private.cy;\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[ i ];\n      var parent = cy.getElementById( ele._private.data.parent );\n\n      if( parent.size() > 0 ){\n        parents.push( parent );\n      }\n    }\n\n    return this.spawn( parents, { unique: true } ).filter( selector );\n  },\n\n  parents: function( selector ){\n    var parents = [];\n\n    var eles = this.parent();\n    while( eles.nonempty() ){\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[ i ];\n        parents.push( ele );\n      }\n\n      eles = eles.parent();\n    }\n\n    return this.spawn( parents, { unique: true } ).filter( selector );\n  },\n\n  commonAncestors: function( selector ){\n    var ancestors;\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[ i ];\n      var parents = ele.parents();\n\n      ancestors = ancestors || parents;\n\n      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set\n    }\n\n    return ancestors.filter( selector );\n  },\n\n  orphans: function( selector ){\n    return this.stdFilter( function( ele ){\n      return ele.isNode() && ele.parent().empty();\n    } ).filter( selector );\n  },\n\n  nonorphans: function( selector ){\n    return this.stdFilter( function( ele ){\n      return ele.isNode() && ele.parent().nonempty();\n    } ).filter( selector );\n  },\n\n  children: function( selector ){\n    var children = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[ i ];\n      children = children.concat( ele._private.children );\n    }\n\n    return this.spawn( children, { unique: true } ).filter( selector );\n  },\n\n  siblings: function( selector ){\n    return this.parent().children().not( this ).filter( selector );\n  },\n\n  isParent: function(){\n    var ele = this[0];\n\n    if( ele ){\n      return ele._private.children.length !== 0;\n    }\n  },\n\n  isChild: function(){\n    var ele = this[0];\n\n    if( ele ){\n      return ele._private.data.parent !== undefined && ele.parent().length !== 0;\n    }\n  },\n\n  descendants: function( selector ){\n    var elements = [];\n\n    function add( eles ){\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[ i ];\n\n        elements.push( ele );\n\n        if( ele.children().nonempty() ){\n          add( ele.children() );\n        }\n      }\n    }\n\n    add( this.children() );\n\n    return this.spawn( elements, { unique: true } ).filter( selector );\n  }\n});\n\n// aliases\nelesfn.ancestors = elesfn.parents;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/compounds.js\n ** module id = 64\n ** module chunks = 0\n **/","'use strict';\n\nvar define = require( '../define' );\nvar fn, elesfn;\n\nfn = elesfn = ({\n\n  data: define.data( {\n    field: 'data',\n    bindingEvent: 'data',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'data',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  } ),\n\n  removeData: define.removeData( {\n    field: 'data',\n    event: 'data',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    immutableKeys: {\n      'id': true,\n      'source': true,\n      'target': true,\n      'parent': true\n    },\n    updateStyle: true\n  } ),\n\n  scratch: define.data( {\n    field: 'scratch',\n    bindingEvent: 'scratch',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'scratch',\n    settingTriggersEvent: true,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    updateStyle: true\n  } ),\n\n  removeScratch: define.removeData( {\n    field: 'scratch',\n    event: 'scratch',\n    triggerFnName: 'trigger',\n    triggerEvent: true,\n    updateStyle: true\n  } ),\n\n  rscratch: define.data( {\n    field: 'rscratch',\n    allowBinding: false,\n    allowSetting: true,\n    settingTriggersEvent: false,\n    allowGetting: true\n  } ),\n\n  removeRscratch: define.removeData( {\n    field: 'rscratch',\n    triggerEvent: false\n  } ),\n\n  id: function(){\n    var ele = this[0];\n\n    if( ele ){\n      return ele._private.data.id;\n    }\n  }\n\n});\n\n// aliases\nfn.attr = fn.data;\nfn.removeAttr = fn.removeData;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/data.js\n ** module id = 65\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\n\nvar elesfn = {};\n\nfunction defineDegreeFunction( callback ){\n  return function( includeLoops ){\n    var self = this;\n\n    if( includeLoops === undefined ){\n      includeLoops = true;\n    }\n\n    if( self.length === 0 ){ return; }\n\n    if( self.isNode() && !self.removed() ){\n      var degree = 0;\n      var node = self[0];\n      var connectedEdges = node._private.edges;\n\n      for( var i = 0; i < connectedEdges.length; i++ ){\n        var edge = connectedEdges[ i ];\n\n        if( !includeLoops && edge.isLoop() ){\n          continue;\n        }\n\n        degree += callback( node, edge );\n      }\n\n      return degree;\n    } else {\n      return;\n    }\n  };\n}\n\nutil.extend( elesfn, {\n  degree: defineDegreeFunction( function( node, edge ){\n    if( edge.source().same( edge.target() ) ){\n      return 2;\n    } else {\n      return 1;\n    }\n  } ),\n\n  indegree: defineDegreeFunction( function( node, edge ){\n    if( edge.target().same( node ) ){\n      return 1;\n    } else {\n      return 0;\n    }\n  } ),\n\n  outdegree: defineDegreeFunction( function( node, edge ){\n    if( edge.source().same( node ) ){\n      return 1;\n    } else {\n      return 0;\n    }\n  } )\n} );\n\nfunction defineDegreeBoundsFunction( degreeFn, callback ){\n  return function( includeLoops ){\n    var ret;\n    var nodes = this.nodes();\n\n    for( var i = 0; i < nodes.length; i++ ){\n      var ele = nodes[ i ];\n      var degree = ele[ degreeFn ]( includeLoops );\n      if( degree !== undefined && (ret === undefined || callback( degree, ret )) ){\n        ret = degree;\n      }\n    }\n\n    return ret;\n  };\n}\n\nutil.extend( elesfn, {\n  minDegree: defineDegreeBoundsFunction( 'degree', function( degree, min ){\n    return degree < min;\n  } ),\n\n  maxDegree: defineDegreeBoundsFunction( 'degree', function( degree, max ){\n    return degree > max;\n  } ),\n\n  minIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, min ){\n    return degree < min;\n  } ),\n\n  maxIndegree: defineDegreeBoundsFunction( 'indegree', function( degree, max ){\n    return degree > max;\n  } ),\n\n  minOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, min ){\n    return degree < min;\n  } ),\n\n  maxOutdegree: defineDegreeBoundsFunction( 'outdegree', function( degree, max ){\n    return degree > max;\n  } )\n} );\n\nutil.extend( elesfn, {\n  totalDegree: function( includeLoops ){\n    var total = 0;\n    var nodes = this.nodes();\n\n    for( var i = 0; i < nodes.length; i++ ){\n      total += nodes[ i ].degree( includeLoops );\n    }\n\n    return total;\n  }\n} );\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/degree.js\n ** module id = 66\n ** module chunks = 0\n **/","'use strict';\n\nvar define = require( '../define' );\nvar is = require( '../is' );\nvar util = require( '../util' );\nvar math = require( '../math' );\nvar fn, elesfn;\n\nfn = elesfn = ({\n\n  position: define.data( {\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: true,\n    triggerFnName: 'rtrigger',\n    allowGetting: true,\n    validKeys: [ 'x', 'y' ],\n    onSet: function( eles ){\n      var updatedEles = eles.updateCompoundBounds();\n      updatedEles.rtrigger( 'position' );\n    },\n    canSet: function( ele ){\n      return !ele.locked() && !ele.isParent();\n    }\n  } ),\n\n  // position but no notification to renderer\n  silentPosition: define.data( {\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: false,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: false,\n    triggerFnName: 'trigger',\n    allowGetting: true,\n    validKeys: [ 'x', 'y' ],\n    onSet: function( eles ){\n      eles.updateCompoundBounds();\n    },\n    canSet: function( ele ){\n      return !ele.locked() && !ele.isParent();\n    }\n  } ),\n\n  positions: function( pos, silent ){\n    if( is.plainObject( pos ) ){\n      this.position( pos );\n\n    } else if( is.fn( pos ) ){\n      var fn = pos;\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[ i ];\n\n        var pos = fn.apply( ele, [ i, ele ] );\n\n        if( pos && !ele.locked() && !ele.isParent() ){\n          var elePos = ele._private.position;\n          elePos.x = pos.x;\n          elePos.y = pos.y;\n        }\n      }\n\n      var updatedEles = this.updateCompoundBounds();\n      var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;\n\n      if( silent ){\n        toTrigger.trigger( 'position' );\n      } else {\n        toTrigger.rtrigger( 'position' );\n      }\n    }\n\n    return this; // chaining\n  },\n\n  silentPositions: function( pos ){\n    return this.positions( pos, true );\n  },\n\n  // get/set the rendered (i.e. on screen) positon of the element\n  renderedPosition: function( dim, val ){\n    var ele = this[0];\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var rpos = is.plainObject( dim ) ? dim : undefined;\n    var setting = rpos !== undefined || ( val !== undefined && is.string( dim ) );\n\n    if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n      if( setting ){\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[ i ];\n\n          if( val !== undefined ){ // set one dimension\n            ele._private.position[ dim ] = ( val - pan[ dim ] ) / zoom;\n          } else if( rpos !== undefined ){ // set whole position\n            ele._private.position = {\n              x: ( rpos.x - pan.x ) / zoom,\n              y: ( rpos.y - pan.y ) / zoom\n            };\n          }\n        }\n\n        this.rtrigger( 'position' );\n      } else { // getting\n        var pos = ele._private.position;\n        rpos = {\n          x: pos.x * zoom + pan.x,\n          y: pos.y * zoom + pan.y\n        };\n\n        if( dim === undefined ){ // then return the whole rendered position\n          return rpos;\n        } else { // then return the specified dimension\n          return rpos[ dim ];\n        }\n      }\n    } else if( !setting ){\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  },\n\n  // get/set the position relative to the parent\n  relativePosition: function( dim, val ){\n    var ele = this[0];\n    var cy = this.cy();\n    var ppos = is.plainObject( dim ) ? dim : undefined;\n    var setting = ppos !== undefined || ( val !== undefined && is.string( dim ) );\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n      if( setting ){\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[ i ];\n          var parent = hasCompoundNodes ? ele.parent() : null;\n          var hasParent = parent && parent.length > 0;\n          var relativeToParent = hasParent;\n\n          if( hasParent ){\n            parent = parent[0];\n          }\n\n          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\n          if( val !== undefined ){ // set one dimension\n            ele._private.position[ dim ] = val + origin[ dim ];\n          } else if( ppos !== undefined ){ // set whole position\n            ele._private.position = {\n              x: ppos.x + origin.x,\n              y: ppos.y + origin.y\n            };\n          }\n        }\n\n        this.rtrigger( 'position' );\n\n      } else { // getting\n        var pos = ele._private.position;\n        var parent = hasCompoundNodes ? ele.parent() : null;\n        var hasParent = parent && parent.length > 0;\n        var relativeToParent = hasParent;\n\n        if( hasParent ){\n          parent = parent[0];\n        }\n\n        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\n        ppos = {\n          x: pos.x - origin.x,\n          y: pos.y - origin.y\n        };\n\n        if( dim === undefined ){ // then return the whole rendered position\n          return ppos;\n        } else { // then return the specified dimension\n          return ppos[ dim ];\n        }\n      }\n    } else if( !setting ){\n      return undefined; // for empty collection case\n    }\n\n    return this; // chaining\n  },\n\n  renderedBoundingBox: function( options ){\n    var bb = this.boundingBox( options );\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n\n    var x1 = bb.x1 * zoom + pan.x;\n    var x2 = bb.x2 * zoom + pan.x;\n    var y1 = bb.y1 * zoom + pan.y;\n    var y2 = bb.y2 * zoom + pan.y;\n\n    return {\n      x1: x1,\n      x2: x2,\n      y1: y1,\n      y2: y2,\n      w: x2 - x1,\n      h: y2 - y1\n    };\n  },\n\n  updateCompoundBounds: function(){\n    var cy = this.cy();\n\n    // save cycles for non compound graphs or when style disabled\n    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); }\n\n    var updated = [];\n\n    function update( parent ){\n      if( !parent.isParent() ){ return; }\n\n      var _p = parent._private;\n      var children = parent.children();\n      var includeLabels = parent.pstyle( 'compound-sizing-wrt-labels' ).value === 'include';\n      var bb = children.boundingBox( {\n        includeLabels: includeLabels,\n        includeShadows: false,\n        includeOverlays: false,\n\n        // updating the compound bounds happens outside of the regular\n        // cache cycle (i.e. before fired events)\n        useCache: false\n      } );\n      var padding = {\n        top: parent.pstyle( 'padding-top' ).pfValue,\n        bottom: parent.pstyle( 'padding-bottom' ).pfValue,\n        left: parent.pstyle( 'padding-left' ).pfValue,\n        right: parent.pstyle( 'padding-right' ).pfValue\n      };\n      var pos = _p.position;\n      var didUpdate = false;\n\n      if( parent.pstyle( 'width' ).value === 'auto' ){\n        _p.autoWidth = bb.w;\n        pos.x = (bb.x1 + bb.x2 - padding.left + padding.right) / 2;\n        didUpdate = true;\n      }\n\n      if( parent.pstyle( 'height' ).value === 'auto' ){\n        _p.autoHeight = bb.h;\n        pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom) / 2;\n        didUpdate = true;\n      }\n\n      if( didUpdate ){\n        updated.push( parent );\n      }\n    }\n\n    // go up, level by level\n    var eles = this;\n    while( eles.nonempty() ){\n\n      // update each parent node in this level\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[ i ];\n\n        update( ele );\n      }\n\n      // next level\n      eles = eles.parent();\n    }\n\n    // return changed\n    return this.spawn( updated );\n  }\n});\n\nvar noninf = function( x ){\n  if( x === Infinity || x === -Infinity ){\n    return 0;\n  }\n\n  return x;\n};\n\nvar updateBounds = function( b, x1, y1, x2, y2 ){\n  // don't update with zero area boxes\n  if( x2 - x1 === 0 || y2 - y1 === 0 ){ return; }\n\n  b.x1 = x1 < b.x1 ? x1 : b.x1;\n  b.x2 = x2 > b.x2 ? x2 : b.x2;\n  b.y1 = y1 < b.y1 ? y1 : b.y1;\n  b.y2 = y2 > b.y2 ? y2 : b.y2;\n};\n\nvar updateBoundsFromBox = function( b, b2 ){\n  return updateBounds( b, b2.x1, b2.y1, b2.x2, b2.y2 );\n};\n\nvar prefixedProperty = function( obj, field, prefix ){\n  return util.getPrefixedProperty( obj, field, prefix );\n};\n\nvar updateBoundsFromArrow = function( bounds, ele, prefix, options ){\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var halfArW = rstyle.arrowWidth / 2;\n  var arrowType = ele.pstyle( prefix + '-arrow-shape' ).value;\n  var x;\n  var y;\n\n  if( arrowType !== 'none' ){\n    if( prefix === 'source' ){\n      x = rstyle.srcX;\n      y = rstyle.srcY;\n    } else if( prefix === 'target' ){\n      x = rstyle.tgtX;\n      y = rstyle.tgtY;\n    } else {\n      x = rstyle.midX;\n      y = rstyle.midY;\n    }\n\n    updateBounds( bounds, x - halfArW, y - halfArW, x + halfArW, y + halfArW );\n  }\n};\n\nvar updateBoundsFromLabel = function( bounds, ele, prefix, options ){\n  var prefixDash;\n\n  if( prefix ){\n    prefixDash = prefix + '-';\n  } else {\n    prefixDash = '';\n  }\n\n  var _p = ele._private;\n  var rstyle = _p.rstyle;\n  var label = ele.pstyle( prefixDash + 'label' ).strValue;\n\n  if( label ){\n    var halign = ele.pstyle( 'text-halign' );\n    var valign = ele.pstyle( 'text-valign' );\n    var labelWidth = prefixedProperty( rstyle, 'labelWidth', prefix );\n    var labelHeight = prefixedProperty( rstyle, 'labelHeight', prefix );\n    var labelX = prefixedProperty( rstyle, 'labelX', prefix );\n    var labelY = prefixedProperty( rstyle, 'labelY', prefix );\n    var marginX = ele.pstyle( prefixDash + 'text-margin-x' ).pfValue;\n    var marginY = ele.pstyle( prefixDash + 'text-margin-y' ).pfValue;\n    var isEdge = ele.isEdge();\n    var rotation = ele.pstyle( prefixDash + 'text-rotation' );\n    var shadowR = ele.pstyle( 'text-shadow-blur' ).pfValue / 2;\n    var shadowX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;\n    var shadowY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;\n    var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;\n    var outlineWidth = ele.pstyle( 'text-outline-width' ).pfValue;\n\n    var lh = labelHeight;\n    var lw = labelWidth;\n    var lx1, lx2, ly1, ly2;\n\n    if( isEdge ){\n      lx1 = labelX - lw / 2;\n      lx2 = labelX + lw / 2;\n      ly1 = labelY - lh / 2;\n      ly2 = labelY + lh / 2;\n    } else {\n      switch( halign.value ){\n        case 'left':\n          lx1 = labelX - lw;\n          lx2 = labelX;\n          break;\n\n        case 'center':\n          lx1 = labelX - lw / 2;\n          lx2 = labelX + lw / 2;\n          break;\n\n        case 'right':\n          lx1 = labelX;\n          lx2 = labelX + lw;\n          break;\n      }\n\n      switch( valign.value ){\n        case 'top':\n          ly1 = labelY - lh;\n          ly2 = labelY;\n          break;\n\n        case 'center':\n          ly1 = labelY - lh / 2;\n          ly2 = labelY + lh / 2;\n          break;\n\n        case 'bottom':\n          ly1 = labelY;\n          ly2 = labelY + lh;\n          break;\n      }\n    }\n\n    var isAutorotate = ( isEdge && rotation.strValue === 'autorotate' );\n    var isPfValue = ( rotation.pfValue != null && rotation.pfValue !== 0 );\n\n    if( isAutorotate || isPfValue ){\n      var theta = isAutorotate ? prefixedProperty( _p.rstyle, 'labelAngle', prefix ) : rotation.pfValue;\n      var cos = Math.cos( theta );\n      var sin = Math.sin( theta );\n\n      var rotate = function( x, y ){\n        x = x - labelX;\n        y = y - labelY;\n\n        return {\n          x: x * cos - y * sin + labelX,\n          y: x * sin + y * cos + labelY\n        };\n      };\n\n      var px1y1 = rotate( lx1, ly1 );\n      var px1y2 = rotate( lx1, ly2 );\n      var px2y1 = rotate( lx2, ly1 );\n      var px2y2 = rotate( lx2, ly2 );\n\n      lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );\n      lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );\n      ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );\n      ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );\n    }\n\n    lx1 += marginX - outlineWidth;\n    lx2 += marginX + outlineWidth;\n    ly1 += marginY - outlineWidth;\n    ly2 += marginY + outlineWidth;\n\n    updateBounds( bounds, lx1, ly1, lx2, ly2 );\n\n    if( options.includeShadows && shadowOpacity > 0 ){\n      lx1 += - shadowR + shadowX;\n      lx2 += + shadowR + shadowX;\n      ly1 += - shadowR + shadowY;\n      ly2 += + shadowR + shadowY;\n\n      updateBounds( bounds, lx1, ly1, lx2, ly2 );\n    }\n  }\n\n  return bounds;\n};\n\n// get the bounding box of the elements (in raw model position)\nvar boundingBoxImpl = function( ele, options ){\n  var cy = ele._private.cy;\n  var cy_p = cy._private;\n  var styleEnabled = cy_p.styleEnabled;\n\n  var bounds = {\n    x1: Infinity,\n    y1: Infinity,\n    x2: -Infinity,\n    y2: -Infinity\n  };\n\n  var _p = ele._private;\n  var display = styleEnabled ? ele.pstyle( 'display' ).value : 'element';\n  var isNode = ele.isNode();\n  var isEdge = ele.isEdge();\n  var ex1, ex2, ey1, ey2, x, y;\n  var displayed = display !== 'none';\n\n  if( displayed ){\n    var overlayOpacity = 0;\n    var overlayPadding = 0;\n\n    if( styleEnabled && options.includeOverlays ){\n      overlayOpacity = ele.pstyle( 'overlay-opacity' ).value;\n\n      if( overlayOpacity !== 0 ){\n        overlayPadding = ele.pstyle( 'overlay-padding' ).value;\n      }\n    }\n\n    var w = 0;\n    var wHalf = 0;\n\n    if( styleEnabled ){\n      w = ele.pstyle( 'width' ).pfValue;\n      wHalf = w / 2;\n    }\n\n    if( isNode && options.includeNodes ){\n      var pos = _p.position;\n      x = pos.x;\n      y = pos.y;\n      var w = ele.outerWidth();\n      var halfW = w / 2;\n      var h = ele.outerHeight();\n      var halfH = h / 2;\n\n      // handle node dimensions\n      /////////////////////////\n\n      ex1 = x - halfW - overlayPadding;\n      ex2 = x + halfW + overlayPadding;\n      ey1 = y - halfH - overlayPadding;\n      ey2 = y + halfH + overlayPadding;\n\n      updateBounds( bounds, ex1, ey1, ex2, ey2 );\n\n    } else if( isEdge && options.includeEdges ){\n      var rstyle = _p.rstyle || {};\n\n      // handle edge dimensions (rough box estimate)\n      //////////////////////////////////////////////\n      if( styleEnabled ){\n        ex1 = Math.min( rstyle.srcX, rstyle.midX, rstyle.tgtX );\n        ex2 = Math.max( rstyle.srcX, rstyle.midX, rstyle.tgtX );\n        ey1 = Math.min( rstyle.srcY, rstyle.midY, rstyle.tgtY );\n        ey2 = Math.max( rstyle.srcY, rstyle.midY, rstyle.tgtY );\n\n        // take into account edge width\n        ex1 -= wHalf;\n        ex2 += wHalf;\n        ey1 -= wHalf;\n        ey2 += wHalf;\n\n        updateBounds( bounds, ex1, ey1, ex2, ey2 );\n      }\n\n      // precise haystacks\n      ////////////////////\n      if( styleEnabled && ele.pstyle( 'curve-style' ).strValue === 'haystack' ){\n        var hpts = rstyle.haystackPts;\n\n        ex1 = hpts[0].x;\n        ey1 = hpts[0].y;\n        ex2 = hpts[1].x;\n        ey2 = hpts[1].y;\n\n        if( ex1 > ex2 ){\n          var temp = ex1;\n          ex1 = ex2;\n          ex2 = temp;\n        }\n\n        if( ey1 > ey2 ){\n          var temp = ey1;\n          ey1 = ey2;\n          ey2 = temp;\n        }\n\n        updateBounds( bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf );\n\n      // handle points along edge\n      ///////////////////////////\n      } else {\n        var pts = rstyle.bezierPts || rstyle.linePts || [];\n\n        for( var j = 0; j < pts.length; j++ ){\n          var pt = pts[ j ];\n\n          ex1 = pt.x - wHalf;\n          ex2 = pt.x + wHalf;\n          ey1 = pt.y - wHalf;\n          ey2 = pt.y + wHalf;\n\n          updateBounds( bounds, ex1, ey1, ex2, ey2 );\n        }\n\n        // fallback on source and target positions\n        //////////////////////////////////////////\n        if( pts.length === 0 ){\n          var n1 = _p.source;\n          var n1_p = n1._private;\n          var n1pos = n1_p.position;\n\n          var n2 = _p.target;\n          var n2_p = n2._private;\n          var n2pos = n2_p.position;\n\n          ex1 = n1pos.x;\n          ex2 = n2pos.x;\n          ey1 = n1pos.y;\n          ey2 = n2pos.y;\n\n          if( ex1 > ex2 ){\n            var temp = ex1;\n            ex1 = ex2;\n            ex2 = temp;\n          }\n\n          if( ey1 > ey2 ){\n            var temp = ey1;\n            ey1 = ey2;\n            ey2 = temp;\n          }\n\n          // take into account edge width\n          ex1 -= wHalf;\n          ex2 += wHalf;\n          ey1 -= wHalf;\n          ey2 += wHalf;\n\n          updateBounds( bounds, ex1, ey1, ex2, ey2 );\n        }\n      }\n\n    } // edges\n\n    // shadow and overlay\n    /////////////////////\n\n    if( styleEnabled ){\n\n      ex1 = bounds.x1;\n      ex2 = bounds.x2;\n      ey1 = bounds.y1;\n      ey2 = bounds.y2;\n\n      if( options.includeShadows && ele.pstyle('shadow-opacity').value > 0 ){\n        var r = ele.pstyle('shadow-blur').pfValue / 2;\n        var ox = ele.pstyle('shadow-offset-x').pfValue;\n        var oy = ele.pstyle('shadow-offset-y').pfValue;\n\n        updateBounds( bounds, ex1 - r + ox, ey1 - r + oy, ex2 + r + ox, ey2 + r + oy );\n      }\n\n      updateBounds( bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding );\n    }\n\n    // handle edge arrow size\n    /////////////////////////\n\n    if( styleEnabled && options.includeEdges && isEdge ){\n      updateBoundsFromArrow( bounds, ele, 'mid-source', options );\n      updateBoundsFromArrow( bounds, ele, 'mid-target', options );\n      updateBoundsFromArrow( bounds, ele, 'source', options );\n      updateBoundsFromArrow( bounds, ele, 'target', options );\n    }\n\n    // handle label dimensions\n    //////////////////////////\n\n    if( styleEnabled && options.includeLabels ){\n      updateBoundsFromLabel( bounds, ele, null, options );\n\n      if( isEdge ){\n        updateBoundsFromLabel( bounds, ele, 'source', options );\n        updateBoundsFromLabel( bounds, ele, 'target', options );\n      }\n    } // style enabled for labels\n  } // if displayed\n\n  bounds.x1 = noninf( bounds.x1 );\n  bounds.y1 = noninf( bounds.y1 );\n  bounds.x2 = noninf( bounds.x2 );\n  bounds.y2 = noninf( bounds.y2 );\n  bounds.w = noninf( bounds.x2 - bounds.x1 );\n  bounds.h = noninf( bounds.y2 - bounds.y1 );\n\n  // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n  if( bounds.w > 0 && bounds.h > 0 && displayed ){\n    math.expandBoundingBox( bounds, 1 );\n  }\n\n  return bounds;\n};\n\nvar tf = function( val ){\n  if( val ){\n    return 't';\n  } else {\n    return 'f';\n  }\n};\n\nvar getKey = function( opts ){\n  var key = '';\n\n  key += tf( opts.incudeNodes );\n  key += tf( opts.includeEdges );\n  key += tf( opts.includeLabels );\n  key += tf( opts.includeShadows );\n  key += tf( opts.includeOverlays );\n\n  return key;\n};\n\nvar cachedBoundingBoxImpl = function( ele, opts ){\n  var _p = ele._private;\n  var bb;\n  var headless = ele.cy().headless();\n  var key = opts === defBbOpts ? defBbOptsKey : getKey( opts );\n\n  if( !opts.useCache || headless || !_p.bbCache || !_p.bbCache[key] ){\n    bb = boundingBoxImpl( ele, opts );\n\n    if( !headless ){\n      _p.bbCache = _p.bbCache || {};\n      _p.bbCache[key] = bb;\n    }\n  } else {\n    bb = _p.bbCache[key];\n  }\n\n  return bb;\n};\n\nvar defBbOpts = {\n  includeNodes: true,\n  includeEdges: true,\n  includeLabels: true,\n  includeShadows: true,\n  includeOverlays: true,\n  useCache: true\n};\n\nvar defBbOptsKey = getKey( defBbOpts );\n\nelesfn.boundingBox = function( options ){\n  // the main usecase is ele.boundingBox() for a single element with no/def options\n  // specified s.t. the cache is used, so check for this case to make it faster by\n  // avoiding the overhead of the rest of the function\n  if( this.length === 1 && this[0]._private.bbCache && (options === undefined || options.useCache === undefined || options.useCache === true) ){\n    if( options === undefined ){\n      options = defBbOpts;\n    }\n\n    return cachedBoundingBoxImpl( this[0], options );\n  }\n\n  var bounds = {\n    x1: Infinity,\n    y1: Infinity,\n    x2: -Infinity,\n    y2: -Infinity\n  };\n\n  options = options || util.staticEmptyObject();\n\n  var opts = {\n    includeNodes: util.default( options.includeNodes, defBbOpts.includeNodes ),\n    includeEdges: util.default( options.includeEdges, defBbOpts.includeEdges ),\n    includeLabels: util.default( options.includeLabels, defBbOpts.includeLabels ),\n    includeShadows: util.default( options.includeShadows, defBbOpts.includeShadows ),\n    includeOverlays: util.default( options.includeOverlays, defBbOpts.includeOverlays ),\n    useCache: util.default( options.useCache, defBbOpts.useCache )\n  };\n\n  var eles = this;\n  var cy = eles.cy();\n  var renderer = eles.cy().renderer();\n  var styleEnabled = cy.styleEnabled();\n\n  if( styleEnabled ){\n    renderer.recalculateRenderedStyle( eles, opts.useCache );\n  }\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[i];\n\n    if( styleEnabled && ele.isEdge() && ele.pstyle('curve-style').strValue === 'bezier' ){\n      renderer.recalculateRenderedStyle( ele.parallelEdges(), opts.useCache ); // n.b. ele.parallelEdges() single is cached\n    }\n\n    updateBoundsFromBox( bounds, cachedBoundingBoxImpl( ele, opts ) );\n  }\n\n  bounds.x1 = noninf( bounds.x1 );\n  bounds.y1 = noninf( bounds.y1 );\n  bounds.x2 = noninf( bounds.x2 );\n  bounds.y2 = noninf( bounds.y2 );\n  bounds.w = noninf( bounds.x2 - bounds.x1 );\n  bounds.h = noninf( bounds.y2 - bounds.y1 );\n\n  return bounds;\n};\n\nvar defineDimFns = function( opts ){\n  opts.uppercaseName = util.capitalize( opts.name );\n  opts.autoName = 'auto' + opts.uppercaseName;\n  opts.labelName = 'label' + opts.uppercaseName;\n  opts.outerName = 'outer' + opts.uppercaseName;\n  opts.uppercaseOuterName = util.capitalize( opts.outerName );\n\n  fn[ opts.name ] = function dimImpl(){\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n\n    if( ele ){\n      if( styleEnabled ){\n        var d = ele.pstyle( opts.name );\n\n        switch( d.strValue ){\n          case 'auto':\n            return _p[ opts.autoName ] || 0;\n          case 'label':\n            return _p.rstyle[ opts.labelName ] || 0;\n          default:\n            return d.pfValue;\n        }\n      } else {\n        return 1;\n      }\n    }\n  };\n\n  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){\n    var ele = this[0];\n    var _p = ele._private;\n    var cy = _p.cy;\n    var styleEnabled = cy._private.styleEnabled;\n\n    if( ele ){\n      if( styleEnabled ){\n        var dim = ele[ opts.name ]();\n        var border = ele.pstyle( 'border-width' ).pfValue;\n        var padding = ele.pstyle( opts.paddings[0] ).pfValue + ele.pstyle( opts.paddings[1] ).pfValue;\n\n        return dim + border + padding;\n      } else {\n        return 1;\n      }\n    }\n  };\n\n  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){\n    var ele = this[0];\n\n    if( ele ){\n      var d = ele[ opts.name ]();\n      return d * this.cy().zoom();\n    }\n  };\n\n  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){\n    var ele = this[0];\n\n    if( ele ){\n      var od = ele[ opts.outerName ]();\n      return od * this.cy().zoom();\n    }\n  };\n};\n\ndefineDimFns( {\n  name: 'width',\n  paddings: [ 'padding-left', 'padding-right' ]\n} );\n\ndefineDimFns( {\n  name: 'height',\n  paddings: [ 'padding-top', 'padding-bottom' ]\n} );\n\n// aliases\nfn.modelPosition = fn.point = fn.position;\nfn.modelPositions = fn.points = fn.positions;\nfn.renderedPoint = fn.renderedPosition;\nfn.relativePoint = fn.relativePosition;\nfn.boundingbox = fn.boundingBox;\nfn.renderedBoundingbox = fn.renderedBoundingBox;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/dimensions.js\n ** module id = 67\n ** module chunks = 0\n **/","'use strict';\n\nvar define = require( '../define' );\n\nvar elesfn = ({\n  on: define.on(), // .on( events [, selector] [, data], handler)\n  one: define.on( { unbindSelfOnTrigger: true } ),\n  once: define.on( { unbindAllBindersOnTrigger: true } ),\n  off: define.off(), // .off( events [, selector] [, handler] )\n  trigger: define.trigger(), // .trigger( events [, extraParams] )\n\n  rtrigger: function( event, extraParams ){ // for internal use only\n    if( this.length === 0 ){ return; } // empty collections don't need to notify anything\n\n    // notify renderer\n    this.cy().notify( {\n      type: event,\n      eles: this\n    } );\n\n    this.trigger( event, extraParams );\n    return this;\n  }\n});\n\n// aliases:\ndefine.eventAliasesOn( elesfn );\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/events.js\n ** module id = 68\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar Selector = require( '../selector' );\n\nvar elesfn = ({\n  nodes: function( selector ){\n    return this.filter( function( i, element ){\n      return element.isNode();\n    } ).filter( selector );\n  },\n\n  edges: function( selector ){\n    return this.filter( function( i, element ){\n      return element.isEdge();\n    } ).filter( selector );\n  },\n\n  filter: function( filter ){\n    if( filter === undefined ){ // check this first b/c it's the most common/performant case\n      return this;\n    } else if( is.string( filter ) || is.elementOrCollection( filter ) ){\n      return Selector( filter ).filter( this );\n    } else if( is.fn( filter ) ){\n      var elements = [];\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[ i ];\n\n        if( filter.apply( ele, [ i, ele ] ) ){\n          elements.push( ele );\n        }\n      }\n\n      return this.spawn( elements );\n    }\n\n    return this.spawn(); // if not handled by above, give 'em an empty collection\n  },\n\n  not: function( toRemove ){\n    if( !toRemove ){\n      return this;\n    } else {\n\n      if( is.string( toRemove ) ){\n        toRemove = this.filter( toRemove );\n      }\n\n      var elements = [];\n\n      for( var i = 0; i < this.length; i++ ){\n        var element = this[ i ];\n\n        var remove = toRemove._private.ids[ element.id() ];\n        if( !remove ){\n          elements.push( element );\n        }\n      }\n\n      return this.spawn( elements );\n    }\n\n  },\n\n  absoluteComplement: function(){\n    var cy = this._private.cy;\n\n    return cy.mutableElements().not( this );\n  },\n\n  intersect: function( other ){\n    // if a selector is specified, then filter by it instead\n    if( is.string( other ) ){\n      var selector = other;\n      return this.filter( selector );\n    }\n\n    var elements = [];\n    var col1 = this;\n    var col2 = other;\n    var col1Smaller = this.length < other.length;\n    // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;\n    var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;\n    var col = col1Smaller ? col1 : col2;\n\n    for( var i = 0; i < col.length; i++ ){\n      var id = col[ i ]._private.data.id;\n      var ele = ids2[ id ];\n\n      if( ele ){\n        elements.push( ele );\n      }\n    }\n\n    return this.spawn( elements );\n  },\n\n  xor: function( other ){\n    var cy = this._private.cy;\n\n    if( is.string( other ) ){\n      other = cy.$( other );\n    }\n\n    var elements = [];\n    var col1 = this;\n    var col2 = other;\n\n    var add = function( col, other ){\n\n      for( var i = 0; i < col.length; i++ ){\n        var ele = col[ i ];\n        var id = ele._private.data.id;\n        var inOther = other._private.ids[ id ];\n\n        if( !inOther ){\n          elements.push( ele );\n        }\n      }\n\n    };\n\n    add( col1, col2 );\n    add( col2, col1 );\n\n    return this.spawn( elements );\n  },\n\n  diff: function( other ){\n    var cy = this._private.cy;\n\n    if( is.string( other ) ){\n      other = cy.$( other );\n    }\n\n    var left = [];\n    var right = [];\n    var both = [];\n    var col1 = this;\n    var col2 = other;\n\n    var add = function( col, other, retEles ){\n\n      for( var i = 0; i < col.length; i++ ){\n        var ele = col[ i ];\n        var id = ele._private.data.id;\n        var inOther = other._private.ids[ id ];\n\n        if( inOther ){\n          both.push( ele );\n        } else {\n          retEles.push( ele );\n        }\n      }\n\n    };\n\n    add( col1, col2, left );\n    add( col2, col1, right );\n\n    return {\n      left: this.spawn( left, { unique: true } ),\n      right: this.spawn( right, { unique: true } ),\n      both: this.spawn( both, { unique: true } )\n    };\n  },\n\n  add: function( toAdd ){\n    var cy = this._private.cy;\n\n    if( !toAdd ){\n      return this;\n    }\n\n    if( is.string( toAdd ) ){\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter( selector );\n    }\n\n    var elements = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      elements.push( this[ i ] );\n    }\n\n    for( var i = 0; i < toAdd.length; i++ ){\n\n      var add = !this._private.ids[ toAdd[ i ].id() ];\n      if( add ){\n        elements.push( toAdd[ i ] );\n      }\n    }\n\n    return this.spawn( elements );\n  },\n\n  // in place merge on calling collection\n  merge: function( toAdd ){\n    var _p = this._private;\n    var cy = _p.cy;\n\n    if( !toAdd ){\n      return this;\n    }\n\n    if( toAdd && is.string( toAdd ) ){\n      var selector = toAdd;\n      toAdd = cy.mutableElements().filter( selector );\n    }\n\n    for( var i = 0; i < toAdd.length; i++ ){\n      var toAddEle = toAdd[ i ];\n      var id = toAddEle._private.data.id;\n      var add = !_p.ids[ id ];\n\n      if( add ){\n        var index = this.length++;\n\n        this[ index ] = toAddEle;\n        _p.ids[ id ] = toAddEle;\n        _p.indexes[ id ] = index;\n      } else { // replace\n        var index = _p.indexes[ id ];\n\n        this[ index ] = toAddEle;\n        _p.ids[ id ] = toAddEle;\n      }\n    }\n\n    return this; // chaining\n  },\n\n  // remove single ele in place in calling collection\n  unmergeOne: function( ele ){\n    ele = ele[0];\n\n    var _p = this._private;\n    var id = ele._private.data.id;\n    var i = _p.indexes[ id ];\n\n    if( i == null ){\n      return this; // no need to remove\n    }\n\n    // remove ele\n    this[ i ] = undefined;\n    _p.ids[ id ] = undefined;\n    _p.indexes[ id ] = undefined;\n\n    var unmergedLastEle = i === this.length - 1;\n\n    // replace empty spot with last ele in collection\n    if( this.length > 1 && !unmergedLastEle ){\n      var lastEleI = this.length - 1;\n      var lastEle = this[ lastEleI ];\n      var lastEleId = lastEle._private.data.id;\n\n      this[ lastEleI ] = undefined;\n      this[ i ] = lastEle;\n      _p.indexes[ lastEleId ] = i;\n    }\n\n    // the collection is now 1 ele smaller\n    this.length--;\n\n    return this;\n  },\n\n  // remove eles in place on calling collection\n  unmerge: function( toRemove ){\n    var cy = this._private.cy;\n\n    if( !toRemove ){\n      return this;\n    }\n\n    if( toRemove && is.string( toRemove ) ){\n      var selector = toRemove;\n      toRemove = cy.mutableElements().filter( selector );\n    }\n\n    for( var i = 0; i < toRemove.length; i++ ){\n      this.unmergeOne( toRemove[ i ] );\n    }\n\n    return this; // chaining\n  },\n\n  map: function( mapFn, thisArg ){\n    var arr = [];\n    var eles = this;\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[ i ];\n      var ret = thisArg ? mapFn.apply( thisArg, [ ele, i, eles ] ) : mapFn( ele, i, eles );\n\n      arr.push( ret );\n    }\n\n    return arr;\n  },\n\n  stdFilter: function( fn, thisArg ){\n    var filterEles = [];\n    var eles = this;\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[ i ];\n      var include = thisArg ? fn.apply( thisArg, [ ele, i, eles ] ) : fn( ele, i, eles );\n\n      if( include ){\n        filterEles.push( ele );\n      }\n    }\n\n    return this.spawn( filterEles );\n  },\n\n  max: function( valFn, thisArg ){\n    var max = -Infinity;\n    var maxEle;\n    var eles = this;\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[ i ];\n      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );\n\n      if( val > max ){\n        max = val;\n        maxEle = ele;\n      }\n    }\n\n    return {\n      value: max,\n      ele: maxEle\n    };\n  },\n\n  min: function( valFn, thisArg ){\n    var min = Infinity;\n    var minEle;\n    var eles = this;\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[ i ];\n      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );\n\n      if( val < min ){\n        min = val;\n        minEle = ele;\n      }\n    }\n\n    return {\n      value: min,\n      ele: minEle\n    };\n  }\n});\n\n// aliases\nvar fn = elesfn;\nfn[ 'u' ] = fn[ '|' ] = fn[ '+' ] = fn.union = fn.or = fn.add;\nfn[ '\\\\' ] = fn[ '!' ] = fn[ '-' ] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;\nfn[ 'n' ] = fn[ '&' ] = fn[ '.' ] = fn.and = fn.intersection = fn.intersect;\nfn[ '^' ] = fn[ '(+)' ] = fn[ '(-)' ] = fn.symmetricDifference = fn.symdiff = fn.xor;\nfn.fnFilter = fn.filterFn = fn.stdFilter;\nfn.complement = fn.abscomp = fn.absoluteComplement;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/filter.js\n ** module id = 69\n ** module chunks = 0\n **/","'use strict';\n\nvar elesfn = ({\n  isNode: function(){\n    return this.group() === 'nodes';\n  },\n\n  isEdge: function(){\n    return this.group() === 'edges';\n  },\n\n  isLoop: function(){\n    return this.isEdge() && this.source().id() === this.target().id();\n  },\n\n  isSimple: function(){\n    return this.isEdge() && this.source().id() !== this.target().id();\n  },\n\n  group: function(){\n    var ele = this[0];\n\n    if( ele ){\n      return ele._private.group;\n    }\n  }\n});\n\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/group.js\n ** module id = 70\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar zIndexSort = require( './zsort' );\n\nvar elesfn = ({\n  each: function( fn ){\n    if( is.fn( fn ) ){\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[ i ];\n        var ret = fn.apply( ele, [ i, ele ] );\n\n        if( ret === false ){ break; } // exit each early on return false\n      }\n    }\n    return this;\n  },\n\n  forEach: function( fn, thisArg ){\n    if( is.fn( fn ) ){\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[ i ];\n        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );\n\n        if( ret === false ){ break; } // exit each early on return false\n      }\n    }\n\n    return this;\n  },\n\n  toArray: function(){\n    var array = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      array.push( this[ i ] );\n    }\n\n    return array;\n  },\n\n  slice: function( start, end ){\n    var array = [];\n    var thisSize = this.length;\n\n    if( end == null ){\n      end = thisSize;\n    }\n\n    if( start == null ){\n      start = 0;\n    }\n\n    if( start < 0 ){\n      start = thisSize + start;\n    }\n\n    if( end < 0 ){\n      end = thisSize + end;\n    }\n\n    for( var i = start; i >= 0 && i < end && i < thisSize; i++ ){\n      array.push( this[ i ] );\n    }\n\n    return this.spawn( array );\n  },\n\n  size: function(){\n    return this.length;\n  },\n\n  eq: function( i ){\n    return this[ i ] || this.spawn();\n  },\n\n  first: function(){\n    return this[0] || this.spawn();\n  },\n\n  last: function(){\n    return this[ this.length - 1 ] || this.spawn();\n  },\n\n  empty: function(){\n    return this.length === 0;\n  },\n\n  nonempty: function(){\n    return !this.empty();\n  },\n\n  sort: function( sortFn ){\n    if( !is.fn( sortFn ) ){\n      return this;\n    }\n\n    var sorted = this.toArray().sort( sortFn );\n\n    return this.spawn( sorted );\n  },\n\n  sortByZIndex: function(){\n    return this.sort( zIndexSort );\n  },\n\n  zDepth: function(){\n    var ele = this[0];\n    if( !ele ){ return undefined; }\n\n    // var cy = ele.cy();\n    var _p = ele._private;\n    var group = _p.group;\n\n    if( group === 'nodes' ){\n      var depth = _p.data.parent ? ele.parents().size() : 0;\n\n      if( !ele.isParent() ){\n        return Number.MAX_VALUE; // childless nodes always on top\n      }\n\n      return depth;\n    } else {\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcDepth = src.zDepth();\n      var tgtDepth = tgt.zDepth();\n\n      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent\n    }\n  }\n});\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/iteration.js\n ** module id = 71\n ** module chunks = 0\n **/","'use strict';\n\nvar zIndexSort = function( a, b ){\n  var cy = a.cy();\n  var zDiff = a.pstyle( 'z-index' ).value - b.pstyle( 'z-index' ).value;\n  var depthA = 0;\n  var depthB = 0;\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  var aIsNode = a.isNode();\n  var aIsEdge = !aIsNode;\n  var bIsNode = b.isNode();\n  var bIsEdge = !bIsNode;\n\n  // no need to calculate element depth if there is no compound node\n  if( hasCompoundNodes ){\n    depthA = a.zDepth();\n    depthB = b.zDepth();\n  }\n\n  var depthDiff = depthA - depthB;\n  var sameDepth = depthDiff === 0;\n\n  if( sameDepth ){\n\n    if( aIsNode && bIsEdge ){\n      return 1; // 'a' is a node, it should be drawn later\n\n    } else if( aIsEdge && bIsNode ){\n      return -1; // 'a' is an edge, it should be drawn first\n\n    } else { // both nodes or both edges\n      if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)\n        return a.poolIndex() - b.poolIndex();\n      } else {\n        return zDiff;\n      }\n    }\n\n  // elements on different level\n  } else {\n    return depthDiff; // deeper element should be drawn later\n  }\n\n};\n\nmodule.exports = zIndexSort;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/zsort.js\n ** module id = 72\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar util = require( '../util' );\nvar Promise = require('../promise');\n\nvar elesfn = ({\n\n  // using standard layout options, apply position function (w/ or w/o animation)\n  layoutPositions: function( layout, options, fn ){\n    var nodes = this.nodes();\n    var cy = this.cy();\n\n    layout.trigger( { type: 'layoutstart', layout: layout } );\n\n    layout.animations = [];\n\n    if( options.animate ){\n      for( var i = 0; i < nodes.length; i++ ){\n        var node = nodes[ i ];\n        var lastNode = i === nodes.length - 1;\n\n        var newPos = fn.call( node, i, node );\n        var pos = node.position();\n\n        if( !is.number( pos.x ) || !is.number( pos.y ) ){\n          node.silentPosition( { x: 0, y: 0 } );\n        }\n\n        var ani = node.animation( {\n          position: newPos,\n          duration: options.animationDuration,\n          easing: options.animationEasing\n        } );\n\n        layout.animations.push( ani );\n\n        ani.play();\n      }\n\n      var onStep;\n      cy.on( 'step.*', ( onStep = function(){\n        if( options.fit ){\n          cy.fit( options.eles, options.padding );\n        }\n      }) );\n\n      layout.one('layoutstop', function(){\n        cy.off('step.*', onStep);\n      });\n\n      layout.one( 'layoutready', options.ready );\n      layout.trigger( { type: 'layoutready', layout: layout } );\n\n      Promise.all( layout.animations.map(function( ani ){\n        return ani.promise();\n      }) ).then(function(){\n        cy.off('step.*', onStep);\n\n        if( options.zoom != null ){\n          cy.zoom( options.zoom );\n        }\n\n        if( options.pan ){\n          cy.pan( options.pan );\n        }\n\n        if( options.fit ){\n          cy.fit( options.eles, options.padding );\n        }\n\n        layout.one( 'layoutstop', options.stop );\n        layout.trigger( { type: 'layoutstop', layout: layout } );\n      });\n    } else {\n      nodes.positions( fn );\n\n      if( options.fit ){\n        cy.fit( options.eles, options.padding );\n      }\n\n      if( options.zoom != null ){\n        cy.zoom( options.zoom );\n      }\n\n      if( options.pan ){\n        cy.pan( options.pan );\n      }\n\n      layout.one( 'layoutready', options.ready );\n      layout.trigger( { type: 'layoutready', layout: layout } );\n\n      layout.one( 'layoutstop', options.stop );\n      layout.trigger( { type: 'layoutstop', layout: layout } );\n    }\n\n    return this; // chaining\n  },\n\n  layout: function( options ){\n    var cy = this.cy();\n\n    cy.layout( util.extend( {}, options, {\n      eles: this\n    } ) );\n\n    return this;\n  },\n\n  makeLayout: function( options ){\n    var cy = this.cy();\n\n    return cy.makeLayout( util.extend( {}, options, {\n      eles: this\n    } ) );\n  }\n\n});\n\n// aliases:\nelesfn.createLayout = elesfn.makeLayout;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/layout.js\n ** module id = 73\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\n\nvar elesfn = ({\n\n  // fully updates (recalculates) the style for the elements\n  updateStyle: function( notifyRenderer ){\n    var cy = this._private.cy;\n\n    if( !cy.styleEnabled() ){ return this; }\n\n    if( cy._private.batchingStyle ){\n      var bEles = cy._private.batchStyleEles;\n\n      bEles.merge( this );\n\n      return this; // chaining and exit early when batching\n    }\n\n    var style = cy.style();\n    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n    style.apply( this );\n\n    var updatedCompounds = this.updateCompoundBounds();\n    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\n    if( notifyRenderer ){\n      toNotify.rtrigger( 'style' ); // let renderer know we changed style\n    } else {\n      toNotify.trigger( 'style' ); // just fire the event\n    }\n    return this; // chaining\n  },\n\n  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()\n  updateMappers: function( notifyRenderer ){\n    var cy = this._private.cy;\n    var style = cy.style();\n    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n    if( !cy.styleEnabled() ){ return this; }\n\n    style.updateMappers( this );\n\n    var updatedCompounds = this.updateCompoundBounds();\n    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\n    if( notifyRenderer ){\n      toNotify.rtrigger( 'style' ); // let renderer know we changed style\n    } else {\n      toNotify.trigger( 'style' ); // just fire the event\n    }\n    return this; // chaining\n  },\n\n  // get the internal parsed style object for the specified property\n  parsedStyle: function( property ){\n    var ele = this[0];\n    if( !ele.cy().styleEnabled() ){ return; }\n\n    if( ele ){\n      return ele._private.style[ property ] || ele.cy().style().getDefaultProperty( property );\n    }\n  },\n\n  // get the specified css property as a rendered value (i.e. on-screen value)\n  // or get the whole rendered style if no property specified (NB doesn't allow setting)\n  renderedStyle: function( property ){\n    var cy = this.cy();\n    if( !cy.styleEnabled() ){ return this; }\n\n    var ele = this[0];\n\n    if( ele ){\n      var renstyle = ele.cy().style().getRenderedStyle( ele );\n\n      if( property === undefined ){\n        return renstyle;\n      } else {\n        return renstyle[ property ];\n      }\n    }\n  },\n\n  // read the calculated css style of the element or override the style (via a bypass)\n  style: function( name, value ){\n    var cy = this.cy();\n\n    if( !cy.styleEnabled() ){ return this; }\n\n    var updateTransitions = false;\n    var style = cy.style();\n\n    if( is.plainObject( name ) ){ // then extend the bypass\n      var props = name;\n      style.applyBypass( this, props, updateTransitions );\n\n      var updatedCompounds = this.updateCompoundBounds();\n      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n      toNotify.rtrigger( 'style' ); // let the renderer know we've updated style\n\n    } else if( is.string( name ) ){\n\n      if( value === undefined ){ // then get the property from the style\n        var ele = this[0];\n\n        if( ele ){\n          return style.getStylePropertyValue( ele, name );\n        } else { // empty collection => can't get any value\n          return;\n        }\n\n      } else { // then set the bypass with the property value\n        style.applyBypass( this, name, value, updateTransitions );\n\n        var updatedCompounds = this.updateCompoundBounds();\n        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n        toNotify.rtrigger( 'style' ); // let the renderer know we've updated style\n      }\n\n    } else if( name === undefined ){\n      var ele = this[0];\n\n      if( ele ){\n        return style.getRawStyle( ele );\n      } else { // empty collection => can't get any value\n        return;\n      }\n    }\n\n    return this; // chaining\n  },\n\n  removeStyle: function( names ){\n    var cy = this.cy();\n\n    if( !cy.styleEnabled() ){ return this; }\n\n    var updateTransitions = false;\n    var style = cy.style();\n    var eles = this;\n\n    if( names === undefined ){\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[ i ];\n\n        style.removeAllBypasses( ele, updateTransitions );\n      }\n    } else {\n      names = names.split( /\\s+/ );\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[ i ];\n\n        style.removeBypasses( ele, names, updateTransitions );\n      }\n    }\n\n    var updatedCompounds = this.updateCompoundBounds();\n    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n    toNotify.rtrigger( 'style' ); // let the renderer know we've updated style\n\n    return this; // chaining\n  },\n\n  show: function(){\n    this.css( 'display', 'element' );\n    return this; // chaining\n  },\n\n  hide: function(){\n    this.css( 'display', 'none' );\n    return this; // chaining\n  },\n\n  visible: function(){\n    var cy = this.cy();\n    if( !cy.styleEnabled() ){ return true; }\n\n    var ele = this[0];\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    if( ele ){\n      if(\n        ele.pstyle( 'visibility' ).value !== 'visible'\n        || ele.pstyle( 'display' ).value !== 'element'\n      ){\n        return false;\n      }\n\n      if( ele._private.group === 'nodes' ){\n        if( !hasCompoundNodes ){ return true; }\n\n        var parents = ele._private.data.parent ? ele.parents() : null;\n\n        if( parents ){\n          for( var i = 0; i < parents.length; i++ ){\n            var parent = parents[ i ];\n            var pVis = parent.pstyle( 'visibility' ).value;\n            var pDis = parent.pstyle( 'display' ).value;\n\n            if( pVis !== 'visible' || pDis !== 'element' ){\n              return false;\n            }\n          }\n        }\n\n        return true;\n      } else {\n        var src = ele._private.source;\n        var tgt = ele._private.target;\n\n        return src.visible() && tgt.visible();\n      }\n\n    }\n  },\n\n  hidden: function(){\n    var ele = this[0];\n\n    if( ele ){\n      return !ele.visible();\n    }\n  },\n\n  effectiveOpacity: function(){\n    var cy = this.cy();\n    if( !cy.styleEnabled() ){ return 1; }\n\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var ele = this[0];\n\n    if( ele ){\n      var _p = ele._private;\n      var parentOpacity = ele.pstyle( 'opacity' ).value;\n\n      if( !hasCompoundNodes ){ return parentOpacity; }\n\n      var parents = !_p.data.parent ? null : ele.parents();\n\n      if( parents ){\n        for( var i = 0; i < parents.length; i++ ){\n          var parent = parents[ i ];\n          var opacity = parent.pstyle( 'opacity' ).value;\n\n          parentOpacity = opacity * parentOpacity;\n        }\n      }\n\n      return parentOpacity;\n    }\n  },\n\n  transparent: function(){\n    var cy = this.cy();\n    if( !cy.styleEnabled() ){ return false; }\n\n    var ele = this[0];\n    var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n    if( ele ){\n      if( !hasCompoundNodes ){\n        return ele.pstyle( 'opacity' ).value === 0;\n      } else {\n        return ele.effectiveOpacity() === 0;\n      }\n    }\n  },\n\n  isFullAutoParent: function(){\n    var cy = this.cy();\n    if( !cy.styleEnabled() ){ return false; }\n\n    var ele = this[0];\n\n    if( ele ){\n      var autoW = ele.pstyle( 'width' ).value === 'auto';\n      var autoH = ele.pstyle( 'height' ).value === 'auto';\n\n      return ele.isParent() && autoW && autoH;\n    }\n  },\n\n  backgrounding: function(){\n    var cy = this.cy();\n    if( !cy.styleEnabled() ){ return false; }\n\n    var ele = this[0];\n\n    return ele._private.backgrounding ? true : false;\n  }\n\n});\n\n\nelesfn.bypass = elesfn.css = elesfn.style;\nelesfn.renderedCss = elesfn.renderedStyle;\nelesfn.removeBypass = elesfn.removeCss = elesfn.removeStyle;\nelesfn.pstyle = elesfn.parsedStyle;\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/style.js\n ** module id = 74\n ** module chunks = 0\n **/","'use strict';\n\nvar elesfn = {};\n\nfunction defineSwitchFunction( params ){\n  return function(){\n    var args = arguments;\n    var changedEles = [];\n\n    // e.g. cy.nodes().select( data, handler )\n    if( args.length === 2 ){\n      var data = args[0];\n      var handler = args[1];\n      this.on( params.event, data, handler );\n    }\n\n    // e.g. cy.nodes().select( handler )\n    else if( args.length === 1 ){\n      var handler = args[0];\n      this.on( params.event, handler );\n    }\n\n    // e.g. cy.nodes().select()\n    else if( args.length === 0 ){\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[ i ];\n        var able = !params.ableField || ele._private[ params.ableField ];\n        var changed = ele._private[ params.field ] != params.value;\n\n        if( params.overrideAble ){\n          var overrideAble = params.overrideAble( ele );\n\n          if( overrideAble !== undefined ){\n            able = overrideAble;\n\n            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override\n          }\n        }\n\n        if( able ){\n          ele._private[ params.field ] = params.value;\n\n          if( changed ){\n            changedEles.push( ele );\n          }\n        }\n      }\n\n      var changedColl = this.spawn( changedEles );\n      changedColl.updateStyle(); // change of state => possible change of style\n      changedColl.trigger( params.event );\n    }\n\n    return this;\n  };\n}\n\nfunction defineSwitchSet( params ){\n  elesfn[ params.field ] = function(){\n    var ele = this[0];\n\n    if( ele ){\n      if( params.overrideField ){\n        var val = params.overrideField( ele );\n\n        if( val !== undefined ){\n          return val;\n        }\n      }\n\n      return ele._private[ params.field ];\n    }\n  };\n\n  elesfn[ params.on ] = defineSwitchFunction( {\n    event: params.on,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: true\n  } );\n\n  elesfn[ params.off ] = defineSwitchFunction( {\n    event: params.off,\n    field: params.field,\n    ableField: params.ableField,\n    overrideAble: params.overrideAble,\n    value: false\n  } );\n}\n\ndefineSwitchSet( {\n  field: 'locked',\n  overrideField: function( ele ){\n    return ele.cy().autolock() ? true : undefined;\n  },\n  on: 'lock',\n  off: 'unlock'\n} );\n\ndefineSwitchSet( {\n  field: 'grabbable',\n  overrideField: function( ele ){\n    return ele.cy().autoungrabify() ? false : undefined;\n  },\n  on: 'grabify',\n  off: 'ungrabify'\n} );\n\ndefineSwitchSet( {\n  field: 'selected',\n  ableField: 'selectable',\n  overrideAble: function( ele ){\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'select',\n  off: 'unselect'\n} );\n\ndefineSwitchSet( {\n  field: 'selectable',\n  overrideField: function( ele ){\n    return ele.cy().autounselectify() ? false : undefined;\n  },\n  on: 'selectify',\n  off: 'unselectify'\n} );\n\nelesfn.deselect = elesfn.unselect;\n\nelesfn.grabbed = function(){\n  var ele = this[0];\n  if( ele ){\n    return ele._private.grabbed;\n  }\n};\n\ndefineSwitchSet( {\n  field: 'active',\n  on: 'activate',\n  off: 'unactivate'\n} );\n\nelesfn.inactive = function(){\n  var ele = this[0];\n  if( ele ){\n    return !ele._private.active;\n  }\n};\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/switch-functions.js\n ** module id = 75\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar is = require( '../is' );\n\nvar elesfn = {};\n\nvar cache = function( fn, name ){\n  return function traversalCache( arg1, arg2, arg3, arg4 ){\n    var selectorOrEles = arg1;\n    var eles = this;\n    var key;\n\n    if( selectorOrEles == null ){\n      key = 'null';\n    } else if( is.elementOrCollection( selectorOrEles ) && selectorOrEles.length === 1 ){\n      key = '#' + selectorOrEles.id();\n    }\n\n    if( eles.length === 1 && key ){\n      var _p = eles[0]._private;\n      var tch = _p.traversalCache = _p.traversalCache || {};\n      var ch = tch[ name ] = tch[ name ] || {};\n      var cacheHit = ch[ key ];\n\n      if( cacheHit ){\n        return cacheHit;\n      } else {\n        return ( ch[ key ] = fn.call( eles, arg1, arg2, arg3, arg4 ) );\n      }\n    } else {\n      return fn.call( eles, arg1, arg2, arg3, arg4 );\n    }\n  };\n};\n\n// DAG functions\n////////////////\n\nvar defineDagExtremity = function( params ){\n  return function dagExtremityImpl( selector ){\n    var eles = this;\n    var ret = [];\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[ i ];\n      if( !ele.isNode() ){\n        continue;\n      }\n\n      var disqualified = false;\n      var edges = ele.connectedEdges();\n\n      for( var j = 0; j < edges.length; j++ ){\n        var edge = edges[j];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if(\n             ( params.noIncomingEdges && tgt === ele && src !== ele )\n          || ( params.noOutgoingEdges && src === ele && tgt !== ele )\n        ){\n          disqualified = true;\n          break;\n        }\n      }\n\n      if( !disqualified ){\n        ret.push( ele );\n      }\n    }\n\n    return this.spawn( ret, { unique: true } ).filter( selector );\n  };\n};\n\nvar defineDagOneHop = function( params ){\n  return function( selector ){\n    var eles = this;\n    var oEles = [];\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[ i ];\n\n      if( !ele.isNode() ){ continue; }\n\n      var edges = ele.connectedEdges();\n      for( var j = 0; j < edges.length; j++ ){\n        var edge = edges[ j ];\n        var src = edge.source();\n        var tgt = edge.target();\n\n        if( params.outgoing && src === ele ){\n          oEles.push( edge );\n          oEles.push( tgt );\n        } else if( params.incoming && tgt === ele ){\n          oEles.push( edge );\n          oEles.push( src );\n        }\n      }\n    }\n\n    return this.spawn( oEles, { unique: true } ).filter( selector );\n  };\n};\n\nvar defineDagAllHops = function( params ){\n  return function( selector ){\n    var eles = this;\n    var sEles = [];\n    var sElesIds = {};\n\n    for( ;; ){\n      var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\n      if( next.length === 0 ){ break; } // done if none left\n\n      var newNext = false;\n      for( var i = 0; i < next.length; i++ ){\n        var n = next[ i ];\n        var nid = n.id();\n\n        if( !sElesIds[ nid ] ){\n          sElesIds[ nid ] = true;\n          sEles.push( n );\n          newNext = true;\n        }\n      }\n\n      if( !newNext ){ break; } // done if touched all outgoers already\n\n      eles = next;\n    }\n\n    return this.spawn( sEles, { unique: true } ).filter( selector );\n  };\n};\n\nutil.extend( elesfn, {\n  // get the root nodes in the DAG\n  roots: defineDagExtremity({ noIncomingEdges: true }),\n\n  // get the leaf nodes in the DAG\n  leaves: defineDagExtremity({ noOutgoingEdges: true }),\n\n  // normally called children in graph theory\n  // these nodes =edges=> outgoing nodes\n  outgoers: cache( defineDagOneHop({ outgoing: true }) , 'outgoers' ),\n\n  // aka DAG descendants\n  successors: defineDagAllHops({ outgoing: true }),\n\n  // normally called parents in graph theory\n  // these nodes <=edges= incoming nodes\n  incomers: cache( defineDagOneHop({ incoming: true }), 'incomers' ),\n\n  // aka DAG ancestors\n  predecessors: defineDagAllHops({ incoming: true })\n} );\n\n\n// Neighbourhood functions\n//////////////////////////\n\nutil.extend( elesfn, {\n  neighborhood: cache(function( selector ){\n    var elements = [];\n    var nodes = this.nodes();\n\n    for( var i = 0; i < nodes.length; i++ ){ // for all nodes\n      var node = nodes[ i ];\n      var connectedEdges = node.connectedEdges();\n\n      // for each connected edge, add the edge and the other node\n      for( var j = 0; j < connectedEdges.length; j++ ){\n        var edge = connectedEdges[ j ];\n        var src = edge.source();\n        var tgt = edge.target();\n        var otherNode = node === src ? tgt : src;\n\n        // need check in case of loop\n        if( otherNode.length > 0 ){\n          elements.push( otherNode[0] ); // add node 1 hop away\n        }\n\n        // add connected edge\n        elements.push( edge[0] );\n      }\n\n    }\n\n    return ( this.spawn( elements, { unique: true } ) ).filter( selector );\n  }, 'neighborhood'),\n\n  closedNeighborhood: function( selector ){\n    return this.neighborhood().add( this ).filter( selector );\n  },\n\n  openNeighborhood: function( selector ){\n    return this.neighborhood( selector );\n  }\n} );\n\n// aliases\nelesfn.neighbourhood = elesfn.neighborhood;\nelesfn.closedNeighbourhood = elesfn.closedNeighborhood;\nelesfn.openNeighbourhood = elesfn.openNeighborhood;\n\n// Edge functions\n/////////////////\n\nutil.extend( elesfn, {\n  source: cache(function sourceImpl( selector ){\n    var ele = this[0];\n    var src;\n\n    if( ele ){\n      src = ele._private.source || ele.cy().collection();\n    }\n\n    return src && selector ? src.filter( selector ) : src;\n  }, 'source'),\n\n  target: cache(function targetImpl( selector ){\n    var ele = this[0];\n    var tgt;\n\n    if( ele ){\n      tgt = ele._private.target || ele.cy().collection();\n    }\n\n    return tgt && selector ? tgt.filter( selector ) : tgt;\n  }, 'target'),\n\n  sources: defineSourceFunction( {\n    attr: 'source'\n  } ),\n\n  targets: defineSourceFunction( {\n    attr: 'target'\n  } )\n} );\n\nfunction defineSourceFunction( params ){\n  return function sourceImpl( selector ){\n    var sources = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[ i ];\n      var src = ele._private[ params.attr ];\n\n      if( src ){\n        sources.push( src );\n      }\n    }\n\n    return this.spawn( sources, { unique: true } ).filter( selector );\n  };\n}\n\nutil.extend( elesfn, {\n  edgesWith: cache( defineEdgesWithFunction(), 'edgesWith', true ),\n\n  edgesTo: cache( defineEdgesWithFunction( {\n    thisIsSrc: true\n  } ), 'edgesTo', true )\n} );\n\nfunction defineEdgesWithFunction( params ){\n\n  return function edgesWithImpl( otherNodes ){\n    var elements = [];\n    var cy = this._private.cy;\n    var p = params || {};\n\n    // get elements if a selector is specified\n    if( is.string( otherNodes ) ){\n      otherNodes = cy.$( otherNodes );\n    }\n\n    var thisIds = this._private.ids;\n    var otherIds = otherNodes._private.ids;\n\n    for( var h = 0; h < otherNodes.length; h++ ){\n      var edges = otherNodes[ h ]._private.edges;\n\n      for( var i = 0; i < edges.length; i++ ){\n        var edge = edges[ i ];\n        var edgeData = edge._private.data;\n        var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];\n        var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];\n        var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\n        if( !edgeConnectsThisAndOther ){ continue; }\n\n        if( p.thisIsSrc || p.thisIsTgt ){\n          if( p.thisIsSrc && !thisToOther ){ continue; }\n\n          if( p.thisIsTgt && !otherToThis ){ continue; }\n        }\n\n        elements.push( edge );\n      }\n    }\n\n    return this.spawn( elements, { unique: true } );\n  };\n}\n\nutil.extend( elesfn, {\n  connectedEdges: cache(function( selector ){\n    var retEles = [];\n\n    var eles = this;\n    for( var i = 0; i < eles.length; i++ ){\n      var node = eles[ i ];\n      if( !node.isNode() ){ continue; }\n\n      var edges = node._private.edges;\n\n      for( var j = 0; j < edges.length; j++ ){\n        var edge = edges[ j ];\n        retEles.push( edge );\n      }\n    }\n\n    return this.spawn( retEles, { unique: true } ).filter( selector );\n  }, 'connectedEdges'),\n\n  connectedNodes: cache(function( selector ){\n    var retEles = [];\n\n    var eles = this;\n    for( var i = 0; i < eles.length; i++ ){\n      var edge = eles[ i ];\n      if( !edge.isEdge() ){ continue; }\n\n      retEles.push( edge.source()[0] );\n      retEles.push( edge.target()[0] );\n    }\n\n    return this.spawn( retEles, { unique: true } ).filter( selector );\n  }, 'connectedNodes'),\n\n  parallelEdges: cache( defineParallelEdgesFunction(), 'parallelEdges' ),\n\n  codirectedEdges: cache( defineParallelEdgesFunction( {\n    codirected: true\n  } ), 'codirectedEdges' )\n} );\n\nfunction defineParallelEdgesFunction( params ){\n  var defaults = {\n    codirected: false\n  };\n  params = util.extend( {}, defaults, params );\n\n  return function parallelEdgesImpl( selector ){ // micro-optimised for renderer\n    var elements = [];\n    var edges = this.edges();\n    var p = params;\n\n    // look at all the edges in the collection\n    for( var i = 0; i < edges.length; i++ ){\n      var edge1 = edges[ i ];\n      var edge1_p = edge1._private;\n      var src1 = edge1_p.source;\n      var srcid1 = src1._private.data.id;\n      var tgtid1 = edge1_p.data.target;\n      var srcEdges1 = src1._private.edges;\n\n      // look at edges connected to the src node of this edge\n      for( var j = 0; j < srcEdges1.length; j++ ){\n        var edge2 = srcEdges1[ j ];\n        var edge2data = edge2._private.data;\n        var tgtid2 = edge2data.target;\n        var srcid2 = edge2data.source;\n\n        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\n        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){\n          elements.push( edge2 );\n        }\n      }\n    }\n\n    return this.spawn( elements, { unique: true } ).filter( selector );\n  };\n\n}\n\n// Misc functions\n/////////////////\n\nutil.extend( elesfn, {\n  components: function(){\n    var self = this;\n    var cy = self.cy();\n    var visited = self.spawn();\n    var unvisited = self.nodes().spawnSelf();\n    var components = [];\n\n    var visitInComponent = function( node, component ){\n      visited.merge( node );\n      unvisited.unmerge( node );\n      component.merge( node );\n    };\n\n    if( unvisited.empty() ){ return self.spawn(); }\n\n    do {\n      var component = cy.collection();\n      components.push( component );\n\n      var root = unvisited[0];\n      visitInComponent( root, component );\n\n      self.bfs({\n        directed: false,\n        roots: root,\n        visit: function( i, depth, v, e, u ){\n          visitInComponent( v, component );\n        }\n      } );\n\n    } while( unvisited.length > 0 );\n\n    return components.map(function( component ){\n      var connectedEdges = component.connectedEdges().stdFilter(function( edge ){\n        return component.anySame( edge.source() ) && component.anySame( edge.target() );\n      });\n\n      return component.union( connectedEdges );\n    });\n  }\n} );\n\nmodule.exports = elesfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/collection/traversing.js\n ** module id = 76\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar util = require( '../util' );\nvar Collection = require( '../collection' );\nvar Element = require( '../collection/element' );\n\nvar corefn = {\n  add: function( opts ){\n\n    var elements;\n    var cy = this;\n\n    // add the elements\n    if( is.elementOrCollection( opts ) ){\n      var eles = opts;\n\n      if( eles._private.cy === cy ){ // same instance => just restore\n        elements = eles.restore();\n\n      } else { // otherwise, copy from json\n        var jsons = [];\n\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[ i ];\n          jsons.push( ele.json() );\n        }\n\n        elements = new Collection( cy, jsons );\n      }\n    }\n\n    // specify an array of options\n    else if( is.array( opts ) ){\n      var jsons = opts;\n\n      elements = new Collection( cy, jsons );\n    }\n\n    // specify via opts.nodes and opts.edges\n    else if( is.plainObject( opts ) && (is.array( opts.nodes ) || is.array( opts.edges )) ){\n      var elesByGroup = opts;\n      var jsons = [];\n\n      var grs = [ 'nodes', 'edges' ];\n      for( var i = 0, il = grs.length; i < il; i++ ){\n        var group = grs[ i ];\n        var elesArray = elesByGroup[ group ];\n\n        if( is.array( elesArray ) ){\n\n          for( var j = 0, jl = elesArray.length; j < jl; j++ ){\n            var json = util.extend( { group: group }, elesArray[ j ] );\n\n            jsons.push( json );\n          }\n        }\n      }\n\n      elements = new Collection( cy, jsons );\n    }\n\n    // specify options for one element\n    else {\n      var json = opts;\n      elements = (new Element( cy, json )).collection();\n    }\n\n    return elements;\n  },\n\n  remove: function( collection ){\n    if( is.elementOrCollection( collection ) ){\n      collection = collection;\n    } else if( is.string( collection ) ){\n      var selector = collection;\n      collection = this.$( selector );\n    }\n\n    return collection.remove();\n  },\n\n  load: function( elements, onload, ondone ){\n    var cy = this;\n\n    cy.notifications( false );\n\n    // remove old elements\n    var oldEles = cy.mutableElements();\n    if( oldEles.length > 0 ){\n      oldEles.remove();\n    }\n\n    if( elements != null ){\n      if( is.plainObject( elements ) || is.array( elements ) ){\n        cy.add( elements );\n      }\n    }\n\n    cy.one( 'layoutready', function( e ){\n      cy.notifications( true );\n      cy.trigger( e ); // we missed this event by turning notifications off, so pass it on\n\n      cy.notify( {\n        type: 'load',\n        eles: cy.mutableElements()\n      } );\n\n      cy.one( 'load', onload );\n      cy.trigger( 'load' );\n    } ).one( 'layoutstop', function(){\n      cy.one( 'done', ondone );\n      cy.trigger( 'done' );\n    } );\n\n    var layoutOpts = util.extend( {}, cy._private.options.layout );\n    layoutOpts.eles = cy.elements();\n\n    cy.layout( layoutOpts );\n\n    return this;\n  }\n};\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/add-remove.js\n ** module id = 77\n ** module chunks = 0\n **/","'use strict';\n\nvar define = require( '../define' );\nvar util = require( '../util' );\nvar is = require( '../is' );\n\nvar corefn = ({\n\n  // pull in animation functions\n  animate: define.animate(),\n  animation: define.animation(),\n  animated: define.animated(),\n  clearQueue: define.clearQueue(),\n  delay: define.delay(),\n  delayAnimation: define.delayAnimation(),\n  stop: define.stop(),\n\n  addToAnimationPool: function( eles ){\n    var cy = this;\n\n    if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n\n    cy._private.aniEles.merge( eles );\n  },\n\n  stopAnimationLoop: function(){\n    this._private.animationsRunning = false;\n  },\n\n  startAnimationLoop: function(){\n    var cy = this;\n\n    cy._private.animationsRunning = true;\n\n    if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n\n    // NB the animation loop will exec in headless environments if style enabled\n    // and explicit cy.destroy() is necessary to stop the loop\n\n    function globalAnimationStep(){\n      if( !cy._private.animationsRunning ){ return; }\n\n      util.requestAnimationFrame( function animationStep( now ){\n        handleElements( now );\n        globalAnimationStep();\n      } );\n    }\n\n    var renderer = cy.renderer();\n\n    if( renderer && renderer.beforeRender ){ // let the renderer schedule animations\n      renderer.beforeRender( function rendererAnimationStep( willDraw, now ){\n        handleElements( now );\n      }, renderer.beforeRenderPriorities.animations );\n    } else { // manage the animation loop ourselves\n      globalAnimationStep(); // first call\n    }\n\n    function handleElements( now ){\n      var eles = cy._private.aniEles;\n      var doneEles = [];\n\n      function handleElement( ele, isCore ){\n        var _p = ele._private;\n        var current = _p.animation.current;\n        var queue = _p.animation.queue;\n        var ranAnis = false;\n\n        // if nothing currently animating, get something from the queue\n        if( current.length === 0 ){\n          var next = queue.shift();\n\n          if( next ){\n            current.push( next );\n          }\n        }\n\n        var callbacks = function( callbacks ){\n          for( var j = callbacks.length - 1; j >= 0; j-- ){\n            var cb = callbacks[ j ];\n\n            cb();\n          }\n\n          callbacks.splice( 0, callbacks.length );\n        };\n\n        // step and remove if done\n        for( var i = current.length - 1; i >= 0; i-- ){\n          var ani = current[ i ];\n          var ani_p = ani._private;\n\n          if( ani_p.stopped ){\n            current.splice( i, 1 );\n\n            ani_p.hooked = false;\n            ani_p.playing = false;\n            ani_p.started = false;\n\n            callbacks( ani_p.frames );\n\n            continue;\n          }\n\n          if( !ani_p.playing && !ani_p.applying ){ continue; }\n\n          // an apply() while playing shouldn't do anything\n          if( ani_p.playing && ani_p.applying ){\n            ani_p.applying = false;\n          }\n\n          if( !ani_p.started ){\n            startAnimation( ele, ani, now );\n          }\n\n          step( ele, ani, now, isCore );\n\n          if( is.fn( ani_p.step ) ){\n            ani_p.step.call( ele, now );\n          }\n\n          if( ani_p.applying ){\n            ani_p.applying = false;\n          }\n\n          callbacks( ani_p.frames );\n\n          if( ani.completed() ){\n            current.splice( i, 1 );\n\n            ani_p.hooked = false;\n            ani_p.playing = false;\n            ani_p.started = false;\n\n            callbacks( ani_p.completes );\n          }\n\n          ranAnis = true;\n        }\n\n        if( !isCore && current.length === 0 && queue.length === 0 ){\n          doneEles.push( ele );\n        }\n\n        return ranAnis;\n      } // handleElement\n\n      // handle all eles\n      var ranEleAni = false;\n      for( var e = 0; e < eles.length; e++ ){\n        var ele = eles[ e ];\n        var handledThisEle = handleElement( ele );\n\n        ranEleAni = ranEleAni || handledThisEle;\n      } // each element\n\n      var ranCoreAni = handleElement( cy, true );\n\n      // notify renderer\n      if( ranEleAni || ranCoreAni ){\n        if( eles.length > 0 ){\n          var updatedEles = eles.updateCompoundBounds().spawnSelf().merge( eles );\n\n          cy.notify({\n            type: 'draw',\n            eles: updatedEles\n          });\n        } else {\n          cy.notify({\n            type: 'draw'\n          });\n        }\n      }\n\n      // remove elements from list of currently animating if its queues are empty\n      eles.unmerge( doneEles );\n\n      cy.trigger('step');\n\n    } // handleElements\n\n    function startAnimation( self, ani, now ){\n      var isCore = is.core( self );\n      var isEles = !isCore;\n      var ele = self;\n      var style = cy._private.style;\n      var ani_p = ani._private;\n\n      if( isEles ){\n        var pos = ele._private.position;\n\n        ani_p.startPosition = ani_p.startPosition || {\n          x: pos.x,\n          y: pos.y\n        };\n\n        ani_p.startStyle = ani_p.startStyle || style.getAnimationStartStyle( ele, ani_p.style );\n      }\n\n      if( isCore ){\n        var pan = cy._private.pan;\n\n        ani_p.startPan = ani_p.startPan || {\n          x: pan.x,\n          y: pan.y\n        };\n\n        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;\n      }\n\n      ani_p.started = true;\n      ani_p.startTime = now - ani_p.progress * ani_p.duration;\n    }\n\n    function step( self, ani, now, isCore ){\n      var style = cy._private.style;\n      var isEles = !isCore;\n      var _p = self._private;\n      var ani_p = ani._private;\n      var pEasing = ani_p.easing;\n      var startTime = ani_p.startTime;\n\n      if( !ani_p.easingImpl ){\n\n        if( pEasing == null ){ // use default\n          ani_p.easingImpl = easings[ 'linear' ];\n\n        } else { // then define w/ name\n          var easingVals;\n\n          if( is.string( pEasing ) ){\n            var easingProp = style.parse( 'transition-timing-function', pEasing );\n\n            easingVals = easingProp.value;\n\n          } else { // then assume preparsed array\n            easingVals = pEasing;\n          }\n\n          var name, args;\n\n          if( is.string( easingVals ) ){\n            name = easingVals;\n            args = [];\n          } else {\n            name = easingVals[1];\n            args = easingVals.slice( 2 ).map( function( n ){ return +n; } );\n          }\n\n          if( args.length > 0 ){ // create with args\n            if( name === 'spring' ){\n              args.push( ani_p.duration ); // need duration to generate spring\n            }\n\n            ani_p.easingImpl = easings[ name ].apply( null, args );\n          } else { // static impl by name\n            ani_p.easingImpl = easings[ name ];\n          }\n        }\n\n      }\n\n      var easing = ani_p.easingImpl;\n      var percent;\n\n      if( ani_p.duration === 0 ){\n        percent = 1;\n      } else {\n        percent = (now - startTime) / ani_p.duration;\n      }\n\n      if( ani_p.applying ){\n        percent = ani_p.progress;\n      }\n\n      if( percent < 0 ){\n        percent = 0;\n      } else if( percent > 1 ){\n        percent = 1;\n      }\n\n      if( ani_p.delay == null ){ // then update\n\n        var startPos = ani_p.startPosition;\n        var endPos = ani_p.position;\n        var pos = _p.position;\n        if( endPos && isEles ){\n          if( valid( startPos.x, endPos.x ) ){\n            pos.x = ease( startPos.x, endPos.x, percent, easing );\n          }\n\n          if( valid( startPos.y, endPos.y ) ){\n            pos.y = ease( startPos.y, endPos.y, percent, easing );\n          }\n\n          self.trigger('position');\n        }\n\n        var startPan = ani_p.startPan;\n        var endPan = ani_p.pan;\n        var pan = _p.pan;\n        var animatingPan = endPan != null && isCore;\n        if( animatingPan ){\n          if( valid( startPan.x, endPan.x ) ){\n            pan.x = ease( startPan.x, endPan.x, percent, easing );\n          }\n\n          if( valid( startPan.y, endPan.y ) ){\n            pan.y = ease( startPan.y, endPan.y, percent, easing );\n          }\n\n          self.trigger( 'pan' );\n        }\n\n        var startZoom = ani_p.startZoom;\n        var endZoom = ani_p.zoom;\n        var animatingZoom = endZoom != null && isCore;\n        if( animatingZoom ){\n          if( valid( startZoom, endZoom ) ){\n            _p.zoom = ease( startZoom, endZoom, percent, easing );\n          }\n\n          self.trigger( 'zoom' );\n        }\n\n        if( animatingPan || animatingZoom ){\n          self.trigger( 'viewport' );\n        }\n\n        var props = ani_p.style;\n        if( props && props.length > 0 && isEles ){\n          for( var i = 0; i < props.length; i++ ){\n            var prop = props[ i ];\n            var name = prop.name;\n            var end = prop;\n\n            var start = ani_p.startStyle[ name ];\n            var easedVal = ease( start, end, percent, easing );\n\n            style.overrideBypass( self, name, easedVal );\n          } // for props\n\n          self.trigger('style');\n\n        } // if\n\n      }\n\n      ani_p.progress = percent;\n\n      return percent;\n    }\n\n    function valid( start, end ){\n      if( start == null || end == null ){\n        return false;\n      }\n\n      if( is.number( start ) && is.number( end ) ){\n        return true;\n      } else if( (start) && (end) ){\n        return true;\n      }\n\n      return false;\n    }\n\n    // assumes p0 = 0, p3 = 1\n    function evalCubicBezier( p1, p2, t ){\n      var one_t = 1 - t;\n      var tsq = t * t;\n\n      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;\n    }\n\n    function cubicBezier( p1, p2 ){\n      return function( start, end, percent ){\n        return start + (end - start) * evalCubicBezier( p1, p2, percent );\n      };\n    }\n\n    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\n    var generateSpringRK4 = (function(){\n      function springAccelerationForState( state ){\n        return (-state.tension * state.x) - (state.friction * state.v);\n      }\n\n      function springEvaluateStateWithDerivative( initialState, dt, derivative ){\n        var state = {\n          x: initialState.x + derivative.dx * dt,\n          v: initialState.v + derivative.dv * dt,\n          tension: initialState.tension,\n          friction: initialState.friction\n        };\n\n        return { dx: state.v, dv: springAccelerationForState( state ) };\n      }\n\n      function springIntegrateState( state, dt ){\n        var a = {\n          dx: state.v,\n          dv: springAccelerationForState( state )\n        },\n        b = springEvaluateStateWithDerivative( state, dt * 0.5, a ),\n        c = springEvaluateStateWithDerivative( state, dt * 0.5, b ),\n        d = springEvaluateStateWithDerivative( state, dt, c ),\n        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n\n        state.x = state.x + dxdt * dt;\n        state.v = state.v + dvdt * dt;\n\n        return state;\n      }\n\n      return function springRK4Factory( tension, friction, duration ){\n\n        var initState = {\n          x: -1,\n          v: 0,\n          tension: null,\n          friction: null\n        },\n        path = [0],\n        time_lapsed = 0,\n        tolerance = 1 / 10000,\n        DT = 16 / 1000,\n        have_duration, dt, last_state;\n\n        tension = parseFloat( tension ) || 500;\n        friction = parseFloat( friction ) || 20;\n        duration = duration || null;\n\n        initState.tension = tension;\n        initState.friction = friction;\n\n        have_duration = duration !== null;\n\n        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n        if( have_duration ){\n          /* Run the simulation without a duration. */\n          time_lapsed = springRK4Factory( tension, friction );\n          /* Compute the adjusted time delta. */\n          dt = time_lapsed / duration * DT;\n        } else {\n          dt = DT;\n        }\n\n        while( true ){\n          /* Next/step function .*/\n          last_state = springIntegrateState( last_state || initState, dt );\n          /* Store the position. */\n          path.push( 1 + last_state.x );\n          time_lapsed += 16;\n          /* If the change threshold is reached, break. */\n          if( !(Math.abs( last_state.x ) > tolerance && Math.abs( last_state.v ) > tolerance) ){\n            break;\n          }\n        }\n\n        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n           computed path and returns a snapshot of the position according to a given percentComplete. */\n        return !have_duration ? time_lapsed : function( percentComplete ){ return path[ (percentComplete * (path.length - 1)) | 0 ]; };\n      };\n    }());\n\n    var easings = {\n      'linear': function( start, end, percent ){\n        return start + (end - start) * percent;\n      },\n\n      // default easings\n      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),\n      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),\n      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),\n      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),\n\n      // sine\n      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),\n      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),\n      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),\n\n      // quad\n      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),\n      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),\n      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),\n\n      // cubic\n      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),\n      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),\n      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),\n\n      // quart\n      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),\n      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),\n      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),\n\n      // quint\n      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),\n      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),\n      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),\n\n      // expo\n      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),\n      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),\n      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),\n\n      // circ\n      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),\n      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),\n      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),\n\n\n      // user param easings...\n\n      'spring': function( tension, friction, duration ){\n        if( duration === 0 ){ // can't get a spring w/ duration 0\n          return easings.linear; // duration 0 => jump to end so impl doesn't matter\n        }\n\n        var spring = generateSpringRK4( tension, friction, duration );\n\n        return function( start, end, percent ){\n          return start + (end - start) * spring( percent );\n        };\n      },\n\n      'cubic-bezier': function( x1, y1, x2, y2 ){\n        return cubicBezier( x1, y1, x2, y2 );\n      }\n    };\n\n    function ease( startProp, endProp, percent, easingFn ){\n      if( percent < 0 ){\n        percent = 0;\n      } else if( percent > 1 ){\n        percent = 1;\n      }\n\n      var start, end;\n\n      if( startProp.pfValue != null || startProp.value != null ){\n        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;\n      } else {\n        start = startProp;\n      }\n\n      if( endProp.pfValue != null || endProp.value != null ){\n        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;\n      } else {\n        end = endProp;\n      }\n\n      if( is.number( start ) && is.number( end ) ){\n        return easingFn( start, end, percent );\n\n      } else if( is.array( start ) && is.array( end ) ){\n        var easedArr = [];\n\n        for( var i = 0; i < end.length; i++ ){\n          var si = start[ i ];\n          var ei = end[ i ];\n\n          if( si != null && ei != null ){\n            var val = easingFn( si, ei, percent );\n\n            if( startProp.roundValue ){ val = Math.round( val ); }\n\n            easedArr.push( val );\n          } else {\n            easedArr.push( ei );\n          }\n        }\n\n        return easedArr;\n      }\n\n      return undefined;\n    }\n\n  }\n\n});\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/animation.js\n ** module id = 78\n ** module chunks = 0\n **/","'use strict';\n\nvar define = require( '../define' );\n\nvar corefn = ({\n  on: define.on(), // .on( events [, selector] [, data], handler)\n  one: define.on( { unbindSelfOnTrigger: true } ),\n  once: define.on( { unbindAllBindersOnTrigger: true } ),\n  off: define.off(), // .off( events [, selector] [, handler] )\n  trigger: define.trigger() // .trigger( events [, extraParams] )\n});\n\ndefine.eventAliasesOn( corefn );\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/events.js\n ** module id = 79\n ** module chunks = 0\n **/","'use strict';\n\nvar corefn = ({\n\n  png: function( options ){\n    var renderer = this._private.renderer;\n    options = options || {};\n\n    return renderer.png( options );\n  },\n\n  jpg: function( options ){\n    var renderer = this._private.renderer;\n    options = options || {};\n\n    options.bg = options.bg || '#fff';\n\n    return renderer.jpg( options );\n  }\n\n});\n\ncorefn.jpeg = corefn.jpg;\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/export.js\n ** module id = 80\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar is = require( '../is' );\n\nvar corefn = ({\n\n  layout: function( params ){\n    var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.makeLayout( params ) );\n\n    layout.run();\n\n    return this; // chaining\n  },\n\n  makeLayout: function( options ){\n    var cy = this;\n\n    if( options == null ){\n      util.error( 'Layout options must be specified to make a layout' );\n      return;\n    }\n\n    if( options.name == null ){\n      util.error( 'A `name` must be specified to make a layout' );\n      return;\n    }\n\n    var name = options.name;\n    var Layout = cy.extension( 'layout', name );\n\n    if( Layout == null ){\n      util.error( 'Can not apply layout: No such layout `' + name + '` found; did you include its JS file?' );\n      return;\n    }\n\n    var eles;\n    if( is.string( options.eles ) ){\n      eles = cy.$( options.eles );\n    } else {\n      eles = options.eles != null ? options.eles : cy.$();\n    }\n\n    var layout = new Layout( util.extend( {}, options, {\n      cy: cy,\n      eles: eles\n    } ) );\n\n    return layout;\n  }\n\n});\n\ncorefn.createLayout = corefn.makeLayout;\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/layout.js\n ** module id = 81\n ** module chunks = 0\n **/","'use strict';\n\nvar corefn = ({\n  notify: function( params ){\n    var _p = this._private;\n\n    if( _p.batchingNotify ){\n      var bEles = _p.batchNotifyEles;\n      var bTypes = _p.batchNotifyTypes;\n\n      if( params.eles ){\n        bEles.merge( params.eles );\n      }\n\n      if( !bTypes.ids[ params.type ] ){\n        bTypes.push( params.type );\n        bTypes.ids[ params.type ] = true;\n      }\n\n      return; // notifications are disabled during batching\n    }\n\n    if( !_p.notificationsEnabled ){ return; } // exit on disabled\n\n    var renderer = this.renderer();\n\n    renderer.notify( params );\n  },\n\n  notifications: function( bool ){\n    var p = this._private;\n\n    if( bool === undefined ){\n      return p.notificationsEnabled;\n    } else {\n      p.notificationsEnabled = bool ? true : false;\n    }\n  },\n\n  noNotifications: function( callback ){\n    this.notifications( false );\n    callback();\n    this.notifications( true );\n  },\n\n  startBatch: function(){\n    var _p = this._private;\n\n    if( _p.batchCount == null ){\n      _p.batchCount = 0;\n    }\n\n    if( _p.batchCount === 0 ){\n      _p.batchingStyle = _p.batchingNotify = true;\n      _p.batchStyleEles = this.collection();\n      _p.batchNotifyEles = this.collection();\n      _p.batchNotifyTypes = [];\n      _p.batchNotifyTypes.ids = {};\n    }\n\n    _p.batchCount++;\n\n    return this;\n  },\n\n  endBatch: function(){\n    var _p = this._private;\n\n    _p.batchCount--;\n\n    if( _p.batchCount === 0 ){\n      // update style for dirty eles\n      _p.batchingStyle = false;\n      _p.batchStyleEles.updateStyle();\n\n      // notify the renderer of queued eles and event types\n      _p.batchingNotify = false;\n      this.notify( {\n        type: _p.batchNotifyTypes,\n        eles: _p.batchNotifyEles\n      } );\n    }\n\n    return this;\n  },\n\n  batch: function( callback ){\n    this.startBatch();\n    callback();\n    this.endBatch();\n\n    return this;\n  },\n\n  // for backwards compatibility\n  batchData: function( map ){\n    var cy = this;\n\n    return this.batch( function(){\n      var ids = Object.keys( map );\n\n      for( var i = 0; i < ids.length; i++ ){\n        var ids = id[i];\n        var data = map[ id ];\n        var ele = cy.getElementById( id );\n\n        ele.data( data );\n      }\n    } );\n  }\n});\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/notification.js\n ** module id = 82\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\n\nvar corefn = ({\n\n  renderTo: function( context, zoom, pan, pxRatio ){\n    var r = this._private.renderer;\n\n    r.renderTo( context, zoom, pan, pxRatio );\n    return this;\n  },\n\n  renderer: function(){\n    return this._private.renderer;\n  },\n\n  forceRender: function(){\n    this.notify( {\n      type: 'draw'\n    } );\n\n    return this;\n  },\n\n  resize: function(){\n    this.invalidateSize();\n\n    this.notify( {\n      type: 'resize'\n    } );\n\n    this.trigger( 'resize' );\n\n    return this;\n  },\n\n  initRenderer: function( options ){\n    var cy = this;\n\n    var RendererProto = cy.extension( 'renderer', options.name );\n    if( RendererProto == null ){\n      util.error( 'Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name );\n      return;\n    }\n\n    var rOpts = util.extend( {}, options, {\n      cy: cy\n    } );\n\n    cy._private.renderer = new RendererProto( rOpts );\n  },\n\n  onRender: function( fn ){\n    return this.on('render', fn);\n  },\n\n  offRender: function( fn ){\n    return this.off('render', fn);\n  }\n\n});\n\ncorefn.invalidateDimensions = corefn.resize;\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/renderer.js\n ** module id = 83\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar Collection = require( '../collection' );\n\nvar corefn = ({\n\n  // get a collection\n  // - empty collection on no args\n  // - collection of elements in the graph on selector arg\n  // - guarantee a returned collection when elements or collection specified\n  collection: function( eles, opts ){\n\n    if( is.string( eles ) ){\n      return this.$( eles );\n\n    } else if( is.elementOrCollection( eles ) ){\n      return eles.collection();\n\n    } else if( is.array( eles ) ){\n      return new Collection( this, eles, opts );\n    }\n\n    return new Collection( this );\n  },\n\n  nodes: function( selector ){\n    var nodes = this.$( function(){\n      return this.isNode();\n    } );\n\n    if( selector ){\n      return nodes.filter( selector );\n    }\n\n    return nodes;\n  },\n\n  edges: function( selector ){\n    var edges = this.$( function(){\n      return this.isEdge();\n    } );\n\n    if( selector ){\n      return edges.filter( selector );\n    }\n\n    return edges;\n  },\n\n  // search the graph like jQuery\n  $: function( selector ){\n    var eles = this._private.elements;\n\n    if( selector ){\n      return eles.filter( selector );\n    } else {\n      return eles.spawnSelf();\n    }\n  },\n\n  mutableElements: function(){\n    return this._private.elements;\n  }\n\n});\n\n// aliases\ncorefn.elements = corefn.filter = corefn.$;\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/search.js\n ** module id = 84\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar Style = require( '../style' );\n\nvar corefn = ({\n\n  style: function( newStyle ){\n    if( newStyle ){\n      var s = this.setStyle( newStyle );\n\n      s.update();\n    }\n\n    return this._private.style;\n  },\n\n  setStyle: function( style ){\n    var _p = this._private;\n\n    if( is.stylesheet( style ) ){\n      _p.style = style.generateStyle( this );\n\n    } else if( is.array( style ) ){\n      _p.style = Style.fromJson( this, style );\n\n    } else if( is.string( style ) ){\n      _p.style = Style.fromString( this, style );\n\n    } else {\n      _p.style = Style( this );\n    }\n\n    return _p.style;\n  }\n});\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/style.js\n ** module id = 85\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar util = require( '../util' );\nvar Selector = require( '../selector' );\n\nvar Style = function( cy ){\n\n  if( !(this instanceof Style) ){\n    return new Style( cy );\n  }\n\n  if( !is.core( cy ) ){\n    util.error( 'A style must have a core reference' );\n    return;\n  }\n\n  this._private = {\n    cy: cy,\n    coreStyle: {}\n  };\n\n  this.length = 0;\n\n  this.resetToDefault();\n};\n\nvar styfn = Style.prototype;\n\nstyfn.instanceString = function(){\n  return 'style';\n};\n\n// remove all contexts\nstyfn.clear = function(){\n  for( var i = 0; i < this.length; i++ ){\n    this[ i ] = undefined;\n  }\n  this.length = 0;\n\n  var _p = this._private;\n\n  _p.newStyle = true;\n\n  return this; // chaining\n};\n\nstyfn.resetToDefault = function(){\n  this.clear();\n  this.addDefaultStylesheet();\n\n  return this;\n};\n\n// builds a style object for the 'core' selector\nstyfn.core = function(){\n  return this._private.coreStyle;\n};\n\n// create a new context from the specified selector string and switch to that context\nstyfn.selector = function( selectorStr ){\n  // 'core' is a special case and does not need a selector\n  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );\n\n  var i = this.length++; // new context means new index\n  this[ i ] = {\n    selector: selector,\n    properties: [],\n    mappedProperties: [],\n    index: i\n  };\n\n  return this; // chaining\n};\n\n// add one or many css rules to the current context\nstyfn.css = function(){\n  var self = this;\n  var args = arguments;\n\n  switch( args.length ){\n  case 1:\n    var map = args[0];\n\n    for( var i = 0; i < self.properties.length; i++ ){\n      var prop = self.properties[ i ];\n      var mapVal = map[ prop.name ];\n\n      if( mapVal === undefined ){\n        mapVal = map[ util.dash2camel( prop.name ) ];\n      }\n\n      if( mapVal !== undefined ){\n        this.cssRule( prop.name, mapVal );\n      }\n    }\n\n    break;\n\n  case 2:\n    this.cssRule( args[0], args[1] );\n    break;\n\n  default:\n    break; // do nothing if args are invalid\n  }\n\n  return this; // chaining\n};\nstyfn.style = styfn.css;\n\n// add a single css rule to the current context\nstyfn.cssRule = function( name, value ){\n  // name-value pair\n  var property = this.parse( name, value );\n\n  // add property to current context if valid\n  if( property ){\n    var i = this.length - 1;\n    this[ i ].properties.push( property );\n    this[ i ].properties[ property.name ] = property; // allow access by name as well\n\n    if( property.name.match( /pie-(\\d+)-background-size/ ) && property.value ){\n      this._private.hasPie = true;\n    }\n\n    if( property.mapped ){\n      this[ i ].mappedProperties.push( property );\n    }\n\n    // add to core style if necessary\n    var currentSelectorIsCore = !this[ i ].selector;\n    if( currentSelectorIsCore ){\n      this._private.coreStyle[ property.name ] = property;\n    }\n  }\n\n  return this; // chaining\n};\n\n// static function\nStyle.fromJson = function( cy, json ){\n  var style = new Style( cy );\n\n  style.fromJson( json );\n\n  return style;\n};\n\nStyle.fromString = function( cy, string ){\n  return new Style( cy ).fromString( string );\n};\n\n[\n  require( './apply' ),\n  require( './bypass' ),\n  require( './container' ),\n  require( './get-for-ele' ),\n  require( './json' ),\n  require( './string-sheet' ),\n  require( './properties' ),\n  require( './parse' )\n].forEach( function( props ){\n  util.extend( styfn, props );\n} );\n\n\nStyle.types = styfn.types;\nStyle.properties = styfn.properties;\n\nmodule.exports = Style;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/index.js\n ** module id = 86\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar is = require( '../is' );\n\nvar styfn = {};\n\n// (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\nstyfn.apply = function( eles ){\n  var self = this;\n  var _p = self._private;\n\n  if( _p.newStyle ){ // clear style caches\n    _p.contextStyles = {};\n    _p.propDiffs = {};\n\n    self.cleanElements( eles, true );\n  }\n\n  for( var ie = 0; ie < eles.length; ie++ ){\n    var ele = eles[ ie ];\n\n    var cxtMeta = self.getContextMeta( ele );\n    var cxtStyle = self.getContextStyle( cxtMeta );\n    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );\n\n    self.enforceCompoundSizing( ele );\n    self.updateTransitions( ele, app.diffProps );\n    self.updateStyleHints( ele );\n\n  } // for elements\n\n  _p.newStyle = false;\n};\n\nstyfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){\n  var self = this;\n  var cache = self._private.propDiffs = self._private.propDiffs || {};\n  var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n  var cachedVal = cache[ dualCxtKey ];\n\n  if( cachedVal ){\n    return cachedVal;\n  }\n\n  var diffProps = [];\n  var addedProp = {};\n\n  for( var i = 0; i < self.length; i++ ){\n    var cxt = self[ i ];\n    var oldHasCxt = oldCxtKey[ i ] === 't';\n    var newHasCxt = newCxtKey[ i ] === 't';\n    var cxtHasDiffed = oldHasCxt !== newHasCxt;\n    var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n    if( cxtHasDiffed || cxtHasMappedProps ){\n      var props;\n\n      if( cxtHasDiffed && cxtHasMappedProps ){\n        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n      } else if( cxtHasDiffed ){\n        props = cxt.properties; // need to check them all\n      } else if( cxtHasMappedProps ){\n        props = cxt.mappedProperties; // only need to check mapped\n      }\n\n      for( var j = 0; j < props.length; j++ ){\n        var prop = props[ j ];\n        var name = prop.name;\n\n        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n        // is cached)\n        var laterCxtOverrides = false;\n        for( var k = i + 1; k < self.length; k++ ){\n          var laterCxt = self[ k ];\n          var hasLaterCxt = newCxtKey[ k ] === 't';\n\n          if( !hasLaterCxt ){ continue; } // can't override unless the context is active\n\n          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;\n\n          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides\n        }\n\n        if( !addedProp[ name ] && !laterCxtOverrides ){\n          addedProp[ name ] = true;\n          diffProps.push( name );\n        }\n      } // for props\n    } // if\n\n  } // for contexts\n\n  cache[ dualCxtKey ] = diffProps;\n  return diffProps;\n};\n\nstyfn.getContextMeta = function( ele ){\n  var self = this;\n  var cxtKey = '';\n  var diffProps;\n  var prevKey = ele._private.styleCxtKey || '';\n\n  if( self._private.newStyle ){\n    prevKey = ''; // since we need to apply all style if a fresh stylesheet\n  }\n\n  // get the cxt key\n  for( var i = 0; i < self.length; i++ ){\n    var context = self[ i ];\n    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'\n\n    if( contextSelectorMatches ){\n      cxtKey += 't';\n    } else {\n      cxtKey += 'f';\n    }\n  } // for context\n\n  diffProps = self.getPropertiesDiff( prevKey, cxtKey );\n\n  ele._private.styleCxtKey = cxtKey;\n\n  return {\n    key: cxtKey,\n    diffPropNames: diffProps\n  };\n};\n\n// gets a computed ele style object based on matched contexts\nstyfn.getContextStyle = function( cxtMeta ){\n  var cxtKey = cxtMeta.key;\n  var self = this;\n  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n\n  // if already computed style, returned cached copy\n  if( cxtStyles[ cxtKey ] ){ return cxtStyles[ cxtKey ]; }\n\n  var style = {\n    _private: {\n      key: cxtKey\n    }\n  };\n\n  for( var i = 0; i < self.length; i++ ){\n    var cxt = self[ i ];\n    var hasCxt = cxtKey[ i ] === 't';\n\n    if( !hasCxt ){ continue; }\n\n    for( var j = 0; j < cxt.properties.length; j++ ){\n      var prop = cxt.properties[ j ];\n      var styProp = style[ prop.name ] = prop;\n\n      styProp.context = cxt;\n    }\n  }\n\n  cxtStyles[ cxtKey ] = style;\n  return style;\n};\n\nstyfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){\n  var self = this;\n  var diffProps = cxtMeta.diffPropNames;\n  var retDiffProps = {};\n\n  for( var i = 0; i < diffProps.length; i++ ){\n    var diffPropName = diffProps[ i ];\n    var cxtProp = cxtStyle[ diffPropName ];\n    var eleProp = ele.pstyle( diffPropName );\n\n    if( !cxtProp ){ // no context prop means delete\n      if( eleProp.bypass ){\n        cxtProp = { name: diffPropName, deleteBypassed: true };\n      } else {\n        cxtProp = { name: diffPropName, delete: true };\n      }\n    }\n\n    // save cycles when the context prop doesn't need to be applied\n    if( eleProp === cxtProp ){ continue; }\n\n    var retDiffProp = retDiffProps[ diffPropName ] = {\n      prev: eleProp\n    };\n\n    self.applyParsedProperty( ele, cxtProp );\n\n    retDiffProp.next = ele.pstyle( diffPropName );\n\n    if( retDiffProp.next && retDiffProp.next.bypass ){\n      retDiffProp.next = retDiffProp.next.bypassed;\n    }\n  }\n\n  return {\n    diffProps: retDiffProps\n  };\n};\n\n// because a node can become and unbecome a parent, it's safer to enforce auto sizing manually\n// (i.e. the style context diff could be empty, meaning the autosizing is stale)\nstyfn.enforceCompoundSizing = function(ele){\n  var self = this;\n\n  if( ele.isParent() ){\n    self.applyParsedProperty( ele, self.parse('width', 'auto') );\n    self.applyParsedProperty( ele, self.parse('height', 'auto') );\n  }\n};\n\nstyfn.updateStyleHints = function(ele){\n  var _p = ele._private;\n  var self = this;\n\n  if( ele.removed() ){ return; }\n\n  // set whether has pie or not; for greater efficiency\n  var hasPie = false;\n  if( _p.group === 'nodes' ){\n    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N\n      var size = ele.pstyle( 'pie-' + i + '-background-size' ).value;\n\n      if( size > 0 ){\n        hasPie = true;\n        break;\n      }\n    }\n  }\n\n  _p.hasPie = hasPie;\n\n  var transform = ele.pstyle( 'text-transform' ).strValue;\n  var content = ele.pstyle( 'label' ).strValue;\n  var srcContent = ele.pstyle( 'source-label' ).strValue;\n  var tgtContent = ele.pstyle( 'target-label' ).strValue;\n  var fStyle = ele.pstyle( 'font-style' ).strValue;\n  var size = ele.pstyle( 'font-size' ).pfValue + 'px';\n  var family = ele.pstyle( 'font-family' ).strValue;\n  // var variant = style['font-variant'].strValue;\n  var weight = ele.pstyle( 'font-weight' ).strValue;\n  var valign = ele.pstyle( 'text-valign' ).strValue;\n  var halign = ele.pstyle( 'text-valign' ).strValue;\n  var oWidth = ele.pstyle( 'text-outline-width' ).pfValue;\n  var wrap = ele.pstyle( 'text-wrap' ).strValue;\n  var wrapW = ele.pstyle( 'text-max-width' ).pfValue;\n  var labelStyleKey = fStyle + '$' + size + '$' + family + '$' + weight + '$' + transform + '$' + valign + '$' + halign + '$' + oWidth + '$' + wrap + '$' + wrapW;\n  _p.labelStyleKey = labelStyleKey;\n  _p.sourceLabelKey = labelStyleKey + '$' + srcContent;\n  _p.targetLabelKey = labelStyleKey + '$' + tgtContent;\n  _p.labelKey = labelStyleKey + '$' + content;\n  _p.fontKey = fStyle + '$' + weight + '$' + size + '$' + family;\n\n  _p.styleKey = Date.now();\n};\n\n// apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\nstyfn.applyParsedProperty = function( ele, parsedProp ){\n  var self = this;\n  var prop = parsedProp;\n  var style = ele._private.style;\n  var fieldVal, flatProp;\n  var types = self.types;\n  var type = self.properties[ prop.name ].type;\n  var propIsBypass = prop.bypass;\n  var origProp = style[ prop.name ];\n  var origPropIsBypass = origProp && origProp.bypass;\n  var _p = ele._private;\n\n  // can't apply auto to width or height unless it's a parent node\n  if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){\n    if( parsedProp.value === 'auto' && !ele.isParent() ){\n      return false;\n    } else if( parsedProp.value !== 'auto' && ele.isParent() ){\n      prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );\n    }\n  }\n\n  // edges connected to compound nodes can not be haystacks\n  if(\n    parsedProp.name === 'curve-style'\n    && parsedProp.value === 'haystack'\n    && ele.isEdge()\n    && ( ele.isLoop() || ele.source().isParent() || ele.target().isParent() )\n  ){\n    prop = parsedProp = this.parse( parsedProp.name, 'bezier', propIsBypass );\n  }\n\n  if( prop.delete ){ // delete the property and use the default value on falsey value\n    style[ prop.name ] = undefined;\n\n    return true;\n  }\n\n  if( prop.deleteBypassed ){ // delete the property that the\n    if( !origProp ){\n      return true; // can't delete if no prop\n\n    } else if( origProp.bypass ){ // delete bypassed\n      origProp.bypassed = undefined;\n      return true;\n\n    } else {\n      return false; // we're unsuccessful deleting the bypassed\n    }\n  }\n\n  // check if we need to delete the current bypass\n  if( prop.deleteBypass ){ // then this property is just here to indicate we need to delete\n    if( !origProp ){\n      return true; // property is already not defined\n\n    } else if( origProp.bypass ){ // then replace the bypass property with the original\n      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n      style[ prop.name ] = origProp.bypassed;\n      return true;\n\n    } else {\n      return false; // we're unsuccessful deleting the bypass\n    }\n  }\n\n  var printMappingErr = function(){\n    util.error( 'Do not assign mappings to elements without corresponding data (e.g. ele `' + ele.id() + '` for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined' );\n  };\n\n  // put the property in the style objects\n  switch( prop.mapped ){ // flatten the property if mapped\n  case types.mapData:\n  case types.mapLayoutData:\n  case types.mapScratch:\n\n    var isLayout = prop.mapped === types.mapLayoutData;\n    var isScratch = prop.mapped === types.mapScratch;\n\n    // flatten the field (e.g. data.foo.bar)\n    var fields = prop.field.split( '.' );\n    var fieldVal;\n\n    if( isScratch || isLayout ){\n      fieldVal = _p.scratch;\n    } else {\n      fieldVal = _p.data;\n    }\n\n    for( var i = 0; i < fields.length && fieldVal; i++ ){\n      var field = fields[ i ];\n      fieldVal = fieldVal[ field ];\n    }\n\n    var percent;\n    if( !is.number( fieldVal ) ){ // then keep the mapping but assume 0% for now\n      percent = 0;\n    } else {\n      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);\n    }\n\n    // make sure to bound percent value\n    if( percent < 0 ){\n      percent = 0;\n    } else if( percent > 1 ){\n      percent = 1;\n    }\n\n    if( type.color ){\n      var r1 = prop.valueMin[0];\n      var r2 = prop.valueMax[0];\n      var g1 = prop.valueMin[1];\n      var g2 = prop.valueMax[1];\n      var b1 = prop.valueMin[2];\n      var b2 = prop.valueMax[2];\n      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n\n      var clr = [\n        Math.round( r1 + (r2 - r1) * percent ),\n        Math.round( g1 + (g2 - g1) * percent ),\n        Math.round( b1 + (b2 - b1) * percent ),\n        Math.round( a1 + (a2 - a1) * percent )\n      ];\n\n      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing\n        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass\n        name: prop.name,\n        value: clr,\n        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n      };\n\n    } else if( type.number ){\n      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n      flatProp = this.parse( prop.name, calcValue, prop.bypass, true );\n\n    } else {\n      return false; // can only map to colours and numbers\n    }\n\n    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );\n    }\n\n    if( !flatProp ){ printMappingErr(); }\n    flatProp.mapping = prop; // keep a reference to the mapping\n    prop = flatProp; // the flattened (mapped) property is the one we want\n\n    break;\n\n  // direct mapping\n  case types.data:\n  case types.layoutData:\n  case types.scratch:\n    var isLayout = prop.mapped === types.layoutData;\n    var isScratch = prop.mapped === types.scratch;\n\n    // flatten the field (e.g. data.foo.bar)\n    var fields = prop.field.split( '.' );\n    var fieldVal;\n\n    if( isScratch || isLayout ){\n      fieldVal = _p.scratch;\n    } else {\n      fieldVal = _p.data;\n    }\n\n    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){\n      var field = fields[ i ];\n      fieldVal = fieldVal[ field ];\n    } }\n\n    flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );\n\n    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n      var flatPropVal = origProp ? origProp.strValue : '';\n\n      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );\n    }\n\n    if( !flatProp ){ printMappingErr(); }\n    flatProp.mapping = prop; // keep a reference to the mapping\n    prop = flatProp; // the flattened (mapped) property is the one we want\n\n    break;\n\n  case types.fn:\n    var fn = prop.value;\n    var fnRetVal = fn( ele );\n\n    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );\n    flatProp.mapping = prop; // keep a reference to the mapping\n    prop = flatProp; // the flattened (mapped) property is the one we want\n\n    break;\n\n  case undefined:\n    break; // just set the property\n\n  default:\n    return false; // not a valid mapping\n  }\n\n  // if the property is a bypass property, then link the resultant property to the original one\n  if( propIsBypass ){\n    if( origPropIsBypass ){ // then this bypass overrides the existing one\n      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n    } else { // then link the orig prop to the new bypass\n      prop.bypassed = origProp;\n    }\n\n    style[ prop.name ] = prop; // and set\n\n  } else { // prop is not bypass\n    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop\n      origProp.bypassed = prop;\n    } else { // then just replace the old prop with the new one\n      style[ prop.name ] = prop;\n    }\n  }\n\n  return true;\n};\n\nstyfn.cleanElements = function( eles, keepBypasses ){\n  var self = this;\n  var props = self.properties;\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[i];\n\n    if( !keepBypasses ){\n      ele._private.style = {};\n    } else {\n      var style = ele._private.style;\n\n      for( var j = 0; j < props.length; j++ ){\n        var prop = props[j];\n        var eleProp = style[ prop.name ];\n\n        if( eleProp ){\n          if( eleProp.bypass ){\n            eleProp.bypassed = null;\n          } else {\n            style[ prop.name ] = null;\n          }\n        }\n      }\n    }\n  }\n};\n\n// updates the visual style for all elements (useful for manual style modification after init)\nstyfn.update = function(){\n  var cy = this._private.cy;\n  var eles = cy.mutableElements();\n\n  eles.updateStyle();\n};\n\n// just update the functional properties (i.e. mappings) in the elements'\n// styles (less expensive than recalculation)\nstyfn.updateMappers = function( eles ){\n  var self = this;\n\n  for( var i = 0; i < eles.length; i++ ){ // for each ele\n    var ele = eles[ i ];\n    var style = ele._private.style;\n\n    for( var j = 0; j < self.properties.length; j++ ){ // for each prop\n      var prop = self.properties[ j ];\n      var propInStyle = style[ prop.name ];\n\n      if( propInStyle && propInStyle.mapping ){\n        var mapping = propInStyle.mapping;\n        this.applyParsedProperty( ele, mapping ); // reapply the mapping property\n      }\n    }\n\n    this.updateStyleHints( ele );\n  }\n};\n\n// diffProps : { name => { prev, next } }\nstyfn.updateTransitions = function( ele, diffProps, isBypass ){\n  var self = this;\n  var _p = ele._private;\n  var props = ele.pstyle( 'transition-property' ).value;\n  var duration = ele.pstyle( 'transition-duration' ).pfValue;\n  var delay = ele.pstyle( 'transition-delay' ).pfValue;\n\n  if( props.length > 0 && duration > 0 ){\n\n    var css = {};\n\n    // build up the style to animate towards\n    var anyPrev = false;\n    for( var i = 0; i < props.length; i++ ){\n      var prop = props[ i ];\n      var styProp = ele.pstyle( prop );\n      var diffProp = diffProps[ prop ];\n\n      if( !diffProp ){ continue; }\n\n      var prevProp = diffProp.prev;\n      var fromProp = prevProp;\n      var toProp = diffProp.next != null ? diffProp.next : styProp;\n      var diff = false;\n      var initVal;\n      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\n      if( !fromProp ){ continue; }\n\n      // consider px values\n      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){\n        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n        initVal = fromProp.pfValue + initDt * diff;\n\n      // consider numerical values\n      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){\n        diff = toProp.value - fromProp.value; // nonzero is truthy\n        initVal = fromProp.value + initDt * diff;\n\n      // consider colour values\n      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){\n        diff = fromProp.value[0] !== toProp.value[0]\n          || fromProp.value[1] !== toProp.value[1]\n          || fromProp.value[2] !== toProp.value[2]\n        ;\n\n        initVal = fromProp.strValue;\n      }\n\n      // the previous value is good for an animation only if it's different\n      if( diff ){\n        css[ prop ] = toProp.strValue; // to val\n        this.applyBypass( ele, prop, initVal ); // from val\n        anyPrev = true;\n      }\n\n    } // end if props allow ani\n\n    // can't transition if there's nothing previous to transition from\n    if( !anyPrev ){ return; }\n\n    _p.transitioning = true;\n\n    ele.stop();\n\n    if( delay > 0 ){\n      ele.delay( delay );\n    }\n\n    ele.animate( {\n      css: css\n    }, {\n      duration: duration,\n      easing: ele.pstyle( 'transition-timing-function' ).value,\n      queue: false,\n      complete: function(){\n        if( !isBypass ){\n          self.removeBypasses( ele, props );\n        }\n\n        _p.transitioning = false;\n      }\n    } );\n\n  } else if( _p.transitioning ){\n    ele.stop();\n\n    this.removeBypasses( ele, props );\n\n    _p.transitioning = false;\n  }\n};\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/apply.js\n ** module id = 87\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\nvar util = require( '../util' );\n\nvar styfn = {};\n\n// bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\nstyfn.applyBypass = function( eles, name, value, updateTransitions ){\n  var self = this;\n  var props = [];\n  var isBypass = true;\n\n  // put all the properties (can specify one or many) in an array after parsing them\n  if( name === '*' || name === '**' ){ // apply to all property names\n\n    if( value !== undefined ){\n      for( var i = 0; i < self.properties.length; i++ ){\n        var prop = self.properties[ i ];\n        var name = prop.name;\n\n        var parsedProp = this.parse( name, value, true );\n\n        if( parsedProp ){\n          props.push( parsedProp );\n        }\n      }\n    }\n\n  } else if( is.string( name ) ){ // then parse the single property\n    var parsedProp = this.parse( name, value, true );\n\n    if( parsedProp ){\n      props.push( parsedProp );\n    }\n  } else if( is.plainObject( name ) ){ // then parse each property\n    var specifiedProps = name;\n    updateTransitions = value;\n\n    for( var i = 0; i < self.properties.length; i++ ){\n      var prop = self.properties[ i ];\n      var name = prop.name;\n      var value = specifiedProps[ name ];\n\n      if( value === undefined ){ // try camel case name too\n        value = specifiedProps[ util.dash2camel( name ) ];\n      }\n\n      if( value !== undefined ){\n        var parsedProp = this.parse( name, value, true );\n\n        if( parsedProp ){\n          props.push( parsedProp );\n        }\n      }\n    }\n  } else { // can't do anything without well defined properties\n    return false;\n  }\n\n  // we've failed if there are no valid properties\n  if( props.length === 0 ){ return false; }\n\n  // now, apply the bypass properties on the elements\n  var ret = false; // return true if at least one succesful bypass applied\n  for( var i = 0; i < eles.length; i++ ){ // for each ele\n    var ele = eles[ i ];\n    var diffProps = {};\n    var diffProp;\n\n    for( var j = 0; j < props.length; j++ ){ // for each prop\n      var prop = props[ j ];\n\n      if( updateTransitions ){\n        var prevProp = ele.pstyle( prop.name );\n        diffProp = diffProps[ prop.name ] = { prev: prevProp };\n      }\n\n      ret = this.applyParsedProperty( ele, prop ) || ret;\n\n      if( updateTransitions ){\n        diffProp.next = ele.pstyle( prop.name );\n      }\n\n    } // for props\n\n    if( ret ){\n      this.updateStyleHints( ele );\n    }\n\n    if( updateTransitions ){\n      this.updateTransitions( ele, diffProps, isBypass );\n    }\n  } // for eles\n\n  return ret;\n};\n\n// only useful in specific cases like animation\nstyfn.overrideBypass = function( eles, name, value ){\n  name = util.camel2dash( name );\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[ i ];\n    var prop = ele._private.style[ name ];\n    var type = this.properties[ name ].type;\n    var isColor = type.color;\n    var isMulti = type.mutiple;\n\n    if( !prop || !prop.bypass ){ // need a bypass if one doesn't exist\n      this.applyBypass( ele, name, value );\n      continue;\n    }\n\n    prop.value = value;\n\n    if( prop.pfValue != null ){\n      prop.pfValue = value;\n    }\n\n    if( isColor ){\n      prop.strValue = 'rgb(' + value.join( ',' ) + ')';\n    } else if( isMulti ){\n      prop.strValue = value.join( ' ' );\n    } else {\n      prop.strValue = '' + value;\n    }\n  }\n};\n\nstyfn.removeAllBypasses = function( eles, updateTransitions ){\n  return this.removeBypasses( eles, this.propertyNames, updateTransitions );\n};\n\nstyfn.removeBypasses = function( eles, props, updateTransitions ){\n  var isBypass = true;\n\n  for( var j = 0; j < eles.length; j++ ){\n    var ele = eles[ j ];\n    var diffProps = {};\n\n    for( var i = 0; i < props.length; i++ ){\n      var name = props[ i ];\n      var prop = this.properties[ name ];\n      var prevProp = ele.pstyle( prop.name );\n\n      if( !prevProp || !prevProp.bypass ){\n        // if a bypass doesn't exist for the prop, nothing needs to be removed\n        continue;\n      }\n\n      var value = ''; // empty => remove bypass\n      var parsedProp = this.parse( name, value, true );\n      var diffProp = diffProps[ prop.name ] = { prev: prevProp };\n\n      this.applyParsedProperty( ele, parsedProp );\n\n      diffProp.next = ele.pstyle( prop.name );\n    } // for props\n\n    this.updateStyleHints( ele );\n\n    if( updateTransitions ){\n      this.updateTransitions( ele, diffProps, isBypass );\n    }\n  } // for eles\n};\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/bypass.js\n ** module id = 88\n ** module chunks = 0\n **/","'use strict';\n\nvar window = require( '../window' );\n\nvar styfn = {};\n\n// gets what an em size corresponds to in pixels relative to a dom element\nstyfn.getEmSizeInPixels = function(){\n  var px = this.containerCss( 'font-size' );\n\n  if( px != null ){\n    return parseFloat( px );\n  } else {\n    return 1; // for headless\n  }\n};\n\n// gets css property from the core container\nstyfn.containerCss = function( propName ){\n  var cy = this._private.cy;\n  var domElement = cy.container();\n\n  if( window && domElement && window.getComputedStyle ){\n    return window.getComputedStyle( domElement ).getPropertyValue( propName );\n  }\n};\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/container.js\n ** module id = 89\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar is = require( '../is' );\n\nvar styfn = {};\n\n// gets the rendered style for an element\nstyfn.getRenderedStyle = function( ele ){\n  return this.getRawStyle( ele, true );\n};\n\n// gets the raw style for an element\nstyfn.getRawStyle = function( ele, isRenderedVal ){\n  var self = this;\n  var ele = ele[0]; // insure it's an element\n\n  if( ele ){\n    var rstyle = {};\n\n    for( var i = 0; i < self.properties.length; i++ ){\n      var prop = self.properties[ i ];\n      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );\n\n      if( val ){\n        rstyle[ prop.name ] = val;\n        rstyle[ util.dash2camel( prop.name ) ] = val;\n      }\n    }\n\n    return rstyle;\n  }\n};\n\nstyfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){\n  var self = this;\n  var ele = ele[0]; // insure it's an element\n\n  if( ele ){\n    var prop = self.properties[ propName ];\n    var type = prop.type;\n    var styleProp = ele.pstyle( prop.name );\n    var zoom = ele.cy().zoom();\n\n    if( styleProp ){\n      var units = styleProp.units ? type.implicitUnits || 'px' : null;\n      var val = units ? [].concat( styleProp.pfValue ).map( function( pfValue ){\n        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;\n      } ).join( ' ' ) : styleProp.strValue;\n\n      return val;\n    }\n  }\n};\n\nstyfn.getAnimationStartStyle = function( ele, aniProps ){\n  var rstyle = {};\n\n  for( var i = 0; i < aniProps.length; i++ ){\n    var aniProp = aniProps[ i ];\n    var name = aniProp.name;\n\n    var styleProp = ele.pstyle( name );\n\n    if( styleProp !== undefined ){ // then make a prop of it\n      if( is.plainObject( styleProp ) ){\n        styleProp = this.parse( name, styleProp.strValue );\n      } else {\n        styleProp = this.parse( name, styleProp );\n      }\n    }\n\n    if( styleProp ){\n      rstyle[ name ] = styleProp;\n    }\n  }\n\n  return rstyle;\n};\n\nstyfn.getPropsList = function( propsObj ){\n  var self = this;\n  var rstyle = [];\n  var style = propsObj;\n  var props = self.properties;\n\n  if( style ){\n    var names = Object.keys( style );\n\n    for( var i = 0; i < names.length; i++ ){\n      var name = names[i];\n      var val = style[ name ];\n      var prop = props[ name ] || props[ util.camel2dash( name ) ];\n      var styleProp = this.parse( prop.name, val );\n\n      rstyle.push( styleProp );\n    }\n  }\n\n  return rstyle;\n};\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/get-for-ele.js\n ** module id = 90\n ** module chunks = 0\n **/","'use strict';\n\nvar styfn = {};\n\nstyfn.applyFromJson = function( json ){\n  var style = this;\n\n  for( var i = 0; i < json.length; i++ ){\n    var context = json[ i ];\n    var selector = context.selector;\n    var props = context.style || context.css;\n    var names = Object.keys( props );\n\n    style.selector( selector ); // apply selector\n\n    for( var j = 0; j < names.length; j++ ){\n      var name = names[j];\n      var value = props[ name ];\n\n      style.css( name, value ); // apply property\n    }\n  }\n\n  return style;\n};\n\n// accessible cy.style() function\nstyfn.fromJson = function( json ){\n  var style = this;\n\n  style.resetToDefault();\n  style.applyFromJson( json );\n\n  return style;\n};\n\n// get json from cy.style() api\nstyfn.json = function(){\n  var json = [];\n\n  for( var i = this.defaultLength; i < this.length; i++ ){\n    var cxt = this[ i ];\n    var selector = cxt.selector;\n    var props = cxt.properties;\n    var css = {};\n\n    for( var j = 0; j < props.length; j++ ){\n      var prop = props[ j ];\n      css[ prop.name ] = prop.strValue;\n    }\n\n    json.push( {\n      selector: !selector ? 'core' : selector.toString(),\n      style: css\n    } );\n  }\n\n  return json;\n};\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/json.js\n ** module id = 91\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar Selector = require( '../selector' );\n\nvar styfn = {};\n\nstyfn.applyFromString = function( string ){\n  var self = this;\n  var style = this;\n  var remaining = '' + string;\n  var selAndBlockStr;\n  var blockRem;\n  var propAndValStr;\n\n  // remove comments from the style string\n  remaining = remaining.replace( /[/][*](\\s|.)+?[*][/]/g, '' );\n\n  function removeSelAndBlockFromRemaining(){\n    // remove the parsed selector and block from the remaining text to parse\n    if( remaining.length > selAndBlockStr.length ){\n      remaining = remaining.substr( selAndBlockStr.length );\n    } else {\n      remaining = '';\n    }\n  }\n\n  function removePropAndValFromRem(){\n    // remove the parsed property and value from the remaining block text to parse\n    if( blockRem.length > propAndValStr.length ){\n      blockRem = blockRem.substr( propAndValStr.length );\n    } else {\n      blockRem = '';\n    }\n  }\n\n  while( true ){\n    var nothingLeftToParse = remaining.match( /^\\s*$/ );\n    if( nothingLeftToParse ){ break; }\n\n    var selAndBlock = remaining.match( /^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/ );\n\n    if( !selAndBlock ){\n      util.error( 'Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining );\n      break;\n    }\n\n    selAndBlockStr = selAndBlock[0];\n\n    // parse the selector\n    var selectorStr = selAndBlock[1];\n    if( selectorStr !== 'core' ){\n      var selector = new Selector( selectorStr );\n      if( selector._private.invalid ){\n        util.error( 'Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr );\n\n        // skip this selector and block\n        removeSelAndBlockFromRemaining();\n        continue;\n      }\n    }\n\n    // parse the block of properties and values\n    var blockStr = selAndBlock[2];\n    var invalidBlock = false;\n    blockRem = blockStr;\n    var props = [];\n\n    while( true ){\n      var nothingLeftToParse = blockRem.match( /^\\s*$/ );\n      if( nothingLeftToParse ){ break; }\n\n      var propAndVal = blockRem.match( /^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/ );\n\n      if( !propAndVal ){\n        util.error( 'Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr );\n        invalidBlock = true;\n        break;\n      }\n\n      propAndValStr = propAndVal[0];\n      var propStr = propAndVal[1];\n      var valStr = propAndVal[2];\n\n      var prop = self.properties[ propStr ];\n      if( !prop ){\n        util.error( 'Skipping property: Invalid property name in: ' + propAndValStr );\n\n        // skip this property in the block\n        removePropAndValFromRem();\n        continue;\n      }\n\n      var parsedProp = style.parse( propStr, valStr );\n\n      if( !parsedProp ){\n        util.error( 'Skipping property: Invalid property definition in: ' + propAndValStr );\n\n        // skip this property in the block\n        removePropAndValFromRem();\n        continue;\n      }\n\n      props.push( {\n        name: propStr,\n        val: valStr\n      } );\n      removePropAndValFromRem();\n    }\n\n    if( invalidBlock ){\n      removeSelAndBlockFromRemaining();\n      break;\n    }\n\n    // put the parsed block in the style\n    style.selector( selectorStr );\n    for( var i = 0; i < props.length; i++ ){\n      var prop = props[ i ];\n      style.css( prop.name, prop.val );\n    }\n\n    removeSelAndBlockFromRemaining();\n  }\n\n  return style;\n};\n\nstyfn.fromString = function( string ){\n  var style = this;\n\n  style.resetToDefault();\n  style.applyFromString( string );\n\n  return style;\n};\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/string-sheet.js\n ** module id = 92\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\n\nvar styfn = {};\n\n(function(){\n  var number = util.regex.number;\n  var rgba = util.regex.rgbaNoBackRefs;\n  var hsla = util.regex.hslaNoBackRefs;\n  var hex3 = util.regex.hex3;\n  var hex6 = util.regex.hex6;\n  var data = function( prefix ){ return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$'; };\n  var mapData = function( prefix ){\n    var mapArg = number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;\n    return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n  };\n\n  // each visual style property has a type and needs to be validated according to it\n  styfn.types = {\n    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },\n    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },\n    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },\n    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },\n    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },\n    position: { enums: [ 'parent', 'origin' ] },\n    nodeSize: { number: true, min: 0, enums: [ 'auto', 'label' ] },\n    number: { number: true, unitless: true },\n    numbers: { number: true, unitless: true, multiple: true },\n    size: { number: true, min: 0 },\n    bidirectionalSize: { number: true }, // allows negative\n    bidirectionalSizes: { number: true, multiple: true }, // allows negative\n    bgSize: { number: true, min: 0, allowPercent: true },\n    bgWH: { number: true, min: 0, allowPercent: true, enums: [ 'auto' ] },\n    bgPos: { number: true, allowPercent: true },\n    bgRepeat: { enums: [ 'repeat', 'repeat-x', 'repeat-y', 'no-repeat' ] },\n    bgFit: { enums: [ 'none', 'contain', 'cover' ] },\n    bgClip: { enums: [ 'none', 'node' ] },\n    color: { color: true },\n    bool: { enums: [ 'yes', 'no' ] },\n    lineStyle: { enums: [ 'solid', 'dotted', 'dashed' ] },\n    borderStyle: { enums: [ 'solid', 'dotted', 'dashed', 'double' ] },\n    curveStyle: { enums: [ 'bezier', 'unbundled-bezier', 'haystack', 'segments' ] },\n    fontFamily: { regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$' },\n    fontVariant: { enums: [ 'small-caps', 'normal' ] },\n    fontStyle: { enums: [ 'italic', 'normal', 'oblique' ] },\n    fontWeight: { enums: [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900 ] },\n    textDecoration: { enums: [ 'none', 'underline', 'overline', 'line-through' ] },\n    textTransform: { enums: [ 'none', 'uppercase', 'lowercase' ] },\n    textWrap: { enums: [ 'none', 'wrap' ] },\n    textBackgroundShape: { enums: [ 'rectangle', 'roundrectangle' ]},\n    nodeShape: { enums: [ 'rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon' ] },\n    compoundIncludeLabels: { enums: [ 'include', 'exclude' ] },\n    arrowShape: { enums: [ 'tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none' ] },\n    arrowFill: { enums: [ 'filled', 'hollow' ] },\n    display: { enums: [ 'element', 'none' ] },\n    visibility: { enums: [ 'hidden', 'visible' ] },\n    valign: { enums: [ 'top', 'center', 'bottom' ] },\n    halign: { enums: [ 'left', 'center', 'right' ] },\n    text: { string: true },\n    data: { mapping: true, regex: data( 'data' ) },\n    layoutData: { mapping: true, regex: data( 'layoutData' ) },\n    scratch: { mapping: true, regex: data( 'scratch' ) },\n    mapData: { mapping: true, regex: mapData( 'mapData' ) },\n    mapLayoutData: { mapping: true, regex: mapData( 'mapLayoutData' ) },\n    mapScratch: { mapping: true, regex: mapData( 'mapScratch' ) },\n    fn: { mapping: true, fn: true },\n    url: { regex: '^url\\\\s*\\\\(\\\\s*([^\\\\s]+)\\\\s*\\\\s*\\\\)|none|(.+)$' },\n    propList: { propList: true },\n    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },\n    textRotation: { number: true, units: 'deg|rad', implicitUnits: 'rad', enums: [ 'none', 'autorotate' ] },\n    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },\n    edgeDistances: { enums: ['intersection', 'node-position'] },\n    easing: {\n      regexes: [\n        '^(spring)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$',\n        '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + ')\\\\s*\\\\)$'\n      ],\n      enums: [\n        'linear',\n        'ease', 'ease-in', 'ease-out', 'ease-in-out',\n        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',\n        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',\n        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',\n        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',\n        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',\n        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',\n        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'\n      ]\n    }\n  };\n\n  // define visual style properties\n  var t = styfn.types;\n  var props = styfn.properties = [\n    // main label\n    { name: 'label', type: t.text },\n    { name: 'text-rotation', type: t.textRotation },\n    { name: 'text-margin-x', type: t.bidirectionalSize },\n    { name: 'text-margin-y', type: t.bidirectionalSize },\n\n    // source label\n    { name: 'source-label', type: t.text },\n    { name: 'source-text-rotation', type: t.textRotation },\n    { name: 'source-text-margin-x', type: t.bidirectionalSize },\n    { name: 'source-text-margin-y', type: t.bidirectionalSize },\n    { name: 'source-text-offset', type: t.size },\n\n    // target label\n    { name: 'target-label', type: t.text },\n    { name: 'target-text-rotation', type: t.textRotation },\n    { name: 'target-text-margin-x', type: t.bidirectionalSize },\n    { name: 'target-text-margin-y', type: t.bidirectionalSize },\n    { name: 'target-text-offset', type: t.size },\n\n    // common label style\n    { name: 'text-valign', type: t.valign },\n    { name: 'text-halign', type: t.halign },\n    { name: 'color', type: t.color },\n    { name: 'text-outline-color', type: t.color },\n    { name: 'text-outline-width', type: t.size },\n    { name: 'text-outline-opacity', type: t.zeroOneNumber },\n    { name: 'text-opacity', type: t.zeroOneNumber },\n    { name: 'text-background-color', type: t.color },\n    { name: 'text-background-margin', type: t.size },\n    { name: 'text-background-opacity', type: t.zeroOneNumber },\n    { name: 'text-border-opacity', type: t.zeroOneNumber },\n    { name: 'text-border-color', type: t.color },\n    { name: 'text-border-width', type: t.size },\n    { name: 'text-border-style', type: t.borderStyle },\n    { name: 'text-background-shape', type: t.textBackgroundShape},\n    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas\n    { name: 'text-transform', type: t.textTransform },\n    { name: 'text-wrap', type: t.textWrap },\n    { name: 'text-max-width', type: t.size },\n    { name: 'text-events', type: t.bool },\n    { name: 'font-family', type: t.fontFamily },\n    { name: 'font-style', type: t.fontStyle },\n    // { name: 'font-variant', type: t.fontVariant }, // not useful\n    { name: 'font-weight', type: t.fontWeight },\n    { name: 'font-size', type: t.size },\n    { name: 'min-zoomed-font-size', type: t.size },\n\n    // behaviour\n    { name: 'events', type: t.bool },\n\n    // visibility\n    { name: 'display', type: t.display },\n    { name: 'visibility', type: t.visibility },\n    { name: 'opacity', type: t.zeroOneNumber },\n    { name: 'z-index', type: t.nonNegativeInt },\n\n    // overlays\n    { name: 'overlay-padding', type: t.size },\n    { name: 'overlay-color', type: t.color },\n    { name: 'overlay-opacity', type: t.zeroOneNumber },\n\n    // shadows\n    { name: 'shadow-blur', type: t.size },\n    { name: 'shadow-color', type: t.color },\n    { name: 'shadow-opacity', type: t.zeroOneNumber },\n    { name: 'shadow-offset-x', type: t.bidirectionalSize },\n    { name: 'shadow-offset-y', type: t.bidirectionalSize },\n\n    // label shadows\n    { name: 'text-shadow-blur', type: t.size },\n    { name: 'text-shadow-color', type: t.color },\n    { name: 'text-shadow-opacity', type: t.zeroOneNumber },\n    { name: 'text-shadow-offset-x', type: t.bidirectionalSize },\n    { name: 'text-shadow-offset-y', type: t.bidirectionalSize },\n\n    // transition anis\n    { name: 'transition-property', type: t.propList },\n    { name: 'transition-duration', type: t.time },\n    { name: 'transition-delay', type: t.time },\n    { name: 'transition-timing-function', type: t.easing },\n\n    // node body\n    { name: 'height', type: t.nodeSize },\n    { name: 'width', type: t.nodeSize },\n    { name: 'shape', type: t.nodeShape },\n    { name: 'shape-polygon-points', type: t.polygonPointList },\n    { name: 'background-color', type: t.color },\n    { name: 'background-opacity', type: t.zeroOneNumber },\n    { name: 'background-blacken', type: t.nOneOneNumber },\n    { name: 'padding-left', type: t.size },\n    { name: 'padding-right', type: t.size },\n    { name: 'padding-top', type: t.size },\n    { name: 'padding-bottom', type: t.size },\n\n    // node border\n    { name: 'border-color', type: t.color },\n    { name: 'border-opacity', type: t.zeroOneNumber },\n    { name: 'border-width', type: t.size },\n    { name: 'border-style', type: t.borderStyle },\n\n    // node background images\n    { name: 'background-image', type: t.url },\n    { name: 'background-image-opacity', type: t.zeroOneNumber },\n    { name: 'background-position-x', type: t.bgPos },\n    { name: 'background-position-y', type: t.bgPos },\n    { name: 'background-repeat', type: t.bgRepeat },\n    { name: 'background-fit', type: t.bgFit },\n    { name: 'background-clip', type: t.bgClip },\n    { name: 'background-width', type: t.bgWH },\n    { name: 'background-height', type: t.bgWH },\n\n    // compound props\n    { name: 'position', type: t.position },\n    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },\n\n    // edge line\n    { name: 'line-style', type: t.lineStyle },\n    { name: 'line-color', type: t.color },\n    { name: 'curve-style', type: t.curveStyle },\n    { name: 'haystack-radius', type: t.zeroOneNumber },\n    { name: 'control-point-step-size', type: t.size },\n    { name: 'control-point-distances', type: t.bidirectionalSizes },\n    { name: 'control-point-weights', type: t.numbers },\n    { name: 'segment-distances', type: t.bidirectionalSizes },\n    { name: 'segment-weights', type: t.numbers },\n    { name: 'edge-distances', type: t.edgeDistances },\n\n    // these are just for the core\n    { name: 'selection-box-color', type: t.color },\n    { name: 'selection-box-opacity', type: t.zeroOneNumber },\n    { name: 'selection-box-border-color', type: t.color },\n    { name: 'selection-box-border-width', type: t.size },\n    { name: 'active-bg-color', type: t.color },\n    { name: 'active-bg-opacity', type: t.zeroOneNumber },\n    { name: 'active-bg-size', type: t.size },\n    { name: 'outside-texture-bg-color', type: t.color },\n    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }\n  ];\n\n  // define aliases\n  var aliases = styfn.aliases = [\n    { name: 'content', pointsTo: 'label' },\n    { name: 'control-point-distance', pointsTo: 'control-point-distances' },\n    { name: 'control-point-weight', pointsTo: 'control-point-weights' },\n    { name: 'edge-text-rotation', pointsTo: 'text-rotation' }\n  ];\n\n  // pie backgrounds for nodes\n  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n  props.push( { name: 'pie-size', type: t.bgSize } );\n  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){\n    props.push( { name: 'pie-' + i + '-background-color', type: t.color } );\n    props.push( { name: 'pie-' + i + '-background-size', type: t.percent } );\n    props.push( { name: 'pie-' + i + '-background-opacity', type: t.zeroOneNumber } );\n  }\n\n  // edge arrows\n  var arrowPrefixes = styfn.arrowPrefixes = [ 'source', 'mid-source', 'target', 'mid-target' ];\n  [\n    { name: 'arrow-shape', type: t.arrowShape },\n    { name: 'arrow-color', type: t.color },\n    { name: 'arrow-fill', type: t.arrowFill }\n  ].forEach( function( prop ){\n    arrowPrefixes.forEach( function( prefix ){\n      var name = prefix + '-' + prop.name;\n      var type = prop.type;\n\n      props.push( { name: name, type: type } );\n    } );\n  }, {} );\n\n  // list of property names\n  styfn.propertyNames = props.map( function( p ){ return p.name; } );\n\n  // allow access of properties by name ( e.g. style.properties.height )\n  for( var i = 0; i < props.length; i++ ){\n    var prop = props[ i ];\n\n    props[ prop.name ] = prop; // allow lookup by name\n  }\n\n  // map aliases\n  for( var i = 0; i < aliases.length; i++ ){\n    var alias = aliases[ i ];\n    var pointsToProp = props[ alias.pointsTo ];\n    var aliasProp = {\n      name: alias.name,\n      alias: true,\n      pointsTo: pointsToProp\n    };\n\n    // add alias prop for parsing\n    props.push( aliasProp );\n\n    props[ alias.name ] = aliasProp; // allow lookup by name\n  }\n})();\n\nstyfn.getDefaultProperty = function( name ){\n  return this.getDefaultProperties()[ name ];\n};\n\nstyfn.getDefaultProperties = util.memoize( function(){\n  var rawProps = util.extend( {\n    'events': 'yes',\n    'text-events': 'no',\n    'text-valign': 'top',\n    'text-halign': 'center',\n    'color': '#000',\n    'text-outline-color': '#000',\n    'text-outline-width': 0,\n    'text-outline-opacity': 1,\n    'text-opacity': 1,\n    'text-decoration': 'none',\n    'text-transform': 'none',\n    'text-wrap': 'none',\n    'text-max-width': 9999,\n    'text-background-color': '#000',\n    'text-background-opacity': 0,\n    'text-background-margin': 0,\n    'text-border-opacity': 0,\n    'text-border-width': 0,\n    'text-border-style': 'solid',\n    'text-border-color': '#000',\n    'text-background-shape': 'rectangle',\n    'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n    'font-style': 'normal',\n    // 'font-variant': fontVariant,\n    'font-weight': 'normal',\n    'font-size': 16,\n    'min-zoomed-font-size': 0,\n    'text-rotation': 'none',\n    'source-text-rotation': 'none',\n    'target-text-rotation': 'none',\n    'visibility': 'visible',\n    'display': 'element',\n    'opacity': 1,\n    'z-index': 0,\n    'label': '',\n    'text-margin-x': 0,\n    'text-margin-y': 0,\n    'source-label': '',\n    'source-text-offset': 0,\n    'source-text-margin-x': 0,\n    'source-text-margin-y': 0,\n    'target-label': '',\n    'target-text-offset': 0,\n    'target-text-margin-x': 0,\n    'target-text-margin-y': 0,\n    'overlay-opacity': 0,\n    'overlay-color': '#000',\n    'overlay-padding': 10,\n    'shadow-opacity': 0,\n    'shadow-color': '#000',\n    'shadow-blur': 10,\n    'shadow-offset-x': 0,\n    'shadow-offset-y': 0,\n    'text-shadow-opacity': 0,\n    'text-shadow-color': '#000',\n    'text-shadow-blur': 5,\n    'text-shadow-offset-x': 0,\n    'text-shadow-offset-y': 0,\n    'transition-property': 'none',\n    'transition-duration': 0,\n    'transition-delay': 0,\n    'transition-timing-function': 'linear',\n\n    // node props\n    'background-blacken': 0,\n    'background-color': '#999',\n    'background-opacity': 1,\n    'background-image': 'none',\n    'background-image-opacity': 1,\n    'background-position-x': '50%',\n    'background-position-y': '50%',\n    'background-repeat': 'no-repeat',\n    'background-fit': 'none',\n    'background-clip': 'node',\n    'background-width': 'auto',\n    'background-height': 'auto',\n    'border-color': '#000',\n    'border-opacity': 1,\n    'border-width': 0,\n    'border-style': 'solid',\n    'height': 30,\n    'width': 30,\n    'shape': 'ellipse',\n    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n\n    // compound props\n    'padding-top': 0,\n    'padding-bottom': 0,\n    'padding-left': 0,\n    'padding-right': 0,\n    'position': 'origin',\n    'compound-sizing-wrt-labels': 'include'\n  }, {\n    // node pie bg\n    'pie-size': '100%'\n  }, [\n    { name: 'pie-{{i}}-background-color', value: 'black' },\n    { name: 'pie-{{i}}-background-size', value: '0%' },\n    { name: 'pie-{{i}}-background-opacity', value: 1 }\n  ].reduce( function( css, prop ){\n    for( var i = 1; i <= styfn.pieBackgroundN; i++ ){\n      var name = prop.name.replace( '{{i}}', i );\n      var val = prop.value;\n\n      css[ name ] = val;\n    }\n\n    return css;\n  }, {} ), {\n    // edge props\n    'line-style': 'solid',\n    'line-color': '#999',\n    'control-point-step-size': 40,\n    'control-point-weights': 0.5,\n    'segment-weights': 0.5,\n    'segment-distances': 20,\n    'edge-distances': 'intersection',\n    'curve-style': 'bezier',\n    'haystack-radius': 0\n  }, [\n    { name: 'arrow-shape', value: 'none' },\n    { name: 'arrow-color', value: '#999' },\n    { name: 'arrow-fill', value: 'filled' }\n  ].reduce( function( css, prop ){\n    styfn.arrowPrefixes.forEach( function( prefix ){\n      var name = prefix + '-' + prop.name;\n      var val = prop.value;\n\n      css[ name ] = val;\n    } );\n\n    return css;\n  }, {} ) );\n\n  var parsedProps = {};\n\n  for( var i = 0; i < this.properties.length; i++ ){\n    var prop = this.properties[i];\n\n    if( prop.pointsTo ){ continue; }\n\n    var name = prop.name;\n    var val = rawProps[ name ];\n    var parsedProp = this.parse( name, val );\n\n    parsedProps[ name ] = parsedProp;\n  }\n\n  return parsedProps;\n} );\n\nstyfn.addDefaultStylesheet = function(){\n  this\n    .selector( '$node > node' ) // compound (parent) node properties\n      .css( {\n        'width': 'auto',\n        'height': 'auto',\n        'shape': 'rectangle',\n        'padding-top': 10,\n        'padding-right': 10,\n        'padding-left': 10,\n        'padding-bottom': 10,\n        'background-color': '#eee',\n        'border-color': '#ccc',\n        'border-width': 1\n      } )\n    .selector( 'edge' ) // just edge properties\n      .css( {\n        'width': 3,\n        'curve-style': 'haystack'\n      } )\n    .selector( ':selected' )\n      .css( {\n        'background-color': '#0169D9',\n        'line-color': '#0169D9',\n        'source-arrow-color': '#0169D9',\n        'target-arrow-color': '#0169D9',\n        'mid-source-arrow-color': '#0169D9',\n        'mid-target-arrow-color': '#0169D9'\n      } )\n    .selector( 'node:parent:selected' )\n      .css( {\n        'background-color': '#CCE1F9',\n        'border-color': '#aec8e5'\n      } )\n    .selector( ':active' )\n      .css( {\n        'overlay-color': 'black',\n        'overlay-padding': 10,\n        'overlay-opacity': 0.25\n      } )\n    .selector( 'core' ) // just core properties\n      .css( {\n        'selection-box-color': '#ddd',\n        'selection-box-opacity': 0.65,\n        'selection-box-border-color': '#aaa',\n        'selection-box-border-width': 1,\n        'active-bg-color': 'black',\n        'active-bg-opacity': 0.15,\n        'active-bg-size': 30,\n        'outside-texture-bg-color': '#000',\n        'outside-texture-bg-opacity': 0.125\n      } )\n  ;\n\n  this.defaultLength = this.length;\n};\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/properties.js\n ** module id = 93\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../util' );\nvar is = require( '../is' );\nvar math = require( '../math' );\n\nvar styfn = {};\n\n// a caching layer for property parsing\nstyfn.parse = function( name, value, propIsBypass, propIsFlat ){\n  var self = this;\n\n  // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n  if( is.fn( value ) ){\n    return self.parseImpl( name, value, propIsBypass, propIsFlat );\n  }\n\n  var argHash = [ name, value, propIsBypass, propIsFlat ].join( '$' );\n  var propCache = self.propCache = self.propCache || {};\n  var ret;\n\n  if( !(ret = propCache[ argHash ]) ){\n    ret = propCache[ argHash ] = self.parseImpl( name, value, propIsBypass, propIsFlat );\n  }\n\n  // always need a copy since props are mutated later in their lifecycles\n  ret = util.copy( ret );\n\n  if( ret ){\n    ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour\n  }\n\n  return ret;\n};\n\n// parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\nvar parseImpl = function( name, value, propIsBypass, propIsFlat ){\n  var self = this;\n\n  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\n  var property = self.properties[ name ];\n  var passedValue = value;\n  var types = self.types;\n\n  if( !property ){ return null; } // return null on property of unknown name\n  if( value === undefined || value === null ){ return null; } // can't assign null\n\n  // the property may be an alias\n  if( property.alias ){\n    property = property.pointsTo;\n    name = property.name;\n  }\n\n  var valueIsString = is.string( value );\n  if( valueIsString ){ // trim the value to make parsing easier\n    value = value.trim();\n  }\n\n  var type = property.type;\n  if( !type ){ return null; } // no type, no luck\n\n  // check if bypass is null or empty string (i.e. indication to delete bypass property)\n  if( propIsBypass && (value === '' || value === null) ){\n    return {\n      name: name,\n      value: value,\n      bypass: true,\n      deleteBypass: true\n    };\n  }\n\n  // check if value is a function used as a mapper\n  if( is.fn( value ) ){\n    return {\n      name: name,\n      value: value,\n      strValue: 'fn',\n      mapped: types.fn,\n      bypass: propIsBypass\n    };\n  }\n\n  // check if value is mapped\n  var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;\n  if( !valueIsString || propIsFlat ){\n    // then don't bother to do the expensive regex checks\n\n  } else if(\n    ( data = new RegExp( types.data.regex ).exec( value ) ) ||\n    ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||\n    ( scratch = new RegExp( types.scratch.regex ).exec( value ) )\n  ){\n    if( propIsBypass ){ return false; } // mappers not allowed in bypass\n\n    var mapped;\n    if( data ){\n      mapped = types.data;\n    } else if( layoutData ){\n      mapped = types.layoutData;\n    } else {\n      mapped = types.scratch;\n    }\n\n    data = data || layoutData || scratch;\n\n    return {\n      name: name,\n      value: data,\n      strValue: '' + value,\n      mapped: mapped,\n      field: data[1],\n      bypass: propIsBypass\n    };\n\n  } else if(\n    ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||\n    ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||\n    ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )\n  ){\n    if( propIsBypass ){ return false; } // mappers not allowed in bypass\n    if( type.multiple ){ return false; } // impossible to map to num\n\n    var mapped;\n    if( mapData ){\n      mapped = types.mapData;\n    } else if( mapLayoutData ){\n      mapped = types.mapLayoutData;\n    } else {\n      mapped = types.mapScratch;\n    }\n\n    mapData = mapData || mapLayoutData || mapScratch;\n\n    // we can map only if the type is a colour or a number\n    if( !(type.color || type.number) ){ return false; }\n\n    var valueMin = this.parse( name, mapData[4] ); // parse to validate\n    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped\n\n    var valueMax = this.parse( name, mapData[5] ); // parse to validate\n    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped\n\n    // check if valueMin and valueMax are the same\n    if( valueMin.value === valueMax.value ){\n      return false; // can't make much of a mapper without a range\n\n    } else if( type.color ){\n      var c1 = valueMin.value;\n      var c2 = valueMax.value;\n\n      var same = c1[0] === c2[0] // red\n        && c1[1] === c2[1] // green\n        && c1[2] === c2[2] // blue\n        && ( // optional alpha\n          c1[3] === c2[3] // same alpha outright\n          || (\n            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?\n            &&\n            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n          )\n        )\n      ;\n\n      if( same ){ return false; } // can't make a mapper without a range\n    }\n\n    return {\n      name: name,\n      value: mapData,\n      strValue: '' + value,\n      mapped: mapped,\n      field: mapData[1],\n      fieldMin: parseFloat( mapData[2] ), // min & max are numeric\n      fieldMax: parseFloat( mapData[3] ),\n      valueMin: valueMin.value,\n      valueMax: valueMax.value,\n      bypass: propIsBypass\n    };\n  }\n\n  if( type.multiple && propIsFlat !== 'multiple' ){\n    var vals;\n\n    if( valueIsString ){\n      vals = value.split( /\\s+/ );\n    } else if( is.array( value ) ){\n      vals = value;\n    } else {\n      vals = [ value ];\n    }\n\n    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }\n\n    var valArr = vals.map( function( v ){\n      var p = self.parse( name, v, propIsBypass, 'multiple' );\n\n      if( p.pfValue != null ){\n        return p.pfValue;\n      } else {\n        return p.value;\n      }\n    } );\n\n    return {\n      name: name,\n      value: valArr,\n      pfValue: valArr,\n      strValue: valArr.join( ' ' ),\n      bypass: propIsBypass,\n      units: type.number && !type.unitless ? type.implicitUnits || 'px' : undefined\n    };\n  }\n\n  // several types also allow enums\n  var checkEnums = function(){\n    for( var i = 0; i < type.enums.length; i++ ){\n      var en = type.enums[ i ];\n\n      if( en === value ){\n        return {\n          name: name,\n          value: value,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      }\n    }\n\n    return null;\n  };\n\n  // check the type and return the appropriate object\n  if( type.number ){\n    var units;\n    var implicitUnits = 'px'; // not set => px\n\n    if( type.units ){ // use specified units if set\n      units = type.units;\n    }\n\n    if( type.implicitUnits ){\n      implicitUnits = type.implicitUnits;\n    }\n\n    if( !type.unitless ){\n      if( valueIsString ){\n        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n        if( units ){ unitsRegex = units; } // only allow explicit units if so set\n        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );\n\n        if( match ){\n          value = match[1];\n          units = match[2] || implicitUnits;\n        }\n\n      } else if( !units || type.implicitUnits ){\n        units = implicitUnits; // implicitly px if unspecified\n      }\n    }\n\n    value = parseFloat( value );\n\n    // if not a number and enums not allowed, then the value is invalid\n    if( isNaN( value ) && type.enums === undefined ){\n      return null;\n    }\n\n    // check if this number type also accepts special keywords in place of numbers\n    // (i.e. `left`, `auto`, etc)\n    if( isNaN( value ) && type.enums !== undefined ){\n      value = passedValue;\n\n      return checkEnums();\n    }\n\n    // check if value must be an integer\n    if( type.integer && !is.integer( value ) ){\n      return null;\n    }\n\n    // check value is within range\n    if( (type.min !== undefined && value < type.min)\n    || (type.max !== undefined && value > type.max)\n    ){\n      return null;\n    }\n\n    var ret = {\n      name: name,\n      value: value,\n      strValue: '' + value + (units ? units : ''),\n      units: units,\n      bypass: propIsBypass\n    };\n\n    // normalise value in pixels\n    if( type.unitless || (units !== 'px' && units !== 'em') ){\n      ret.pfValue = value;\n    } else {\n      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );\n    }\n\n    // normalise value in ms\n    if( units === 'ms' || units === 's' ){\n      ret.pfValue = units === 'ms' ? value : 1000 * value;\n    }\n\n    // normalise value in rad\n    if( units === 'deg' || units === 'rad' ){\n      ret.pfValue = units === 'rad' ? value : math.deg2rad( value );\n    }\n\n    return ret;\n\n  } else if( type.propList ){\n\n    var props = [];\n    var propsStr = '' + value;\n\n    if( propsStr === 'none' ){\n      // leave empty\n\n    } else { // go over each prop\n\n      var propsSplit = propsStr.split( ',' );\n      for( var i = 0; i < propsSplit.length; i++ ){\n        var propName = propsSplit[ i ].trim();\n\n        if( self.properties[ propName ] ){\n          props.push( propName );\n        }\n      }\n\n      if( props.length === 0 ){ return null; }\n    }\n\n    return {\n      name: name,\n      value: props,\n      strValue: props.length === 0 ? 'none' : props.join( ', ' ),\n      bypass: propIsBypass\n    };\n\n  } else if( type.color ){\n    var tuple = util.color2tuple( value );\n\n    if( !tuple ){ return null; }\n\n    return {\n      name: name,\n      value: tuple,\n      strValue: '' + value,\n      bypass: propIsBypass,\n      roundValue: true\n    };\n\n  } else if( type.regex || type.regexes ){\n\n    // first check enums\n    if( type.enums ){\n      var enumProp = checkEnums();\n\n      if( enumProp ){ return enumProp; }\n    }\n\n    var regexes = type.regexes ? type.regexes : [ type.regex ];\n\n    for( var i = 0; i < regexes.length; i++ ){\n      var regex = new RegExp( regexes[ i ] ); // make a regex from the type string\n      var m = regex.exec( value );\n\n      if( m ){ // regex matches\n        return {\n          name: name,\n          value: m,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n\n      }\n    }\n\n    return null; // didn't match any\n\n  } else if( type.string ){\n    // just return\n    return {\n      name: name,\n      value: value,\n      strValue: '' + value,\n      bypass: propIsBypass\n    };\n\n  } else if( type.enums ){ // check enums last because it's a combo type in others\n    return checkEnums();\n\n  } else {\n    return null; // not a type we can handle\n  }\n\n};\nstyfn.parseImpl = parseImpl;\n\nmodule.exports = styfn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/style/parse.js\n ** module id = 94\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../is' );\n\nvar corefn = ({\n\n  autolock: function( bool ){\n    if( bool !== undefined ){\n      this._private.autolock = bool ? true : false;\n    } else {\n      return this._private.autolock;\n    }\n\n    return this; // chaining\n  },\n\n  autoungrabify: function( bool ){\n    if( bool !== undefined ){\n      this._private.autoungrabify = bool ? true : false;\n    } else {\n      return this._private.autoungrabify;\n    }\n\n    return this; // chaining\n  },\n\n  autounselectify: function( bool ){\n    if( bool !== undefined ){\n      this._private.autounselectify = bool ? true : false;\n    } else {\n      return this._private.autounselectify;\n    }\n\n    return this; // chaining\n  },\n\n  panningEnabled: function( bool ){\n    if( bool !== undefined ){\n      this._private.panningEnabled = bool ? true : false;\n    } else {\n      return this._private.panningEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  userPanningEnabled: function( bool ){\n    if( bool !== undefined ){\n      this._private.userPanningEnabled = bool ? true : false;\n    } else {\n      return this._private.userPanningEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  zoomingEnabled: function( bool ){\n    if( bool !== undefined ){\n      this._private.zoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.zoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  userZoomingEnabled: function( bool ){\n    if( bool !== undefined ){\n      this._private.userZoomingEnabled = bool ? true : false;\n    } else {\n      return this._private.userZoomingEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  boxSelectionEnabled: function( bool ){\n    if( bool !== undefined ){\n      this._private.boxSelectionEnabled = bool ? true : false;\n    } else {\n      return this._private.boxSelectionEnabled;\n    }\n\n    return this; // chaining\n  },\n\n  pan: function(){\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n\n    switch( args.length ){\n    case 0: // .pan()\n      return pan;\n\n    case 1:\n\n      if( is.string( args[0] ) ){ // .pan('x')\n        dim = args[0];\n        return pan[ dim ];\n\n      } else if( is.plainObject( args[0] ) ){ // .pan({ x: 0, y: 100 })\n        if( !this._private.panningEnabled ){\n          return this;\n        }\n\n        dims = args[0];\n        x = dims.x;\n        y = dims.y;\n\n        if( is.number( x ) ){\n          pan.x = x;\n        }\n\n        if( is.number( y ) ){\n          pan.y = y;\n        }\n\n        this.trigger( 'pan viewport' );\n      }\n      break;\n\n    case 2: // .pan('x', 100)\n      if( !this._private.panningEnabled ){\n        return this;\n      }\n\n      dim = args[0];\n      val = args[1];\n\n      if( (dim === 'x' || dim === 'y') && is.number( val ) ){\n        pan[ dim ] = val;\n      }\n\n      this.trigger( 'pan viewport' );\n      break;\n\n    default:\n      break; // invalid\n    }\n\n    this.notify( { // notify the renderer that the viewport changed\n      type: 'viewport'\n    } );\n\n    return this; // chaining\n  },\n\n  panBy: function( params ){\n    var args = arguments;\n    var pan = this._private.pan;\n    var dim, val, dims, x, y;\n\n    if( !this._private.panningEnabled ){\n      return this;\n    }\n\n    switch( args.length ){\n    case 1:\n\n      if( is.plainObject( args[0] ) ){ // .panBy({ x: 0, y: 100 })\n        dims = args[0];\n        x = dims.x;\n        y = dims.y;\n\n        if( is.number( x ) ){\n          pan.x += x;\n        }\n\n        if( is.number( y ) ){\n          pan.y += y;\n        }\n\n        this.trigger( 'pan viewport' );\n      }\n      break;\n\n    case 2: // .panBy('x', 100)\n      dim = args[0];\n      val = args[1];\n\n      if( (dim === 'x' || dim === 'y') && is.number( val ) ){\n        pan[ dim ] += val;\n      }\n\n      this.trigger( 'pan viewport' );\n      break;\n\n    default:\n      break; // invalid\n    }\n\n    this.notify( { // notify the renderer that the viewport changed\n      type: 'viewport'\n    } );\n\n    return this; // chaining\n  },\n\n  fit: function( elements, padding ){\n    var viewportState = this.getFitViewport( elements, padding );\n\n    if( viewportState ){\n      var _p = this._private;\n      _p.zoom = viewportState.zoom;\n      _p.pan = viewportState.pan;\n\n      this.trigger( 'pan zoom viewport' );\n\n      this.notify( { // notify the renderer that the viewport changed\n        type: 'viewport'\n      } );\n    }\n\n    return this; // chaining\n  },\n\n  getFitViewport: function( elements, padding ){\n    if( is.number( elements ) && padding === undefined ){ // elements is optional\n      padding = elements;\n      elements = undefined;\n    }\n\n    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n      return;\n    }\n\n    var bb;\n\n    if( is.string( elements ) ){\n      var sel = elements;\n      elements = this.$( sel );\n\n    } else if( is.boundingBox( elements ) ){ // assume bb\n      var bbe = elements;\n      bb = {\n        x1: bbe.x1,\n        y1: bbe.y1,\n        x2: bbe.x2,\n        y2: bbe.y2\n      };\n\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n\n    } else if( !is.elementOrCollection( elements ) ){\n      elements = this.mutableElements();\n    }\n\n    bb = bb || elements.boundingBox();\n\n    var w = this.width();\n    var h = this.height();\n    var zoom;\n    padding = is.number( padding ) ? padding : 0;\n\n    if( !isNaN( w ) && !isNaN( h ) && w > 0 && h > 0 && !isNaN( bb.w ) && !isNaN( bb.h ) &&  bb.w > 0 && bb.h > 0 ){\n      zoom = Math.min( (w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h );\n\n      // crop zoom\n      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\n      var pan = { // now pan to middle\n        x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,\n        y: (h - zoom * ( bb.y1 + bb.y2 )) / 2\n      };\n\n      return {\n        zoom: zoom,\n        pan: pan\n      };\n    }\n\n    return;\n  },\n\n  minZoom: function( zoom ){\n    if( zoom === undefined ){\n      return this._private.minZoom;\n    } else if( is.number( zoom ) ){\n      this._private.minZoom = zoom;\n    }\n\n    return this;\n  },\n\n  maxZoom: function( zoom ){\n    if( zoom === undefined ){\n      return this._private.maxZoom;\n    } else if( is.number( zoom ) ){\n      this._private.maxZoom = zoom;\n    }\n\n    return this;\n  },\n\n  zoom: function( params ){\n    var pos; // in rendered px\n    var zoom;\n\n    if( params === undefined ){ // then get the zoom\n      return this._private.zoom;\n\n    } else if( is.number( params ) ){ // then set the zoom\n      zoom = params;\n\n    } else if( is.plainObject( params ) ){ // then zoom about a point\n      zoom = params.level;\n\n      if( params.position ){\n        var p = params.position;\n        var pan = this._private.pan;\n        var z = this._private.zoom;\n\n        pos = { // convert to rendered px\n          x: p.x * z + pan.x,\n          y: p.y * z + pan.y\n        };\n      } else if( params.renderedPosition ){\n        pos = params.renderedPosition;\n      }\n\n      if( pos && !this._private.panningEnabled ){\n        return this; // panning disabled\n      }\n    }\n\n    if( !this._private.zoomingEnabled ){\n      return this; // zooming disabled\n    }\n\n    if( !is.number( zoom ) || ( pos && (!is.number( pos.x ) || !is.number( pos.y )) ) ){\n      return this; // can't zoom with invalid params\n    }\n\n    // crop zoom\n    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\n    if( pos ){ // set zoom about position\n      var pan1 = this._private.pan;\n      var zoom1 = this._private.zoom;\n      var zoom2 = zoom;\n\n      var pan2 = {\n        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n      };\n\n      this._private.zoom = zoom;\n      this._private.pan = pan2;\n\n      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;\n      this.trigger( ' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );\n\n    } else { // just set the zoom\n      this._private.zoom = zoom;\n      this.trigger( 'zoom viewport' );\n    }\n\n    this.notify( { // notify the renderer that the viewport changed\n      type: 'viewport'\n    } );\n\n    return this; // chaining\n  },\n\n  viewport: function( opts ){\n    var _p = this._private;\n    var zoomDefd = true;\n    var panDefd = true;\n    var events = []; // to trigger\n    var zoomFailed = false;\n    var panFailed = false;\n\n    if( !opts ){ return this; }\n    if( !is.number( opts.zoom ) ){ zoomDefd = false; }\n    if( !is.plainObject( opts.pan ) ){ panDefd = false; }\n    if( !zoomDefd && !panDefd ){ return this; }\n\n    if( zoomDefd ){\n      var z = opts.zoom;\n\n      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){\n        zoomFailed = true;\n\n      } else {\n        _p.zoom = z;\n\n        events.push( 'zoom' );\n      }\n    }\n\n    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){\n      var p = opts.pan;\n\n      if( is.number( p.x ) ){\n        _p.pan.x = p.x;\n        panFailed = false;\n      }\n\n      if( is.number( p.y ) ){\n        _p.pan.y = p.y;\n        panFailed = false;\n      }\n\n      if( !panFailed ){\n        events.push( 'pan' );\n      }\n    }\n\n    if( events.length > 0 ){\n      events.push( 'viewport' );\n      this.trigger( events.join( ' ' ) );\n\n      this.notify( {\n        type: 'viewport'\n      } );\n    }\n\n    return this; // chaining\n  },\n\n  center: function( elements ){\n    var pan = this.getCenterPan( elements );\n\n    if( pan ){\n      this._private.pan = pan;\n\n      this.trigger( 'pan viewport' );\n\n      this.notify( { // notify the renderer that the viewport changed\n        type: 'viewport'\n      } );\n    }\n\n    return this; // chaining\n  },\n\n  getCenterPan: function( elements, zoom ){\n    if( !this._private.panningEnabled ){\n      return;\n    }\n\n    if( is.string( elements ) ){\n      var selector = elements;\n      elements = this.mutableElements().filter( selector );\n    } else if( !is.elementOrCollection( elements ) ){\n      elements = this.mutableElements();\n    }\n\n    var bb = elements.boundingBox();\n    var w = this.width();\n    var h = this.height();\n    zoom = zoom === undefined ? this._private.zoom : zoom;\n\n    var pan = { // middle\n      x: (w - zoom * ( bb.x1 + bb.x2 )) / 2,\n      y: (h - zoom * ( bb.y1 + bb.y2 )) / 2\n    };\n\n    return pan;\n  },\n\n  reset: function(){\n    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n      return this;\n    }\n\n    this.viewport( {\n      pan: { x: 0, y: 0 },\n      zoom: 1\n    } );\n\n    return this; // chaining\n  },\n\n  invalidateSize: function(){\n    this._private.sizeCache = null;\n  },\n\n  size: function(){\n    var _p = this._private;\n    var container = _p.container;\n\n    return ( _p.sizeCache = _p.sizeCache || ( container ? {\n      width: container.clientWidth,\n      height: container.clientHeight\n    } : { // fallback if no container (not 0 b/c can be used for dividing etc)\n      width: 1,\n      height: 1\n    } ) );\n  },\n\n  width: function(){\n    return this.size().width;\n  },\n\n  height: function(){\n    return this.size().height;\n  },\n\n  extent: function(){\n    var pan = this._private.pan;\n    var zoom = this._private.zoom;\n    var rb = this.renderedExtent();\n\n    var b = {\n      x1: ( rb.x1 - pan.x ) / zoom,\n      x2: ( rb.x2 - pan.x ) / zoom,\n      y1: ( rb.y1 - pan.y ) / zoom,\n      y2: ( rb.y2 - pan.y ) / zoom\n    };\n\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n\n    return b;\n  },\n\n  renderedExtent: function(){\n    var width = this.width();\n    var height = this.height();\n\n    return {\n      x1: 0,\n      y1: 0,\n      x2: width,\n      y2: height,\n      w: width,\n      h: height\n    };\n  }\n});\n\n// aliases\ncorefn.centre = corefn.center;\n\n// backwards compatibility\ncorefn.autolockNodes = corefn.autolock;\ncorefn.autoungrabifyNodes = corefn.autoungrabify;\n\nmodule.exports = corefn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/core/viewport.js\n ** module id = 95\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( './util' );\nvar define = require( './define' );\nvar Collection = require( './collection' );\nvar Core = require( './core' );\nvar incExts = require( './extensions' );\nvar is = require( './is' );\n\n// registered extensions to cytoscape, indexed by name\nvar extensions = {};\n\n// registered modules for extensions, indexed by name\nvar modules = {};\n\nfunction setExtension( type, name, registrant ){\n\n  var ext = registrant;\n\n  var overrideErr = function( field ){\n    util.error( 'Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden' );\n  };\n\n  if( type === 'core' ){\n    if( Core.prototype[ name ] ){\n      return overrideErr( name );\n    } else {\n      Core.prototype[ name ] = registrant;\n    }\n\n  } else if( type === 'collection' ){\n    if( Collection.prototype[ name ] ){\n      return overrideErr( name );\n    } else {\n      Collection.prototype[ name ] = registrant;\n    }\n\n  } else if( type === 'layout' ){\n    // fill in missing layout functions in the prototype\n\n    var Layout = function( options ){\n      this.options = options;\n\n      registrant.call( this, options );\n\n      // make sure layout has _private for use w/ std apis like .on()\n      if( !is.plainObject( this._private ) ){\n        this._private = {};\n      }\n\n      this._private.cy = options.cy;\n      this._private.listeners = [];\n    };\n\n    var layoutProto = Layout.prototype = Object.create( registrant.prototype );\n\n    var optLayoutFns = [];\n\n    for( var i = 0; i < optLayoutFns.length; i++ ){\n      var fnName = optLayoutFns[ i ];\n\n      layoutProto[ fnName ] = layoutProto[ fnName ] || function(){ return this; };\n    }\n\n    // either .start() or .run() is defined, so autogen the other\n    if( layoutProto.start && !layoutProto.run ){\n      layoutProto.run = function(){ this.start(); return this; };\n    } else if( !layoutProto.start && layoutProto.run ){\n      layoutProto.start = function(){ this.run(); return this; };\n    }\n\n    if( !layoutProto.stop ){\n      layoutProto.stop = function(){\n        var opts = this.options;\n\n        if( opts && opts.animate ){\n          var anis = this.animations;\n          for( var i = 0; i < anis.length; i++ ){\n            anis[ i ].stop();\n          }\n        }\n\n        this.trigger( 'layoutstop' );\n\n        return this;\n      };\n    }\n\n    if( !layoutProto.destroy ){\n      layoutProto.destroy = function(){\n        return this;\n      };\n    }\n\n    layoutProto.on = define.on( { layout: true } );\n    layoutProto.one = define.on( { layout: true, unbindSelfOnTrigger: true } );\n    layoutProto.once = define.on( { layout: true, unbindAllBindersOnTrigger: true } );\n    layoutProto.off = define.off( { layout: true } );\n    layoutProto.trigger = define.trigger( { layout: true } );\n\n    define.eventAliasesOn( layoutProto );\n\n    ext = Layout; // replace with our wrapped layout\n\n  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){\n    // user registered renderers inherit from base\n\n    var BaseRenderer = getExtension( 'renderer', 'base' );\n    var bProto = BaseRenderer.prototype;\n    var RegistrantRenderer = registrant;\n    var rProto = registrant.prototype;\n\n    var Renderer = function(){\n      BaseRenderer.apply( this, arguments );\n      RegistrantRenderer.apply( this, arguments );\n    };\n\n    var proto = Renderer.prototype;\n\n    for( var pName in bProto ){\n      var pVal = bProto[ pName ];\n      var existsInR = rProto[ pName ] != null;\n\n      if( existsInR ){\n        return overrideErr( pName );\n      }\n\n      proto[ pName ] = pVal; // take impl from base\n    }\n\n    for( var pName in rProto ){\n      proto[ pName ] = rProto[ pName ]; // take impl from registrant\n    }\n\n    bProto.clientFunctions.forEach( function( name ){\n      proto[ name ] = proto[ name ] || function(){\n        util.error( 'Renderer does not implement `renderer.' + name + '()` on its prototype' );\n      };\n    } );\n\n    ext = Renderer;\n\n  }\n\n  return util.setMap( {\n    map: extensions,\n    keys: [ type, name ],\n    value: ext\n  } );\n}\n\nfunction getExtension( type, name ){\n  return util.getMap( {\n    map: extensions,\n    keys: [ type, name ]\n  } );\n}\n\nfunction setModule( type, name, moduleType, moduleName, registrant ){\n  return util.setMap( {\n    map: modules,\n    keys: [ type, name, moduleType, moduleName ],\n    value: registrant\n  } );\n}\n\nfunction getModule( type, name, moduleType, moduleName ){\n  return util.getMap( {\n    map: modules,\n    keys: [ type, name, moduleType, moduleName ]\n  } );\n}\n\nvar extension = function(){\n  // e.g. extension('renderer', 'svg')\n  if( arguments.length === 2 ){\n    return getExtension.apply( null, arguments );\n  }\n\n  // e.g. extension('renderer', 'svg', { ... })\n  else if( arguments.length === 3 ){\n    return setExtension.apply( null, arguments );\n  }\n\n  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n  else if( arguments.length === 4 ){\n    return getModule.apply( null, arguments );\n  }\n\n  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n  else if( arguments.length === 5 ){\n    return setModule.apply( null, arguments );\n  }\n\n  else {\n    util.error( 'Invalid extension access syntax' );\n  }\n\n};\n\n// allows a core instance to access extensions internally\nCore.prototype.extension = extension;\n\n// included extensions\nincExts.forEach( function( group ){\n  group.extensions.forEach( function( ext ){\n    setExtension( group.type, ext.name, ext.impl );\n  } );\n} );\n\nmodule.exports = extension;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extension.js\n ** module id = 96\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = [\n  {\n    type: 'layout',\n    extensions: require( './layout' )\n  },\n\n  {\n    type: 'renderer',\n    extensions: require( './renderer' )\n  }\n];\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/index.js\n ** module id = 97\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = [\n  { name: 'breadthfirst', impl: require( './breadthfirst' ) },\n  { name: 'circle', impl: require( './circle' ) },\n  { name: 'concentric',impl: require( './concentric' ) },\n  { name: 'cose', impl: require( './cose' ) },\n  { name: 'grid', impl: require( './grid' ) },\n  { name: 'null', impl: require( './null' ) },\n  { name: 'preset', impl: require( './preset' ) },\n  { name: 'random', impl: require( './random' ) }\n];\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/index.js\n ** module id = 98\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\nvar math = require( '../../math' );\nvar is = require( '../../is' );\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)\n  padding: 30, // padding on fit\n  circle: false, // put depths in concentric circles if true, put depths top down if false\n  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n  roots: undefined, // the roots of the trees\n  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  ready: undefined, // callback on layoutready\n  stop: undefined // callback on layoutstop\n};\n\nfunction BreadthFirstLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\nBreadthFirstLayout.prototype.run = function(){\n  var params = this.options;\n  var options = params;\n\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not( ':parent' );\n  var graph = eles;\n\n  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  } );\n\n  var roots;\n  if( is.elementOrCollection( options.roots ) ){\n    roots = options.roots;\n  } else if( is.array( options.roots ) ){\n    var rootsArray = [];\n\n    for( var i = 0; i < options.roots.length; i++ ){\n      var id = options.roots[ i ];\n      var ele = cy.getElementById( id );\n      rootsArray.push( ele );\n    }\n\n    roots = cy.collection( rootsArray );\n  } else if( is.string( options.roots ) ){\n    roots = cy.$( options.roots );\n\n  } else {\n    if( options.directed ){\n      roots = nodes.roots();\n    } else {\n      var components = [];\n      var unhandledNodes = nodes;\n\n      while( unhandledNodes.length > 0 ){\n        var currComp = cy.collection();\n\n        eles.bfs( {\n          roots: unhandledNodes[0],\n          visit: function( i, depth, node, edge, pNode ){\n            currComp = currComp.add( node );\n          },\n          directed: false\n        } );\n\n        unhandledNodes = unhandledNodes.not( currComp );\n        components.push( currComp );\n      }\n\n      roots = cy.collection();\n      for( var i = 0; i < components.length; i++ ){\n        var comp = components[ i ];\n        var maxDegree = comp.maxDegree( false );\n        var compRoots = comp.filter( function(){\n          return this.degree( false ) === maxDegree;\n        } );\n\n        roots = roots.add( compRoots );\n      }\n\n    }\n  }\n\n\n  var depths = [];\n  var foundByBfs = {};\n  var id2depth = {};\n  var prevNode = {};\n  var prevEdge = {};\n  var successors = {};\n\n  // find the depths of the nodes\n  graph.bfs( {\n    roots: roots,\n    directed: options.directed,\n    visit: function( i, depth, node, edge, pNode ){\n      var ele = this[0];\n      var id = ele.id();\n\n      if( !depths[ depth ] ){\n        depths[ depth ] = [];\n      }\n\n      depths[ depth ].push( ele );\n      foundByBfs[ id ] = true;\n      id2depth[ id ] = depth;\n      prevNode[ id ] = pNode;\n      prevEdge[ id ] = edge;\n\n      if( pNode ){\n        var prevId = pNode.id();\n        var succ = successors[ prevId ] = successors[ prevId ] || [];\n\n        succ.push( node );\n      }\n    }\n  } );\n\n  // check for nodes not found by bfs\n  var orphanNodes = [];\n  for( var i = 0; i < nodes.length; i++ ){\n    var ele = nodes[ i ];\n\n    if( foundByBfs[ ele.id() ] ){\n      continue;\n    } else {\n      orphanNodes.push( ele );\n    }\n  }\n\n  // assign orphan nodes a depth from their neighborhood\n  var maxChecks = orphanNodes.length * 3;\n  var checks = 0;\n  while( orphanNodes.length !== 0 && checks < maxChecks ){\n    var node = orphanNodes.shift();\n    var neighbors = node.neighborhood().nodes();\n    var assignedDepth = false;\n\n    for( var i = 0; i < neighbors.length; i++ ){\n      var depth = id2depth[ neighbors[ i ].id() ];\n\n      if( depth !== undefined ){\n        depths[ depth ].push( node );\n        assignedDepth = true;\n        break;\n      }\n    }\n\n    if( !assignedDepth ){\n      orphanNodes.push( node );\n    }\n\n    checks++;\n  }\n\n  // assign orphan nodes that are still left to the depth of their subgraph\n  while( orphanNodes.length !== 0 ){\n    var node = orphanNodes.shift();\n    //var subgraph = graph.bfs( node ).path;\n    var assignedDepth = false;\n\n    // for( var i = 0; i < subgraph.length; i++ ){\n    //   var depth = id2depth[ subgraph[i].id() ];\n\n    //   if( depth !== undefined ){\n    //     depths[depth].push( node );\n    //     assignedDepth = true;\n    //     break;\n    //   }\n    // }\n\n    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0\n      if( depths.length === 0 ){\n        depths.push( [] );\n      }\n\n      depths[0].push( node );\n    }\n  }\n\n  // assign the nodes a depth and index\n  var assignDepthsToEles = function(){\n    for( var i = 0; i < depths.length; i++ ){\n      var eles = depths[ i ];\n\n      for( var j = 0; j < eles.length; j++ ){\n        var ele = eles[ j ];\n\n        ele._private.scratch.breadthfirst = {\n          depth: i,\n          index: j\n        };\n      }\n    }\n  };\n  assignDepthsToEles();\n\n\n  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth\n    var edges = node.connectedEdges( function(){\n      return this.data( 'target' ) === node.id();\n    } );\n    var thisInfo = node._private.scratch.breadthfirst;\n    var highestDepthOfOther = 0;\n    var highestOther;\n    for( var i = 0; i < edges.length; i++ ){\n      var edge = edges[ i ];\n      var otherNode = edge.source()[0];\n      var otherInfo = otherNode._private.scratch.breadthfirst;\n\n      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){\n        highestDepthOfOther = otherInfo.depth;\n        highestOther = otherNode;\n      }\n    }\n\n    return highestOther;\n  };\n\n  // make maximal if so set by adjusting depths\n  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){\n\n    var nDepths = depths.length;\n    var elesToMove = [];\n    for( var i = 0; i < nDepths; i++ ){\n      var depth = depths[ i ];\n\n      var nDepth = depth.length;\n      for( var j = 0; j < nDepth; j++ ){\n        var ele = depth[ j ];\n        var info = ele._private.scratch.breadthfirst;\n        var intEle = intersectsDepth( ele );\n\n        if( intEle ){\n          info.intEle = intEle;\n          elesToMove.push( ele );\n        }\n      }\n    }\n\n    for( var i = 0; i < elesToMove.length; i++ ){\n      var ele = elesToMove[ i ];\n      var info = ele._private.scratch.breadthfirst;\n      var intEle = info.intEle;\n      var intInfo = intEle._private.scratch.breadthfirst;\n\n      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index\n\n      // add to end of new depth\n      var newDepth = intInfo.depth + 1;\n      while( newDepth > depths.length - 1 ){\n        depths.push( [] );\n      }\n      depths[ newDepth ].push( ele );\n\n      info.depth = newDepth;\n      info.index = depths[ newDepth ].length - 1;\n    }\n\n    assignDepthsToEles();\n  }\n\n  // find min distance we need to leave between nodes\n  var minDistance = 0;\n  if( options.avoidOverlap ){\n    for( var i = 0; i < nodes.length; i++ ){\n      var n = nodes[ i ];\n      var nbb = n.boundingBox();\n      var w = nbb.w;\n      var h = nbb.h;\n\n      minDistance = Math.max( minDistance, w, h );\n    }\n    minDistance *= options.spacingFactor; // just to have some nice spacing\n  }\n\n  // get the weighted percent for an element based on its connectivity to other levels\n  var cachedWeightedPercent = {};\n  var getWeightedPercent = function( ele ){\n    if( cachedWeightedPercent[ ele.id() ] ){\n      return cachedWeightedPercent[ ele.id() ];\n    }\n\n    var eleDepth = ele._private.scratch.breadthfirst.depth;\n    var neighbors = ele.neighborhood().nodes().not( ':parent' );\n    var percent = 0;\n    var samples = 0;\n\n    for( var i = 0; i < neighbors.length; i++ ){\n      var neighbor = neighbors[ i ];\n      var bf = neighbor._private.scratch.breadthfirst;\n      var index = bf.index;\n      var depth = bf.depth;\n      var nDepth = depths[ depth ].length;\n\n      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above\n        percent += index / nDepth;\n        samples++;\n      }\n    }\n\n    samples = Math.max( 1, samples );\n    percent = percent / samples;\n\n    if( samples === 0 ){ // so lone nodes have a \"don't care\" state in sorting\n      percent = undefined;\n    }\n\n    cachedWeightedPercent[ ele.id() ] = percent;\n    return percent;\n  };\n\n\n  // rearrange the indices in each depth level based on connectivity\n\n  var sortFn = function( a, b ){\n    var apct = getWeightedPercent( a );\n    var bpct = getWeightedPercent( b );\n\n    return apct - bpct;\n  };\n\n  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result\n\n    for( var i = 0; i < depths.length; i++ ){\n      depths[ i ] = depths[ i ].sort( sortFn );\n    }\n    assignDepthsToEles(); // and update\n\n  }\n\n  var biggestDepthSize = 0;\n  for( var i = 0; i < depths.length; i++ ){\n    biggestDepthSize = Math.max( depths[ i ].length, biggestDepthSize );\n  }\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.x1 + bb.h / 2\n  };\n\n  var getPosition = function( ele, isBottomDepth ){\n    var info = ele._private.scratch.breadthfirst;\n    var depth = info.depth;\n    var index = info.index;\n    var depthSize = depths[ depth ].length;\n\n    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );\n    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );\n    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );\n    radiusStepSize = Math.max( radiusStepSize, minDistance );\n\n    if( !options.circle ){\n\n      var epos = {\n        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n        y: (depth + 1) * distanceY\n      };\n\n      if( isBottomDepth ){\n        return epos;\n      }\n\n      // var succs = successors[ ele.id() ];\n      // if( succs ){\n      //   epos.x = 0;\n      //\n      //   for( var i = 0 ; i < succs.length; i++ ){\n      //     var spos = pos[ succs[i].id() ];\n      //\n      //     epos.x += spos.x;\n      //   }\n      //\n      //   epos.x /= succs.length;\n      // } else {\n      //   //debugger;\n      // }\n\n      return epos;\n\n    } else {\n      if( options.circle ){\n        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n        var theta = 2 * Math.PI / depths[ depth ].length * index;\n\n        if( depth === 0 && depths[0].length === 1 ){\n          radius = 1;\n        }\n\n        return {\n          x: center.x + radius * Math.cos( theta ),\n          y: center.y + radius * Math.sin( theta )\n        };\n\n      } else {\n        return {\n          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n          y: (depth + 1) * distanceY\n        };\n      }\n    }\n\n  };\n\n  // get positions in reverse depth order\n  var pos = {};\n  for( var i = depths.length - 1; i >= 0; i-- ){\n    var depth = depths[ i ];\n\n    for( var j = 0; j < depth.length; j++ ){\n      var node = depth[ j ];\n\n      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );\n    }\n  }\n\n  nodes.layoutPositions( this, options, function(){\n    return pos[ this.id() ];\n  } );\n\n  return this; // chaining\n};\n\nmodule.exports = BreadthFirstLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/breadthfirst.js\n ** module id = 99\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\nvar math = require( '../../math' );\nvar is = require( '../../is' );\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  padding: 30, // the padding on fit\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space\n  radius: undefined, // the radius of the circle\n  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  ready: undefined, // callback on layoutready\n  stop: undefined // callback on layoutstop\n};\n\nfunction CircleLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\nCircleLayout.prototype.run = function(){\n  var params = this.options;\n  var options = params;\n\n  var cy = params.cy;\n  var eles = options.eles;\n\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\n  var nodes = eles.nodes().not( ':parent' );\n\n  if( options.sort ){\n    nodes = nodes.sort( options.sort );\n  }\n\n  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  } );\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n\n  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n\n  var dTheta = sweep / ( Math.max( 1, nodes.length - 1 ) );\n  var r;\n\n  var minDistance = 0;\n  for( var i = 0; i < nodes.length; i++ ){\n    var n = nodes[ i ];\n    var nbb = n.boundingBox();\n    var w = nbb.w;\n    var h = nbb.h;\n\n    minDistance = Math.max( minDistance, w, h );\n  }\n\n  if( is.number( options.radius ) ){\n    r = options.radius;\n  } else if( nodes.length <= 1 ){\n    r = 0;\n  } else {\n    r = Math.min( bb.h, bb.w ) / 2 - minDistance;\n  }\n\n  // calculate the radius\n  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n    minDistance *= 1.75; // just to have some nice spacing\n\n    var dcos = Math.cos( dTheta ) - Math.cos( 0 );\n    var dsin = Math.sin( dTheta ) - Math.sin( 0 );\n    var rMin = Math.sqrt( minDistance * minDistance / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping\n    r = Math.max( rMin, r );\n  }\n\n  var getPos = function( i, ele ){\n    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );\n\n    var rx = r * Math.cos( theta );\n    var ry = r * Math.sin( theta );\n    var pos = {\n      x: center.x + rx,\n      y: center.y + ry\n    };\n\n    return pos;\n  };\n\n  nodes.layoutPositions( this, options, getPos );\n\n  return this; // chaining\n};\n\nmodule.exports = CircleLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/circle.js\n ** module id = 100\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\nvar math = require( '../../math' );\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  padding: 30, // the padding on fit\n  startAngle: 3 / 2 * Math.PI, // where nodes start in radians\n  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)\n  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n  height: undefined, // height of layout area (overrides container height)\n  width: undefined, // width of layout area (overrides container width)\n  concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre\n    return node.degree();\n  },\n  levelWidth: function( nodes ){ // the variation of concentric values in each level\n    return nodes.maxDegree() / 4;\n  },\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  ready: undefined, // callback on layoutready\n  stop: undefined // callback on layoutstop\n};\n\nfunction ConcentricLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\nConcentricLayout.prototype.run = function(){\n  var params = this.options;\n  var options = params;\n\n  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n\n  var cy = params.cy;\n\n  var eles = options.eles;\n  var nodes = eles.nodes().not( ':parent' );\n\n  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  } );\n\n  var center = {\n    x: bb.x1 + bb.w / 2,\n    y: bb.y1 + bb.h / 2\n  };\n\n  var nodeValues = []; // { node, value }\n  var theta = options.startAngle;\n  var maxNodeSize = 0;\n\n  for( var i = 0; i < nodes.length; i++ ){\n    var node = nodes[ i ];\n    var value;\n\n    // calculate the node value\n    value = options.concentric.apply( node, [ node ] );\n    nodeValues.push( {\n      value: value,\n      node: node\n    } );\n\n    // for style mapping\n    node._private.scratch.concentric = value;\n  }\n\n  // in case we used the `concentric` in style\n  nodes.updateStyle();\n\n  // calculate max size now based on potentially updated mappers\n  for( var i = 0; i < nodes.length; i++ ){\n    var node = nodes[ i ];\n    var nbb = node.boundingBox();\n\n    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );\n  }\n\n  // sort node values in descreasing order\n  nodeValues.sort( function( a, b ){\n    return b.value - a.value;\n  } );\n\n  var levelWidth = options.levelWidth( nodes );\n\n  // put the values into levels\n  var levels = [ [] ];\n  var currentLevel = levels[0];\n  for( var i = 0; i < nodeValues.length; i++ ){\n    var val = nodeValues[ i ];\n\n    if( currentLevel.length > 0 ){\n      var diff = Math.abs( currentLevel[0].value - val.value );\n\n      if( diff >= levelWidth ){\n        currentLevel = [];\n        levels.push( currentLevel );\n      }\n    }\n\n    currentLevel.push( val );\n  }\n\n  // create positions from levels\n\n  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n  if( !options.avoidOverlap ){ // then strictly constrain to bb\n    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n    var maxR = ( Math.min( bb.w, bb.h ) / 2 - minDist );\n    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );\n\n    minDist = Math.min( minDist, rStep );\n  }\n\n  // find the metrics for each level\n  var r = 0;\n  for( var i = 0; i < levels.length; i++ ){\n    var level = levels[ i ];\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n    var dTheta = level.dTheta = sweep / ( Math.max( 1, level.length - 1 ) );\n\n    // calculate the radius\n    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n      var dcos = Math.cos( dTheta ) - Math.cos( 0 );\n      var dsin = Math.sin( dTheta ) - Math.sin( 0 );\n      var rMin = Math.sqrt( minDist * minDist / ( dcos * dcos + dsin * dsin ) ); // s.t. no nodes overlapping\n\n      r = Math.max( rMin, r );\n    }\n\n    level.r = r;\n\n    r += minDist;\n  }\n\n  if( options.equidistant ){\n    var rDeltaMax = 0;\n    var r = 0;\n\n    for( var i = 0; i < levels.length; i++ ){\n      var level = levels[ i ];\n      var rDelta = level.r - r;\n\n      rDeltaMax = Math.max( rDeltaMax, rDelta );\n    }\n\n    r = 0;\n    for( var i = 0; i < levels.length; i++ ){\n      var level = levels[ i ];\n\n      if( i === 0 ){\n        r = level.r;\n      }\n\n      level.r = r;\n\n      r += rDeltaMax;\n    }\n  }\n\n  // calculate the node positions\n  var pos = {}; // id => position\n  for( var i = 0; i < levels.length; i++ ){\n    var level = levels[ i ];\n    var dTheta = level.dTheta;\n    var r = level.r;\n\n    for( var j = 0; j < level.length; j++ ){\n      var val = level[ j ];\n      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;\n\n      var p = {\n        x: center.x + r * Math.cos( theta ),\n        y: center.y + r * Math.sin( theta )\n      };\n\n      pos[ val.node.id() ] = p;\n    }\n  }\n\n  // position the nodes\n  nodes.layoutPositions( this, options, function(){\n    var id = this.id();\n\n    return pos[ id ];\n  } );\n\n  return this; // chaining\n};\n\nmodule.exports = ConcentricLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/concentric.js\n ** module id = 101\n ** module chunks = 0\n **/","'use strict';\n\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/\n\nvar util = require( '../../util' );\nvar math = require( '../../math' );\nvar Thread = require( '../../thread' );\nvar is = require( '../../is' );\n\nvar DEBUG;\n\n/**\n * @brief :  default layout options\n */\nvar defaults = {\n  // Called on `layoutready`\n  ready: function(){},\n\n  // Called on `layoutstop`\n  stop: function(){},\n\n  // Whether to animate while running the layout\n  animate: true,\n\n  // The layout animates only after this many milliseconds\n  // (prevents flashing on fast runs)\n  animationThreshold: 250,\n\n  // Number of iterations between consecutive screen positions update\n  // (0 -> only updated on the end)\n  refresh: 20,\n\n  // Whether to fit the network view after when done\n  fit: true,\n\n  // Padding on fit\n  padding: 30,\n\n  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  boundingBox: undefined,\n\n  // Extra spacing between components in non-compound graphs\n  componentSpacing: 100,\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function( node ){ return 400000; },\n\n  // Node repulsion (overlapping) multiplier\n  nodeOverlap: 10,\n\n  // Ideal edge (non nested) length\n  idealEdgeLength: function( edge ){ return 10; },\n\n  // Divisor to compute edge forces\n  edgeElasticity: function( edge ){ return 100; },\n\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 5,\n\n  // Gravity force (constant)\n  gravity: 80,\n\n  // Maximum number of iterations to perform\n  numIter: 1000,\n\n  // Initial temperature (maximum node displacement)\n  initialTemp: 200,\n\n  // Cooling factor (how the temperature is reduced between consecutive iterations\n  coolingFactor: 0.95,\n\n  // Lower temperature threshold (below this point the layout will end)\n  minTemp: 1.0,\n\n  // Whether to use threading to speed up the layout\n  useMultitasking: true\n};\n\n\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */\nfunction CoseLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n\n  this.options.layout = this;\n}\n\n\n/**\n * @brief : runs the layout\n */\nCoseLayout.prototype.run = function(){\n  var options = this.options;\n  var cy      = options.cy;\n  var layout  = this;\n  var thread  = this.thread;\n\n  if( !thread || thread.stopped() ){\n    thread = this.thread = Thread( { disabled: !options.useMultitasking } );\n  }\n\n  layout.stopped = false;\n\n  layout.trigger( { type: 'layoutstart', layout: layout } );\n\n  // Set DEBUG - Global variable\n  if( true === options.debug ){\n    DEBUG = true;\n  } else {\n    DEBUG = false;\n  }\n\n  // Initialize layout info\n  var layoutInfo = createLayoutInfo( cy, layout, options );\n\n  // Show LayoutInfo contents if debugging\n  if( DEBUG ){\n    printLayoutInfo( layoutInfo );\n  }\n\n  // If required, randomize node positions\n  // if (true === options.randomize) {\n  randomizePositions( layoutInfo, cy );\n  // }\n\n  var startTime = Date.now();\n  var refreshRequested = false;\n  var refresh = function( rOpts ){\n    rOpts = rOpts || {};\n\n    if( refreshRequested && !rOpts.next ){\n      return;\n    }\n\n    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){\n      return;\n    }\n\n    refreshRequested = true;\n\n    util.requestAnimationFrame( function(){\n      refreshPositions( layoutInfo, cy, options );\n\n      // Fit the graph if necessary\n      if( true === options.fit ){\n        cy.fit( options.padding );\n      }\n\n      refreshRequested = false;\n\n      if( rOpts.next ){ rOpts.next(); }\n    });\n  };\n\n  thread.on( 'message', function( e ){\n    var layoutNodes = e.message;\n\n    layoutInfo.layoutNodes = layoutNodes;\n    refresh();\n  } );\n\n  thread.pass( {\n    layoutInfo: layoutInfo,\n    options: {\n      animate: options.animate,\n      refresh: options.refresh,\n      componentSpacing: options.componentSpacing,\n      nodeOverlap: options.nodeOverlap,\n      nestingFactor: options.nestingFactor,\n      gravity: options.gravity,\n      numIter: options.numIter,\n      initialTemp: options.initialTemp,\n      coolingFactor: options.coolingFactor,\n      minTemp: options.minTemp\n    }\n  } ).run( function( pass ){\n    var layoutInfo = pass.layoutInfo;\n    var options = pass.options;\n    var stopped = false;\n\n    /**\n     * @brief          : Performs one iteration of the physical simulation\n     * @arg layoutInfo : LayoutInfo object already initialized\n     * @arg cy         : Cytoscape object\n     * @arg options    : Layout options\n     */\n    var step = function( layoutInfo, options, step ){\n      // var s = \"\\n\\n###############################\";\n      // s += \"\\nSTEP: \" + step;\n      // s += \"\\n###############################\\n\";\n      // logDebug(s);\n\n      // Calculate node repulsions\n      calculateNodeForces( layoutInfo, options );\n      // Calculate edge forces\n      calculateEdgeForces( layoutInfo, options );\n      // Calculate gravity forces\n      calculateGravityForces( layoutInfo, options );\n      // Propagate forces from parent to child\n      propagateForces( layoutInfo, options );\n      // Update positions based on calculated forces\n      updatePositions( layoutInfo, options );\n    };\n\n    /**\n     * @brief : Computes the node repulsion forces\n     */\n    var calculateNodeForces = function( layoutInfo, options ){\n      // Go through each of the graphs in graphSet\n      // Nodes only repel each other if they belong to the same graph\n      // var s = 'calculateNodeForces';\n      // logDebug(s);\n      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){\n        var graph    = layoutInfo.graphSet[ i ];\n        var numNodes = graph.length;\n\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n\n        // Now get all the pairs of nodes\n        // Only get each pair once, (A, B) = (B, A)\n        for( var j = 0; j < numNodes; j++ ){\n          var node1 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];\n\n          for( var k = j + 1; k < numNodes; k++ ){\n            var node2 = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ k ] ] ];\n\n            nodeRepulsion( node1, node2, layoutInfo, options );\n          }\n        }\n      }\n    };\n\n    /**\n     * @brief : Compute the node repulsion forces between a pair of nodes\n     */\n    var nodeRepulsion = function( node1, node2, layoutInfo, options ){\n      // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n\n      var cmptId1 = node1.cmptId;\n      var cmptId2 = node2.cmptId;\n\n      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }\n\n      // Get direction of line connecting both node centers\n      var directionX = node2.positionX - node1.positionX;\n      var directionY = node2.positionY - node1.positionY;\n      // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n\n      // If both centers are the same, apply a random force\n      if( 0 === directionX && 0 === directionY ){\n        // s += \"\\nNodes have the same position.\";\n        return; // TODO could be improved with random force\n      }\n\n      var overlap = nodesOverlap( node1, node2, directionX, directionY );\n\n      if( overlap > 0 ){\n        // s += \"\\nNodes DO overlap.\";\n        // s += \"\\nOverlap: \" + overlap;\n        // If nodes overlap, repulsion force is proportional\n        // to the overlap\n        var force    = options.nodeOverlap * overlap;\n\n        // Compute the module and components of the force vector\n        var distance = Math.sqrt( directionX * directionX + directionY * directionY );\n        // s += \"\\nDistance: \" + distance;\n        var forceX   = force * directionX / distance;\n        var forceY   = force * directionY / distance;\n\n      } else {\n        // s += \"\\nNodes do NOT overlap.\";\n        // If there's no overlap, force is inversely proportional\n        // to squared distance\n\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint( node1, directionX, directionY );\n        var point2 = findClippingPoint( node2, -1 * directionX, -1 * directionY );\n\n        // Use clipping points to compute distance\n        var distanceX   = point2.x - point1.x;\n        var distanceY   = point2.y - point1.y;\n        var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n        var distance    = Math.sqrt( distanceSqr );\n        // s += \"\\nDistance: \" + distance;\n\n        // Compute the module and components of the force vector\n        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;\n        var forceX = force * distanceX / distance;\n        var forceY = force * distanceY / distance;\n      }\n\n      // Apply force\n      if( !node1.isLocked ){\n        node1.offsetX -= forceX;\n        node1.offsetY -= forceY;\n      }\n\n      if( !node2.isLocked ){\n        node2.offsetX += forceX;\n        node2.offsetY += forceY;\n      }\n\n      // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n      // logDebug(s);\n\n      return;\n    };\n\n    /**\n     * @brief  : Determines whether two nodes overlap or not\n     * @return : Amount of overlapping (0 => no overlap)\n     */\n    var nodesOverlap = function( node1, node2, dX, dY ){\n\n      if( dX > 0 ){\n        var overlapX = node1.maxX - node2.minX;\n      } else {\n        var overlapX = node2.maxX - node1.minX;\n      }\n\n      if( dY > 0 ){\n        var overlapY = node1.maxY - node2.minY;\n      } else {\n        var overlapY = node2.maxY - node1.minY;\n      }\n\n      if( overlapX >= 0 && overlapY >= 0 ){\n        return Math.sqrt( overlapX * overlapX + overlapY * overlapY );\n      } else {\n        return 0;\n      }\n    };\n\n    /**\n     * @brief : Finds the point in which an edge (direction dX, dY) intersects\n     *          the rectangular bounding box of it's source/target node\n     */\n    var findClippingPoint = function( node, dX, dY ){\n\n      // Shorcuts\n      var X = node.positionX;\n      var Y = node.positionY;\n      var H = node.height || 1;\n      var W = node.width || 1;\n      var dirSlope     = dY / dX;\n      var nodeSlope    = H / W;\n\n      // var s = 'Computing clipping point of node ' + node.id +\n      //   \" . Height:  \" + H + \", Width: \" + W +\n      //   \"\\nDirection \" + dX + \", \" + dY;\n      //\n      // Compute intersection\n      var res = {};\n      do {\n        // Case: Vertical direction (up)\n        if( 0 === dX && 0 < dY ){\n          res.x = X;\n          // s += \"\\nUp direction\";\n          res.y = Y + H / 2;\n          break;\n        }\n\n        // Case: Vertical direction (down)\n        if( 0 === dX && 0 > dY ){\n          res.x = X;\n          res.y = Y + H / 2;\n          // s += \"\\nDown direction\";\n          break;\n        }\n\n        // Case: Intersects the right border\n        if( 0 < dX &&\n        -1 * nodeSlope <= dirSlope &&\n        dirSlope <= nodeSlope ){\n          res.x = X + W / 2;\n          res.y = Y + (W * dY / 2 / dX);\n          // s += \"\\nRightborder\";\n          break;\n        }\n\n        // Case: Intersects the left border\n        if( 0 > dX &&\n        -1 * nodeSlope <= dirSlope &&\n        dirSlope <= nodeSlope ){\n          res.x = X - W / 2;\n          res.y = Y - (W * dY / 2 / dX);\n          // s += \"\\nLeftborder\";\n          break;\n        }\n\n        // Case: Intersects the top border\n        if( 0 < dY &&\n        ( dirSlope <= -1 * nodeSlope ||\n          dirSlope >= nodeSlope ) ){\n          res.x = X + (H * dX / 2 / dY);\n          res.y = Y + H / 2;\n          // s += \"\\nTop border\";\n          break;\n        }\n\n        // Case: Intersects the bottom border\n        if( 0 > dY &&\n        ( dirSlope <= -1 * nodeSlope ||\n          dirSlope >= nodeSlope ) ){\n          res.x = X - (H * dX / 2 / dY);\n          res.y = Y - H / 2;\n          // s += \"\\nBottom border\";\n          break;\n        }\n\n      } while( false);\n\n      // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n      // logDebug(s);\n      return res;\n    };\n\n    /**\n     * @brief : Calculates all edge forces\n     */\n    var calculateEdgeForces = function( layoutInfo, options ){\n      // Iterate over all edges\n      for( var i = 0; i < layoutInfo.edgeSize; i++ ){\n        // Get edge, source & target nodes\n        var edge     = layoutInfo.layoutEdges[ i ];\n        var sourceIx = layoutInfo.idToIndex[ edge.sourceId ];\n        var source   = layoutInfo.layoutNodes[ sourceIx ];\n        var targetIx = layoutInfo.idToIndex[ edge.targetId ];\n        var target   = layoutInfo.layoutNodes[ targetIx ];\n\n        // Get direction of line connecting both node centers\n        var directionX = target.positionX - source.positionX;\n        var directionY = target.positionY - source.positionY;\n\n        // If both centers are the same, do nothing.\n        // A random force has already been applied as node repulsion\n        if( 0 === directionX && 0 === directionY ){\n          return;\n        }\n\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint( source, directionX, directionY );\n        var point2 = findClippingPoint( target, -1 * directionX, -1 * directionY );\n\n\n        var lx = point2.x - point1.x;\n        var ly = point2.y - point1.y;\n        var l  = Math.sqrt( lx * lx + ly * ly );\n\n        var force  = Math.pow( edge.idealLength - l, 2 ) / edge.elasticity;\n\n        if( 0 !== l ){\n          var forceX = force * lx / l;\n          var forceY = force * ly / l;\n        } else {\n          var forceX = 0;\n          var forceY = 0;\n        }\n\n        // Add this force to target and source nodes\n        if( !source.isLocked ){\n          source.offsetX += forceX;\n          source.offsetY += forceY;\n        }\n\n        if( !target.isLocked ){\n          target.offsetX -= forceX;\n          target.offsetY -= forceY;\n        }\n\n        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n        // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n        // logDebug(s);\n      }\n    };\n\n    /**\n     * @brief : Computes gravity forces for all nodes\n     */\n    var calculateGravityForces = function( layoutInfo, options ){\n      var distThreshold = 1;\n\n      // var s = 'calculateGravityForces';\n      // logDebug(s);\n      for( var i = 0; i < layoutInfo.graphSet.length; i ++ ){\n        var graph    = layoutInfo.graphSet[ i ];\n        var numNodes = graph.length;\n\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n\n        // Compute graph center\n        if( 0 === i ){\n          var centerX   = layoutInfo.clientHeight / 2;\n          var centerY   = layoutInfo.clientWidth  / 2;\n        } else {\n          // Get Parent node for this graph, and use its position as center\n          var temp    = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[0] ] ];\n          var parent  = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ temp.parentId ] ];\n          var centerX = parent.positionX;\n          var centerY = parent.positionY;\n        }\n        // s = \"Center found at: \" + centerX + \", \" + centerY;\n        // logDebug(s);\n\n        // Apply force to all nodes in graph\n        for( var j = 0; j < numNodes; j++ ){\n          var node = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ graph[ j ] ] ];\n          // s = \"Node: \" + node.id;\n\n          if( node.isLocked ){ continue; }\n\n          var dx = centerX - node.positionX;\n          var dy = centerY - node.positionY;\n          var d  = Math.sqrt( dx * dx + dy * dy );\n          if( d > distThreshold ){\n            var fx = options.gravity * dx / d;\n            var fy = options.gravity * dy / d;\n            node.offsetX += fx;\n            node.offsetY += fy;\n            // s += \": Applied force: \" + fx + \", \" + fy;\n          } else {\n            // s += \": skypped since it's too close to center\";\n          }\n          // logDebug(s);\n        }\n      }\n    };\n\n    /**\n     * @brief          : This function propagates the existing offsets from\n     *                   parent nodes to its descendents.\n     * @arg layoutInfo : layoutInfo Object\n     * @arg cy         : cytoscape Object\n     * @arg options    : Layout options\n     */\n    var propagateForces = function( layoutInfo, options ){\n      // Inline implementation of a queue, used for traversing the graph in BFS order\n      var queue = [];\n      var start = 0;   // Points to the start the queue\n      var end   = -1;  // Points to the end of the queue\n\n      // logDebug('propagateForces');\n\n      // Start by visiting the nodes in the root graph\n      queue.push.apply( queue, layoutInfo.graphSet[0] );\n      end += layoutInfo.graphSet[0].length;\n\n      // Traverse the graph, level by level,\n      while( start <= end ){\n        // Get the node to visit and remove it from queue\n        var nodeId    = queue[ start++ ];\n        var nodeIndex = layoutInfo.idToIndex[ nodeId ];\n        var node      = layoutInfo.layoutNodes[ nodeIndex ];\n        var children  = node.children;\n\n        // We only need to process the node if it's compound\n        if( 0 < children.length && !node.isLocked ){\n          var offX = node.offsetX;\n          var offY = node.offsetY;\n\n          // var s = \"Propagating offset from parent node : \" + node.id +\n          //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n          // s += \"\\n Children: \" + children.toString();\n          // logDebug(s);\n\n          for( var i = 0; i < children.length; i++ ){\n            var childNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ children[ i ] ] ];\n            // Propagate offset\n            childNode.offsetX += offX;\n            childNode.offsetY += offY;\n            // Add children to queue to be visited\n            queue[ ++end ] = children[ i ];\n          }\n\n          // Reset parent offsets\n          node.offsetX = 0;\n          node.offsetY = 0;\n        }\n\n      }\n    };\n\n    /**\n     * @brief : Updates the layout model positions, based on\n     *          the accumulated forces\n     */\n    var updatePositions = function( layoutInfo, options ){\n      // var s = 'Updating positions';\n      // logDebug(s);\n\n      // Reset boundaries for compound nodes\n      for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n        var n = layoutInfo.layoutNodes[ i ];\n        if( 0 < n.children.length ){\n          // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n          n.maxX = undefined;\n          n.minX = undefined;\n          n.maxY = undefined;\n          n.minY = undefined;\n        }\n      }\n\n      for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n        var n = layoutInfo.layoutNodes[ i ];\n        if( 0 < n.children.length || n.isLocked ){\n          // No need to set compound or locked node position\n          // logDebug(\"Skipping position update of node: \" + n.id);\n          continue;\n        }\n        // s = \"Node: \" + n.id + \" Previous position: (\" +\n        // n.positionX + \", \" + n.positionY + \").\";\n\n        // Limit displacement in order to improve stability\n        var tempForce = limitForce( n.offsetX, n.offsetY, layoutInfo.temperature );\n        n.positionX += tempForce.x;\n        n.positionY += tempForce.y;\n        n.offsetX = 0;\n        n.offsetY = 0;\n        n.minX    = n.positionX - n.width;\n        n.maxX    = n.positionX + n.width;\n        n.minY    = n.positionY - n.height;\n        n.maxY    = n.positionY + n.height;\n        // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n        // logDebug(s);\n\n        // Update ancestry boudaries\n        updateAncestryBoundaries( n, layoutInfo );\n      }\n\n      // Update size, position of compund nodes\n      for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n        var n = layoutInfo.layoutNodes[ i ];\n        if( 0 < n.children.length && !n.isLocked ){\n          n.positionX = (n.maxX + n.minX) / 2;\n          n.positionY = (n.maxY + n.minY) / 2;\n          n.width     = n.maxX - n.minX;\n          n.height    = n.maxY - n.minY;\n          // s = \"Updating position, size of compound node \" + n.id;\n          // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n          // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n          // logDebug(s);\n        }\n      }\n    };\n\n    /**\n     * @brief : Limits a force (forceX, forceY) to be not\n     *          greater (in modulo) than max.\n     8          Preserves force direction.\n     */\n    var limitForce = function( forceX, forceY, max ){\n      // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n      var force = Math.sqrt( forceX * forceX + forceY * forceY );\n\n      if( force > max ){\n        var res = {\n          x: max * forceX / force,\n          y: max * forceY / force\n        };\n\n      } else {\n        var res = {\n          x: forceX,\n          y: forceY\n        };\n      }\n\n      // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n      // logDebug(s);\n\n      return res;\n    };\n\n    /**\n     * @brief : Function used for keeping track of compound node\n     *          sizes, since they should bound all their subnodes.\n     */\n    var updateAncestryBoundaries = function( node, layoutInfo ){\n      // var s = \"Propagating new position/size of node \" + node.id;\n      var parentId = node.parentId;\n      if( null == parentId ){\n        // If there's no parent, we are done\n        // s += \". No parent node.\";\n        // logDebug(s);\n        return;\n      }\n\n      // Get Parent Node\n      var p = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ parentId ] ];\n      var flag = false;\n\n      // MaxX\n      if( null == p.maxX || node.maxX + p.padRight > p.maxX ){\n        p.maxX = node.maxX + p.padRight;\n        flag = true;\n        // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n      }\n\n      // MinX\n      if( null == p.minX || node.minX - p.padLeft < p.minX ){\n        p.minX = node.minX - p.padLeft;\n        flag = true;\n        // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n      }\n\n      // MaxY\n      if( null == p.maxY || node.maxY + p.padBottom > p.maxY ){\n        p.maxY = node.maxY + p.padBottom;\n        flag = true;\n        // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n      }\n\n      // MinY\n      if( null == p.minY || node.minY - p.padTop < p.minY ){\n        p.minY = node.minY - p.padTop;\n        flag = true;\n        // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n      }\n\n      // If updated boundaries, propagate changes upward\n      if( flag ){\n        // logDebug(s);\n        return updateAncestryBoundaries( p, layoutInfo );\n      }\n\n      // s += \". No changes in boundaries/position of parent node \" + p.id;\n      // logDebug(s);\n      return;\n    };\n\n    var separateComponents = function( layutInfo, options ){\n      var nodes = layoutInfo.layoutNodes;\n      var components = [];\n\n      for( var i = 0; i < nodes.length; i++ ){\n        var node = nodes[ i ];\n        var cid = node.cmptId;\n        var component = components[ cid ] = components[ cid ] || [];\n\n        component.push( node );\n      }\n\n      var totalA = 0;\n\n      for( var i = 0; i < components.length; i++ ){\n        var c = components[ i ];\n\n        if( !c ){ continue; }\n\n        c.x1 = Infinity;\n        c.x2 = -Infinity;\n        c.y1 = Infinity;\n        c.y2 = -Infinity;\n\n        for( var j = 0; j < c.length; j++ ){\n          var n = c[ j ];\n\n          c.x1 = Math.min( c.x1, n.positionX - n.width / 2 );\n          c.x2 = Math.max( c.x2, n.positionX + n.width / 2 );\n          c.y1 = Math.min( c.y1, n.positionY - n.height / 2 );\n          c.y2 = Math.max( c.y2, n.positionY + n.height / 2 );\n        }\n\n        c.w = c.x2 - c.x1;\n        c.h = c.y2 - c.y1;\n\n        totalA += c.w * c.h;\n      }\n\n      components.sort( function( c1, c2 ){\n        return c2.w * c2.h - c1.w * c1.h;\n      } );\n\n      var x = 0;\n      var y = 0;\n      var usedW = 0;\n      var rowH = 0;\n      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n\n      for( var i = 0; i < components.length; i++ ){\n        var c = components[ i ];\n\n        if( !c ){ continue; }\n\n        for( var j = 0; j < c.length; j++ ){\n          var n = c[ j ];\n\n          if( !n.isLocked ){\n            n.positionX += x;\n            n.positionY += y;\n          }\n        }\n\n        x += c.w + options.componentSpacing;\n        usedW += c.w + options.componentSpacing;\n        rowH = Math.max( rowH, c.h );\n\n        if( usedW > maxRowW ){\n          y += rowH + options.componentSpacing;\n          x = 0;\n          usedW = 0;\n          rowH = 0;\n        }\n      }\n    };\n\n    var mainLoop = function( i ){\n      if( stopped ){\n        // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n        return false;\n      }\n\n      // Do one step in the phisical simulation\n      step( layoutInfo, options, i );\n\n      // Update temperature\n      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n      // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n      if( layoutInfo.temperature < options.minTemp ){\n        // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n        return false;\n      }\n\n      return true;\n    };\n\n    var i = 0;\n    var loopRet;\n\n    do {\n      var f = 0;\n\n      while( f < options.refresh && i < options.numIter ){\n        var loopRet = mainLoop( i );\n        if( !loopRet ){ break; }\n\n        f++;\n        i++;\n      }\n\n      if( options.animate ){\n        broadcast( layoutInfo.layoutNodes ); // jshint ignore:line\n      }\n\n    } while( loopRet && i + 1 < options.numIter );\n\n    separateComponents( layoutInfo, options );\n\n    return layoutInfo;\n  } ).then( function( layoutInfoUpdated ){\n    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions\n\n    thread.stop();\n    done();\n  } );\n\n  var done = function(){\n    refresh({\n      force: true,\n      next: function(){\n        // Layout has finished\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n      }\n    });\n  };\n\n  return this; // chaining\n};\n\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\nCoseLayout.prototype.stop = function(){\n  this.stopped = true;\n\n  if( this.thread ){\n    this.thread.stop();\n  }\n\n  this.trigger( 'layoutstop' );\n\n  return this; // chaining\n};\n\nCoseLayout.prototype.destroy = function(){\n  if( this.thread ){\n    this.thread.stop();\n  }\n\n  return this; // chaining\n};\n\n\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */\nvar createLayoutInfo = function( cy, layout, options ){\n  // Shortcut\n  var edges = options.eles.edges();\n  var nodes = options.eles.nodes();\n\n  var layoutInfo   = {\n    isCompound: cy.hasCompoundNodes(),\n    layoutNodes: [],\n    idToIndex: {},\n    nodeSize: nodes.size(),\n    graphSet: [],\n    indexToGraph: [],\n    layoutEdges: [],\n    edgeSize: edges.size(),\n    temperature: options.initialTemp,\n    clientWidth: cy.width(),\n    clientHeight: cy.width(),\n    boundingBox: math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n                     x1: 0, y1: 0, w: cy.width(), h: cy.height()\n                   } )\n  };\n\n  var components = options.eles.components();\n  var id2cmptId = {};\n\n  for( var i = 0; i < components.length; i++ ){\n    var component = components[ i ];\n\n    for( var j = 0; j < component.length; j++ ){\n      var node = component[ j ];\n\n      id2cmptId[ node.id() ] = i;\n    }\n  }\n\n  // Iterate over all nodes, creating layout nodes\n  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n    var n = nodes[ i ];\n    var nbb = n.boundingBox();\n\n    var tempNode        = {};\n    tempNode.isLocked   = n.locked();\n    tempNode.id         = n.data( 'id' );\n    tempNode.parentId   = n.data( 'parent' );\n    tempNode.cmptId     = id2cmptId[ n.id() ];\n    tempNode.children   = [];\n    tempNode.positionX  = n.position( 'x' );\n    tempNode.positionY  = n.position( 'y' );\n    tempNode.offsetX    = 0;\n    tempNode.offsetY    = 0;\n    tempNode.height     = nbb.w;\n    tempNode.width      = nbb.h;\n    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;\n    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;\n    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;\n    tempNode.minY       = tempNode.positionY - tempNode.height / 2;\n    tempNode.padLeft    = parseFloat( n.style( 'padding-left' ) );\n    tempNode.padRight   = parseFloat( n.style( 'padding-right' ) );\n    tempNode.padTop     = parseFloat( n.style( 'padding-top' ) );\n    tempNode.padBottom  = parseFloat( n.style( 'padding-bottom' ) );\n\n    // forces\n    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion.call( n, n ) : options.nodeRepulsion;\n\n    // Add new node\n    layoutInfo.layoutNodes.push( tempNode );\n    // Add entry to id-index map\n    layoutInfo.idToIndex[ tempNode.id ] = i;\n  }\n\n  // Inline implementation of a queue, used for traversing the graph in BFS order\n  var queue = [];\n  var start = 0;   // Points to the start the queue\n  var end   = -1;  // Points to the end of the queue\n\n  var tempGraph = [];\n\n  // Second pass to add child information and\n  // initialize queue for hierarchical traversal\n  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n    var n = layoutInfo.layoutNodes[ i ];\n    var p_id = n.parentId;\n    // Check if node n has a parent node\n    if( null != p_id ){\n      // Add node Id to parent's list of children\n      layoutInfo.layoutNodes[ layoutInfo.idToIndex[ p_id ] ].children.push( n.id );\n    } else {\n      // If a node doesn't have a parent, then it's in the root graph\n      queue[ ++end ] = n.id;\n      tempGraph.push( n.id );\n    }\n  }\n\n  // Add root graph to graphSet\n  layoutInfo.graphSet.push( tempGraph );\n\n  // Traverse the graph, level by level,\n  while( start <= end ){\n    // Get the node to visit and remove it from queue\n    var node_id  = queue[ start++ ];\n    var node_ix  = layoutInfo.idToIndex[ node_id ];\n    var node     = layoutInfo.layoutNodes[ node_ix ];\n    var children = node.children;\n    if( children.length > 0 ){\n      // Add children nodes as a new graph to graph set\n      layoutInfo.graphSet.push( children );\n      // Add children to que queue to be visited\n      for( var i = 0; i < children.length; i++ ){\n        queue[ ++end ] = children[ i ];\n      }\n    }\n  }\n\n  // Create indexToGraph map\n  for( var i = 0; i < layoutInfo.graphSet.length; i++ ){\n    var graph = layoutInfo.graphSet[ i ];\n    for( var j = 0; j < graph.length; j++ ){\n      var index = layoutInfo.idToIndex[ graph[ j ] ];\n      layoutInfo.indexToGraph[ index ] = i;\n    }\n  }\n\n  // Iterate over all edges, creating Layout Edges\n  for( var i = 0; i < layoutInfo.edgeSize; i++ ){\n    var e = edges[ i ];\n    var tempEdge = {};\n    tempEdge.id       = e.data( 'id' );\n    tempEdge.sourceId = e.data( 'source' );\n    tempEdge.targetId = e.data( 'target' );\n\n    // Compute ideal length\n    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength.call( e, e ) : options.idealEdgeLength;\n    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity.call( e, e ) : options.edgeElasticity;\n\n    // Check if it's an inter graph edge\n    var sourceIx    = layoutInfo.idToIndex[ tempEdge.sourceId ];\n    var targetIx    = layoutInfo.idToIndex[ tempEdge.targetId ];\n    var sourceGraph = layoutInfo.indexToGraph[ sourceIx ];\n    var targetGraph = layoutInfo.indexToGraph[ targetIx ];\n\n    if( sourceGraph != targetGraph ){\n      // Find lowest common graph ancestor\n      var lca = findLCA( tempEdge.sourceId, tempEdge.targetId, layoutInfo );\n\n      // Compute sum of node depths, relative to lca graph\n      var lcaGraph = layoutInfo.graphSet[ lca ];\n      var depth    = 0;\n\n      // Source depth\n      var tempNode = layoutInfo.layoutNodes[ sourceIx ];\n      while( -1 === lcaGraph.indexOf( tempNode.id ) ){\n        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];\n        depth++;\n      }\n\n      // Target depth\n      tempNode = layoutInfo.layoutNodes[ targetIx ];\n      while( -1 === lcaGraph.indexOf( tempNode.id ) ){\n        tempNode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ tempNode.parentId ] ];\n        depth++;\n      }\n\n      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n      //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n      //  \". Depth: \" + depth);\n\n      // Update idealLength\n      idealLength *= depth * options.nestingFactor;\n    }\n\n    tempEdge.idealLength = idealLength;\n    tempEdge.elasticity = elasticity;\n\n    layoutInfo.layoutEdges.push( tempEdge );\n  }\n\n  // Finally, return layoutInfo object\n  return layoutInfo;\n};\n\n\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */\nvar findLCA = function( node1, node2, layoutInfo ){\n  // Find their common ancester, starting from the root graph\n  var res = findLCA_aux( node1, node2, 0, layoutInfo );\n  if( 2 > res.count ){\n    // If aux function couldn't find the common ancester,\n    // then it is the root graph\n    return 0;\n  } else {\n    return res.graph;\n  }\n};\n\n\n/**\n * @brief          : Auxiliary function used for LCA computation\n *\n * @arg node1      : node1's ID\n * @arg node2      : node2's ID\n * @arg graphIx    : subgraph index\n * @arg layoutInfo : layoutInfo object\n *\n * @return         : object of the form {count: X, graph: Y}, where:\n *                   X is the number of ancesters (max: 2) found in\n *                   graphIx (and it's subgraphs),\n *                   Y is the graph index of the lowest graph containing\n *                   all X nodes\n */\nvar findLCA_aux = function( node1, node2, graphIx, layoutInfo ){\n  var graph = layoutInfo.graphSet[ graphIx ];\n  // If both nodes belongs to graphIx\n  if( -1 < graph.indexOf( node1 ) && -1 < graph.indexOf( node2 ) ){\n    return {count: 2, graph: graphIx};\n  }\n\n  // Make recursive calls for all subgraphs\n  var c = 0;\n  for( var i = 0; i < graph.length; i++ ){\n    var nodeId   = graph[ i ];\n    var nodeIx   = layoutInfo.idToIndex[ nodeId ];\n    var children = layoutInfo.layoutNodes[ nodeIx ].children;\n\n    // If the node has no child, skip it\n    if( 0 === children.length ){\n      continue;\n    }\n\n    var childGraphIx = layoutInfo.indexToGraph[ layoutInfo.idToIndex[ children[0] ] ];\n    var result = findLCA_aux( node1, node2, childGraphIx, layoutInfo );\n    if( 0 === result.count ){\n      // Neither node1 nor node2 are present in this subgraph\n      continue;\n    } else if( 1 === result.count ){\n      // One of (node1, node2) is present in this subgraph\n      c++;\n      if( 2 === c ){\n        // We've already found both nodes, no need to keep searching\n        break;\n      }\n    } else {\n      // Both nodes are present in this subgraph\n      return result;\n    }\n  }\n\n  return {count: c, graph: graphIx};\n};\n\n\n/**\n * @brief: printsLayoutInfo into js console\n *         Only used for debbuging\n */\nvar printLayoutInfo = function( layoutInfo ){\n  /* jshint ignore:start */\n\n  if( !DEBUG ){\n    return;\n  }\n  console.debug( 'layoutNodes:' );\n  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n    var n = layoutInfo.layoutNodes[ i ];\n    var s =\n    '\\nindex: '     + i +\n    '\\nId: '        + n.id +\n    '\\nChildren: '  + n.children.toString() +\n    '\\nparentId: '  + n.parentId  +\n    '\\npositionX: ' + n.positionX +\n    '\\npositionY: ' + n.positionY +\n    '\\nOffsetX: ' + n.offsetX +\n    '\\nOffsetY: ' + n.offsetY +\n    '\\npadLeft: ' + n.padLeft +\n    '\\npadRight: ' + n.padRight +\n    '\\npadTop: ' + n.padTop +\n    '\\npadBottom: ' + n.padBottom;\n\n    console.debug( s );\n  }\n\n  console.debug( 'idToIndex' );\n  for( var i in layoutInfo.idToIndex ){\n    console.debug( 'Id: ' + i + '\\nIndex: ' + layoutInfo.idToIndex[ i ] );\n  }\n\n  console.debug( 'Graph Set' );\n  var set = layoutInfo.graphSet;\n  for( var i = 0; i < set.length; i ++ ){\n    console.debug( 'Set : ' + i + ': ' + set[ i ].toString() );\n  }\n\n  var s = 'IndexToGraph';\n  for( var i = 0; i < layoutInfo.indexToGraph.length; i ++ ){\n    s += '\\nIndex : ' + i + ' Graph: ' + layoutInfo.indexToGraph[ i ];\n  }\n  console.debug( s );\n\n  s = 'Layout Edges';\n  for( var i = 0; i < layoutInfo.layoutEdges.length; i++ ){\n    var e = layoutInfo.layoutEdges[ i ];\n    s += '\\nEdge Index: ' + i + ' ID: ' + e.id +\n    ' SouceID: ' + e.sourceId + ' TargetId: ' + e.targetId +\n    ' Ideal Length: ' + e.idealLength;\n  }\n  console.debug( s );\n\n  s =  'nodeSize: ' + layoutInfo.nodeSize;\n  s += '\\nedgeSize: ' + layoutInfo.edgeSize;\n  s += '\\ntemperature: ' + layoutInfo.temperature;\n  console.debug( s );\n\n  return;\n  /* jshint ignore:end */\n};\n\n\n/**\n * @brief : Randomizes the position of all nodes\n */\nvar randomizePositions = function( layoutInfo, cy ){\n  var width     = layoutInfo.clientWidth;\n  var height    = layoutInfo.clientHeight;\n\n  for( var i = 0; i < layoutInfo.nodeSize; i++ ){\n    var n = layoutInfo.layoutNodes[ i ];\n\n    // No need to randomize compound nodes or locked nodes\n    if( 0 === n.children.length && !n.isLocked ){\n      n.positionX = Math.random() * width;\n      n.positionY = Math.random() * height;\n    }\n  }\n};\n\n\n/**\n * @brief          : Updates the positions of nodes in the network\n * @arg layoutInfo : LayoutInfo object\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */\nvar refreshPositions = function( layoutInfo, cy, options ){\n  // var s = 'Refreshing positions';\n  // logDebug(s);\n\n  var layout = options.layout;\n  var nodes = options.eles.nodes();\n  var bb = layoutInfo.boundingBox;\n  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n\n  if( options.boundingBox ){\n    nodes.forEach( function( node ){\n      var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ node.data( 'id' ) ] ];\n\n      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );\n      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );\n\n      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );\n      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );\n    } );\n\n    coseBB.w = coseBB.x2 - coseBB.x1;\n    coseBB.h = coseBB.y2 - coseBB.y1;\n  }\n\n  nodes.positions( function( i, ele ){\n    var lnode = layoutInfo.layoutNodes[ layoutInfo.idToIndex[ ele.data( 'id' ) ] ];\n    // s = \"Node: \" + lnode.id + \". Refreshed position: (\" +\n    // lnode.positionX + \", \" + lnode.positionY + \").\";\n    // logDebug(s);\n\n    if( options.boundingBox ){ // then add extra bounding box constraint\n      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n\n      return {\n        x: bb.x1 + pctX * bb.w,\n        y: bb.y1 + pctY * bb.h\n      };\n    } else {\n      return {\n        x: lnode.positionX,\n        y: lnode.positionY\n      };\n    }\n  } );\n\n  // Trigger layoutReady only on first call\n  if( true !== layoutInfo.ready ){\n    // s = 'Triggering layoutready';\n    // logDebug(s);\n    layoutInfo.ready = true;\n    layout.one( 'layoutready', options.ready );\n    layout.trigger( { type: 'layoutready', layout: this } );\n  }\n};\n\n/**\n * @brief : Logs a debug message in JS console, if DEBUG is ON\n */\n// var logDebug = function(text) {\n//   if (DEBUG) {\n//     console.debug(text);\n//   }\n// };\n\nmodule.exports = CoseLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/cose.js\n ** module id = 102\n ** module chunks = 0\n **/","/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n\n// cross-env thread/worker\n// NB : uses (heavyweight) processes on nodejs so best not to create too many threads\n\n'use strict';\n\nvar window = require('./window');\nvar util = require('./util');\nvar Promise = require('./promise');\nvar Event = require('./event');\nvar define = require('./define');\nvar is = require('./is');\n\nvar Thread = function( opts ){\n  if( !(this instanceof Thread) ){\n    return new Thread( opts );\n  }\n\n  var _p = this._private = {\n    requires: [],\n    files: [],\n    queue: null,\n    pass: [],\n    disabled: false\n  };\n\n  if( is.plainObject(opts) ){\n    if( opts.disabled != null ){\n      _p.disabled = !!opts.disabled;\n    }\n  }\n\n};\n\nvar thdfn = Thread.prototype; // short alias\n\nvar stringifyFieldVal = function( val ){\n  var valStr = is.fn( val ) ? val.toString() : \"JSON.parse('\" + JSON.stringify(val) + \"')\";\n\n  return valStr;\n};\n\n// allows for requires with prototypes and subobjs etc\nvar fnAsRequire = function( fn ){\n  var req;\n  var fnName;\n\n  if( is.object(fn) && fn.fn ){ // manual fn\n    req = fnAs( fn.fn, fn.name );\n    fnName = fn.name;\n    fn = fn.fn;\n  } else if( is.fn(fn) ){ // auto fn\n    req = fn.toString();\n    fnName = fn.name;\n  } else if( is.string(fn) ){ // stringified fn\n    req = fn;\n  } else if( is.object(fn) ){ // plain object\n    if( fn.proto ){\n      req = '';\n    } else {\n      req = fn.name + ' = {};';\n    }\n\n    fnName = fn.name;\n    fn = fn.obj;\n  }\n\n  req += '\\n';\n\n  var protoreq = function( val, subname ){\n    if( val.prototype ){\n      var protoNonempty = false;\n      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line\n\n      if( protoNonempty ){\n        req += fnAsRequire( {\n          name: subname,\n          obj: val,\n          proto: true\n        }, val );\n      }\n    }\n  };\n\n  // pull in prototype\n  if( fn.prototype && fnName != null ){\n\n    for( var name in fn.prototype ){\n      var protoStr = '';\n\n      var val = fn.prototype[ name ];\n      var valStr = stringifyFieldVal( val );\n      var subname = fnName + '.prototype.' + name;\n\n      protoStr += subname + ' = ' + valStr + ';\\n';\n\n      if( protoStr ){\n        req += protoStr;\n      }\n\n      protoreq( val, subname ); // subobject with prototype\n    }\n\n  }\n\n  // pull in properties for obj/fns\n  if( !is.string(fn) ){ for( var name in fn ){\n    var propsStr = '';\n\n    if( fn.hasOwnProperty(name) ){\n      var val = fn[ name ];\n      var valStr = stringifyFieldVal( val );\n      var subname = fnName + '[\"' + name + '\"]';\n\n      propsStr += subname + ' = ' + valStr + ';\\n';\n    }\n\n    if( propsStr ){\n      req += propsStr;\n    }\n\n    protoreq( val, subname ); // subobject with prototype\n  } }\n\n  return req;\n};\n\nvar isPathStr = function( str ){\n  return is.string(str) && str.match(/\\.js$/);\n};\n\nutil.extend(thdfn, {\n\n  instanceString: function(){ return 'thread'; },\n\n  require: function( fn, as ){\n    var requires = this._private.requires;\n\n    if( isPathStr(fn) ){\n      this._private.files.push( fn );\n\n      return this;\n    }\n\n    if( as ){\n      if( is.fn(fn) ){\n        fn = { name: as, fn: fn };\n      } else {\n        fn = { name: as, obj: fn };\n      }\n    } else {\n      if( is.fn(fn) ){\n        if( !fn.name ){\n          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, \"someFunction\" )';\n        }\n\n        fn = { name: fn.name, fn: fn };\n      }\n    }\n\n    requires.push( fn );\n\n    return this; // chaining\n  },\n\n  pass: function( data ){\n    this._private.pass.push( data );\n\n    return this; // chaining\n  },\n\n  run: function( fn, pass ){ // fn used like main()\n    var self = this;\n    var _p = this._private;\n    pass = pass || _p.pass.shift();\n\n    if( _p.stopped ){\n      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';\n    }\n\n    if( _p.running ){\n      return ( _p.queue = _p.queue.then(function(){ // inductive step\n        return self.run( fn, pass );\n      }) );\n    }\n\n    var useWW = window != null && !_p.disabled;\n    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;\n\n    self.trigger('run');\n\n    var runP = new Promise(function( resolve, reject ){\n\n      _p.running = true;\n\n      var threadTechAlreadyExists = _p.ran;\n\n      var fnImplStr = is.string( fn ) ? fn : fn.toString();\n\n      // worker code to exec\n      var fnStr = '\\n' + ( _p.requires.map(function( r ){\n        return fnAsRequire( r );\n      }) ).concat( _p.files.map(function( f ){\n        if( useWW ){\n          var wwifyFile = function( file ){\n            if( file.match(/^\\.\\//) || file.match(/^\\.\\./) ){\n              return window.location.origin + window.location.pathname + file;\n            } else if( file.match(/^\\//) ){\n              return window.location.origin + '/' + file;\n            }\n            return file;\n          };\n\n          return 'importScripts(\"' + wwifyFile(f) + '\");';\n        } else if( useNode ) {\n          return 'eval( require(\"fs\").readFileSync(\"' + f + '\", { encoding: \"utf8\" }) );';\n        } else {\n          throw 'External file `' + f + '` can not be required without any threading technology.';\n        }\n      }) ).concat([\n        '( function(){',\n          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',\n          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it\n        '} )()\\n'\n      ]).join('\\n');\n\n      // because we've now consumed the requires, empty the list so we don't dupe on next run()\n      _p.requires = [];\n      _p.files = [];\n\n      if( useWW ){\n        var fnBlob, fnUrl;\n\n        // add normalised thread api functions\n        if( !threadTechAlreadyExists ){\n          var fnPre = fnStr + '';\n\n          fnStr = [\n            'function _ref_(o){ return eval(o); };',\n            'function broadcast(m){ return message(m); };', // alias\n            'function message(m){ postMessage(m); };',\n            'function listen(fn){',\n            '  self.addEventListener(\"message\", function(m){ ',\n            '    if( typeof m === \"object\" && (m.data.$$eval || m.data === \"$$start\") ){',\n            '    } else { ',\n            '      fn( m.data );',\n            '    }',\n            '  });',\n            '};',\n            'self.addEventListener(\"message\", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',\n            'function resolve(v){ postMessage({ $$resolve: v }); };',\n            'function reject(v){ postMessage({ $$reject: v }); };'\n          ].join('\\n');\n\n          fnStr += fnPre;\n\n          fnBlob = new Blob([ fnStr ], {\n            type: 'application/javascript'\n          });\n          fnUrl = window.URL.createObjectURL( fnBlob );\n        }\n        // create webworker and let it exec the serialised code\n        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );\n\n        if( threadTechAlreadyExists ){ // then just exec new run() code\n          ww.postMessage({\n            $$eval: fnStr\n          });\n        }\n\n        // worker messages => events\n        var cb;\n        ww.addEventListener('message', cb = function( m ){\n          var isObject = is.object(m) && is.object( m.data );\n\n          if( isObject && ('$$resolve' in m.data) ){\n            ww.removeEventListener('message', cb); // done listening b/c resolve()\n\n            resolve( m.data.$$resolve );\n          } else if( isObject && ('$$reject' in m.data) ){\n            ww.removeEventListener('message', cb); // done listening b/c reject()\n\n            reject( m.data.$$reject );\n          } else {\n            self.trigger( new Event(m, { type: 'message', message: m.data }) );\n          }\n        }, false);\n\n        if( !threadTechAlreadyExists ){\n          ww.postMessage('$$start'); // start up the worker\n        }\n\n      } else if( useNode ){\n        // create a new process\n\n        if( !_p.child ){\n          _p.child = ( require('child_process').fork( require('path').join(__dirname, 'thread-node-fork') ) );\n        }\n\n        var child = _p.child;\n\n        // child process messages => events\n        var cb;\n        child.on('message', cb = function( m ){\n          if( is.object(m) && ('$$resolve' in m) ){\n            child.removeListener('message', cb); // done listening b/c resolve()\n\n            resolve( m.$$resolve );\n          } else if( is.object(m) && ('$$reject' in m) ){\n            child.removeListener('message', cb); // done listening b/c reject()\n\n            reject( m.$$reject );\n          } else {\n            self.trigger( new Event({}, { type: 'message', message: m }) );\n          }\n        });\n\n        // ask the child process to eval the worker code\n        child.send({\n          $$eval: fnStr\n        });\n\n      } else { // use a fallback mechanism using a timeout\n\n        var promiseResolve = resolve;\n        var promiseReject = reject;\n\n        var timer = _p.timer = _p.timer || {\n\n          listeners: [],\n\n          exec: function(){\n            // as a string so it can't be mangled by minifiers and processors\n            fnStr = [\n              'function _ref_(o){ return eval(o); };',\n              'function broadcast(m){ return message(m); };',\n              'function message(m){ self.trigger( new Event({}, { type: \"message\", message: m }) ); };',\n              'function listen(fn){ timer.listeners.push( fn ); };',\n              'function resolve(v){ promiseResolve(v); };',\n              'function reject(v){ promiseReject(v); };'\n            ].join('\\n') + fnStr;\n\n            // the .run() code\n            eval( fnStr ); // jshint ignore:line\n          },\n\n          message: function( m ){\n            var ls = timer.listeners;\n\n            for( var i = 0; i < ls.length; i++ ){\n              var fn = ls[i];\n\n              fn( m );\n            }\n          }\n\n        };\n\n        timer.exec();\n      }\n\n    }).then(function( v ){\n      _p.running = false;\n      _p.ran = true;\n\n      self.trigger('ran');\n\n      return v;\n    });\n\n    if( _p.queue == null ){\n      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)\n    }\n\n    return runP;\n  },\n\n  // send the thread a message\n  message: function( m ){\n    var _p = this._private;\n\n    if( _p.webworker ){\n      _p.webworker.postMessage( m );\n    }\n\n    if( _p.child ){\n      _p.child.send( m );\n    }\n\n    if( _p.timer ){\n      _p.timer.message( m );\n    }\n\n    return this; // chaining\n  },\n\n  stop: function(){\n    var _p = this._private;\n\n    if( _p.webworker ){\n      _p.webworker.terminate();\n    }\n\n    if( _p.child ){\n      _p.child.kill();\n    }\n\n    if( _p.timer ){\n      // nothing we can do if we've run a timeout\n    }\n\n    _p.stopped = true;\n\n    return this.trigger('stop'); // chaining\n  },\n\n  stopped: function(){\n    return this._private.stopped;\n  }\n\n});\n\n// turns a stringified function into a (re)named function\nvar fnAs = function( fn, name ){\n  var fnStr = fn.toString();\n  fnStr = fnStr.replace(/function\\s*?\\S*?\\s*?\\(/, 'function ' + name + '(');\n\n  return fnStr;\n};\n\nvar defineFnal = function( opts ){\n  opts = opts || {};\n\n  return function fnalImpl( fn, arg1 ){\n    var fnStr = fnAs( fn, '_$_$_' + opts.name );\n\n    this.require( fnStr );\n\n    return this.run( [\n      'function( data ){',\n      '  var origResolve = resolve;',\n      '  var res = [];',\n      '  ',\n      '  resolve = function( val ){',\n      '    res.push( val );',\n      '  };',\n      '  ',\n      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',\n      '  ',\n      '  resolve = origResolve;',\n      '  resolve( res.length > 0 ? res : ret );',\n      '}'\n    ].join('\\n') );\n  };\n};\n\nutil.extend(thdfn, {\n  reduce: defineFnal({ name: 'reduce' }),\n\n  reduceRight: defineFnal({ name: 'reduceRight' }),\n\n  map: defineFnal({ name: 'map' })\n});\n\n// aliases\nvar fn = thdfn;\nfn.promise = fn.run;\nfn.terminate = fn.halt = fn.stop;\nfn.include = fn.require;\n\n// pull in event apis\nutil.extend(thdfn, {\n  on: define.on(),\n  one: define.on({ unbindSelfOnTrigger: true }),\n  off: define.off(),\n  trigger: define.trigger()\n});\n\ndefine.eventAliasesOn( thdfn );\n\nmodule.exports = Thread;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/thread.js\n ** module id = 103\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/path-browserify/index.js\n ** module id = 105\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\nvar math = require( '../../math' );\n\nvar defaults = {\n  fit: true, // whether to fit the viewport to the graph\n  padding: 30, // padding used on fit\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true\n  condense: false, // uses all available space on false, uses minimal space on true\n  rows: undefined, // force num of rows in the grid\n  cols: undefined, // force num of columns in the grid\n  position: function( node ){}, // returns { row, col } for element\n  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  ready: undefined, // callback on layoutready\n  stop: undefined // callback on layoutstop\n};\n\nfunction GridLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\nGridLayout.prototype.run = function(){\n  var params = this.options;\n  var options = params;\n\n  var cy = params.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not( ':parent' );\n\n  if( options.sort ){\n    nodes = nodes.sort( options.sort );\n  }\n\n  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  } );\n\n  if( bb.h === 0 || bb.w === 0 ){\n    nodes.layoutPositions( this, options, function(){\n      return { x: bb.x1, y: bb.y1 };\n    } );\n\n  } else {\n\n    // width/height * splits^2 = cells where splits is number of times to split width\n    var cells = nodes.size();\n    var splits = Math.sqrt( cells * bb.h / bb.w );\n    var rows = Math.round( splits );\n    var cols = Math.round( bb.w / bb.h * splits );\n\n    var small = function( val ){\n      if( val == null ){\n        return Math.min( rows, cols );\n      } else {\n        var min = Math.min( rows, cols );\n        if( min == rows ){\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    var large = function( val ){\n      if( val == null ){\n        return Math.max( rows, cols );\n      } else {\n        var max = Math.max( rows, cols );\n        if( max == rows ){\n          rows = val;\n        } else {\n          cols = val;\n        }\n      }\n    };\n\n    var oRows = options.rows;\n    var oCols = options.cols != null ? options.cols : options.columns;\n\n    // if rows or columns were set in options, use those values\n    if( oRows != null && oCols != null ){\n      rows = oRows;\n      cols = oCols;\n    } else if( oRows != null && oCols == null ){\n      rows = oRows;\n      cols = Math.ceil( cells / rows );\n    } else if( oRows == null && oCols != null ){\n      cols = oCols;\n      rows = Math.ceil( cells / cols );\n    }\n\n    // otherwise use the automatic values and adjust accordingly\n\n    // if rounding was up, see if we can reduce rows or columns\n    else if( cols * rows > cells ){\n      var sm = small();\n      var lg = large();\n\n      // reducing the small side takes away the most cells, so try it first\n      if( (sm - 1) * lg >= cells ){\n        small( sm - 1 );\n      } else if( (lg - 1) * sm >= cells ){\n        large( lg - 1 );\n      }\n    } else {\n\n      // if rounding was too low, add rows or columns\n      while( cols * rows < cells ){\n        var sm = small();\n        var lg = large();\n\n        // try to add to larger side first (adds less in multiplication)\n        if( (lg + 1) * sm >= cells ){\n          large( lg + 1 );\n        } else {\n          small( sm + 1 );\n        }\n      }\n    }\n\n    var cellWidth = bb.w / cols;\n    var cellHeight = bb.h / rows;\n\n    if( options.condense ){\n      cellWidth = 0;\n      cellHeight = 0;\n    }\n\n    if( options.avoidOverlap ){\n      for( var i = 0; i < nodes.length; i++ ){\n        var node = nodes[ i ];\n        var pos = node._private.position;\n\n        if( pos.x == null || pos.y == null ){ // for bb\n          pos.x = 0;\n          pos.y = 0;\n        }\n\n        var nbb = node.boundingBox();\n        var p = options.avoidOverlapPadding;\n\n        var w = nbb.w + p;\n        var h = nbb.h + p;\n\n        cellWidth = Math.max( cellWidth, w );\n        cellHeight = Math.max( cellHeight, h );\n      }\n    }\n\n    var cellUsed = {}; // e.g. 'c-0-2' => true\n\n    var used = function( row, col ){\n      return cellUsed[ 'c-' + row + '-' + col ] ? true : false;\n    };\n\n    var use = function( row, col ){\n      cellUsed[ 'c-' + row + '-' + col ] = true;\n    };\n\n    // to keep track of current cell position\n    var row = 0;\n    var col = 0;\n    var moveToNextCell = function(){\n      col++;\n      if( col >= cols ){\n        col = 0;\n        row++;\n      }\n    };\n\n    // get a cache of all the manual positions\n    var id2manPos = {};\n    for( var i = 0; i < nodes.length; i++ ){\n      var node = nodes[ i ];\n      var rcPos = options.position( node );\n\n      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd\n        var pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if( pos.col === undefined ){ // find unused col\n          pos.col = 0;\n\n          while( used( pos.row, pos.col ) ){\n            pos.col++;\n          }\n        } else if( pos.row === undefined ){ // find unused row\n          pos.row = 0;\n\n          while( used( pos.row, pos.col ) ){\n            pos.row++;\n          }\n        }\n\n        id2manPos[ node.id() ] = pos;\n        use( pos.row, pos.col );\n      }\n    }\n\n    var getPos = function( i, element ){\n      var x, y;\n\n      if( element.locked() || element.isFullAutoParent() ){\n        return false;\n      }\n\n      // see if we have a manual position set\n      var rcPos = id2manPos[ element.id() ];\n      if( rcPos ){\n        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n\n      } else { // otherwise set automatically\n\n        while( used( row, col ) ){\n          moveToNextCell();\n        }\n\n        x = col * cellWidth + cellWidth / 2 + bb.x1;\n        y = row * cellHeight + cellHeight / 2 + bb.y1;\n        use( row, col );\n\n        moveToNextCell();\n      }\n\n      return { x: x, y: y };\n\n    };\n\n    nodes.layoutPositions( this, options, getPos );\n  }\n\n  return this; // chaining\n\n};\n\nmodule.exports = GridLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/grid.js\n ** module id = 106\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\n\n// default layout options\nvar defaults = {\n  ready: function(){}, // on layoutready\n  stop: function(){} // on layoutstop\n};\n\n// constructor\n// options : object containing layout options\nfunction NullLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\n// runs the layout\nNullLayout.prototype.run = function(){\n  var options = this.options;\n  var eles = options.eles; // elements to consider in the layout\n  var layout = this;\n\n  // cy is automatically populated for us in the constructor\n  var cy = options.cy; // jshint ignore:line\n\n  layout.trigger( 'layoutstart' );\n\n  // puts all nodes at (0, 0)\n  eles.nodes().positions( function(){\n    return {\n      x: 0,\n      y: 0\n    };\n  } );\n\n  // trigger layoutready when each node has had its position set at least once\n  layout.one( 'layoutready', options.ready );\n  layout.trigger( 'layoutready' );\n\n  // trigger layoutstop when the layout stops (e.g. finishes)\n  layout.one( 'layoutstop', options.stop );\n  layout.trigger( 'layoutstop' );\n\n  return this; // chaining\n};\n\n// called on continuous layouts to stop them before they finish\nNullLayout.prototype.stop = function(){\n  return this; // chaining\n};\n\nmodule.exports = NullLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/null.js\n ** module id = 107\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\nvar is = require( '../../is' );\n\nvar defaults = {\n  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }\n  zoom: undefined, // the zoom level to set (prob want fit = false if set)\n  pan: undefined, // the pan level to set (prob want fit = false if set)\n  fit: true, // whether to fit to viewport\n  padding: 30, // padding on fit\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  ready: undefined, // callback on layoutready\n  stop: undefined // callback on layoutstop\n};\n\nfunction PresetLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\nPresetLayout.prototype.run = function(){\n  var options = this.options;\n  var eles = options.eles;\n\n  var nodes = eles.nodes();\n  var posIsFn = is.fn( options.positions );\n\n  function getPosition( node ){\n    if( options.positions == null ){\n      return null;\n    }\n\n    if( posIsFn ){\n      return options.positions.apply( node, [ node ] );\n    }\n\n    var pos = options.positions[ node._private.data.id ];\n\n    if( pos == null ){\n      return null;\n    }\n\n    return pos;\n  }\n\n  nodes.layoutPositions( this, options, function( i, node ){\n    var position = getPosition( node );\n\n    if( node.locked() || position == null ){\n      return false;\n    }\n\n    return position;\n  } );\n\n  return this; // chaining\n};\n\nmodule.exports = PresetLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/preset.js\n ** module id = 108\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../util' );\nvar math = require( '../../math' );\n\nvar defaults = {\n  fit: true, // whether to fit to viewport\n  padding: 30, // fit padding\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  animate: false, // whether to transition the node positions\n  animationDuration: 500, // duration of animation in ms if enabled\n  animationEasing: undefined, // easing of animation if enabled\n  ready: undefined, // callback on layoutready\n  stop: undefined // callback on layoutstop\n};\n\nfunction RandomLayout( options ){\n  this.options = util.extend( {}, defaults, options );\n}\n\nRandomLayout.prototype.run = function(){\n  var options = this.options;\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes().not( ':parent' );\n\n  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n    x1: 0, y1: 0, w: cy.width(), h: cy.height()\n  } );\n\n  var getPos = function( i, node ){\n    return {\n      x: bb.x1 + Math.round( Math.random() * bb.w ),\n      y: bb.y1 + Math.round( Math.random() * bb.h )\n    };\n  };\n\n  nodes.layoutPositions( this, options, getPos );\n\n  return this; // chaining\n};\n\nmodule.exports = RandomLayout;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/layout/random.js\n ** module id = 109\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = [\n  { name: 'null', impl: require( './null' ) },\n  { name: 'base', impl: require( './base' ) },\n  { name: 'canvas', impl: require( './canvas' ) }\n];\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/index.js\n ** module id = 110\n ** module chunks = 0\n **/","'use strict';\n\nfunction NullRenderer( options ){\n  this.options = options;\n  this.notifications = 0; // for testing\n}\n\nvar noop = function(){};\n\nNullRenderer.prototype = {\n  recalculateRenderedStyle: noop,\n  notify: function(){ this.notifications++; },\n  init: noop\n};\n\nmodule.exports = NullRenderer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/null/index.js\n ** module id = 111\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../../is' );\nvar util = require( '../../../util' );\n\nvar BaseRenderer = function( options ){ this.init( options ); };\nvar BR = BaseRenderer;\nvar BRp = BR.prototype;\n\nBRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];\n\nBRp.init = function( options ){\n  var r = this;\n\n  r.options = options;\n\n  r.cy = options.cy;\n\n  r.container = options.cy.container();\n\n  r.selection = [ undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\n  r.bezierProjPcts = [ 0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95 ];\n\n  //--Pointer-related data\n  r.hoverData = {down: null, last: null,\n      downTime: null, triggerMode: null,\n      dragging: false,\n      initialPan: [ null, null ], capture: false};\n\n  r.dragData = {possibleDragElements: []};\n\n  r.touchData = {\n    start: null, capture: false,\n\n    // These 3 fields related to tap, taphold events\n    startPosition: [ null, null, null, null, null, null ],\n    singleTouchStartTime: null,\n    singleTouchMoved: true,\n\n    now: [ null, null, null, null, null, null ],\n    earlier: [ null, null, null, null, null, null ]\n  };\n\n  r.redraws = 0;\n  r.showFps = options.showFps;\n\n  r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n  r.hideLabelsOnViewport = options.hideLabelsOnViewport;\n  r.textureOnViewport = options.textureOnViewport;\n  r.wheelSensitivity = options.wheelSensitivity;\n  r.motionBlurEnabled = options.motionBlur; // on by default\n  r.forcedPixelRatio = options.pixelRatio;\n  r.motionBlur = options.motionBlur; // for initial kick off\n  r.motionBlurOpacity = options.motionBlurOpacity;\n  r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n  r.motionBlurPxRatio = 1;\n  r.mbPxRBlurry = 1; //0.8;\n  r.minMbLowQualFrames = 4;\n  r.fullQualityMb = false;\n  r.clearedForMotionBlur = [];\n  r.desktopTapThreshold = options.desktopTapThreshold;\n  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n  r.touchTapThreshold = options.touchTapThreshold;\n  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n  r.tapholdDuration = 500;\n\n  r.bindings = [];\n  r.beforeRenderCallbacks = [];\n  r.beforeRenderPriorities = { // higher priority execs before lower one\n    animations:   400,\n    eleCalcs:     300,\n    eleTxrDeq:    200,\n    lyrTxrDeq:    100\n  };\n\n  r.registerNodeShapes();\n  r.registerArrowShapes();\n  r.registerCalculationListeners();\n  r.load();\n};\n\nBRp.notify = function( params ){\n  var types;\n  var r = this;\n\n  if( is.array( params.type ) ){\n    types = params.type;\n\n  } else {\n    types = [ params.type ];\n  }\n\n  var has = {};\n  for( var i = 0; i < types.length; i++ ){\n    var type = types[ i ];\n\n    has[ type ] = true;\n  } // for\n\n  if( has['destroy'] ){\n    r.destroy();\n    return;\n  }\n\n  if( has['add'] || has['remove'] || has['load'] || has['style'] ){\n    r.updateCachedZSortedEles();\n  }\n\n  if( has['viewport'] ){\n    r.redrawHint( 'select', true );\n  }\n\n  if( has['load'] || has['resize'] ){\n    r.invalidateContainerClientCoordsCache();\n    r.matchCanvasSize( r.container );\n  }\n\n  r.redrawHint( 'eles', true );\n  r.redrawHint( 'drag', true );\n\n  this.startRenderLoop();\n\n  this.redraw();\n};\n\nBRp.destroy = function(){\n  var r = this;\n\n  r.destroyed = true;\n\n  r.cy.stopAnimationLoop();\n\n  for( var i = 0; i < r.bindings.length; i++ ){\n    var binding = r.bindings[ i ];\n    var b = binding;\n    var tgt = b.target;\n\n    ( tgt.off || tgt.removeEventListener ).apply( tgt, b.args );\n  }\n\n  if( r.removeObserver ){\n    r.removeObserver.disconnect();\n  }\n\n  if( r.styleObserver ){\n    r.styleObserver.disconnect();\n  }\n\n  if( r.labelCalcDiv ){\n    try {\n      document.body.removeChild( r.labelCalcDiv );\n    } catch( e ){\n      // ie10 issue #1014\n    }\n  }\n};\n\n[\n  require( './arrow-shapes' ),\n  require( './coord-ele-math' ),\n  require( './images' ),\n  require( './load-listeners' ),\n  require( './node-shapes' ),\n  require( './redraw' )\n].forEach( function( props ){\n  util.extend( BRp, props );\n} );\n\nmodule.exports = BR;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/base/index.js\n ** module id = 112\n ** module chunks = 0\n **/","'use strict';\n\nvar math = require( '../../../math' );\nvar is = require( '../../../is' );\nvar util = require( '../../../util' );\n\nvar BRp = {};\n\nBRp.arrowShapeWidth = 0.3;\n\nBRp.registerArrowShapes = function(){\n  var arrowShapes = this.arrowShapes = {};\n  var renderer = this;\n\n  // Contract for arrow shapes:\n  // 0, 0 is arrow tip\n  // (0, 1) is direction towards node\n  // (1, 0) is right\n  //\n  // functional api:\n  // collide: check x, y in shape\n  // roughCollide: called before collide, no false negatives\n  // draw: draw\n  // spacing: dist(arrowTip, nodeBoundary)\n  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n  var bbCollide = function( x, y, size, angle, translation, padding ){\n    var x1 = translation.x - size / 2 - padding;\n    var x2 = translation.x + size / 2 + padding;\n    var y1 = translation.y - size / 2 - padding;\n    var y2 = translation.y + size / 2 + padding;\n\n    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);\n\n    return inside;\n  };\n\n  var transform = function( x, y, size, angle, translation ){\n    var xRotated = x * Math.cos( angle ) - y * Math.sin( angle );\n    var yRotated = x * Math.sin( angle ) + y * Math.cos( angle );\n\n    var xScaled = xRotated * size;\n    var yScaled = yRotated * size;\n\n    var xTranslated = xScaled + translation.x;\n    var yTranslated = yScaled + translation.y;\n\n    return {\n      x: xTranslated,\n      y: yTranslated\n    };\n  };\n\n  var transformPoints = function( pts, size, angle, translation ){\n    var retPts = [];\n\n    for( var i = 0; i < pts.length; i += 2 ){\n      var x = pts[ i ];\n      var y = pts[ i + 1];\n\n      retPts.push( transform( x, y, size, angle, translation ) );\n    }\n\n    return retPts;\n  };\n\n  var pointsToArr = function( pts ){\n    var ret = [];\n\n    for( var i = 0; i < pts.length; i++ ){\n      var p = pts[ i ];\n\n      ret.push( p.x, p.y );\n    }\n\n    return ret;\n  };\n\n  var defineArrowShape = function( name, defn ){\n    if( is.string( defn ) ){\n      defn = arrowShapes[ defn ];\n    }\n\n    arrowShapes[ name ] = util.extend( {\n      name: name,\n\n      points: [\n        -0.15, -0.3,\n        0.15, -0.3,\n        0.15, 0.3,\n        -0.15, 0.3\n      ],\n\n      collide: function( x, y, size, angle, translation, padding ){\n        var points = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );\n        var inside = math.pointInsidePolygonPoints( x, y, points );\n\n        return inside;\n      },\n\n      roughCollide: bbCollide,\n\n      draw: function( context, size, angle, translation ){\n        var points = transformPoints( this.points, size, angle, translation );\n\n        renderer.arrowShapeImpl( 'polygon' )( context, points );\n      },\n\n      spacing: function( edge ){\n        return 0;\n      },\n\n      gap: function( edge ){\n        return edge.pstyle( 'width' ).pfValue * 2;\n      }\n    }, defn );\n  };\n\n  defineArrowShape( 'none', {\n    collide: util.falsify,\n\n    roughCollide: util.falsify,\n\n    draw: util.noop,\n\n    spacing: util.zeroify,\n\n    gap: util.zeroify\n  } );\n\n  defineArrowShape( 'triangle', {\n    points: [\n      -0.15, -0.3,\n      0, 0,\n      0.15, -0.3\n    ]\n  } );\n\n  defineArrowShape( 'arrow', 'triangle' );\n\n  defineArrowShape( 'triangle-backcurve', {\n    points: arrowShapes[ 'triangle' ].points,\n\n    controlPoint: [ 0, -0.15 ],\n\n    roughCollide: bbCollide,\n\n    draw: function( context, size, angle, translation ){\n      var ptsTrans = transformPoints( this.points, size, angle, translation );\n      var ctrlPt = this.controlPoint;\n      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );\n\n      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );\n    },\n\n    gap: function( edge ){\n      return edge.pstyle( 'width' ).pfValue;\n    }\n  } );\n\n\n  defineArrowShape( 'triangle-tee', {\n    points: [\n      -0.15, -0.3,\n      0, 0,\n      0.15, -0.3,\n      -0.15, -0.3\n    ],\n\n    pointsTee: [\n      -0.15, -0.4,\n      -0.15, -0.5,\n      0.15, -0.5,\n      0.15, -0.4\n    ],\n\n    collide: function( x, y, size, angle, translation, padding ){\n      var triPts = pointsToArr( transformPoints( this.points, size + 2 * padding, angle, translation ) );\n      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2 * padding, angle, translation ) );\n\n      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );\n\n      return inside;\n    },\n\n    draw: function( context, size, angle, translation ){\n      var triPts = transformPoints( this.points, size, angle, translation );\n      var teePts = transformPoints( this.pointsTee, size, angle, translation );\n\n      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );\n    }\n  } );\n\n  defineArrowShape( 'vee', {\n    points: [\n      -0.15, -0.3,\n      0, 0,\n      0.15, -0.3,\n      0, -0.15\n    ],\n\n    gap: function( edge ){\n      return edge.pstyle( 'width' ).pfValue;\n    }\n  } );\n\n  defineArrowShape( 'circle', {\n    radius: 0.15,\n\n    collide: function( x, y, size, angle, translation, padding ){\n      var t = translation;\n      var inside = ( Math.pow( t.x - x, 2 ) + Math.pow( t.y - y, 2 ) <= Math.pow( (size + 2 * padding) * this.radius, 2 ) );\n\n      return inside;\n    },\n\n    draw: function( context, size, angle, translation ){\n      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );\n    },\n\n    spacing: function( edge ){\n      return renderer.getArrowWidth( edge.pstyle( 'width' ).pfValue )\n        * this.radius;\n    }\n  } );\n\n  defineArrowShape( 'inhibitor', {\n    points: [\n      -0.15, 0,\n      -0.15, -0.1,\n      0.15, -0.1,\n      0.15, 0\n    ],\n\n    spacing: function( edge ){\n      return 1;\n    },\n\n    gap: function( edge ){\n      return 1;\n    }\n  } );\n\n  defineArrowShape( 'tee', 'inhibitor' );\n\n  defineArrowShape( 'square', {\n    points: [\n      -0.15, 0.00,\n      0.15, 0.00,\n      0.15, -0.3,\n      -0.15, -0.3\n    ]\n  } );\n\n  defineArrowShape( 'diamond', {\n    points: [\n      -0.15, -0.15,\n      0, -0.3,\n      0.15, -0.15,\n      0, 0\n    ],\n\n    gap: function( edge ){\n      return edge.pstyle( 'width' ).pfValue;\n    }\n  } );\n\n};\n\nmodule.exports = BRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/base/arrow-shapes.js\n ** module id = 113\n ** module chunks = 0\n **/","'use strict';\n\nvar math = require( '../../../math' );\nvar is = require( '../../../is' );\nvar util = require( '../../../util' );\nvar zIndexSort = require( '../../../collection/zsort' );\n\nvar BRp = {};\n\nBRp.registerCalculationListeners = function(){\n  var cy = this.cy;\n  var elesToUpdate = cy.collection();\n  var r = this;\n\n  var enqueue = function( eles, e ){\n    elesToUpdate.merge( eles );\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[i];\n      var _p = ele._private;\n      var rstyle = _p.rstyle;\n\n      rstyle.clean = false;\n      _p.bbCache = null;\n\n      var evts = rstyle.dirtyEvents = rstyle.dirtyEvents || { length: 0 };\n\n      if( !evts[ e.type ] ){\n        evts[ e.type ] = true;\n        evts.length++;\n//\n        // elesToUpdate.merge( ele );\n      }\n    }\n  };\n\n  r.binder( cy )\n    // nodes\n\n    .on('position.* style.* free.*', 'node', function onDirtyModNode( e ){\n      var node = e.cyTarget;\n\n      enqueue( node, e );\n      enqueue( node.connectedEdges(), e );\n\n      if( cy.hasCompoundNodes() ){\n        var parents = node.parents();\n\n        enqueue( parents, e );\n        enqueue( parents.connectedEdges(), e );\n      }\n    })\n\n    .on('add.* background.*', 'node', function onDirtyAddNode( e ){\n      var ele = e.cyTarget;\n\n      enqueue( ele, e );\n    })\n\n    // edges\n\n    .on('add.* style.*', 'edge', function onDirtyEdge( e ){\n      var edge = e.cyTarget;\n\n      enqueue( edge, e );\n      enqueue( edge.parallelEdges(), e );\n    })\n\n    .on('remove.*', 'edge', function onDirtyRemoveEdge( e ){\n      var edge = e.cyTarget;\n      var pEdges = edge.parallelEdges();\n\n      for( var i = 0; i < pEdges.length; i++ ){\n        var pEdge = pEdges[i];\n\n        if( !pEdge.removed() ){\n          enqueue( pEdge, e );\n        }\n      }\n    })\n  ;\n\n  var updateEleCalcs = function( willDraw ){\n    if( willDraw ){\n      var fns = r.onUpdateEleCalcsFns;\n\n      if( fns ){ for( var i = 0; i < fns.length; i++ ){\n        var fn = fns[i];\n\n        fn( willDraw, elesToUpdate );\n      } }\n\n      r.recalculateRenderedStyle( elesToUpdate, false );\n\n      for( var i = 0; i < elesToUpdate.length; i++ ){\n        elesToUpdate[i]._private.rstyle.dirtyEvents = null;\n      }\n\n      elesToUpdate = cy.collection();\n    }\n  };\n\n  r.beforeRender( updateEleCalcs, r.beforeRenderPriorities.eleCalcs );\n};\n\nBRp.onUpdateEleCalcs = function( fn ){\n  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n\n  fns.push( fn );\n};\n\nBRp.recalculateRenderedStyle = function( eles, useCache ){\n  var edges = [];\n  var nodes = [];\n\n  // use cache by default for perf\n  if( useCache === undefined ){ useCache = true; }\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[ i ];\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n\n    // only update if dirty and in graph\n    if( (useCache && rstyle.clean) || ele.removed() ){ continue; }\n\n    if( _p.group === 'nodes' ){\n      var pos = _p.position;\n\n      nodes.push( ele );\n\n      rstyle.nodeX = pos.x;\n      rstyle.nodeY = pos.y;\n      rstyle.nodeW = ele.pstyle( 'width' ).pfValue;\n      rstyle.nodeH = ele.pstyle( 'height' ).pfValue;\n    } else { // edges\n\n      edges.push( ele );\n\n    } // if edges\n\n    rstyle.clean = true;\n    // rstyle.dirtyEvents = null;\n  }\n\n  this.recalculateEdgeProjections( edges );\n  this.recalculateLabelProjections( nodes, edges );\n\n  // update edge data from projections\n  for( var i = 0; i < edges.length; i++ ){\n    var ele = edges[ i ];\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var rs = _p.rscratch;\n\n    // update rstyle positions\n    rstyle.srcX = rs.arrowStartX;\n    rstyle.srcY = rs.arrowStartY;\n    rstyle.tgtX = rs.arrowEndX;\n    rstyle.tgtY = rs.arrowEndY;\n    rstyle.midX = rs.midX;\n    rstyle.midY = rs.midY;\n  }\n};\n\n// Project mouse\nBRp.projectIntoViewport = function( clientX, clientY ){\n  var offsets = this.findContainerClientCoords();\n  var offsetLeft = offsets[0];\n  var offsetTop = offsets[1];\n\n  var x = clientX - offsetLeft;\n  var y = clientY - offsetTop;\n\n  x -= this.cy.pan().x; y -= this.cy.pan().y; x /= this.cy.zoom(); y /= this.cy.zoom();\n  return [ x, y ];\n};\n\nBRp.findContainerClientCoords = function(){\n  var container = this.container;\n\n  var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();\n\n  return [ bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top ];\n};\n\nBRp.invalidateContainerClientCoordsCache = function(){\n  this.containerBB = null;\n};\n\nBRp.findNearestElement = function( x, y, visibleElementsOnly, isTouch ){\n  return this.findNearestElements( x, y, visibleElementsOnly, isTouch )[0];\n};\n\nBRp.findNearestElements = function( x, y, visibleElementsOnly, isTouch ){\n  var self = this;\n  var r = this;\n  var eles = r.getCachedZSortedEles();\n  var near = []; // 1 node max, 1 edge max\n  var zoom = r.cy.zoom();\n  var hasCompounds = r.cy.hasCompoundNodes();\n  var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n  var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n  var labelThreshold = (isTouch ? 8 : 2) / zoom;\n  var minSqDist = Infinity;\n  var nearEdge;\n  var nearNode;\n\n  function addEle( ele, sqDist ){\n    if( ele.isNode() ){\n      if( nearNode ){\n        return; // can't replace node\n      } else {\n        nearNode = ele;\n        near.push( ele );\n      }\n    }\n\n    if( ele.isEdge() && ( sqDist == null || sqDist < minSqDist ) ){\n      if( nearEdge ){ // then replace existing edge\n        // can replace only if same z-index\n        if( nearEdge.pstyle( 'z-index' ).value === ele.pstyle('z-index').value ){\n          for( var i = 0; i < near.length; i++ ){\n            if( near[i].isEdge() ){\n              near[i] = ele;\n              nearEdge = ele;\n              minSqDist = sqDist != null ? sqDist : minSqDist;\n              break;\n            }\n          }\n        }\n      } else {\n        near.push( ele );\n        nearEdge = ele;\n        minSqDist = sqDist != null ? sqDist : minSqDist;\n      }\n    }\n  }\n\n  function checkNode( node ){\n    var _p = node._private;\n\n    if( node.pstyle( 'events' ).strValue === 'no' ){ return; }\n\n    var width = node.outerWidth() + 2 * nodeThreshold;\n    var height = node.outerHeight() + 2 * nodeThreshold;\n    var hw = width / 2;\n    var hh = height / 2;\n    var pos = _p.position;\n\n    if(\n      pos.x - hw <= x && x <= pos.x + hw // bb check x\n        &&\n      pos.y - hh <= y && y <= pos.y + hh // bb check y\n    ){\n      var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );\n\n      // exit early if invisible edge and must be visible\n      if( visibleElementsOnly && !visible ){\n        return;\n      }\n\n      var shape = r.nodeShapes[ self.getNodeShape( node ) ];\n\n      if(\n        shape.checkPoint( x, y, 0, width, height, pos.x, pos.y )\n      ){\n        addEle( node, 0 );\n      }\n\n    }\n  }\n\n  function checkEdge( edge ){\n    var _p = edge._private;\n\n    if( edge.pstyle('events').strValue === 'no' ){ return; }\n\n    var rs = _p.rscratch;\n    var width = edge.pstyle( 'width' ).pfValue / 2 + edgeThreshold; // more like a distance radius from centre\n    var widthSq = width * width;\n    var width2 = width * 2;\n    var src = _p.source;\n    var tgt = _p.target;\n    var inEdgeBB = false;\n    var sqDist;\n\n    // exit early if invisible edge and must be visible\n    var passedVisibilityCheck;\n    var passesVisibilityCheck = function(){\n      if( passedVisibilityCheck !== undefined ){\n        return passedVisibilityCheck;\n      }\n\n      if( !visibleElementsOnly ){\n        passedVisibilityCheck = true;\n        return true;\n      }\n\n      var visible = edge.visible() && !edge.transparent();\n      if( visible ){\n        passedVisibilityCheck = true;\n        return true;\n      }\n\n      passedVisibilityCheck = false;\n      return false;\n    };\n\n    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){\n      var pts = rs.allpts;\n\n      for( var i = 0; i + 3 < pts.length; i += 2 ){\n        if(\n          (inEdgeBB = math.inLineVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], width2 ))\n            && passesVisibilityCheck() &&\n          widthSq > ( sqDist = math.sqdistToFiniteLine( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] ) )\n        ){\n          addEle( edge, sqDist );\n        }\n      }\n\n    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){\n      var pts = rs.allpts;\n      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){\n        if(\n          (inEdgeBB = math.inBezierVicinity( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5], width2 ))\n            && passesVisibilityCheck() &&\n          (widthSq > (sqDist = math.sqdistToQuadraticBezier( x, y, pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3], pts[ i + 4], pts[ i + 5] )) )\n        ){\n          addEle( edge, sqDist );\n        }\n      }\n    }\n\n    // if we're close to the edge but didn't hit it, maybe we hit its arrows\n    if( inEdgeBB && passesVisibilityCheck() ){\n      var src = src || _p.source;\n      var tgt = tgt || _p.target;\n\n      var eWidth = edge.pstyle( 'width' ).pfValue;\n      var arSize = self.getArrowWidth( eWidth );\n\n      var arrows = [\n        { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },\n        { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },\n        { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },\n        { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }\n      ];\n\n      for( var i = 0; i < arrows.length; i++ ){\n        var ar = arrows[ i ];\n        var shape = r.arrowShapes[ edge.pstyle( ar.name + '-arrow-shape' ).value ];\n\n        if(\n          shape.roughCollide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )\n           &&\n          shape.collide( x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold )\n        ){\n          addEle( edge );\n          break;\n        }\n      }\n    }\n\n    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n    if( hasCompounds && near.length > 0 ){\n      checkNode( src );\n      checkNode( tgt );\n    }\n  }\n\n  function preprop( obj, name, pre ){\n    return util.getPrefixedProperty( obj, name, pre );\n  }\n\n  function checkLabel( ele, prefix ){\n    var _p = ele._private;\n    var th = labelThreshold;\n\n    var prefixDash;\n    if( prefix ){\n      prefixDash = prefix + '-';\n    } else {\n      prefixDash = '';\n    }\n\n    if( ele.pstyle( 'text-events' ).strValue === 'no' ){ return; }\n\n    var rotation = ele.pstyle( prefixDash + 'text-rotation' );\n\n    // adjust bb w/ angle\n    if( rotation.strValue === 'autorotate' || !!rotation.pfValue ){\n\n      var rstyle = _p.rstyle;\n      var bw = ele.pstyle('text-border-width').pfValue;\n      var lw = preprop( rstyle, 'labelWidth', prefix ) + bw/2 + 2*th;\n      var lh = preprop( rstyle, 'labelHeight', prefix ) + bw/2 + 2*th;\n      var lx = preprop( rstyle, 'labelX', prefix );\n      var ly = preprop( rstyle, 'labelY', prefix );\n\n      var theta = preprop( _p.rscratch, 'labelAngle', prefix );\n      var cos = Math.cos( theta );\n      var sin = Math.sin( theta );\n\n      var rotate = function( x, y ){\n        x = x - lx;\n        y = y - ly;\n\n        return {\n          x: x * cos - y * sin + lx,\n          y: x * sin + y * cos + ly\n        };\n      };\n\n      var lx1 = lx - lw / 2;\n      var lx2 = lx + lw / 2;\n      var ly1 = ly - lh / 2;\n      var ly2 = ly + lh / 2;\n\n      var px1y1 = rotate( lx1, ly1 );\n      var px1y2 = rotate( lx1, ly2 );\n      var px2y1 = rotate( lx2, ly1 );\n      var px2y2 = rotate( lx2, ly2 );\n\n      var points = [\n        px1y1.x, px1y1.y,\n        px2y1.x, px2y1.y,\n        px2y2.x, px2y2.y,\n        px1y2.x, px1y2.y\n      ];\n\n      if( math.pointInsidePolygonPoints( x, y, points ) ){\n        addEle( ele );\n      }\n\n    } else {\n      var bb = ele.boundingBox( {\n        includeLabels: true,\n        includeNodes: false,\n        includeEdges: false\n      } );\n\n      // adjust bb w/ threshold\n      bb.x1 -= th;\n      bb.y1 -= th;\n      bb.x2 += th;\n      bb.y2 += th;\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n\n      if( math.inBoundingBox( bb, x, y ) ){\n        addEle( ele );\n      }\n    }\n\n  }\n\n  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence\n    var ele = eles[ i ];\n\n    if( ele.isNode() ){\n      checkNode( ele );\n\n      checkLabel( ele );\n\n    } else { // then edge\n      checkEdge( ele );\n\n      checkLabel( ele );\n      checkLabel( ele, 'source' );\n      checkLabel( ele, 'target' );\n    }\n  }\n\n  return near;\n};\n\n// 'Give me everything from this box'\nBRp.getAllInBox = function( x1, y1, x2, y2 ){\n  var eles = this.getCachedZSortedEles();\n  var nodes = eles.nodes;\n  var edges = eles.edges;\n  var box = [];\n\n  var x1c = Math.min( x1, x2 );\n  var x2c = Math.max( x1, x2 );\n  var y1c = Math.min( y1, y2 );\n  var y2c = Math.max( y1, y2 );\n\n  x1 = x1c;\n  x2 = x2c;\n  y1 = y1c;\n  y2 = y2c;\n\n  var boxBb = math.makeBoundingBox( {\n    x1: x1, y1: y1,\n    x2: x2, y2: y2\n  } );\n\n  for( var i = 0; i < nodes.length; i++ ){\n    var node = nodes[ i ];\n    var nodeBb = node.boundingBox( {\n      includeNodes: true,\n      includeEdges: false,\n      includeLabels: false,\n      includeShadows: false\n    } );\n\n    if( math.boundingBoxesIntersect( boxBb, nodeBb ) ){\n      box.push( nodes[ i ] );\n    }\n  }\n\n  for( var e = 0; e < edges.length; e++ ){\n    var edge = edges[ e ];\n    var _p = edge._private;\n    var rs = _p.rscratch;\n\n    if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }\n    if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }\n\n    if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){\n\n      var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n      var allInside = true;\n\n      for( var i = 0; i < pts.length; i++ ){\n        if( !math.pointInBoundingBox( boxBb, pts[ i ] ) ){\n          allInside = false;\n          break;\n        }\n      }\n\n      if( allInside ){\n        box.push( edge );\n      }\n\n    } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){\n      box.push( edge );\n    }\n\n  }\n\n  return box;\n};\n\n\n/**\n * Returns the shape of the given node. If the height or width of the given node\n * is set to auto, the node is considered to be a compound.\n *\n * @param node          a node\n * @return {String}     shape of the node\n */\nBRp.getNodeShape = function( node ){\n  var r = this;\n  var shape = node.pstyle( 'shape' ).value;\n\n  if( node.isParent() ){\n    if( shape === 'rectangle' || shape === 'roundrectangle' ){\n      return shape;\n    } else {\n      return 'rectangle';\n    }\n  }\n\n  if( shape === 'polygon' ){\n    var points = node.pstyle( 'shape-polygon-points' ).value;\n\n    return r.nodeShapes.makePolygon( points ).name;\n  }\n\n  return shape;\n};\n\nBRp.updateCachedZSortedEles = function(){\n  this.getCachedZSortedEles( true );\n};\n\nBRp.updateCachedGrabbedEles = function(){\n  var eles = this.cachedZSortedEles;\n\n  eles.drag = [];\n  eles.nondrag = [];\n\n  var grabTarget;\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n\n    if( rs.isGrabTarget && !ele.isParent() ){\n      grabTarget = ele;\n    } else if( rs.inDragLayer ){\n      eles.drag.push( ele );\n    } else {\n      eles.nondrag.push( ele );\n    }\n  }\n\n  // put the grab target node last so it's on top of its neighbourhood\n  if( grabTarget ){\n    eles.drag.push( grabTarget );\n  }\n};\n\nBRp.getCachedZSortedEles = function( forceRecalc ){\n  if( forceRecalc || !this.cachedZSortedEles ){\n    //console.time('cachezorder')\n\n    var cyEles = this.cy.mutableElements();\n    var eles = [];\n\n    eles.nodes = [];\n    eles.edges = [];\n\n    for( var i = 0; i < cyEles.length; i++ ){\n      var ele = cyEles[i];\n\n      if( ele.animated() || (ele.visible() && !ele.transparent()) ){\n        eles.push( ele );\n\n        if( ele.isNode() ){\n          eles.nodes.push( ele );\n        } else {\n          eles.edges.push( ele );\n        }\n      }\n    }\n\n    eles.sort( zIndexSort );\n\n    this.cachedZSortedEles = eles;\n\n    this.updateCachedGrabbedEles();\n\n    //console.log('make cache')\n\n    //console.timeEnd('cachezorder')\n  } else {\n    eles = this.cachedZSortedEles;\n    //console.log('read cache')\n  }\n\n  return eles;\n};\n\nfunction pushBezierPts( r, edge, pts ){\n  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt( p1, p2, p3, t ); };\n  var _p = edge._private;\n  var bpts = _p.rstyle.bezierPts;\n\n  for( var i = 0; i < r.bezierProjPcts.length; i++ ){\n    var p = r.bezierProjPcts[i];\n\n    bpts.push( {\n      x: qbezierAt( pts[0], pts[2], pts[4], p ),\n      y: qbezierAt( pts[1], pts[3], pts[5], p )\n    } );\n  }\n}\n\nBRp.projectLines = function( edge ){\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var et = rs.edgeType;\n\n  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){\n    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line\n\n    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){\n      pushBezierPts( this, edge, rs.allpts.slice( i, i + 6 ) );\n    }\n  } else if(  et === 'segments' ){\n    var lpts = _p.rstyle.linePts = [];\n\n    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){\n      lpts.push( {\n        x: rs.allpts[ i ],\n        y: rs.allpts[ i + 1]\n      } );\n    }\n  } else if( et === 'haystack' ){\n    var hpts = rs.haystackPts;\n\n    _p.rstyle.haystackPts = [\n      { x: hpts[0], y: hpts[1] },\n      { x: hpts[2], y: hpts[3] }\n    ];\n  }\n\n  _p.rstyle.arrowWidth = this.getArrowWidth( edge.pstyle('width').pfValue ) * this.arrowShapeWidth;\n};\n\nBRp.projectBezier = BRp.projectLines;\n\nBRp.recalculateNodeLabelProjection = function( node ){\n  var content = node.pstyle( 'label' ).strValue;\n\n  if( is.emptyString(content) ){ return; }\n\n  var textX, textY;\n  var _p = node._private;\n  var nodeWidth = node.width();\n  var nodeHeight = node.height();\n  var paddingLeft = node.pstyle('padding-left').pfValue;\n  var paddingRight = node.pstyle('padding-right').pfValue;\n  var paddingTop = node.pstyle('padding-top').pfValue;\n  var paddingBottom = node.pstyle('padding-bottom').pfValue;\n  var nodePos = _p.position;\n  var textHalign = node.pstyle( 'text-halign' ).strValue;\n  var textValign = node.pstyle( 'text-valign' ).strValue;\n  var rs = _p.rscratch;\n  var rstyle = _p.rstyle;\n\n  switch( textHalign ){\n    case 'left':\n      textX = nodePos.x - nodeWidth / 2 - paddingLeft;\n      break;\n\n    case 'right':\n      textX = nodePos.x + nodeWidth / 2 + paddingRight;\n      break;\n\n    default: // e.g. center\n      textX = nodePos.x;\n  }\n\n  switch( textValign ){\n    case 'top':\n      textY = nodePos.y - nodeHeight / 2 - paddingTop;\n      break;\n\n    case 'bottom':\n      textY = nodePos.y + nodeHeight / 2 + paddingBottom;\n      break;\n\n    default: // e.g. middle\n      textY = nodePos.y;\n  }\n\n  rs.labelX = textX;\n  rs.labelY = textY;\n  rstyle.labelX = textX;\n  rstyle.labelY = textY;\n\n  this.applyLabelDimensions( node );\n};\n\nBRp.recalculateEdgeLabelProjections = function( edge ){\n  var p;\n  var _p = edge._private;\n  var rs = _p.rscratch;\n  var r = this;\n  var content = {\n    mid: edge.pstyle('label').strValue,\n    source: edge.pstyle('source-label').strValue,\n    target: edge.pstyle('target-label').strValue\n  };\n\n  if( content.mid || content.source || content.target ){\n    // then we have to calculate...\n  } else {\n    return; // no labels => no calcs\n  }\n\n  // add center point to style so bounding box calculations can use it\n  //\n  p = {\n    x: rs.midX,\n    y: rs.midY\n  };\n\n  var setRs = function( propName, prefix, value ){\n    util.setPrefixedProperty( _p.rscratch, propName, prefix, value );\n    util.setPrefixedProperty( _p.rstyle, propName, prefix, value );\n  };\n\n  setRs( 'labelX', null, p.x );\n  setRs( 'labelY', null, p.y );\n\n  var createControlPointInfo = function(){\n    if( createControlPointInfo.cache ){ return createControlPointInfo.cache; } // use cache so only 1x per edge\n\n    var ctrlpts = [];\n\n    // store each ctrlpt info init\n    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){\n      var p0 = { x: rs.allpts[i], y: rs.allpts[i+1] };\n      var p1 = { x: rs.allpts[i+2], y: rs.allpts[i+3] }; // ctrlpt\n      var p2 = { x: rs.allpts[i+4], y: rs.allpts[i+5] };\n\n      ctrlpts.push({\n        p0: p0,\n        p1: p1,\n        p2: p2,\n        startDist: 0,\n        length: 0,\n        segments: []\n      });\n    }\n\n    var bpts = _p.rstyle.bezierPts;\n    var nProjs = r.bezierProjPcts.length;\n\n    function addSegment( cp, p0, p1, t0, t1 ){\n      var length = math.dist( p0, p1 );\n      var prevSegment = cp.segments[ cp.segments.length - 1 ];\n      var segment = {\n        p0: p0,\n        p1: p1,\n        t0: t0,\n        t1: t1,\n        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n        length: length\n      };\n\n      cp.segments.push( segment );\n\n      cp.length += length;\n    }\n\n    // update each ctrlpt with segment info\n    for( var i = 0; i < ctrlpts.length; i++ ){\n      var cp = ctrlpts[i];\n      var prevCp = ctrlpts[i - 1];\n\n      if( prevCp ){\n        cp.startDist = prevCp.startDist + prevCp.length;\n      }\n\n      addSegment(\n        cp,\n        cp.p0,   bpts[ i * nProjs ],\n        0,       r.bezierProjPcts[ 0 ]\n      ); // first\n\n      for( var j = 0; j < nProjs - 1; j++ ){\n        addSegment(\n          cp,\n          bpts[ i * nProjs + j ],   bpts[ i * nProjs + j + 1 ],\n          r.bezierProjPcts[ j ],    r.bezierProjPcts[ j + 1 ]\n        );\n      }\n\n      addSegment(\n        cp,\n        bpts[ i * nProjs + nProjs - 1 ],   cp.p2,\n        r.bezierProjPcts[ nProjs - 1 ],    1\n      ); // last\n    }\n\n    return ( createControlPointInfo.cache = ctrlpts );\n  };\n\n  var calculateEndProjection = function( prefix ){\n    var angle;\n    var isSrc = prefix === 'source';\n\n    if( !content[ prefix ] ){ return; }\n\n    var offset = edge.pstyle(prefix+'-text-offset').pfValue;\n\n    var lineAngle = function( p0, p1 ){\n      var dx = p1.x - p0.x;\n      var dy = p1.y - p0.y;\n\n      return Math.atan( dy / dx );\n    };\n\n    var bezierAngle = function( p0, p1, p2, t ){\n      var t0 = math.bound( 0, t - 0.001, 1 );\n      var t1 = math.bound( 0, t + 0.001, 1 );\n\n      var lp0 = math.qbezierPtAt( p0, p1, p2, t0 );\n      var lp1 = math.qbezierPtAt( p0, p1, p2, t1 );\n\n      return lineAngle( lp0, lp1 );\n    };\n\n    switch( rs.edgeType ){\n      case 'self':\n      case 'compound':\n      case 'bezier':\n      case 'multibezier':\n        var cps = createControlPointInfo();\n        var selected;\n        var startDist = 0;\n        var totalDist = 0;\n\n        // find the segment we're on\n        for( var i = 0; i < cps.length; i++ ){\n          var cp = cps[ isSrc ? i : cps.length - 1 - i ];\n\n          for( var j = 0; j < cp.segments.length; j++ ){\n            var seg = cp.segments[ isSrc ? j : cp.segments.length - 1 - j ];\n            var lastSeg = i === cps.length - 1 && j === cp.segments.length - 1;\n\n            startDist = totalDist;\n            totalDist += seg.length;\n\n            if( totalDist >= offset || lastSeg ){\n              selected = { cp: cp, segment: seg };\n              break;\n            }\n          }\n\n          if( selected ){ break; }\n        }\n\n        var cp = selected.cp;\n        var seg = selected.segment;\n        var tSegment = ( offset - startDist ) / ( seg.length );\n        var segDt = seg.t1 - seg.t0;\n        var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n\n        t = math.bound( 0, t, 1 );\n        p = math.qbezierPtAt( cp.p0, cp.p1, cp.p2, t );\n        angle = bezierAngle( cp.p0, cp.p1, cp.p2, t, p );\n\n        break;\n\n      case 'straight':\n      case 'segments':\n      case 'haystack':\n        var d = 0, di, d0;\n        var p0, p1;\n        var l = rs.allpts.length;\n\n        for( var i = 0; i + 3 < l; i += 2 ){\n          if( isSrc ){\n            p0 = { x: rs.allpts[i],     y: rs.allpts[i+1] };\n            p1 = { x: rs.allpts[i+2],   y: rs.allpts[i+3] };\n          } else {\n            p0 = { x: rs.allpts[l-2-i], y: rs.allpts[l-1-i] };\n            p1 = { x: rs.allpts[l-4-i], y: rs.allpts[l-3-i] };\n          }\n\n          di = math.dist( p0, p1 );\n          d0 = d;\n          d += di;\n\n          if( d >= offset ){ break; }\n        }\n\n        var pD = offset - d0;\n        var t = pD / di;\n\n        t  = math.bound( 0, t, 1 );\n        p = math.lineAt( p0, p1, t );\n        angle = lineAngle( p0, p1 );\n\n        break;\n    }\n\n    setRs( 'labelX', prefix, p.x );\n    setRs( 'labelY', prefix, p.y );\n    setRs( 'labelAutoAngle', prefix, angle );\n  };\n\n  calculateEndProjection( 'source' );\n  calculateEndProjection( 'target' );\n\n  this.applyLabelDimensions( edge );\n};\n\nBRp.applyLabelDimensions = function( ele ){\n  this.applyPrefixedLabelDimensions( ele );\n\n  if( ele.isEdge() ){\n    this.applyPrefixedLabelDimensions( ele, 'source' );\n    this.applyPrefixedLabelDimensions( ele, 'target' );\n  }\n};\n\nBRp.applyPrefixedLabelDimensions = function( ele, prefix ){\n  var _p = ele._private;\n\n  var text = this.getLabelText( ele, prefix );\n  var labelDims = this.calculateLabelDimensions( ele, text );\n\n  util.setPrefixedProperty( _p.rstyle,   'labelWidth', prefix, labelDims.width );\n  util.setPrefixedProperty( _p.rscratch, 'labelWidth', prefix, labelDims.width );\n\n  util.setPrefixedProperty( _p.rstyle,   'labelHeight', prefix, labelDims.height );\n  util.setPrefixedProperty( _p.rscratch, 'labelHeight', prefix, labelDims.height );\n};\n\nBRp.getLabelText = function( ele, prefix ){\n  var _p = ele._private;\n  var pfd = prefix ? prefix + '-' : '';\n  var text = ele.pstyle( pfd + 'label' ).strValue;\n  var textTransform = ele.pstyle( 'text-transform' ).value;\n  var rscratch = function( propName, value ){\n    if( value ){\n      util.setPrefixedProperty( _p.rscratch, propName, prefix, value );\n      return value;\n    } else {\n      return util.getPrefixedProperty( _p.rscratch, propName, prefix );\n    }\n  };\n\n  if( textTransform == 'none' ){\n  } else if( textTransform == 'uppercase' ){\n    text = text.toUpperCase();\n  } else if( textTransform == 'lowercase' ){\n    text = text.toLowerCase();\n  }\n\n  if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){\n    //console.log('wrap');\n\n    var labelKey = rscratch( 'labelKey' );\n\n    // save recalc if the label is the same as before\n    if( labelKey && rscratch( 'labelWrapKey' ) === labelKey ){\n      // console.log('wrap cache hit');\n      return rscratch( 'labelWrapCachedText' );\n    }\n    // console.log('wrap cache miss');\n\n    var lines = text.split( '\\n' );\n    var maxW = ele.pstyle( 'text-max-width' ).pfValue;\n    var wrappedLines = [];\n\n    for( var l = 0; l < lines.length; l++ ){\n      var line = lines[ l ];\n      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );\n      var lineW = lineDims.width;\n\n      if( lineW > maxW ){ // line is too long\n        var words = line.split( /\\s+/ ); // NB: assume collapsed whitespace into single space\n        var subline = '';\n\n        for( var w = 0; w < words.length; w++ ){\n          var word = words[ w ];\n          var testLine = subline.length === 0 ? word : subline + ' ' + word;\n          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );\n          var testW = testDims.width;\n\n          if( testW <= maxW ){ // word fits on current line\n            subline += word + ' ';\n          } else { // word starts new line\n            wrappedLines.push( subline );\n            subline = word + ' ';\n          }\n        }\n\n        // if there's remaining text, put it in a wrapped line\n        if( !subline.match( /^\\s+$/ ) ){\n          wrappedLines.push( subline );\n        }\n      } else { // line is already short enough\n        wrappedLines.push( line );\n      }\n    } // for\n\n    rscratch( 'labelWrapCachedLines', wrappedLines );\n    text = rscratch( 'labelWrapCachedText', wrappedLines.join( '\\n' ) );\n    rscratch( 'labelWrapKey', labelKey );\n\n    // console.log(text)\n  } // if wrap\n\n  return text;\n};\n\nBRp.calculateLabelDimensions = function( ele, text, extraKey ){\n  var r = this;\n\n  var cacheKey = ele._private.labelStyleKey + '$@$' + text;\n\n  if( extraKey ){\n    cacheKey += '$@$' + extraKey;\n  }\n\n  var cache = r.labelDimCache || (r.labelDimCache = {});\n\n  if( cache[ cacheKey ] ){\n    return cache[ cacheKey ];\n  }\n\n  var fStyle = ele.pstyle( 'font-style' ).strValue;\n  var size = ele.pstyle( 'font-size' ).pfValue + 'px';\n  var family = ele.pstyle( 'font-family' ).strValue;\n  var weight = ele.pstyle( 'font-weight' ).strValue;\n\n  var div = this.labelCalcDiv;\n\n  if( !div ){\n    div = this.labelCalcDiv = document.createElement( 'div' );\n    document.body.appendChild( div );\n  }\n\n  var ds = div.style;\n\n  // from ele style\n  ds.fontFamily = family;\n  ds.fontStyle = fStyle;\n  ds.fontSize = size;\n  ds.fontWeight = weight;\n\n  // forced style\n  ds.position = 'absolute';\n  ds.left = '-9999px';\n  ds.top = '-9999px';\n  ds.zIndex = '-1';\n  ds.visibility = 'hidden';\n  ds.pointerEvents = 'none';\n  ds.padding = '0';\n  ds.lineHeight = '1';\n\n  if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){\n    ds.whiteSpace = 'pre'; // so newlines are taken into account\n  } else {\n    ds.whiteSpace = 'normal';\n  }\n\n  // put label content in div\n  div.textContent = text;\n\n  cache[ cacheKey ] = {\n    width: div.clientWidth,\n    height: div.clientHeight\n  };\n\n  return cache[ cacheKey ];\n};\n\nBRp.recalculateLabelProjections = function( nodes, edges ){\n  for( var i = 0; i < nodes.length; i++ ){\n    this.recalculateNodeLabelProjection( nodes[ i ] );\n  }\n\n  for( var i = 0; i < edges.length; i++ ){\n    this.recalculateEdgeLabelProjections( edges[ i ] );\n  }\n};\n\nBRp.recalculateEdgeProjections = function( edges ){\n  this.findEdgeControlPoints( edges );\n};\n\n\n// Find edge control points\nBRp.findEdgeControlPoints = function( edges ){\n  if( !edges || edges.length === 0 ){ return; }\n\n  var r = this;\n  var cy = r.cy;\n  var hasCompounds = cy.hasCompoundNodes();\n  var hashTable = {};\n  var pairIds = [];\n  var haystackEdges = [];\n\n  // create a table of edge (src, tgt) => list of edges between them\n  var pairId;\n  for( var i = 0; i < edges.length; i++ ){\n    var edge = edges[ i ];\n    var _p = edge._private;\n    var data = _p.data;\n    var curveStyle = edge.pstyle( 'curve-style' ).value;\n    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n\n    // ignore edges who are not to be displayed\n    // they shouldn't take up space\n    if( edge.pstyle( 'display').value === 'none' ){\n      continue;\n    }\n\n    if( curveStyle === 'haystack' ){\n      haystackEdges.push( edge );\n      continue;\n    }\n\n    var srcId = data.source;\n    var tgtId = data.target;\n\n    pairId = srcId > tgtId ?\n      tgtId + '$-$' + srcId :\n      srcId + '$-$' + tgtId ;\n\n    if( edgeIsUnbundled ){\n      pairId = 'unbundled' + '$-$' + data.id;\n    }\n\n    if( hashTable[ pairId ] == null ){\n      hashTable[ pairId ] = [];\n      pairIds.push( pairId );\n    }\n\n    hashTable[ pairId ].push( edge );\n\n    if( edgeIsUnbundled ){\n      hashTable[ pairId ].hasUnbundled = true;\n    }\n  }\n\n  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;\n  var vectorNormInverse;\n  var badBezier;\n\n  // for each pair (src, tgt), create the ctrl pts\n  // Nested for loop is OK; total number of iterations for both loops = edgeCount\n  for( var p = 0; p < pairIds.length; p++ ){\n    pairId = pairIds[ p ];\n    var pairEdges = hashTable[ pairId ];\n\n    // for each pair id, the edges should be sorted by index\n    pairEdges.sort( function( edge1, edge2 ){\n      return edge1.poolIndex() - edge2.poolIndex();\n    } );\n\n    src = pairEdges[0]._private.source;\n    tgt = pairEdges[0]._private.target;\n\n    src_p = src._private;\n    tgt_p = tgt._private;\n\n    // make sure src/tgt distinction is consistent\n    // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)\n    if( src_p.data.id > tgt_p.data.id ){\n      var temp = src;\n      src = tgt;\n      tgt = temp;\n    }\n\n    srcPos = src_p.position;\n    tgtPos = tgt_p.position;\n\n    srcW = src.outerWidth();\n    srcH = src.outerHeight();\n\n    tgtW = tgt.outerWidth();\n    tgtH = tgt.outerHeight();\n\n    srcShape = r.nodeShapes[ this.getNodeShape( src ) ];\n    tgtShape = r.nodeShapes[ this.getNodeShape( tgt ) ];\n\n    badBezier = false;\n\n\n    if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){\n\n      // pt outside src shape to calc distance/displacement from src to tgt\n      var srcOutside = srcShape.intersectLine(\n        srcPos.x,\n        srcPos.y,\n        srcW,\n        srcH,\n        tgtPos.x,\n        tgtPos.y,\n        0\n      );\n\n      // pt outside tgt shape to calc distance/displacement from src to tgt\n      var tgtOutside = tgtShape.intersectLine(\n        tgtPos.x,\n        tgtPos.y,\n        tgtW,\n        tgtH,\n        srcPos.x,\n        srcPos.y,\n        0\n      );\n\n      var midptSrcPts = {\n        x1: srcOutside[0],\n        x2: tgtOutside[0],\n        y1: srcOutside[1],\n        y2: tgtOutside[1]\n      };\n\n      var posPts = {\n        x1: srcPos.x,\n        x2: tgtPos.x,\n        y1: srcPos.y,\n        y2: tgtPos.y\n      };\n\n      var dy = ( tgtOutside[1] - srcOutside[1] );\n      var dx = ( tgtOutside[0] - srcOutside[0] );\n      var l = Math.sqrt( dx * dx + dy * dy );\n\n      var vector = {\n        x: dx,\n        y: dy\n      };\n\n      var vectorNorm = {\n        x: vector.x / l,\n        y: vector.y / l\n      };\n      vectorNormInverse = {\n        x: -vectorNorm.y,\n        y: vectorNorm.x\n      };\n\n\n      // if node shapes overlap, then no ctrl pts to draw\n      if(\n        tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  &&\n        srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )\n      ){\n        vectorNormInverse = {};\n        badBezier = true;\n      }\n\n    }\n\n    var edge;\n    var edge_p;\n    var rs;\n\n    for( var i = 0; i < pairEdges.length; i++ ){\n      edge = pairEdges[ i ];\n      edge_p = edge._private;\n      rs = edge_p.rscratch;\n\n      var edgeIndex1 = rs.lastEdgeIndex;\n      var edgeIndex2 = i;\n\n      var numEdges1 = rs.lastNumEdges;\n      var numEdges2 = pairEdges.length;\n\n      var curveStyle = edge.pstyle( 'curve-style' ).value;\n      var ctrlptDists = edge.pstyle( 'control-point-distances' );\n      var ctrlptWs = edge.pstyle( 'control-point-weights' );\n      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;\n      var stepSize = edge.pstyle( 'control-point-step-size' ).pfValue;\n      var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n      var ctrlptWeight = ctrlptWs.value[0];\n      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';\n\n      var swappedDirection = edge_p.source !== src;\n\n      if( swappedDirection && edgeIsUnbundled ){\n        ctrlptDist *= -1;\n      }\n\n      var srcX1 = rs.lastSrcCtlPtX;\n      var srcX2 = srcPos.x;\n      var srcY1 = rs.lastSrcCtlPtY;\n      var srcY2 = srcPos.y;\n      var srcW1 = rs.lastSrcCtlPtW;\n      var srcW2 = src.outerWidth();\n      var srcH1 = rs.lastSrcCtlPtH;\n      var srcH2 = src.outerHeight();\n\n      var tgtX1 = rs.lastTgtCtlPtX;\n      var tgtX2 = tgtPos.x;\n      var tgtY1 = rs.lastTgtCtlPtY;\n      var tgtY2 = tgtPos.y;\n      var tgtW1 = rs.lastTgtCtlPtW;\n      var tgtW2 = tgt.outerWidth();\n      var tgtH1 = rs.lastTgtCtlPtH;\n      var tgtH2 = tgt.outerHeight();\n\n      var width1 = rs.lastW;\n      var width2 = edge.pstyle( 'control-point-step-size' ).pfValue;\n\n      var edgeDistances = edge.pstyle('edge-distances').value;\n\n      if( badBezier ){\n        rs.badBezier = true;\n      } else {\n        rs.badBezier = false;\n      }\n\n      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2\n      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2\n      &&  width1 === width2\n      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){\n        // console.log('edge ctrl pt cache HIT')\n        continue; // then the control points haven't changed and we can skip calculating them\n      } else {\n        rs.lastSrcCtlPtX = srcX2;\n        rs.lastSrcCtlPtY = srcY2;\n        rs.lastSrcCtlPtW = srcW2;\n        rs.lastSrcCtlPtH = srcH2;\n        rs.lastTgtCtlPtX = tgtX2;\n        rs.lastTgtCtlPtY = tgtY2;\n        rs.lastTgtCtlPtW = tgtW2;\n        rs.lastTgtCtlPtH = tgtH2;\n        rs.lastEdgeIndex = edgeIndex2;\n        rs.lastNumEdges = numEdges2;\n        rs.lastWidth = width2;\n        // console.log('edge ctrl pt cache MISS')\n      }\n\n      if( src === tgt ){\n        // Self-edge\n\n        rs.edgeType = 'self';\n\n        var j = i;\n        var loopDist = stepSize;\n\n        if( edgeIsUnbundled ){\n          j = 0;\n          loopDist = ctrlptDist;\n        }\n\n        rs.ctrlpts = [\n          srcPos.x,\n          srcPos.y - (1 + Math.pow( srcH, 1.12 ) / 100) * loopDist * (j / 3 + 1),\n\n          srcPos.x - (1 + Math.pow( srcW, 1.12 ) / 100) * loopDist * (j / 3 + 1),\n          srcPos.y\n        ];\n\n      } else if(\n        hasCompounds &&\n        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&\n        ( src.parents().anySame( tgt ) || tgt.parents().anySame( src ) )\n      ){\n        // Compound edge\n\n        rs.edgeType = 'compound';\n\n        // because the line approximation doesn't apply for compound beziers\n        // (loop/self edges are already elided b/c of cheap src==tgt check)\n        rs.badBezier = false;\n\n        var j = i;\n        var loopDist = stepSize;\n\n        if( edgeIsUnbundled ){\n          j = 0;\n          loopDist = ctrlptDist;\n        }\n\n        var loopW = 50;\n\n        var loopaPos = {\n          x: srcPos.x - srcW / 2,\n          y: srcPos.y - srcH / 2\n        };\n\n        var loopbPos = {\n          x: tgtPos.x - tgtW / 2,\n          y: tgtPos.y - tgtH / 2\n        };\n\n        var loopPos = {\n          x: Math.min( loopaPos.x, loopbPos.x ),\n          y: Math.min( loopaPos.y, loopbPos.y )\n        };\n\n        // avoids cases with impossible beziers\n        var minCompoundStretch = 0.5;\n        var compoundStretchA = Math.max( minCompoundStretch, Math.log( srcW * 0.01 ) );\n        var compoundStretchB = Math.max( minCompoundStretch, Math.log( tgtW * 0.01 ) );\n\n        rs.ctrlpts = [\n          loopPos.x,\n          loopPos.y - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,\n\n          loopPos.x - (1 + Math.pow( loopW, 1.12 ) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,\n          loopPos.y\n        ];\n\n      } else if( curveStyle === 'segments' ){\n        // Segments (multiple straight lines)\n\n        rs.edgeType = 'segments';\n        rs.segpts = [];\n\n        var segmentWs = edge.pstyle( 'segment-weights' ).pfValue;\n        var segmentDs = edge.pstyle( 'segment-distances' ).pfValue;\n        var segmentsN = Math.min( segmentWs.length, segmentDs.length );\n\n        for( var s = 0; s < segmentsN; s++ ){\n          var w = segmentWs[ s ];\n          var d = segmentDs[ s ];\n\n          // d = swappedDirection ? -d : d;\n          //\n          // d = Math.abs(d);\n\n          // var w1 = !swappedDirection ? (1 - w) : w;\n          // var w2 = !swappedDirection ? w : (1 - w);\n\n          var w1 = (1 - w);\n          var w2 = w;\n\n          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\n          var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n          };\n\n          rs.segpts.push(\n            adjustedMidpt.x + vectorNormInverse.x * d,\n            adjustedMidpt.y + vectorNormInverse.y * d\n          );\n        }\n\n      // Straight edge\n      } else if(\n        pairEdges.length % 2 === 1\n        && i === Math.floor( pairEdges.length / 2 )\n        && !edgeIsUnbundled\n      ){\n\n        rs.edgeType = 'straight';\n\n      } else {\n        // (Multi)bezier\n\n        var multi = edgeIsUnbundled;\n\n        rs.edgeType = multi ? 'multibezier' : 'bezier';\n        rs.ctrlpts = [];\n\n        for( var b = 0; b < bezierN; b++ ){\n          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;\n          var manctrlptDist;\n          var sign = math.signum( normctrlptDist );\n\n          if( multi ){\n            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[ b ] : stepSize; // fall back on step size\n            ctrlptWeight = ctrlptWs.value[ b ];\n          }\n\n          if( edgeIsUnbundled ){ // multi or single unbundled\n            manctrlptDist = ctrlptDist;\n          } else {\n            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n          }\n\n          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n\n          var w1 = !swappedDirection || edgeIsUnbundled ? (1 - ctrlptWeight) : ctrlptWeight;\n          var w2 = !swappedDirection || edgeIsUnbundled ? ctrlptWeight : (1 - ctrlptWeight);\n\n          var midptPts = edgeDistances === 'node-position' ? posPts : midptSrcPts;\n\n          var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n          };\n\n          rs.ctrlpts.push(\n            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,\n            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint\n          );\n        }\n\n      }\n\n      // find endpts for edge\n      this.findEndpoints( edge );\n\n      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );\n      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );\n      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );\n      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );\n\n      var minCpADistFactor = 3;\n      var arrowW = this.getArrowWidth( edge.pstyle( 'width' ).pfValue ) * this.arrowShapeWidth;\n      var minCpADist = minCpADistFactor * arrowW;\n\n      if( rs.edgeType === 'bezier' ){\n        var startACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );\n        var closeStartACp = startACpDist < minCpADist;\n        var endACpDist = math.dist( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );\n        var closeEndACp = endACpDist < minCpADist;\n\n        var overlapping = false;\n\n        if( badStart || badAStart || closeStartACp ){\n          overlapping = true;\n\n          // project control point along line from src centre to outside the src shape\n          // (otherwise intersection will yield nothing)\n          var cpD = { // delta\n            x: rs.ctrlpts[0] - srcPos.x,\n            y: rs.ctrlpts[1] - srcPos.y\n          };\n          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line\n          var cpM = { // normalised delta\n            x: cpD.x / cpL,\n            y: cpD.y / cpL\n          };\n          var radius = Math.max( srcW, srcH );\n          var cpProj = { // *2 radius guarantees outside shape\n            x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n            y: rs.ctrlpts[1] + cpM.y * 2 * radius\n          };\n\n          var srcCtrlPtIntn = srcShape.intersectLine(\n            srcPos.x,\n            srcPos.y,\n            srcW,\n            srcH,\n            cpProj.x,\n            cpProj.y,\n            0\n          );\n\n          if( closeStartACp ){\n            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n          } else {\n            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n          }\n        }\n\n        if( badEnd || badAEnd || closeEndACp ){\n          overlapping = true;\n\n          // project control point along line from tgt centre to outside the tgt shape\n          // (otherwise intersection will yield nothing)\n          var cpD = { // delta\n            x: rs.ctrlpts[0] - tgtPos.x,\n            y: rs.ctrlpts[1] - tgtPos.y\n          };\n          var cpL = Math.sqrt( cpD.x * cpD.x + cpD.y * cpD.y ); // length of line\n          var cpM = { // normalised delta\n            x: cpD.x / cpL,\n            y: cpD.y / cpL\n          };\n          var radius = Math.max( srcW, srcH );\n          var cpProj = { // *2 radius guarantees outside shape\n            x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n            y: rs.ctrlpts[1] + cpM.y * 2 * radius\n          };\n\n          var tgtCtrlPtIntn = tgtShape.intersectLine(\n            tgtPos.x,\n            tgtPos.y,\n            tgtW,\n            tgtH,\n            cpProj.x,\n            cpProj.y,\n            0\n          );\n\n          if( closeEndACp ){\n            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);\n            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);\n          } else {\n            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;\n            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;\n          }\n\n        }\n\n        if( overlapping ){\n          // recalc endpts\n          this.findEndpoints( edge );\n        }\n\n      }\n\n      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){\n        rs.allpts = [];\n\n        rs.allpts.push( rs.startX, rs.startY );\n\n        for( var b = 0; b + 1 < rs.ctrlpts.length; b += 2 ){\n          // ctrl pt itself\n          rs.allpts.push( rs.ctrlpts[ b ], rs.ctrlpts[ b + 1] );\n\n          // the midpt between ctrlpts as intermediate destination pts\n          if( b + 3 < rs.ctrlpts.length ){\n            rs.allpts.push( (rs.ctrlpts[ b ] + rs.ctrlpts[ b + 2]) / 2, (rs.ctrlpts[ b + 1] + rs.ctrlpts[ b + 3]) / 2 );\n          }\n        }\n\n        rs.allpts.push( rs.endX, rs.endY );\n\n        var m, mt;\n        if( rs.ctrlpts.length / 2 % 2 === 0 ){\n          m = rs.allpts.length / 2 - 1;\n\n          rs.midX = rs.allpts[ m ];\n          rs.midY = rs.allpts[ m + 1];\n        } else {\n          m = rs.allpts.length / 2 - 3;\n          mt = 0.5;\n\n          rs.midX = math.qbezierAt( rs.allpts[ m ], rs.allpts[ m + 2], rs.allpts[ m + 4], mt );\n          rs.midY = math.qbezierAt( rs.allpts[ m + 1], rs.allpts[ m + 3], rs.allpts[ m + 5], mt );\n        }\n\n      } else if( rs.edgeType === 'straight' ){\n        // need to calc these after endpts\n        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];\n\n        // default midpt for labels etc\n        rs.midX = ( rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX ) / 4;\n        rs.midY = ( rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY ) / 4;\n\n      } else if( rs.edgeType === 'segments' ){\n        rs.allpts = [];\n        rs.allpts.push( rs.startX, rs.startY );\n        rs.allpts.push.apply( rs.allpts, rs.segpts );\n        rs.allpts.push( rs.endX, rs.endY );\n\n        if( rs.segpts.length % 4 === 0 ){\n          var i2 = rs.segpts.length / 2;\n          var i1 = i2 - 2;\n\n          rs.midX = ( rs.segpts[ i1 ] + rs.segpts[ i2 ] ) / 2;\n          rs.midY = ( rs.segpts[ i1 + 1] + rs.segpts[ i2 + 1] ) / 2;\n        } else {\n          var i1 = rs.segpts.length / 2 - 1;\n\n          rs.midX = rs.segpts[ i1 ];\n          rs.midY = rs.segpts[ i1 + 1];\n        }\n\n\n      }\n\n      this.projectLines( edge );\n      this.calculateArrowAngles( edge );\n      this.recalculateEdgeLabelProjections( edge );\n      this.calculateLabelAngles( edge );\n\n    } // for pair edges\n  } // for pair ids\n\n  for( var i = 0; i < haystackEdges.length; i++ ){\n    var edge = haystackEdges[ i ];\n    var _p = edge._private;\n    var rscratch = _p.rscratch;\n    var rs = rscratch;\n\n    if( !rscratch.haystack ){\n      var angle = Math.random() * 2 * Math.PI;\n\n      rscratch.source = {\n        x: Math.cos( angle ),\n        y: Math.sin( angle )\n      };\n\n      var angle = Math.random() * 2 * Math.PI;\n\n      rscratch.target = {\n        x: Math.cos( angle ),\n        y: Math.sin( angle )\n      };\n\n    }\n\n    var src = _p.source;\n    var tgt = _p.target;\n    var srcPos = src._private.position;\n    var tgtPos = tgt._private.position;\n    var srcW = src.width();\n    var tgtW = tgt.width();\n    var srcH = src.height();\n    var tgtH = tgt.height();\n    var radius = edge.pstyle( 'haystack-radius' ).value;\n    var halfRadius = radius / 2; // b/c have to half width/height\n\n    rs.haystackPts = rs.allpts = [\n      rs.source.x * srcW * halfRadius + srcPos.x,\n      rs.source.y * srcH * halfRadius + srcPos.y,\n      rs.target.x * tgtW * halfRadius + tgtPos.x,\n      rs.target.y * tgtH * halfRadius + tgtPos.y\n    ];\n\n    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n\n    // always override as haystack in case set to different type previously\n    rscratch.edgeType = 'haystack';\n    rscratch.haystack = true;\n\n    this.projectLines( edge );\n    this.calculateArrowAngles( edge );\n    this.recalculateEdgeLabelProjections( edge );\n    this.calculateLabelAngles( edge );\n  }\n\n  return hashTable;\n};\n\nvar getAngleFromDisp = function( dispX, dispY ){\n  return Math.atan2( dispY, dispX ) - Math.PI / 2;\n};\n\nBRp.calculateArrowAngles = function( edge ){\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n  var isMultibezier = rs.edgeType === 'multibezier';\n  var isSegments = rs.edgeType === 'segments';\n  var isCompound = rs.edgeType === 'compound';\n  var isSelf = rs.edgeType === 'self';\n\n  // Displacement gives direction for arrowhead orientation\n  var dispX, dispY;\n  var startX, startY, endX, endY;\n\n  var srcPos = edge._private.source._private.position;\n  var tgtPos = edge._private.target._private.position;\n\n  if( isHaystack ){\n    startX = rs.haystackPts[0];\n    startY = rs.haystackPts[1];\n    endX = rs.haystackPts[2];\n    endY = rs.haystackPts[3];\n  } else {\n    startX = rs.arrowStartX;\n    startY = rs.arrowStartY;\n    endX = rs.arrowEndX;\n    endY = rs.arrowEndY;\n  }\n\n  // source\n  //\n\n  dispX = srcPos.x - startX;\n  dispY = srcPos.y - startY;\n\n  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );\n\n  // mid target\n  //\n\n  var midX = rs.midX;\n  var midY = rs.midY;\n\n  if( isHaystack ){\n    midX = ( startX + endX ) / 2;\n    midY = ( startY + endY ) / 2;\n  }\n\n  dispX = endX - startX;\n  dispY = endY - startY;\n\n  if( isSelf ){\n    dispX = -1;\n    dispY = 1;\n  } else if( isSegments ){\n    var pts = rs.allpts;\n\n    if( pts.length / 2 % 2 === 0 ){\n      var i2 = pts.length / 2;\n      var i1 = i2 - 2;\n\n      dispX = ( pts[ i2 ] - pts[ i1 ] );\n      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );\n    } else {\n      var i2 = pts.length / 2 - 1;\n      var i1 = i2 - 2;\n      var i3 = i2 + 2;\n\n      dispX = ( pts[ i2 ] - pts[ i1 ] );\n      dispY = ( pts[ i2 + 1] - pts[ i1 + 1] );\n    }\n  } else if( isMultibezier || isCompound ){\n    var pts = rs.allpts;\n    var cpts = rs.ctrlpts;\n    var bp0x, bp0y;\n    var bp1x, bp1y;\n\n    if( cpts.length / 2 % 2 === 0 ){\n      var p0 = pts.length / 2 - 1; // startpt\n      var ic = p0 + 2;\n      var p1 = ic + 2;\n\n      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0 );\n      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0 );\n\n      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.0001 );\n      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.0001 );\n    } else {\n      var ic = pts.length / 2 - 1; // ctrpt\n      var p0 = ic - 2; // startpt\n      var p1 = ic + 2; // endpt\n\n      bp0x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.4999 );\n      bp0y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.4999 );\n\n      bp1x = math.qbezierAt( pts[ p0 ], pts[ ic ], pts[ p1 ], 0.5 );\n      bp1y = math.qbezierAt( pts[ p0 + 1], pts[ ic + 1], pts[ p1 + 1], 0.5 );\n    }\n\n    dispX = ( bp1x - bp0x );\n    dispY = ( bp1y - bp0y );\n  }\n\n  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );\n\n  rs.midDispX = dispX;\n  rs.midDispY = dispY;\n\n  // mid source\n  //\n\n  dispX *= -1;\n  dispY *= -1;\n\n  if( isSegments ){\n    var pts = rs.allpts;\n\n    if( pts.length / 2 % 2 === 0 ){\n      // already ok\n    } else {\n      var i2 = pts.length / 2 - 1;\n      var i3 = i2 + 2;\n\n      dispX = -( pts[ i3 ] - pts[ i2 ] );\n      dispY = -( pts[ i3 + 1] - pts[ i2 + 1] );\n    }\n  }\n\n  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );\n\n  // target\n  //\n\n  dispX = tgtPos.x - endX;\n  dispY = tgtPos.y - endY;\n\n  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );\n};\n\nBRp.calculateLabelAngles = function( ele ){\n  var _p = ele._private;\n  var rs = _p.rscratch;\n  var isEdge = ele.isEdge();\n  var rot = ele.pstyle( 'text-rotation' );\n  var rotStr = rot.strValue;\n\n  if( rotStr === 'none' ){\n    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n  } else if( isEdge && rotStr === 'autorotate' ){\n    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );\n    rs.sourceLabelAngle = rs.sourceLabelAutoAngle;\n    rs.targetLabelAngle = rs.targetLabelAutoAngle;\n  } else if( rotStr === 'autorotate' ){\n    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = 0;\n  } else {\n    rs.labelAngle = rs.sourceLabelAngle = rs.targetLabelAngle = rot.pfValue;\n  }\n};\n\n\nBRp.findEndpoints = function( edge ){\n  var r = this;\n  var intersect;\n\n  var source = edge.source()[0];\n  var target = edge.target()[0];\n\n  var src_p = source._private;\n  var tgt_p = target._private;\n\n  var srcPos = src_p.position;\n  var tgtPos = tgt_p.position;\n\n  var tgtArShape = edge.pstyle( 'target-arrow-shape' ).value;\n  var srcArShape = edge.pstyle( 'source-arrow-shape' ).value;\n\n  var rs = edge._private.rscratch;\n\n  var et = rs.edgeType;\n  var bezier = et === 'bezier' || et === 'multibezier' || et === 'self' || et === 'compound';\n  var multi = et !== 'bezier';\n  var lines = et === 'straight' || et === 'segments';\n  var segments = et === 'segments';\n  var hasEndpts = bezier || multi || lines;\n\n  var p1, p2;\n\n  if( bezier ){\n    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];\n    var cpEnd = multi ? [ rs.ctrlpts[ rs.ctrlpts.length - 2], rs.ctrlpts[ rs.ctrlpts.length - 1] ] : cpStart;\n\n    p1 = cpEnd;\n    p2 = cpStart;\n  } else if( lines ){\n    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );\n    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );\n\n    p1 = tgtArrowFromPt;\n    p2 = srcArrowFromPt;\n  }\n\n  intersect = r.nodeShapes[ this.getNodeShape( target ) ].intersectLine(\n    tgtPos.x,\n    tgtPos.y,\n    target.outerWidth(),\n    target.outerHeight(),\n    p1[0],\n    p1[1],\n    0\n  );\n\n  var arrowEnd = math.shortenIntersection( intersect, p1,\n    r.arrowShapes[ tgtArShape ].spacing( edge ) );\n  var edgeEnd = math.shortenIntersection( intersect, p1,\n    r.arrowShapes[ tgtArShape ].gap( edge ) );\n\n  rs.endX = edgeEnd[0];\n  rs.endY = edgeEnd[1];\n\n  rs.arrowEndX = arrowEnd[0];\n  rs.arrowEndY = arrowEnd[1];\n\n  intersect = r.nodeShapes[ this.getNodeShape( source ) ].intersectLine(\n    srcPos.x,\n    srcPos.y,\n    source.outerWidth(),\n    source.outerHeight(),\n    p2[0],\n    p2[1],\n    0\n  );\n\n  var arrowStart = math.shortenIntersection(\n    intersect, p2,\n    r.arrowShapes[ srcArShape ].spacing( edge )\n  );\n  var edgeStart = math.shortenIntersection(\n    intersect, p2,\n    r.arrowShapes[ srcArShape ].gap( edge )\n  );\n\n  rs.startX = edgeStart[0];\n  rs.startY = edgeStart[1];\n\n  rs.arrowStartX = arrowStart[0];\n  rs.arrowStartY = arrowStart[1];\n\n  if( hasEndpts ){\n    if( !is.number( rs.startX ) || !is.number( rs.startY ) || !is.number( rs.endX ) || !is.number( rs.endY ) ){\n      rs.badLine = true;\n    } else {\n      rs.badLine = false;\n    }\n  }\n};\n\nBRp.getArrowWidth = BRp.getArrowHeight = function( edgeWidth ){\n  var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n\n  var cachedVal = cache[ edgeWidth ];\n  if( cachedVal ){\n    return cachedVal;\n  }\n\n  cachedVal =  Math.max( Math.pow( edgeWidth * 13.37, 0.9 ), 29 );\n  cache[ edgeWidth ] = cachedVal;\n\n  return cachedVal;\n};\n\nmodule.exports = BRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/base/coord-ele-math.js\n ** module id = 114\n ** module chunks = 0\n **/","'use strict';\n\nvar BRp = {};\n\nBRp.getCachedImage = function( url, onLoad ){\n  var r = this;\n  var imageCache = r.imageCache = r.imageCache || {};\n\n  if( imageCache[ url ] && imageCache[ url ].image ){\n    return imageCache[ url ].image;\n  }\n\n  var cache = imageCache[ url ] = imageCache[ url ] || {};\n\n  var image = cache.image = new Image();\n  image.addEventListener('load', onLoad);\n  image.crossOrigin = 'Anonymous'; // prevent tainted canvas\n  image.src = url;\n\n  return image;\n};\n\nmodule.exports = BRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/base/images.js\n ** module id = 115\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../../is' );\nvar util = require( '../../../util' );\nvar math = require( '../../../math' );\nvar Event = require( '../../../event' );\n\nvar BRp = {};\n\nBRp.registerBinding = function( target, event, handler, useCapture ){\n  var args = Array.prototype.slice.apply( arguments, [1] ); // copy\n  var b = this.binder( target );\n\n  return b.on.apply( b, args );\n};\n\nBRp.binder = function( tgt ){\n  var r = this;\n\n  var on = function(){\n    var args = arguments;\n\n    r.bindings.push({\n      target: tgt,\n      args: args\n    });\n\n    ( tgt.on || tgt.addEventListener ).apply( tgt, args );\n\n    return this;\n  };\n\n  return {\n    on: on,\n    addEventListener: on,\n    addListener: on,\n    bind: on\n  };\n};\n\nBRp.nodeIsDraggable = function( node ){\n  return (\n    node\n    && node.isNode()\n    && !node.locked()\n    && node.grabbable()\n  );\n};\n\nBRp.nodeIsGrabbable = function( node ){\n  return (\n    this.nodeIsDraggable( node )\n    && node.pstyle( 'opacity' ).value !== 0\n    && node.pstyle( 'visibility' ).value === 'visible'\n    && node.pstyle( 'display' ).value === 'element'\n  );\n};\n\nBRp.load = function(){\n  var r = this;\n\n  var triggerEvents = function( target, names, e, props ){\n    if( target == null ){\n      target = r.cy;\n    }\n\n    for( var i = 0; i < names.length; i++ ){\n      var name = names[ i ];\n\n      var event = new Event( e, util.extend( { type: name }, props ) );\n      target.trigger( event );\n    }\n  };\n\n  var isMultSelKeyDown = function( e ){\n    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n  };\n\n  var allowPanningPassthrough = function( down, downs ){\n    var allowPassthrough = true;\n\n    if( r.cy.hasCompoundNodes() && down && down.isEdge() ){\n      // a compound node below the edge => no passthrough panning\n      for( var i = 0; downs && i < downs.length; i++ ){\n        var down = downs[i];\n\n        if( down.isNode() && down.isParent() ){\n          allowPassthrough = false;\n          break;\n        }\n      }\n    } else {\n      allowPassthrough = true;\n    }\n\n    return allowPassthrough;\n  };\n\n  var getDragListIds = function( opts ){\n    var listHasId;\n\n    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs\n      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist\n        opts.addToList.hasId = {};\n\n        for( var i = 0; i < opts.addToList.length; i++ ){\n          var ele = opts.addToList[ i ];\n\n          opts.addToList.hasId[ ele.id() ] = true;\n        }\n      }\n\n      listHasId = opts.addToList.hasId;\n    }\n\n    return listHasId || {};\n  };\n\n  var setGrabbed = function( ele ){\n    ele[0]._private.grabbed = true;\n  };\n\n  var setFreed = function( ele ){\n    ele[0]._private.grabbed = false;\n  };\n\n  var setInDragLayer = function( ele ){\n    ele[0]._private.rscratch.inDragLayer = true;\n  };\n\n  var setOutDragLayer = function( ele ){\n    ele[0]._private.rscratch.inDragLayer = false;\n  };\n\n  var setGrabTarget = function( ele ){\n    ele[0]._private.rscratch.isGrabTarget = true;\n  };\n\n  var removeGrabTarget = function( ele ){\n    ele[0]._private.rscratch.isGrabTarget = false;\n  };\n\n  var addToDragList = function( ele, opts ){\n    var listHasId = getDragListIds( opts );\n\n    if( !listHasId[ ele.id() ] ){\n      opts.addToList.push( ele );\n      listHasId[ ele.id() ] = true;\n\n      setGrabbed( ele );\n    }\n  };\n\n  // helper function to determine which child nodes and inner edges\n  // of a compound node to be dragged as well as the grabbed and selected nodes\n  var addDescendantsToDrag = function( node, opts ){\n    if( !node.cy().hasCompoundNodes() ){\n      return;\n    }\n\n    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do\n\n    var innerNodes = node.descendants();\n\n    if( opts.inDragLayer ){\n      innerNodes.forEach( setInDragLayer );\n      innerNodes.connectedEdges().forEach( setInDragLayer );\n    }\n\n    if( opts.addToList ){\n      innerNodes.forEach(function( ele ){\n        addToDragList( ele, opts );\n      });\n    }\n  };\n\n  // adds the given nodes and its neighbourhood to the drag layer\n  var addNodesToDrag = function( nodes, opts ){\n    opts = opts || {};\n\n    var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n\n    if( opts.inDragLayer ){\n      nodes.forEach( setInDragLayer );\n\n      nodes.neighborhood().stdFilter(function( ele ){\n        return !hasCompoundNodes || ele.isEdge();\n      }).forEach( setInDragLayer );\n    }\n\n    if( opts.addToList ){\n      nodes.forEach(function( ele ){\n        addToDragList( ele, opts );\n      });\n    }\n\n    addDescendantsToDrag( nodes, opts ); // always add to drag\n\n    // also add nodes and edges related to the topmost ancestor\n    updateAncestorsInDragLayer( nodes, {\n      inDragLayer: opts.inDragLayer\n    } );\n\n    r.updateCachedGrabbedEles();\n  };\n\n  var addNodeToDrag = addNodesToDrag;\n\n  var freeDraggedElements = function( grabbedEles ){\n    if( !grabbedEles ){ return; }\n\n    grabbedEles.hasId = {}; // clear the id list\n\n    // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n    r.getCachedZSortedEles().forEach(function( ele ){\n      setFreed( ele );\n      setOutDragLayer( ele );\n      removeGrabTarget( ele );\n    });\n\n    r.updateCachedGrabbedEles();\n  };\n\n  // helper function to determine which ancestor nodes and edges should go\n  // to the drag layer (or should be removed from drag layer).\n  var updateAncestorsInDragLayer = function( node, opts ){\n\n    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do\n\n    if( !node.cy().hasCompoundNodes() ){\n      return;\n    }\n\n    // find top-level parent\n    var parent = node.ancestors().orphans();\n\n    // no parent node: no nodes to add to the drag layer\n    if( parent.same( node ) ){\n      return;\n    }\n\n    var nodes = parent.descendants().spawnSelf()\n      .merge( parent )\n      .unmerge( node )\n      .unmerge( node.descendants() )\n    ;\n\n    var edges = nodes.connectedEdges();\n\n    if( opts.inDragLayer ){\n      edges.forEach( setInDragLayer );\n      nodes.forEach( setInDragLayer );\n    }\n\n    if( opts.addToList ){\n      nodes.forEach(function( ele ){\n        addToDragList( ele, opts );\n      });\n    }\n  };\n\n  var haveMutationsApi = typeof MutationObserver !== 'undefined';\n\n  // watch for when the cy container is removed from the dom\n  if( haveMutationsApi ){\n    r.removeObserver = new MutationObserver( function( mutns ){\n      for( var i = 0; i < mutns.length; i++ ){\n        var mutn = mutns[ i ];\n        var rNodes = mutn.removedNodes;\n\n        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){\n          var rNode = rNodes[ j ];\n\n          if( rNode === r.container ){\n            r.destroy();\n            break;\n          }\n        } }\n      }\n    } );\n\n    if( r.container.parentNode ){\n      r.removeObserver.observe( r.container.parentNode, { childList: true } );\n    }\n  } else {\n    r.registerBinding( r.container, 'DOMNodeRemoved', function( e ){\n      r.destroy();\n    } );\n  }\n\n  var onResize = util.debounce( function(){\n    r.cy.invalidateSize();\n    r.invalidateContainerClientCoordsCache();\n\n    r.matchCanvasSize( r.container );\n    r.redrawHint( 'eles', true );\n    r.redrawHint( 'drag', true );\n    r.redraw();\n  }, 100 );\n\n  if( haveMutationsApi ){\n    r.styleObserver = new MutationObserver( onResize );\n\n    r.styleObserver.observe( r.container, { attributes: true } );\n  }\n\n  // auto resize\n  r.registerBinding( window, 'resize', onResize );\n\n  var invalCtnrBBOnScroll = function( domEle ){\n    r.registerBinding( domEle, 'scroll', function( e ){\n      r.invalidateContainerClientCoordsCache();\n    } );\n  };\n\n  var bbCtnr = r.cy.container();\n\n  for( ;; ){\n\n    invalCtnrBBOnScroll( bbCtnr );\n\n    if( bbCtnr.parentNode ){\n      bbCtnr = bbCtnr.parentNode;\n    } else {\n      break;\n    }\n\n  }\n\n  // stop right click menu from appearing on cy\n  r.registerBinding( r.container, 'contextmenu', function( e ){\n    e.preventDefault();\n  } );\n\n  var inBoxSelection = function(){\n    return r.selection[4] !== 0;\n  };\n\n  // Primary key\n  r.registerBinding( r.container, 'mousedown', function mousedownHandler( e ){\n    e.preventDefault();\n    r.hoverData.capture = true;\n    r.hoverData.which = e.which;\n\n    var cy = r.cy;\n    var gpos = [ e.clientX, e.clientY ];\n    var pos = r.projectIntoViewport( gpos[0], gpos[1] );\n    var select = r.selection;\n    var nears = r.findNearestElements( pos[0], pos[1], true, false );\n    var near = nears[0];\n    var draggedElements = r.dragData.possibleDragElements;\n\n    r.hoverData.mdownPos = pos;\n    r.hoverData.mdownGPos = gpos;\n\n    var checkForTaphold = function(){\n      r.hoverData.tapholdCancelled = false;\n\n      clearTimeout( r.hoverData.tapholdTimeout );\n\n      r.hoverData.tapholdTimeout = setTimeout( function(){\n\n        if( r.hoverData.tapholdCancelled ){\n          return;\n        } else {\n          var ele = r.hoverData.down;\n\n          if( ele ){\n            ele.trigger( new Event( e, {\n              type: 'taphold',\n              cyPosition: { x: pos[0], y: pos[1] }\n            } ) );\n          } else {\n            cy.trigger( new Event( e, {\n              type: 'taphold',\n              cyPosition: { x: pos[0], y: pos[1] }\n            } ) );\n          }\n        }\n\n      }, r.tapholdDuration );\n    };\n\n    // Right click button\n    if( e.which == 3 ){\n\n      r.hoverData.cxtStarted = true;\n\n      var cxtEvt = new Event( e, {\n        type: 'cxttapstart',\n        cyPosition: { x: pos[0], y: pos[1] }\n      } );\n\n      if( near ){\n        near.activate();\n        near.trigger( cxtEvt );\n\n        r.hoverData.down = near;\n      } else {\n        cy.trigger( cxtEvt );\n      }\n\n      r.hoverData.downTime = (new Date()).getTime();\n      r.hoverData.cxtDragged = false;\n\n    // Primary button\n    } else if( e.which == 1 ){\n\n      if( near ){\n        near.activate();\n      }\n\n      // Element dragging\n      {\n        // If something is under the cursor and it is draggable, prepare to grab it\n        if( near != null ){\n\n          if( r.nodeIsGrabbable( near ) ){\n\n            var grabEvent = new Event( e, {\n              type: 'grab',\n              cyPosition: { x: pos[0], y: pos[1] }\n            } );\n\n            setGrabTarget( near );\n\n            if( !near.selected() ){\n\n              draggedElements = r.dragData.possibleDragElements = [];\n              addNodeToDrag( near, { addToList: draggedElements } );\n\n              near.trigger( grabEvent );\n\n            } else if( near.selected() ){\n              draggedElements = r.dragData.possibleDragElements = [  ];\n\n              var selectedNodes = cy.$( function(){ return this.isNode() && this.selected() && r.nodeIsGrabbable( this ); } );\n\n              addNodesToDrag( selectedNodes, { addToList: draggedElements } );\n\n              near.trigger( grabEvent );\n            }\n\n            r.redrawHint( 'eles', true );\n            r.redrawHint( 'drag', true );\n\n          }\n\n        }\n\n        r.hoverData.down = near;\n        r.hoverData.downs = nears;\n        r.hoverData.downTime = (new Date()).getTime();\n      }\n\n      triggerEvents( near, [ 'mousedown', 'tapstart', 'vmousedown' ], e, {\n        cyPosition: { x: pos[0], y: pos[1] }\n      } );\n\n      if( near == null ){\n        select[4] = 1;\n\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n\n        r.redrawHint( 'select', true );\n\n        r.redraw();\n      } else if( near.isEdge() ){\n        select[4] = 1; // for future pan\n      }\n\n      checkForTaphold();\n\n    }\n\n    // Initialize selection box coordinates\n    select[0] = select[2] = pos[0];\n    select[1] = select[3] = pos[1];\n\n  }, false );\n\n  r.registerBinding( window, 'mousemove', function mousemoveHandler( e ){\n    var preventDefault = false;\n    var capture = r.hoverData.capture;\n\n    // save cycles if mouse events aren't to be captured\n    if( !capture ){\n      var containerPageCoords = r.findContainerClientCoords();\n\n      if( e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth\n        && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight\n      ){\n        // inside container bounds so OK\n      } else {\n        return;\n      }\n\n      var cyContainer = r.container;\n      var target = e.target;\n      var tParent = target.parentNode;\n      var containerIsTarget = false;\n\n      while( tParent ){\n        if( tParent === cyContainer ){\n          containerIsTarget = true;\n          break;\n        }\n\n        tParent = tParent.parentNode;\n      }\n\n      if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us\n    }\n\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var gpos = [ e.clientX, e.clientY ];\n    var pos = r.projectIntoViewport( gpos[0], gpos[1] );\n    var mdownPos = r.hoverData.mdownPos;\n    var mdownGPos = r.hoverData.mdownGPos;\n    var select = r.selection;\n\n    var near = null;\n    if( !r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting ){\n      near = r.findNearestElement( pos[0], pos[1], true, false );\n    }\n    var last = r.hoverData.last;\n    var down = r.hoverData.down;\n\n    var disp = [ pos[0] - select[2], pos[1] - select[3] ];\n\n    var draggedElements = r.dragData.possibleDragElements;\n\n    var isOverThresholdDrag;\n\n    if( mdownGPos ){\n      var dx = gpos[0] - mdownGPos[0];\n      var dx2 = dx * dx;\n      var dy = gpos[1] - mdownGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n\n      isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n    }\n\n    var multSelKeyDown = isMultSelKeyDown( e );\n\n    if (isOverThresholdDrag) {\n      r.hoverData.tapholdCancelled = true;\n    }\n\n    var updateDragDelta = function(){\n      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\n      if( dragDelta.length === 0 ){\n        dragDelta.push( disp[0] );\n        dragDelta.push( disp[1] );\n      } else {\n        dragDelta[0] += disp[0];\n        dragDelta[1] += disp[1];\n      }\n    };\n\n\n    preventDefault = true;\n\n    triggerEvents( near, [ 'mousemove', 'vmousemove', 'tapdrag' ], e, {\n      cyPosition: { x: pos[0], y: pos[1] }\n    } );\n\n    // trigger context drag if rmouse down\n    if( r.hoverData.which === 3 ){\n      // but only if over threshold\n      if( isOverThresholdDrag ){\n        var cxtEvt = new Event( e, {\n          type: 'cxtdrag',\n          cyPosition: { x: pos[0], y: pos[1] }\n        } );\n\n        if( down ){\n          down.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        r.hoverData.cxtDragged = true;\n\n        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){\n\n          if( r.hoverData.cxtOver ){\n            r.hoverData.cxtOver.trigger( new Event( e, {\n              type: 'cxtdragout',\n              cyPosition: { x: pos[0], y: pos[1] }\n            } ) );\n          }\n\n          r.hoverData.cxtOver = near;\n\n          if( near ){\n            near.trigger( new Event( e, {\n              type: 'cxtdragover',\n              cyPosition: { x: pos[0], y: pos[1] }\n            } ) );\n          }\n\n        }\n      }\n\n    // Check if we are drag panning the entire graph\n    } else if( r.hoverData.dragging ){\n      preventDefault = true;\n\n      if( cy.panningEnabled() && cy.userPanningEnabled() ){\n        var deltaP;\n\n        if( r.hoverData.justStartedPan ){\n          var mdPos = r.hoverData.mdownPos;\n\n          deltaP = {\n            x: ( pos[0] - mdPos[0] ) * zoom,\n            y: ( pos[1] - mdPos[1] ) * zoom\n          };\n\n          r.hoverData.justStartedPan = false;\n\n        } else {\n          deltaP = {\n            x: disp[0] * zoom,\n            y: disp[1] * zoom\n          };\n\n        }\n\n        cy.panBy( deltaP );\n\n        r.hoverData.dragged = true;\n      }\n\n      // Needs reproject due to pan changing viewport\n      pos = r.projectIntoViewport( e.clientX, e.clientY );\n\n    // Checks primary button down & out of time & mouse not moved much\n    } else if(\n        select[4] == 1 && (down == null || down.isEdge())\n    ){\n\n      if( isOverThresholdDrag ){\n\n        if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){\n          r.data.bgActivePosistion = undefined;\n\n          if( !r.hoverData.selecting ){\n            cy.trigger('boxstart');\n          }\n\n          r.hoverData.selecting = true;\n\n          r.redrawHint( 'select', true );\n          r.redraw();\n\n        } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){\n          var allowPassthrough = allowPanningPassthrough( down, r.hoverData.downs );\n\n          if( allowPassthrough ){\n            r.hoverData.dragging = true;\n            r.hoverData.justStartedPan = true;\n            select[4] = 0;\n\n            r.data.bgActivePosistion = math.array2point( mdownPos );\n\n            r.redrawHint( 'select', true );\n            r.redraw();\n          }\n        }\n\n        if( down && down.isEdge() && down.active() ){ down.unactivate(); }\n\n      }\n\n    } else {\n      if( down && down.isEdge() && down.active() ){ down.unactivate(); }\n\n      if( ( !down || !down.grabbed() ) && near != last ){\n\n        if( last ){\n          triggerEvents( last, [ 'mouseout', 'tapdragout' ], e, {\n            cyPosition: { x: pos[0], y: pos[1] }\n          } );\n        }\n\n        if( near ){\n          triggerEvents( near, [ 'mouseover', 'tapdragover' ], e, {\n            cyPosition: { x: pos[0], y: pos[1] }\n          } );\n        }\n\n        r.hoverData.last = near;\n      }\n\n      if( down && r.nodeIsDraggable( down ) ){\n\n        if( isOverThresholdDrag ){ // then drag\n\n          var justStartedDrag = !r.dragData.didDrag;\n\n          if( justStartedDrag ){\n            r.redrawHint( 'eles', true );\n          }\n\n          r.dragData.didDrag = true; // indicate that we actually did drag the node\n\n          var toTrigger = [];\n\n          // now, add the elements to the drag layer if not done already\n          if( !r.hoverData.draggingEles ){\n            addNodesToDrag( cy.collection( draggedElements ), { inDragLayer: true } );\n          }\n\n          for( var i = 0; i < draggedElements.length; i++ ){\n            var dEle = draggedElements[ i ];\n\n            // Locked nodes not draggable, as well as non-visible nodes\n            if( r.nodeIsDraggable( dEle ) && dEle.grabbed() ){\n              var dPos = dEle._private.position;\n\n              toTrigger.push( dEle );\n\n              if( is.number( disp[0] ) && is.number( disp[1] ) ){\n                var updatePos = !dEle.isParent();\n\n                if( updatePos ){\n                  dPos.x += disp[0];\n                  dPos.y += disp[1];\n                }\n\n                if( justStartedDrag ){\n                  var dragDelta = r.hoverData.dragDelta;\n\n                  if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){\n                    dPos.x += dragDelta[0];\n                    dPos.y += dragDelta[1];\n                  }\n                }\n              }\n\n            }\n          }\n\n          r.hoverData.draggingEles = true;\n\n          var tcol = cy.collection( toTrigger );\n\n          tcol.updateCompoundBounds();\n          tcol.trigger( 'position drag' );\n\n          r.redrawHint( 'drag', true );\n          r.redraw();\n\n        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n          updateDragDelta();\n        }\n      }\n\n      // prevent the dragging from triggering text selection on the page\n      preventDefault = true;\n    }\n\n    select[2] = pos[0]; select[3] = pos[1];\n\n    if( preventDefault ){\n      if( e.stopPropagation ) e.stopPropagation();\n      if( e.preventDefault ) e.preventDefault();\n      return false;\n    }\n  }, false );\n\n  r.registerBinding( window, 'mouseup', function mouseupHandler( e ){\n    var capture = r.hoverData.capture;\n    if( !capture ){ return; }\n    r.hoverData.capture = false;\n\n    var cy = r.cy; var pos = r.projectIntoViewport( e.clientX, e.clientY ); var select = r.selection;\n    var near = r.findNearestElement( pos[0], pos[1], true, false );\n    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;\n    var multSelKeyDown = isMultSelKeyDown( e );\n\n    if( r.data.bgActivePosistion ){\n      r.redrawHint( 'select', true );\n      r.redraw();\n    }\n\n    r.hoverData.tapholdCancelled = true;\n\n    r.data.bgActivePosistion = undefined; // not active bg now\n\n    if( down ){\n      down.unactivate();\n    }\n\n    if( r.hoverData.which === 3 ){\n      var cxtEvt = new Event( e, {\n        type: 'cxttapend',\n        cyPosition: { x: pos[0], y: pos[1] }\n      } );\n\n      if( down ){\n        down.trigger( cxtEvt );\n      } else {\n        cy.trigger( cxtEvt );\n      }\n\n      if( !r.hoverData.cxtDragged ){\n        var cxtTap = new Event( e, {\n          type: 'cxttap',\n          cyPosition: { x: pos[0], y: pos[1] }\n        } );\n\n        if( down ){\n          down.trigger( cxtTap );\n        } else {\n          cy.trigger( cxtTap );\n        }\n      }\n\n      r.hoverData.cxtDragged = false;\n      r.hoverData.which = null;\n\n    } else if( r.hoverData.which === 1 ){\n\n      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n      if( (down == null) // not mousedown on node\n        && !r.dragData.didDrag // didn't move the node around\n        && !r.hoverData.selecting // not box selection\n        && !r.hoverData.dragged // didn't pan\n        && !isMultSelKeyDown( e )\n      ){\n\n        cy.$( function(){\n          return this.selected();\n        } ).unselect();\n\n        if( draggedElements.length > 0 ){\n          r.redrawHint( 'eles', true );\n        }\n\n        r.dragData.possibleDragElements = draggedElements = [];\n      }\n\n      triggerEvents( near, [ 'mouseup', 'tapend', 'vmouseup' ], e, {\n        cyPosition: { x: pos[0], y: pos[1] }\n      } );\n\n      if(\n        !r.dragData.didDrag // didn't move a node around\n        && !r.hoverData.dragged // didn't pan\n        && !r.hoverData.selecting // not box selection\n      ){\n        triggerEvents( down, ['click', 'tap', 'vclick'], e, {\n          cyPosition: { x: pos[0], y: pos[1] }\n        } );\n      }\n\n      // Single selection\n      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){\n        if( near != null && near._private.selectable ){\n\n          if( r.hoverData.dragging ){\n            // if panning, don't change selection state\n          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){\n            if( near.selected() ){\n              near.unselect();\n            } else {\n              near.select();\n            }\n          } else {\n            if( !multSelKeyDown ){\n              cy.$( ':selected' ).unmerge( near ).unselect();\n              near.select();\n            }\n          }\n\n          r.redrawHint( 'eles', true );\n        }\n      }\n\n      if( r.hoverData.selecting ){\n        var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );\n\n        r.redrawHint( 'select', true );\n\n        if( box.length > 0 ){\n          r.redrawHint( 'eles', true );\n        }\n\n        cy.trigger('boxend');\n\n        var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };\n\n        if( cy.selectionType() === 'additive' ){\n          box\n            .trigger('box')\n            .stdFilter( eleWouldBeSelected )\n              .select()\n              .trigger('boxselect')\n          ;\n        } else {\n          if( !multSelKeyDown ){\n            cy.$( ':selected' ).unmerge( box ).unselect();\n          }\n\n          box\n            .trigger('box')\n            .stdFilter( eleWouldBeSelected )\n              .select()\n              .trigger('boxselect')\n          ;\n        }\n\n        // always need redraw in case eles unselectable\n        r.redraw();\n\n      }\n\n      // Cancel drag pan\n      if( r.hoverData.dragging ){\n        r.hoverData.dragging = false;\n\n        r.redrawHint( 'select', true );\n        r.redrawHint( 'eles', true );\n\n        r.redraw();\n      }\n\n      if( !select[4] ) {\n        r.redrawHint('drag', true);\n        r.redrawHint('eles', true);\n\n        var downWasGrabbed = down && down.grabbed();\n\n        freeDraggedElements( draggedElements );\n\n        if( downWasGrabbed ){ down.trigger('free'); }\n      }\n\n    } // else not right mouse\n\n    select[4] = 0; r.hoverData.down = null;\n\n    r.hoverData.cxtStarted = false;\n    r.hoverData.draggingEles = false;\n    r.hoverData.selecting = false;\n    r.dragData.didDrag = false;\n    r.hoverData.dragged = false;\n    r.hoverData.dragDelta = [];\n    r.hoverData.mdownPos = null;\n    r.hoverData.mdownGPos = null;\n\n  }, false );\n\n  var wheelHandler = function( e ){\n\n\n    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom\n\n    var cy = r.cy;\n    var pos = r.projectIntoViewport( e.clientX, e.clientY );\n    var rpos = [ pos[0] * cy.zoom() + cy.pan().x,\n                  pos[1] * cy.zoom() + cy.pan().y ];\n\n    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom\n      e.preventDefault();\n      return;\n    }\n\n    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){\n      e.preventDefault();\n\n      r.data.wheelZooming = true;\n      clearTimeout( r.data.wheelTimeout );\n      r.data.wheelTimeout = setTimeout( function(){\n        r.data.wheelZooming = false;\n\n        r.redrawHint( 'eles', true );\n        r.redraw();\n      }, 150 );\n\n      var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;\n      diff = diff * r.wheelSensitivity;\n\n      var needsWheelFix = e.deltaMode === 1;\n      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows\n        diff *= 33;\n      }\n\n      cy.zoom( {\n        level: cy.zoom() * Math.pow( 10, diff ),\n        renderedPosition: { x: rpos[0], y: rpos[1] }\n      } );\n    }\n\n  };\n\n  // Functions to help with whether mouse wheel should trigger zooming\n  // --\n  r.registerBinding( r.container, 'wheel', wheelHandler, true );\n\n  // disable nonstandard wheel events\n  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n  r.registerBinding( window, 'scroll', function scrollHandler( e ){\n    r.scrollingPage = true;\n\n    clearTimeout( r.scrollingPageTimeout );\n    r.scrollingPageTimeout = setTimeout( function(){\n      r.scrollingPage = false;\n    }, 250 );\n  }, true );\n\n  // Functions to help with handling mouseout/mouseover on the Cytoscape container\n  // Handle mouseout on Cytoscape container\n  r.registerBinding( r.container, 'mouseout', function mouseOutHandler( e ){\n    var pos = r.projectIntoViewport( e.clientX, e.clientY );\n\n    r.cy.trigger( new Event( e, {\n      type: 'mouseout',\n      cyPosition: { x: pos[0], y: pos[1] }\n    } ) );\n  }, false );\n\n  r.registerBinding( r.container, 'mouseover', function mouseOverHandler( e ){\n    var pos = r.projectIntoViewport( e.clientX, e.clientY );\n\n    r.cy.trigger( new Event( e, {\n      type: 'mouseover',\n      cyPosition: { x: pos[0], y: pos[1] }\n    } ) );\n  }, false );\n\n  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n  var center1, modelCenter1; // center point on start pinch to zoom\n  var offsetLeft, offsetTop;\n  var containerWidth, containerHeight;\n  var twoFingersStartInside;\n\n  var distance = function( x1, y1, x2, y2 ){\n    return Math.sqrt( (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) );\n  };\n\n  var distanceSq = function( x1, y1, x2, y2 ){\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  };\n\n  var touchstartHandler;\n  r.registerBinding( r.container, 'touchstart', touchstartHandler = function( e ){\n    r.touchData.capture = true;\n    r.data.bgActivePosistion = undefined;\n\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n\n    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\n    // record starting points for pinch-to-zoom\n    if( e.touches[1] ){\n\n      freeDraggedElements( r.dragData.touchDragEles );\n\n      var offsets = r.findContainerClientCoords();\n      offsetLeft = offsets[0];\n      offsetTop = offsets[1];\n      containerWidth = offsets[2];\n      containerHeight = offsets[3];\n\n      f1x1 = e.touches[0].clientX - offsetLeft;\n      f1y1 = e.touches[0].clientY - offsetTop;\n\n      f2x1 = e.touches[1].clientX - offsetLeft;\n      f2y1 = e.touches[1].clientY - offsetTop;\n\n      twoFingersStartInside =\n           0 <= f1x1 && f1x1 <= containerWidth\n        && 0 <= f2x1 && f2x1 <= containerWidth\n        && 0 <= f1y1 && f1y1 <= containerHeight\n        && 0 <= f2y1 && f2y1 <= containerHeight\n      ;\n\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n\n      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );\n      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );\n      center1 = [ (f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2 ];\n      modelCenter1 = [\n        (center1[0] - pan.x) / zoom,\n        (center1[1] - pan.y) / zoom\n      ];\n\n      // consider context tap\n      var cxtDistThreshold = 200;\n      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){\n\n        var near1 = r.findNearestElement( now[0], now[1], true, true );\n        var near2 = r.findNearestElement( now[2], now[3], true, true );\n\n        if( near1 && near1.isNode() ){\n          near1.activate().trigger( new Event( e, {\n            type: 'cxttapstart',\n            cyPosition: { x: now[0], y: now[1] }\n          } ) );\n          r.touchData.start = near1;\n\n        } else if( near2 && near2.isNode() ){\n          near2.activate().trigger( new Event( e, {\n            type: 'cxttapstart',\n            cyPosition: { x: now[0], y: now[1] }\n          } ) );\n          r.touchData.start = near2;\n\n        } else {\n          cy.trigger( new Event( e, {\n            type: 'cxttapstart',\n            cyPosition: { x: now[0], y: now[1] }\n          } ) );\n          r.touchData.start = null;\n        }\n\n        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n        r.touchData.cxt = true;\n        r.touchData.cxtDragged = false;\n        r.data.bgActivePosistion = undefined;\n\n        r.redraw();\n        return;\n\n      }\n\n    }\n\n    if( e.touches[2] ){\n\n    } else if( e.touches[1] ){\n\n    } else if( e.touches[0] ){\n      var nears = r.findNearestElements( now[0], now[1], true, true );\n      var near = nears[0];\n\n      if( near != null ){\n        near.activate();\n\n        r.touchData.start = near;\n        r.touchData.starts = nears;\n\n        if( r.nodeIsGrabbable( near ) ){\n\n          var draggedEles = r.dragData.touchDragEles = [];\n\n          r.redrawHint( 'eles', true );\n          r.redrawHint( 'drag', true );\n\n          if( near.selected() ){\n            // reset drag elements, since near will be added again\n\n            var selectedNodes = cy.$( function(){\n              return this.selected() && r.nodeIsGrabbable( this );\n            } );\n\n            addNodesToDrag( selectedNodes, { addToList: draggedEles } );\n          } else {\n            addNodeToDrag( near, { addToList: draggedEles } );\n          }\n\n          setGrabTarget( near );\n\n          near.trigger( new Event( e, {\n            type: 'grab',\n            cyPosition: { x: now[0], y: now[1] }\n          } ) );\n        }\n      }\n\n      triggerEvents( near, [ 'touchstart', 'tapstart', 'vmousedown' ], e, {\n        cyPosition: { x: now[0], y: now[1] }\n      } );\n\n      if( near == null ){\n        r.data.bgActivePosistion = {\n          x: pos[0],\n          y: pos[1]\n        };\n\n        r.redrawHint( 'select', true );\n        r.redraw();\n      }\n\n\n      // Tap, taphold\n      // -----\n\n      r.touchData.startPosition = [];\n      for (var i=0; i<now.length; i++) {\n        earlier[i] = now[i];\n        r.touchData.startPosition[i] = now[i];\n      }\n\n      r.touchData.startGPosition = [ e.touches[0].clientX, e.touches[0].clientY ];\n\n      r.touchData.singleTouchMoved = false;\n      r.touchData.singleTouchStartTime = +new Date();\n\n      clearTimeout( r.touchData.tapholdTimeout );\n      r.touchData.tapholdTimeout = setTimeout( function(){\n        if(\n            r.touchData.singleTouchMoved === false\n            && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n            && !r.touchData.selecting // box selection shouldn't allow taphold through\n        ){\n          triggerEvents( r.touchData.start, [ 'taphold' ], e, {\n            cyPosition: { x: now[0], y: now[1] }\n          } );\n\n          if( !r.touchData.start ){\n            cy.$( ':selected' ).unselect();\n          }\n\n        }\n      }, r.tapholdDuration );\n    }\n\n  }, false );\n\n  var touchmoveHandler;\n  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) {\n    var select = r.selection;\n    var capture = r.touchData.capture;\n    var cy = r.cy;\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n    var zoom = cy.zoom();\n\n    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\n    var isOverThresholdDrag;\n\n    if( capture && e.touches[0] ){\n      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }\n      var startGPos = r.touchData.startGPosition;\n      var dx = e.touches[0].clientX - startGPos[0];\n      var dx2 = dx * dx;\n      var dy = e.touches[0].clientY - startGPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n\n      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n    }\n\n    // context swipe cancelling\n    if( capture && r.touchData.cxt ){\n      e.preventDefault();\n\n      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n      var factorSq = distance2Sq / distance1Sq;\n\n      var distThreshold = 150;\n      var distThresholdSq = distThreshold * distThreshold;\n      var factorThreshold = 1.5;\n      var factorThresholdSq = factorThreshold * factorThreshold;\n\n      // cancel ctx gestures if the distance b/t the fingers increases\n      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){\n        r.touchData.cxt = false;\n        if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint( 'select', true );\n\n        var cxtEvt = new Event( e, {\n          type: 'cxttapend',\n          cyPosition: { x: now[0], y: now[1] }\n        } );\n        if( r.touchData.start ){\n          r.touchData.start.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n      }\n\n    }\n\n    // context swipe\n    if( capture && r.touchData.cxt ){\n      var cxtEvt = new Event( e, {\n        type: 'cxtdrag',\n        cyPosition: { x: now[0], y: now[1] }\n      } );\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint( 'select', true );\n\n      if( r.touchData.start ){\n        r.touchData.start.trigger( cxtEvt );\n      } else {\n        cy.trigger( cxtEvt );\n      }\n\n      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n      r.touchData.cxtDragged = true;\n\n      var near = r.findNearestElement( now[0], now[1], true, true );\n\n      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){\n\n        if( r.touchData.cxtOver ){\n          r.touchData.cxtOver.trigger( new Event( e, {\n            type: 'cxtdragout',\n            cyPosition: { x: now[0], y: now[1] }\n          } ) );\n        }\n\n        r.touchData.cxtOver = near;\n\n        if( near ){\n          near.trigger( new Event( e, {\n            type: 'cxtdragover',\n            cyPosition: { x: now[0], y: now[1] }\n          } ) );\n\n        }\n\n      }\n\n    // box selection\n    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){\n      e.preventDefault();\n\n      r.data.bgActivePosistion = undefined;\n\n      this.lastThreeTouch = +new Date();\n\n      if( !r.touchData.selecting ){\n        cy.trigger('boxstart');\n      }\n\n      r.touchData.selecting = true;\n\n      r.redrawHint( 'select', true );\n\n      if( !select || select.length === 0 || select[0] === undefined ){\n        select[0] = (now[0] + now[2] + now[4]) / 3;\n        select[1] = (now[1] + now[3] + now[5]) / 3;\n        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n      } else {\n        select[2] = (now[0] + now[2] + now[4]) / 3;\n        select[3] = (now[1] + now[3] + now[5]) / 3;\n      }\n\n      select[4] = 1;\n      r.touchData.selecting = true;\n\n      r.redraw();\n\n    // pinch to zoom\n    } else if( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ){ // two fingers => pinch to zoom\n      e.preventDefault();\n\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint( 'select', true );\n\n      var draggedEles = r.dragData.touchDragEles;\n      if( draggedEles ){\n        r.redrawHint( 'drag', true );\n\n        for( var i = 0; i < draggedEles.length; i++ ){\n          draggedEles[ i ]._private.grabbed = false;\n          draggedEles[ i ]._private.rscratch.inDragLayer = false;\n        }\n      }\n\n      // (x2, y2) for fingers 1 and 2\n      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n\n\n      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n      var factor = distance2 / distance1;\n\n      if( factor != 1 && twoFingersStartInside ){\n        // delta finger1\n        var df1x = f1x2 - f1x1;\n        var df1y = f1y2 - f1y1;\n\n        // delta finger 2\n        var df2x = f2x2 - f2x1;\n        var df2y = f2y2 - f2y1;\n\n        // translation is the normalised vector of the two fingers movement\n        // i.e. so pinching cancels out and moving together pans\n        var tx = (df1x + df2x) / 2;\n        var ty = (df1y + df2y) / 2;\n\n        // adjust factor by the speed multiplier\n        // var speed = 1.5;\n        // if( factor > 1 ){\n        //   factor = (factor - 1) * speed + 1;\n        // } else {\n        //   factor = 1 - (1 - factor) * speed;\n        // }\n\n        // now calculate the zoom\n        var zoom1 = cy.zoom();\n        var zoom2 = zoom1 * factor;\n        var pan1 = cy.pan();\n\n        // the model center point converted to the current rendered pos\n        var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n        var ctry = modelCenter1[1] * zoom1 + pan1.y;\n\n        var pan2 = {\n          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n        };\n\n        // remove dragged eles\n        if( r.touchData.start ){\n          var draggedEles = r.dragData.touchDragEles;\n\n          freeDraggedElements( draggedEles );\n\n          r.redrawHint( 'drag', true );\n          r.redrawHint( 'eles', true );\n\n          r.touchData.start\n            .trigger( 'free' )\n            .unactivate()\n          ;\n        }\n\n        cy.viewport( {\n          zoom: zoom2,\n          pan: pan2,\n          cancelOnFailedZoom: true\n        } );\n\n        distance1 = distance2;\n        f1x1 = f1x2;\n        f1y1 = f1y2;\n        f2x1 = f2x2;\n        f2y1 = f2y2;\n\n        r.pinching = true;\n      }\n\n      // Re-project\n      if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n      if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n      if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\n    } else if( e.touches[0] ){\n      var start = r.touchData.start;\n      var last = r.touchData.last;\n      var near;\n\n      if( !r.hoverData.draggingEles && !r.swipePanning ){\n        near = r.findNearestElement( now[0], now[1], true, true );\n      }\n\n      if( capture && start != null ){\n        e.preventDefault();\n      }\n\n      // dragging nodes\n      if( capture && start != null && r.nodeIsDraggable( start ) ){\n\n        if( isOverThresholdDrag ){ // then dragging can happen\n          var draggedEles = r.dragData.touchDragEles;\n          var justStartedDrag = !r.dragData.didDrag;\n\n          if( justStartedDrag ){\n            addNodesToDrag( cy.collection( draggedEles ), { inDragLayer: true } );\n          }\n\n          for( var k = 0; k < draggedEles.length; k++ ){\n            var draggedEle = draggedEles[ k ];\n\n            if( r.nodeIsDraggable( draggedEle ) && draggedEle.grabbed() ){\n              r.dragData.didDrag = true;\n              var dPos = draggedEle._private.position;\n              var updatePos = !draggedEle.isParent();\n\n              if( updatePos && is.number( disp[0] ) && is.number( disp[1] ) ){\n                dPos.x += disp[0];\n                dPos.y += disp[1];\n              }\n\n              if( justStartedDrag ){\n                r.redrawHint( 'eles', true );\n\n                var dragDelta = r.touchData.dragDelta;\n\n                if( updatePos && dragDelta && is.number( dragDelta[0] ) && is.number( dragDelta[1] ) ){\n                  dPos.x += dragDelta[0];\n                  dPos.y += dragDelta[1];\n                }\n\n              }\n            }\n          }\n\n          var tcol = cy.collection( draggedEles );\n\n          tcol.updateCompoundBounds();\n          tcol.trigger( 'position drag' );\n\n          r.hoverData.draggingEles = true;\n\n          r.redrawHint( 'drag', true );\n\n          if(\n               r.touchData.startPosition[0] == earlier[0]\n            && r.touchData.startPosition[1] == earlier[1]\n          ){\n\n            r.redrawHint( 'eles', true );\n          }\n\n          r.redraw();\n        } else { // otherise keep track of drag delta for later\n          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\n          if( dragDelta.length === 0 ){\n            dragDelta.push( disp[0] );\n            dragDelta.push( disp[1] );\n          } else {\n            dragDelta[0] += disp[0];\n            dragDelta[1] += disp[1];\n          }\n        }\n      }\n\n      // touchmove\n      {\n        triggerEvents( (start || near), [ 'touchmove', 'tapdrag', 'vmousemove' ], e, {\n          cyPosition: { x: now[0], y: now[1] }\n        } );\n\n        if( ( !start || !start.grabbed() ) && near != last ){\n          if( last ){ last.trigger( new Event( e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } } ) ); }\n          if( near ){ near.trigger( new Event( e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } } ) ); }\n        }\n\n        r.touchData.last = near;\n      }\n\n      // check to cancel taphold\n      if( capture ){\n        for( var i = 0; i < now.length; i++ ){\n          if( now[ i ]\n            && r.touchData.startPosition[ i ]\n            && isOverThresholdDrag ){\n\n            r.touchData.singleTouchMoved = true;\n          }\n        }\n      }\n\n      // panning\n      if(\n          capture\n          && ( start == null || start.isEdge() )\n          && cy.panningEnabled() && cy.userPanningEnabled()\n      ){\n\n        var allowPassthrough = allowPanningPassthrough( start, r.touchData.starts );\n\n        if( allowPassthrough ){\n          e.preventDefault();\n\n          if( r.swipePanning ){\n            cy.panBy( {\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            } );\n\n          } else if( isOverThresholdDrag ){\n            r.swipePanning = true;\n\n            cy.panBy( {\n              x: dx * zoom,\n              y: dy * zoom\n            } );\n\n            if( start ){\n              start.unactivate();\n\n              if( !r.data.bgActivePosistion ){\n                r.data.bgActivePosistion = math.array2point( r.touchData.startPosition );\n              }\n\n              r.redrawHint( 'select', true );\n\n              r.touchData.start = null;\n            }\n          }\n\n        }\n\n        // Re-project\n        var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY );\n        now[0] = pos[0]; now[1] = pos[1];\n      }\n    }\n\n    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }\n    //r.redraw();\n\n  }, false );\n\n  var touchcancelHandler;\n  r.registerBinding( window, 'touchcancel', touchcancelHandler = function( e ){\n    var start = r.touchData.start;\n\n    r.touchData.capture = false;\n\n    if( start ){\n      start.unactivate();\n    }\n  } );\n\n  var touchendHandler;\n  r.registerBinding( window, 'touchend', touchendHandler = function( e ){\n    var start = r.touchData.start;\n\n    var capture = r.touchData.capture;\n\n    if( capture ){\n      r.touchData.capture = false;\n\n      e.preventDefault();\n    } else {\n      return;\n    }\n\n    var select = r.selection;\n\n    r.swipePanning = false;\n    r.hoverData.draggingEles = false;\n\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var now = r.touchData.now;\n    var earlier = r.touchData.earlier;\n\n    if( e.touches[0] ){ var pos = r.projectIntoViewport( e.touches[0].clientX, e.touches[0].clientY ); now[0] = pos[0]; now[1] = pos[1]; }\n    if( e.touches[1] ){ var pos = r.projectIntoViewport( e.touches[1].clientX, e.touches[1].clientY ); now[2] = pos[0]; now[3] = pos[1]; }\n    if( e.touches[2] ){ var pos = r.projectIntoViewport( e.touches[2].clientX, e.touches[2].clientY ); now[4] = pos[0]; now[5] = pos[1]; }\n\n    if( start ){\n      start.unactivate();\n    }\n\n    var ctxTapend;\n    if( r.touchData.cxt ){\n      ctxTapend = new Event( e, {\n        type: 'cxttapend',\n        cyPosition: { x: now[0], y: now[1] }\n      } );\n\n      if( start ){\n        start.trigger( ctxTapend );\n      } else {\n        cy.trigger( ctxTapend );\n      }\n\n      if( !r.touchData.cxtDragged ){\n        var ctxTap = new Event( e, {\n          type: 'cxttap',\n          cyPosition: { x: now[0], y: now[1] }\n        } );\n\n        if( start ){\n          start.trigger( ctxTap );\n        } else {\n          cy.trigger( ctxTap );\n        }\n\n      }\n\n      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n      r.touchData.cxt = false;\n      r.touchData.start = null;\n\n      r.redraw();\n      return;\n    }\n\n    // no more box selection if we don't have three fingers\n    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){\n      r.touchData.selecting = false;\n\n      var box = cy.collection( r.getAllInBox( select[0], select[1], select[2], select[3] ) );\n\n      select[0] = undefined;\n      select[1] = undefined;\n      select[2] = undefined;\n      select[3] = undefined;\n      select[4] = 0;\n\n      r.redrawHint( 'select', true );\n\n      cy.trigger('boxend');\n\n      var eleWouldBeSelected = function( ele ){ return ele.selectable() && !ele.selected(); };\n\n      box\n        .trigger('box')\n        .stdFilter( eleWouldBeSelected )\n          .select()\n          .trigger('boxselect')\n      ;\n\n      if( box.nonempty() ){\n        r.redrawHint( 'eles', true );\n      }\n\n      r.redraw();\n    }\n\n    if( start != null ){\n      start.unactivate();\n    }\n\n    if( e.touches[2] ){\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint( 'select', true );\n    } else if( e.touches[1] ){\n\n    } else if( e.touches[0] ){\n\n    // Last touch released\n    } else if( !e.touches[0] ){\n\n      r.data.bgActivePosistion = undefined;\n      r.redrawHint( 'select', true );\n\n      var draggedEles = r.dragData.touchDragEles;\n\n      if( start != null ){\n\n        var startWasGrabbed = start._private.grabbed;\n\n        freeDraggedElements( draggedEles );\n\n        r.redrawHint( 'drag', true );\n        r.redrawHint( 'eles', true );\n\n        if( startWasGrabbed ){\n          start.trigger( 'free' );\n        }\n\n        triggerEvents( start, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {\n          cyPosition: { x: now[0], y: now[1] }\n        } );\n\n        start.unactivate();\n\n        r.touchData.start = null;\n\n      } else {\n        var near = r.findNearestElement( now[0], now[1], true, true );\n\n        triggerEvents( near, [ 'touchend', 'tapend', 'vmouseup', 'tapdragout' ], e, {\n          cyPosition: { x: now[0], y: now[1] }\n        } );\n\n      }\n\n      var dx = r.touchData.startPosition[0] - now[0];\n      var dx2 = dx * dx;\n      var dy = r.touchData.startPosition[1] - now[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom;\n\n      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n      if( start != null\n          && !r.dragData.didDrag // didn't drag nodes around\n          && start._private.selectable\n          && rdist2 < r.touchTapThreshold2\n          && !r.pinching // pinch to zoom should not affect selection\n      ){\n\n        if( cy.selectionType() === 'single' ){\n          cy.$( ':selected' ).unmerge( start ).unselect();\n          start.select();\n        } else {\n          if( start.selected() ){\n            start.unselect();\n          } else {\n            start.select();\n          }\n        }\n\n        r.redrawHint( 'eles', true );\n      }\n\n      // Tap event, roughly same as mouse click event for touch\n      if( !r.touchData.singleTouchMoved ){\n        triggerEvents( start, [ 'tap', 'vclick' ], e, {\n          cyPosition: { x: now[0], y: now[1] }\n        } );\n      }\n\n      r.touchData.singleTouchMoved = true;\n    }\n\n    for( var j = 0; j < now.length; j++ ){ earlier[ j ] = now[ j ]; }\n\n    r.dragData.didDrag = false; // reset for next mousedown\n\n    if( e.touches.length === 0 ){\n      r.touchData.dragDelta = [];\n      r.touchData.startPosition = null;\n      r.touchData.startGPosition = null;\n    }\n\n    if( e.touches.length < 2 ){\n      r.pinching = false;\n      r.redrawHint( 'eles', true );\n      r.redraw();\n    }\n\n    //r.redraw();\n\n  }, false );\n\n  // fallback compatibility layer for ms pointer events\n  if( typeof TouchEvent === 'undefined' ){\n\n    var pointers = [];\n\n    var makeTouch = function( e ){\n      return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n        force: 1,\n        identifier: e.pointerId,\n        pageX: e.pageX,\n        pageY: e.pageY,\n        radiusX: e.width / 2,\n        radiusY: e.height / 2,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        target: e.target\n      };\n    };\n\n    var makePointer = function( e ){\n      return {\n        event: e,\n        touch: makeTouch( e )\n      };\n    };\n\n    var addPointer = function( e ){\n      pointers.push( makePointer( e ) );\n    };\n\n    var removePointer = function( e ){\n      for( var i = 0; i < pointers.length; i++ ){\n        var p = pointers[ i ];\n\n        if( p.event.pointerId === e.pointerId ){\n          pointers.splice( i, 1 );\n          return;\n        }\n      }\n    };\n\n    var updatePointer = function( e ){\n      var p = pointers.filter( function( p ){\n        return p.event.pointerId === e.pointerId;\n      } )[0];\n\n      p.event = e;\n      p.touch = makeTouch( e );\n    };\n\n    var addTouchesToEvent = function( e ){\n      e.touches = pointers.map( function( p ){\n        return p.touch;\n      } );\n    };\n\n    r.registerBinding( r.container, 'pointerdown', function( e ){\n      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\n      e.preventDefault();\n\n      addPointer( e );\n\n      addTouchesToEvent( e );\n      touchstartHandler( e );\n    } );\n\n    r.registerBinding( r.container, 'pointerup', function( e ){\n      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\n      removePointer( e );\n\n      addTouchesToEvent( e );\n      touchendHandler( e );\n    } );\n\n    r.registerBinding( r.container, 'pointercancel', function( e ){\n      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\n      removePointer( e );\n\n      addTouchesToEvent( e );\n      touchcancelHandler( e );\n    } );\n\n    r.registerBinding( r.container, 'pointermove', function( e ){\n      if( e.pointerType === 'mouse' ){ return; } // mouse already handled\n\n      e.preventDefault();\n\n      updatePointer( e );\n\n      addTouchesToEvent( e );\n      touchmoveHandler( e );\n    } );\n\n  }\n};\n\nmodule.exports = BRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/base/load-listeners.js\n ** module id = 116\n ** module chunks = 0\n **/","'use strict';\n\nvar math = require( '../../../math' );\n\nvar BRp = {};\n\nBRp.registerNodeShapes = function(){\n  var nodeShapes = this.nodeShapes = {};\n  var renderer = this;\n\n  nodeShapes[ 'ellipse' ] = {\n    name: 'ellipse',\n\n    draw: function( context, centerX, centerY, width, height ){\n      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );\n    },\n\n    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){\n      return math.intersectLineEllipse(\n        x, y,\n        nodeX,\n        nodeY,\n        width / 2 + padding,\n        height / 2 + padding )\n      ;\n    },\n\n    checkPoint: function( x, y, padding, width, height, centerX, centerY ){\n      x -= centerX;\n      y -= centerY;\n\n      x /= (width / 2 + padding);\n      y /= (height / 2 + padding);\n\n      return x * x + y * y <= 1;\n    }\n  };\n\n  function generatePolygon( name, points ){\n    return ( nodeShapes[ name ] = {\n      name: name,\n\n      points: points,\n\n      draw: function( context, centerX, centerY, width, height ){\n        renderer.nodeShapeImpl( 'polygon' )( context, centerX, centerY, width, height, this.points );\n      },\n\n      intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){\n        return math.polygonIntersectLine(\n            x, y,\n            this.points,\n            nodeX,\n            nodeY,\n            width / 2, height / 2,\n            padding )\n          ;\n      },\n\n      checkPoint: function( x, y, padding, width, height, centerX, centerY ){\n        return math.pointInsidePolygon( x, y, nodeShapes[ name ].points,\n          centerX, centerY, width, height, [0, -1], padding )\n        ;\n      }\n    } );\n  }\n\n  generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare( 3, 0 ) );\n\n  generatePolygon( 'square', math.generateUnitNgonPointsFitToSquare( 4, 0 ) );\n  nodeShapes[ 'rectangle' ] = nodeShapes[ 'square' ];\n\n  nodeShapes[ 'roundrectangle' ] = {\n    name: 'roundrectangle',\n\n    points: math.generateUnitNgonPointsFitToSquare( 4, 0 ),\n\n    draw: function( context, centerX, centerY, width, height ){\n      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );\n    },\n\n    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){\n      return math.roundRectangleIntersectLine(\n        x, y,\n        nodeX,\n        nodeY,\n        width, height,\n        padding )\n      ;\n    },\n\n    // Looks like the width passed into this function is actually the total width / 2\n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY ){\n\n      var cornerRadius = math.getRoundRectangleRadius( width, height );\n\n      // Check hBox\n      if( math.pointInsidePolygon( x, y, this.points,\n        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding ) ){\n        return true;\n      }\n\n      // Check vBox\n      if( math.pointInsidePolygon( x, y, this.points,\n        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding ) ){\n        return true;\n      }\n\n      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){\n        x -= centerX;\n        y -= centerY;\n\n        x /= (width / 2 + padding);\n        y /= (height / 2 + padding);\n\n        return (x * x + y * y <= 1);\n      };\n\n\n      // Check top left quarter circle\n      if( checkInEllipse( x, y,\n        centerX - width / 2 + cornerRadius,\n        centerY - height / 2 + cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\n        return true;\n      }\n\n      // Check top right quarter circle\n      if( checkInEllipse( x, y,\n        centerX + width / 2 - cornerRadius,\n        centerY - height / 2 + cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\n        return true;\n      }\n\n      // Check bottom right quarter circle\n      if( checkInEllipse( x, y,\n        centerX + width / 2 - cornerRadius,\n        centerY + height / 2 - cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\n        return true;\n      }\n\n      // Check bottom left quarter circle\n      if( checkInEllipse( x, y,\n        centerX - width / 2 + cornerRadius,\n        centerY + height / 2 - cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding ) ){\n\n        return true;\n      }\n\n      return false;\n    }\n  };\n\n  generatePolygon( 'diamond', [\n    0, 1,\n    1, 0,\n    0, -1,\n    -1, 0\n  ] );\n\n  generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare( 5, 0 ) );\n\n  generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare( 6, 0 ) );\n\n  generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare( 7, 0 ) );\n\n  generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare( 8, 0 ) );\n\n  var star5Points = new Array( 20 );\n  {\n    var outerPoints = math.generateUnitNgonPoints( 5, 0 );\n    var innerPoints = math.generateUnitNgonPoints( 5, Math.PI / 5 );\n\n    // Outer radius is 1; inner radius of star is smaller\n    var innerRadius = 0.5 * (3 - Math.sqrt( 5 ));\n    innerRadius *= 1.57;\n\n    for( var i = 0;i < innerPoints.length / 2;i++ ){\n      innerPoints[ i * 2] *= innerRadius;\n      innerPoints[ i * 2 + 1] *= innerRadius;\n    }\n\n    for( var i = 0;i < 20 / 4;i++ ){\n      star5Points[ i * 4] = outerPoints[ i * 2];\n      star5Points[ i * 4 + 1] = outerPoints[ i * 2 + 1];\n\n      star5Points[ i * 4 + 2] = innerPoints[ i * 2];\n      star5Points[ i * 4 + 3] = innerPoints[ i * 2 + 1];\n    }\n  }\n\n  star5Points = math.fitPolygonToSquare( star5Points );\n\n  generatePolygon( 'star', star5Points );\n\n  generatePolygon( 'vee', [\n    -1, -1,\n    0, -0.333,\n    1, -1,\n    0, 1\n  ] );\n\n  generatePolygon( 'rhomboid', [\n    -1, -1,\n    0.333, -1,\n    1, 1,\n    -0.333, 1\n  ] );\n\n  nodeShapes.makePolygon = function( points ){\n\n    // use caching on user-specified polygons so they are as fast as native shapes\n\n    var key = points.join( '$' );\n    var name = 'polygon-' + key;\n    var shape;\n\n    if( (shape = nodeShapes[ name ]) ){ // got cached shape\n      return shape;\n    }\n\n    // create and cache new shape\n    return generatePolygon( name, points );\n  };\n\n};\n\nmodule.exports = BRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/base/node-shapes.js\n ** module id = 117\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../../util' );\n\nvar BRp = {};\n\nBRp.timeToRender = function(){\n  return this.redrawTotalTime / this.redrawCount;\n};\n\nBRp.redraw = function( options ){\n  options = options || util.staticEmptyObject();\n\n  var r = this;\n\n  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }\n  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }\n  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }\n\n  r.requestedFrame = true;\n  r.renderOptions = options;\n};\n\nBRp.beforeRender = function( fn, priority ){\n  priority = priority || 0;\n\n  var cbs = this.beforeRenderCallbacks;\n\n  cbs.push({ fn: fn, priority: priority });\n\n  // higher priority callbacks executed first\n  cbs.sort(function( a, b ){ return b.priority - a.priority; });\n};\n\nBRp.startRenderLoop = function(){\n  var r = this;\n\n  if( r.renderLoopStarted ){\n    return;\n  } else {\n    r.renderLoopStarted = true;\n  }\n\n  var beforeRenderCallbacks = function( willDraw, startTime ){\n    var cbs = r.beforeRenderCallbacks;\n\n    for( var i = 0; i < cbs.length; i++ ){\n      cbs[i].fn( willDraw, startTime );\n    }\n  };\n\n  var renderFn = function( requestTime ){\n    if( r.destroyed ){ return; }\n\n    if( r.requestedFrame && !r.skipFrame ){\n      beforeRenderCallbacks( true, requestTime );\n\n      var startTime = util.performanceNow();\n\n      r.render( r.renderOptions );\n\n      var endTime = r.lastDrawTime = util.performanceNow();\n\n      if( r.averageRedrawTime === undefined ){\n        r.averageRedrawTime = endTime - startTime;\n      }\n\n      if( r.redrawCount === undefined ){\n        r.redrawCount = 0;\n      }\n\n      r.redrawCount++;\n\n      if( r.redrawTotalTime === undefined ){\n        r.redrawTotalTime = 0;\n      }\n\n      var duration = endTime - startTime;\n\n      r.redrawTotalTime += duration;\n      r.lastRedrawTime = duration;\n\n      // use a weighted average with a bias from the previous average so we don't spike so easily\n      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n\n      r.requestedFrame = false;\n    } else {\n      beforeRenderCallbacks( false, requestTime );\n    }\n\n    r.skipFrame = false;\n\n    util.requestAnimationFrame( renderFn );\n  };\n\n  util.requestAnimationFrame( renderFn );\n\n};\n\nmodule.exports = BRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/base/redraw.js\n ** module id = 118\n ** module chunks = 0\n **/","/*\nThe canvas renderer was written by Yue Dong.\n\nModifications tracked on Github.\n*/\n\n'use strict';\n\nvar util = require( '../../../util' );\nvar is = require( '../../../is' );\nvar ElementTextureCache = require('./ele-texture-cache');\nvar LayeredTextureCache = require('./layered-texture-cache');\n\nvar CR = CanvasRenderer;\nvar CRp = CanvasRenderer.prototype;\n\nCRp.CANVAS_LAYERS = 3;\n//\nCRp.SELECT_BOX = 0;\nCRp.DRAG = 1;\nCRp.NODE = 2;\n\nCRp.BUFFER_COUNT = 3;\n//\nCRp.TEXTURE_BUFFER = 0;\nCRp.MOTIONBLUR_BUFFER_NODE = 1;\nCRp.MOTIONBLUR_BUFFER_DRAG = 2;\n\nfunction CanvasRenderer( options ){\n  var r = this;\n\n  r.data = {\n    canvases: new Array( CRp.CANVAS_LAYERS ),\n    contexts: new Array( CRp.CANVAS_LAYERS ),\n    canvasNeedsRedraw: new Array( CRp.CANVAS_LAYERS ),\n\n    bufferCanvases: new Array( CRp.BUFFER_COUNT ),\n    bufferContexts: new Array( CRp.CANVAS_LAYERS ),\n  };\n\n  r.data.canvasContainer = document.createElement( 'div' );\n  var containerStyle = r.data.canvasContainer.style;\n  r.data.canvasContainer.setAttribute( 'style', '-webkit-tap-highlight-color: rgba(0,0,0,0);' );\n  containerStyle.position = 'relative';\n  containerStyle.zIndex = '0';\n  containerStyle.overflow = 'hidden';\n\n  var container = options.cy.container();\n  container.appendChild( r.data.canvasContainer );\n  container.setAttribute( 'style', ( container.getAttribute( 'style' ) || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);' );\n\n  for( var i = 0; i < CRp.CANVAS_LAYERS; i++ ){\n    var canvas = r.data.canvases[ i ] = document.createElement( 'canvas' );\n    r.data.contexts[ i ] = canvas.getContext( '2d' );\n    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );\n    canvas.style.position = 'absolute';\n    canvas.setAttribute( 'data-id', 'layer' + i );\n    canvas.style.zIndex = String( CRp.CANVAS_LAYERS - i );\n    r.data.canvasContainer.appendChild( canvas );\n\n    r.data.canvasNeedsRedraw[ i ] = false;\n  }\n  r.data.topCanvas = r.data.canvases[0];\n\n  r.data.canvases[ CRp.NODE ].setAttribute( 'data-id', 'layer' + CRp.NODE + '-node' );\n  r.data.canvases[ CRp.SELECT_BOX ].setAttribute( 'data-id', 'layer' + CRp.SELECT_BOX + '-selectbox' );\n  r.data.canvases[ CRp.DRAG ].setAttribute( 'data-id', 'layer' + CRp.DRAG + '-drag' );\n\n  for( var i = 0; i < CRp.BUFFER_COUNT; i++ ){\n    r.data.bufferCanvases[ i ] = document.createElement( 'canvas' );\n    r.data.bufferContexts[ i ] = r.data.bufferCanvases[ i ].getContext( '2d' );\n    r.data.bufferCanvases[ i ].style.position = 'absolute';\n    r.data.bufferCanvases[ i ].setAttribute( 'data-id', 'buffer' + i );\n    r.data.bufferCanvases[ i ].style.zIndex = String( -i - 1 );\n    r.data.bufferCanvases[ i ].style.visibility = 'hidden';\n    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n  }\n\n  r.pathsEnabled = true;\n\n  r.data.eleTxrCache = new ElementTextureCache( r );\n  r.data.lyrTxrCache = new LayeredTextureCache( r, r.data.eleTxrCache );\n\n  r.onUpdateEleCalcs(function invalidateTextureCaches( willDraw, eles ){\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[i];\n      var rs = ele._private.rstyle;\n      var de = rs.dirtyEvents;\n\n      if( ele.isNode() && de && de.length === 1 && de['position'] ){\n        // then keep cached ele texture\n      } else {\n        r.data.eleTxrCache.invalidateElement( ele );\n      }\n    }\n\n    if( eles.length > 0 ){\n      r.data.lyrTxrCache.invalidateElements( eles );\n    }\n  });\n}\n\nCRp.redrawHint = function( group, bool ){\n  var r = this;\n\n  switch( group ){\n    case 'eles':\n      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;\n      break;\n    case 'drag':\n      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;\n      break;\n    case 'select':\n      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;\n      break;\n  }\n};\n\n// whether to use Path2D caching for drawing\nvar pathsImpld = typeof Path2D !== 'undefined';\n\nCRp.path2dEnabled = function( on ){\n  if( on === undefined ){\n    return this.pathsEnabled;\n  }\n\n  this.pathsEnabled = on ? true : false;\n};\n\nCRp.usePaths = function(){\n  return pathsImpld && this.pathsEnabled;\n};\n\n[\n  require( './arrow-shapes' ),\n  require( './drawing-elements' ),\n  require( './drawing-edges' ),\n  require( './drawing-images' ),\n  require( './drawing-label-text' ),\n  require( './drawing-nodes' ),\n  require( './drawing-redraw' ),\n  require( './drawing-shapes' ),\n  require( './export-image' ),\n  require( './node-shapes' )\n].forEach( function( props ){\n  util.extend( CRp, props );\n} );\n\nmodule.exports = CR;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/index.js\n ** module id = 119\n ** module chunks = 0\n **/","'use strict';\n\nvar math = require( '../../../math' );\nvar util = require( '../../../util' );\nvar Heap = require( '../../../heap' );\nvar defs = require( './texture-cache-defs' );\n\nvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\nvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\nvar defTxrWidth = 1024; // default/minimum texture width\nvar maxTxrW = 1024; // the maximum width of a texture\nvar maxTxrH = 1024;  // the maximum height of a texture\nvar minUtility = 0.5; // if usage of texture is less than this, it is retired\nvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\nvar maxFullnessChecks = 10; // dequeued after this many checks\nvar allowEdgeTxrCaching = false; // whether edges can be cached as textures (TODO maybe better on if webgl supported?)\nvar allowParentTxrCaching = false; // whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\nvar getTxrReasons = {\n  dequeue: 'dequeue',\n  downscale: 'downscale',\n  highQuality: 'highQuality'\n};\n\nvar ElementTextureCache = function( renderer ){\n  var self = this;\n\n  self.renderer = renderer;\n  self.onDequeues = [];\n\n  self.setupDequeueing();\n};\n\nvar ETCp = ElementTextureCache.prototype;\n\nETCp.reasons = getTxrReasons;\n\n// the list of textures in which new subtextures for elements can be placed\nETCp.getTextureQueue = function( txrH ){\n  var self = this;\n  self.eleImgCaches = self.eleImgCaches || {};\n\n  return ( self.eleImgCaches[ txrH ] = self.eleImgCaches[ txrH ] || [] );\n};\n\n// the list of usused textures which can be recycled (in use in texture queue)\nETCp.getRetiredTextureQueue = function( txrH ){\n  var self = this;\n\n  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n  var rtxtrQ = rtxtrQs[ txrH ] = rtxtrQs[ txrH ] || [];\n\n  return rtxtrQ;\n};\n\n// queue of element draw requests at different scale levels\nETCp.getElementQueue = function(){\n  var self = this;\n\n  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function( a, b ){\n    return b.reqs - a.reqs;\n  });\n\n  return q;\n};\n\n// queue of element draw requests at different scale levels (element id lookup)\nETCp.getElementIdToQueue = function(){\n  var self = this;\n\n  var id2q = self.eleIdToCacheQueue = self.eleIdToCacheQueue || {};\n\n  return id2q;\n};\n\nETCp.getElement = function( ele, bb, pxRatio, lvl, reason ){\n  var self = this;\n  var r = this.renderer;\n  var rs = ele._private.rscratch;\n  var zoom = r.cy.zoom();\n\n  if( lvl == null ){\n    lvl = Math.ceil( math.log2( zoom * pxRatio ) );\n  }\n\n  if( lvl < minLvl ){\n    lvl = minLvl;\n  } else if( zoom >= maxZoom || lvl > maxLvl ){\n    return null;\n  }\n\n  var scale = Math.pow( 2, lvl );\n  var eleScaledH = bb.h * scale;\n  var eleScaledW = bb.w * scale;\n  var caches = rs.imgCaches = rs.imgCaches || {};\n  var eleCache = caches[lvl];\n\n  if( eleCache ){\n    return eleCache;\n  }\n\n  var txrH; // which texture height this ele belongs to\n\n  if( eleScaledH <= minTxrH ){\n    txrH = minTxrH;\n  } else if( eleScaledH <= txrStepH ){\n    txrH = txrStepH;\n  } else {\n    txrH = Math.ceil( eleScaledH / txrStepH ) * txrStepH;\n  }\n\n  if(\n    eleScaledH > maxTxrH\n    || eleScaledW > maxTxrW\n    || ( !allowEdgeTxrCaching && ele.isEdge() )\n    || ( !allowParentTxrCaching && ele.isParent() )\n  ){\n    return null; // caching large elements is not efficient\n  }\n\n  var txrQ = self.getTextureQueue( txrH );\n\n  // first try the second last one in case it has space at the end\n  var txr = txrQ[ txrQ.length - 2 ];\n\n  var addNewTxr = function(){\n    return self.recycleTexture( txrH, eleScaledW ) || self.addTexture( txrH, eleScaledW );\n  };\n\n  // try the last one if there is no second last one\n  if( !txr ){\n    txr = txrQ[ txrQ.length - 1 ];\n  }\n\n  // if the last one doesn't exist, we need a first one\n  if( !txr ){\n    txr = addNewTxr();\n  }\n\n  // if there's no room in the current texture, we need a new one\n  if( txr.width - txr.usedWidth < eleScaledW ){\n    txr = addNewTxr();\n  }\n\n  var scaledLabelShown = r.eleTextBiggerThanMin( ele, scale );\n  var scalableFrom = function( otherCache ){\n    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n  };\n\n  var deqing = reason && reason === getTxrReasons.dequeue;\n  var highQualityReq = reason && reason === getTxrReasons.highQuality;\n  var downscaleReq = reason && reason === getTxrReasons.downscale;\n\n  var higherCache; // the nearest cache with a higher level\n  for( var l = lvl + 1; l <= maxLvl; l++ ){\n    var c = caches[l];\n\n    if( c ){ higherCache = c; break; }\n  }\n\n  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n\n  var downscale = function(){\n    txr.context.drawImage(\n      oneUpCache.texture.canvas,\n      oneUpCache.x, 0,\n      oneUpCache.width, oneUpCache.height,\n      txr.usedWidth, 0,\n      eleScaledW, eleScaledH\n    );\n  };\n\n  if( scalableFrom(oneUpCache) ){\n    // then we can relatively cheaply rescale the existing image w/o rerendering\n    downscale();\n\n  } else if( scalableFrom(higherCache) ){\n    // then use the higher cache for now and queue the next level down\n    // to cheaply scale towards the smaller level\n\n    if( highQualityReq ){\n      for( var l = higherCache.level; l > lvl; l-- ){\n        oneUpCache = self.getElement( ele, bb, pxRatio, l, getTxrReasons.downscale );\n      }\n\n      downscale();\n\n    } else {\n      self.queueElement( ele, bb, higherCache.level - 1 );\n\n      return higherCache;\n    }\n  } else {\n\n    var lowerCache; // the nearest cache with a lower level\n    if( !deqing && !highQualityReq && !downscaleReq ){\n      for( var l = lvl - 1; l >= minLvl; l-- ){\n        var c = caches[l];\n\n        if( c ){ lowerCache = c; break; }\n      }\n    }\n\n    if( scalableFrom(lowerCache) ){\n      // then use the lower quality cache for now and queue the better one for later\n\n      self.queueElement( ele, bb, lvl );\n\n      return lowerCache;\n    }\n\n    txr.context.translate( txr.usedWidth, 0 );\n    txr.context.scale( scale, scale );\n\n    r.drawElement( txr.context, ele, bb, scaledLabelShown );\n\n    txr.context.scale( 1/scale, 1/scale );\n    txr.context.translate( -txr.usedWidth, 0 );\n  }\n\n  eleCache = caches[lvl] = {\n    ele: ele,\n    x: txr.usedWidth,\n    texture: txr,\n    level: lvl,\n    scale: scale,\n    width: eleScaledW,\n    height: eleScaledH,\n    scaledLabelShown: scaledLabelShown\n  };\n\n  txr.usedWidth += Math.ceil( eleScaledW + eleTxrSpacing );\n\n  txr.eleCaches.push( eleCache );\n\n  self.checkTextureFullness( txr );\n\n  return eleCache;\n};\n\nETCp.invalidateElement = function( ele ){\n  var self = this;\n  var caches = ele._private.rscratch.imgCaches;\n\n  if( caches ){\n    for( var lvl = minLvl; lvl <= maxLvl; lvl++ ){\n      var cache = caches[ lvl ];\n\n      if( cache ){\n        var txr = cache.texture;\n\n        // remove space from the texture it belongs to\n        txr.invalidatedWidth += cache.width;\n\n        // remove refs with the element\n        caches[ lvl ] = null;\n        util.removeFromArray( txr.eleCaches, cache );\n\n        // might have to remove the entire texture if it's not efficiently using its space\n        self.checkTextureUtility( txr );\n      }\n    }\n  }\n};\n\nETCp.checkTextureUtility = function( txr ){\n  // invalidate all entries in the cache if the cache size is small\n  if( txr.invalidatedWidth >= minUtility * txr.width ){\n    this.retireTexture( txr );\n  }\n};\n\nETCp.checkTextureFullness = function( txr ){\n  // if texture has been mostly filled and passed over several times, remove\n  // it from the queue so we don't need to waste time looking at it to put new things\n\n  var self = this;\n  var txrQ = self.getTextureQueue( txr.height );\n\n  if( txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks ){\n    util.removeFromArray( txrQ, txr );\n  } else {\n    txr.fullnessChecks++;\n  }\n};\n\nETCp.retireTexture = function( txr ){\n  var self = this;\n  var txrH = txr.height;\n  var txrQ = self.getTextureQueue( txrH );\n\n  // retire the texture from the active / searchable queue:\n\n  util.removeFromArray( txrQ, txr );\n\n  txr.retired = true;\n\n  // remove the refs from the eles to the caches:\n\n  var eleCaches = txr.eleCaches;\n\n  for( var i = 0; i < eleCaches.length; i++ ){\n    var eleCache = eleCaches[i];\n    var ele = eleCache.ele;\n    var lvl = eleCache.level;\n    var imgCaches = ele._private.rscratch.imgCaches;\n\n    if( imgCaches ){\n      imgCaches[ lvl ] = null;\n    }\n  }\n\n  util.clearArray( eleCaches );\n\n  // add the texture to a retired queue so it can be recycled in future:\n\n  var rtxtrQ = self.getRetiredTextureQueue( txrH );\n\n  rtxtrQ.push( txr );\n};\n\nETCp.addTexture = function( txrH, minW ){\n  var self = this;\n  var txrQ = self.getTextureQueue( txrH );\n  var txr = {};\n\n  txrQ.push( txr );\n\n  txr.eleCaches = [];\n\n  txr.height = txrH;\n  txr.width = Math.max( defTxrWidth, minW );\n  txr.usedWidth = 0;\n  txr.invalidatedWidth = 0;\n  txr.fullnessChecks = 0;\n\n  txr.canvas = document.createElement('canvas');\n  txr.canvas.width = txr.width;\n  txr.canvas.height = txr.height;\n\n  txr.context = txr.canvas.getContext('2d');\n\n  return txr;\n};\n\nETCp.recycleTexture = function( txrH, minW ){\n  var self = this;\n  var txrQ = self.getTextureQueue( txrH );\n  var rtxtrQ = self.getRetiredTextureQueue( txrH );\n\n  for( var i = 0; i < rtxtrQ.length; i++ ){\n    var txr = rtxtrQ[i];\n\n    if( txr.width >= minW ){\n      txr.retired = false;\n\n      txr.usedWidth = 0;\n      txr.invalidatedWidth = 0;\n      txr.fullnessChecks = 0;\n\n      util.clearArray( txr.eleCaches );\n\n      txr.context.clearRect( 0, 0, txr.width, txr.height );\n\n      util.removeFromArray( rtxtrQ, txr );\n      txrQ.push( txr );\n\n      return txr;\n    }\n  }\n};\n\nETCp.queueElement = function( ele, bb, lvl ){\n  var self = this;\n  var q = self.getElementQueue();\n  var id2q = self.getElementIdToQueue();\n  var id = ele.id();\n  var existingReq = id2q[ id ];\n\n  if( existingReq ){ // use the max lvl b/c in between lvls are cheap to make\n    existingReq.level = Math.max( existingReq.level, lvl );\n    existingReq.reqs++;\n\n    q.updateItem( existingReq );\n  } else {\n    var req = {\n      ele: ele,\n      bb: bb,\n      position: math.copyPosition( ele.position() ),\n      level: lvl,\n      reqs: 1\n    };\n\n    if( ele.isEdge() ){\n      req.positions = {\n        source: math.copyPosition( ele.source().position() ),\n        target: math.copyPosition( ele.target().position() )\n      };\n    }\n\n    q.push( req );\n\n    id2q[ id ] = req;\n  }\n};\n\nETCp.dequeue = function( pxRatio, extent ){\n  var self = this;\n  var q = self.getElementQueue();\n  var id2q = self.getElementIdToQueue();\n  var dequeued = [];\n\n  for( var i = 0; i < maxDeqSize; i++ ){\n    if( q.size() > 0 ){\n      var req = q.pop();\n\n      id2q[ req.ele.id() ] = null;\n\n      dequeued.push( req );\n\n      var ele = req.ele;\n      var bb;\n\n      if(\n        ( ele.isEdge()\n          && (\n            !math.arePositionsSame( ele.source().position(), req.positions.source )\n            || !math.arePositionsSame( ele.target().position(), req.positions.target )\n          )\n        )\n        || ( !math.arePositionsSame( ele.position(), req.position ) )\n      ){\n        bb = ele.boundingBox();\n      } else {\n        bb = req.bb;\n      }\n\n      self.getElement( req.ele, bb, pxRatio, req.level, getTxrReasons.dequeue );\n    } else {\n      break;\n    }\n  }\n\n  return dequeued;\n};\n\nETCp.onDequeue = function( fn ){ this.onDequeues.push( fn ); };\nETCp.offDequeue = function( fn ){ util.removeFromArray( this.onDequeues, fn ); };\n\nETCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold,\n  deqCost: deqCost,\n  deqAvgCost: deqAvgCost,\n  deqNoDrawCost: deqNoDrawCost,\n  deqFastCost: deqFastCost,\n  deq: function( self, pxRatio, extent ){\n    return self.dequeue( pxRatio, extent );\n  },\n  onDeqd: function( self, deqd ){\n    for( var i = 0; i < self.onDequeues.length; i++ ){\n      var fn = self.onDequeues[i];\n\n      fn( deqd );\n    }\n  },\n  shouldRedraw: function( self, deqd, pxRatio, extent ){\n    for( var i = 0; i < deqd.length; i++ ){\n      var bb = deqd[i].bb;\n\n      if( math.boundingBoxesIntersect( bb, extent ) ){\n        return true;\n      }\n    }\n\n    return false;\n  },\n  priority: function( self ){\n    return self.renderer.beforeRenderPriorities.eleTxrDeq;\n  }\n});\n\nmodule.exports = ElementTextureCache;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/ele-texture-cache.js\n ** module id = 120\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../../util' );\n\nvar fullFpsTime = 1000/60; // assume 60 frames per second\n\nmodule.exports = {\n  setupDequeueing: function( opts ){\n    return function setupDequeueingImpl(){\n      var self = this;\n      var r = this.renderer;\n\n      if( self.dequeueingSetup ){\n        return;\n      } else {\n        self.dequeueingSetup = true;\n      }\n\n      var queueRedraw = util.debounce( function(){\n        r.redrawHint( 'eles', true );\n        r.redrawHint( 'drag', true );\n\n        r.redraw();\n      }, opts.deqRedrawThreshold );\n\n      var dequeue = function( willDraw, frameStartTime ){\n        var startTime = util.performanceNow();\n        var avgRenderTime = r.averageRedrawTime;\n        var renderTime = r.lastRedrawTime;\n        var deqd = [];\n        var extent = r.cy.extent();\n        var pixelRatio = r.getPixelRatio();\n\n        while( true ){\n          var now = util.performanceNow();\n          var duration = now - startTime;\n          var frameDuration = now - frameStartTime;\n\n          if( renderTime < fullFpsTime ){\n            // if we're rendering faster than the ideal fps, then do dequeueing\n            // during all of the remaining frame time\n\n            var timeAvailable = fullFpsTime - ( willDraw ? avgRenderTime : 0 );\n\n            if( frameDuration >= opts.deqFastCost * timeAvailable ){\n              break;\n            }\n          } else {\n            if( willDraw ){\n              if(\n                   duration >= opts.deqCost * renderTime\n                || duration >= opts.deqAvgCost * avgRenderTime\n              ){\n                break;\n              }\n            } else if( frameDuration >= opts.deqNoDrawCost * fullFpsTime ){\n              break;\n            }\n          }\n\n          var thisDeqd = opts.deq( self, pixelRatio, extent );\n\n          if( thisDeqd.length > 0 ){\n            for( var i = 0; i < thisDeqd.length; i++ ){\n              deqd.push( thisDeqd[i] );\n            }\n          } else {\n            break;\n          }\n        }\n\n        // callbacks on dequeue\n        if( deqd.length > 0 ){\n          opts.onDeqd( self, deqd );\n\n          if( !willDraw && opts.shouldRedraw( self, deqd, pixelRatio, extent ) ){\n            queueRedraw();\n          }\n        }\n      };\n\n      var priority = opts.priority || util.noop;\n\n      r.beforeRender( dequeue, priority( self ) );\n    };\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/texture-cache-defs.js\n ** module id = 121\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../../util' );\nvar math = require( '../../../math' );\nvar Heap = require( '../../../heap' );\nvar is = require( '../../../is' );\nvar defs = require( './texture-cache-defs' );\n\nvar defNumLayers = 1; // default number of layers to use\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\nvar disableEleImgSmoothing = true; // when drawing eles on layers from an ele cache ; crisper and more performant when true\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\nvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\nvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\nvar alwaysQueue = true; // never draw all the layers in a level on a frame; draw directly until all dequeued\nvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n\nvar useEleTxrCaching = true; // whether to use individual ele texture caching underneath this cache\n\n// var log = function(){ console.log.apply( console, arguments ); };\n\nvar LayeredTextureCache = function( renderer, eleTxrCache ){\n  var self = this;\n\n  // TODO disable once not debugging\n  window.cache = this;\n\n  var r = self.renderer = renderer;\n\n  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\n  self.firstGet = true;\n\n  self.lastInvalidationTime = util.performanceNow() - 2*invalidThreshold;\n\n  self.skipping = false;\n\n  r.beforeRender(function( willDraw, now ){\n    if( now - self.lastInvalidationTime <= invalidThreshold ){\n      self.skipping = true;\n    } else {\n      self.skipping = false;\n    }\n  });\n\n  var qSort = function(a, b){\n    return b.reqs - a.reqs;\n  };\n\n  self.layersQueue = new Heap( qSort );\n\n  self.eleTxrCache = eleTxrCache;\n\n  self.setupEleCacheInvalidation();\n\n  self.setupDequeueing();\n};\n\nvar LTCp = LayeredTextureCache.prototype;\n\nvar layerIdPool = 0;\nvar MAX_INT = Math.pow(2, 53) - 1;\n\nLTCp.makeLayer = function( bb, lvl ){\n  var scale = Math.pow( 2, lvl );\n\n  var w = Math.ceil( bb.w * scale );\n  var h = Math.ceil( bb.h * scale );\n\n  var canvas = document.createElement('canvas');\n\n  canvas.width = w;\n  canvas.height = h;\n\n  var layer = {\n    id: (layerIdPool = ++layerIdPool % MAX_INT ),\n    bb: bb,\n    level: lvl,\n    width: w,\n    height: h,\n    canvas: canvas,\n    context: canvas.getContext('2d'),\n    eles: [],\n    elesQueue: [],\n    reqs: 0\n  };\n\n  // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\n  var cxt = layer.context;\n  var dx = -layer.bb.x1;\n  var dy = -layer.bb.y1;\n\n  // do the transform on creation to save cycles (it's the same for all eles)\n  cxt.scale( scale, scale );\n  cxt.translate( dx, dy );\n\n  return layer;\n};\n\nLTCp.getLayers = function( eles, pxRatio, lvl ){\n  var self = this;\n  var r = self.renderer;\n  var cy = r.cy;\n  var zoom = cy.zoom();\n  var firstGet = self.firstGet;\n\n  self.firstGet = false;\n\n  // log('--\\nget layers with %s eles', eles.length);\n  //log eles.map(function(ele){ return ele.id() }) );\n\n  if( lvl == null ){\n    lvl = Math.ceil( math.log2( zoom * pxRatio ) );\n\n    if( lvl < minLvl ){\n      lvl = minLvl;\n    } else if( zoom >= maxZoom || lvl > maxLvl ){\n      return null;\n    }\n  }\n\n  self.validateLayersElesOrdering( lvl, eles );\n\n  var layersByLvl = self.layersByLevel;\n  var scale = Math.pow( 2, lvl );\n  var layers = layersByLvl[ lvl ] = layersByLvl[ lvl ] || [];\n  var bb;\n\n  var lvlComplete = self.levelIsComplete( lvl, eles );\n  var tmpLayers;\n\n  var checkTempLevels = function(){\n    var canUseAsTmpLvl = function( l ){\n      self.validateLayersElesOrdering( l, eles );\n\n      if( self.levelIsComplete( l, eles ) ){\n        tmpLayers = layersByLvl[l];\n        return true;\n      }\n    };\n\n    var checkLvls = function( dir ){\n      if( tmpLayers ){ return; }\n\n      for( var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir ){\n        if( canUseAsTmpLvl(l) ){ break; }\n      }\n    };\n\n    checkLvls( +1 );\n    checkLvls( -1 );\n\n    // remove the invalid layers; they will be replaced as needed later in this function\n    for( var i = layers.length - 1; i >= 0; i-- ){\n      var layer = layers[i];\n\n      if( layer.invalid ){\n        util.removeFromArray( layers, layer );\n      }\n    }\n  };\n\n  if( !lvlComplete ){\n    // if the current level is incomplete, then use the closest, best quality layerset temporarily\n    // and later queue the current layerset so we can get the proper quality level soon\n\n    checkTempLevels();\n\n  } else {\n    // log('level complete, using existing layers\\n--');\n    return layers;\n  }\n\n  var getBb = function(){\n    if( !bb ){\n      bb = math.makeBoundingBox();\n\n      for( var i = 0; i < eles.length; i++ ){\n        math.updateBoundingBox( bb, eles[i].boundingBox() );\n      }\n    }\n\n    return bb;\n  };\n\n  var makeLayer = function( opts ){\n    opts = opts || {};\n\n    var after = opts.after;\n\n    getBb();\n\n    var area = ( bb.w * scale ) * ( bb.h * scale );\n\n    if( area > maxLayerArea ){\n      return null;\n    }\n\n    var layer = self.makeLayer( bb, lvl );\n\n    if( after != null ){\n      var index = layers.indexOf( after ) + 1;\n\n      layers.splice( index, 0, layer );\n    } else if( opts.insert === undefined || opts.insert ){\n      // no after specified => first layer made so put at start\n      layers.unshift( layer );\n    }\n\n    // if( tmpLayers ){\n      //self.queueLayer( layer );\n    // }\n\n    return layer;\n  };\n\n  if( self.skipping && !firstGet ){\n    // log('skip layers');\n    return null;\n  }\n\n  // log('do layers');\n\n  var layer = null;\n  var maxElesPerLayer = eles.length / defNumLayers;\n  var allowLazyQueueing = alwaysQueue && !firstGet;\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[i];\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n    // log('look at ele', ele.id());\n\n    var existingLayer = caches[ lvl ];\n\n    if( existingLayer ){\n      // reuse layer for later eles\n      // log('reuse layer for', ele.id());\n      layer = existingLayer;\n      continue;\n    }\n\n    if(\n      !layer\n      || layer.eles.length >= maxElesPerLayer\n      || ( defNumLayers > 1 && !math.boundingBoxInBoundingBox( layer.bb, ele.boundingBox() ) )\n    ){\n      // log('make new layer for ele %s', ele.id());\n\n      layer = makeLayer({ insert: true, after: layer });\n\n      // if now layer can be built then we can't use layers at this level\n      if( !layer ){ return null; }\n\n      // log('new layer with id %s', layer.id);\n    }\n\n    if( tmpLayers || allowLazyQueueing ){\n      // log('queue ele %s in layer %s', ele.id(), layer.id);\n      self.queueLayer( layer, ele );\n    } else {\n      // log('draw ele %s in layer %s', ele.id(), layer.id);\n      self.drawEleInLayer( layer, ele, lvl, pxRatio );\n    }\n\n    layer.eles.push( ele );\n\n    caches[ lvl ] = layer;\n  }\n\n  // log('--');\n\n  if( tmpLayers ){ // then we only queued the current layerset and can't draw it yet\n    return tmpLayers;\n  }\n\n  if( allowLazyQueueing ){\n    // log('lazy queue level', lvl);\n    return null;\n  }\n\n  return layers;\n};\n\n// a layer may want to use an ele cache of a higher level to avoid blurriness\n// so the layer level might not equal the ele level\nLTCp.getEleLevelForLayerLevel = function( lvl, pxRatio ){\n  return lvl;\n};\n\nfunction imgSmoothing( context, bool ){\n  if( context.imageSmoothingEnabled != null ){\n    context.imageSmoothingEnabled = bool;\n  } else {\n    context.webkitImageSmoothingEnabled = bool;\n    context.mozImageSmoothingEnabled = bool;\n    context.msImageSmoothingEnabled = bool;\n  }\n}\n\nLTCp.drawEleInLayer = function( layer, ele, lvl, pxRatio ){\n  var self = this;\n  var r = this.renderer;\n  var context = layer.context;\n  var bb = ele.boundingBox();\n  var eleCache = self.eleTxrCache;\n  var reason = useHighQualityEleTxrReqs ? eleCache.reasons.highQuality : undefined;\n\n  lvl = self.getEleLevelForLayerLevel( lvl, pxRatio );\n\n  var cache = useEleTxrCaching ? eleCache.getElement( ele, bb, null, lvl, reason ) : null;\n\n  if( cache ){\n    if( disableEleImgSmoothing ){ imgSmoothing( context, false ); }\n\n    context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );\n\n    if( disableEleImgSmoothing ){ imgSmoothing( context, true ); }\n  } else { // if the element is not cacheable, then draw directly\n    r.drawElement( context, ele );\n  }\n};\n\nLTCp.levelIsComplete = function( lvl, eles ){\n  var self = this;\n  var layers = self.layersByLevel[ lvl ];\n\n  if( !layers || layers.length === 0 ){ return false; }\n\n  var numElesInLayers = 0;\n\n  for( var i = 0; i < layers.length; i++ ){\n    var layer = layers[i];\n\n    // if there are any eles needed to be drawn yet, the level is not complete\n    if( layer.reqs > 0 ){ return false; }\n\n    // if the layer is invalid, the level is not complete\n    if( layer.invalid ){ return false; }\n\n    numElesInLayers += layer.eles.length;\n  }\n\n  // we should have exactly the number of eles passed in to be complete\n  if( numElesInLayers !== eles.length ){ return false; }\n\n  return true;\n};\n\nLTCp.validateLayersElesOrdering = function( lvl, eles ){\n  var layers = this.layersByLevel[ lvl ];\n\n  if( !layers ){ return; }\n\n  // if in a layer the eles are not in the same order, then the layer is invalid\n  // (i.e. there is an ele in between the eles in the layer)\n\n  for( var i = 0; i < layers.length; i++ ){\n    var layer = layers[i];\n    var offset = -1;\n\n    // find the offset\n    for( var j = 0; j < eles.length; j++ ){\n      if( layer.eles[0] === eles[j] ){\n        offset = j;\n        break;\n      }\n    }\n\n    if( offset < 0 ){\n      // then the layer has nonexistant elements and is invalid\n      this.invalidateLayer( layer );\n      continue;\n    }\n\n    // the eles in the layer must be in the same continuous order, else the layer is invalid\n\n    var o = offset;\n\n    for( var j = 0; j < layer.eles.length; j++ ){\n      if( layer.eles[j] !== eles[o+j] ){\n        // log('invalidate based on ordering', layer.id);\n\n        this.invalidateLayer( layer );\n        break;\n      }\n    }\n  }\n};\n\nLTCp.updateElementsInLayers = function( eles, update ){\n  var self = this;\n  var isEles = is.element( eles[0] );\n\n  // collect udpated elements (cascaded from the layers) and update each\n  // layer itself along the way\n  for( var i = 0; i < eles.length; i++ ){\n    var req = isEles ? null : eles[i];\n    var ele = isEles ? eles[i] : eles[i].ele;\n    var rs = ele._private.rscratch;\n    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n    for( var l = minLvl; l <= maxLvl; l++ ){\n      var layer = caches[l];\n\n      if( !layer ){ continue; }\n\n      // if update is a request from the ele cache, then it affects only\n      // the matching level\n      if( req && self.getEleLevelForLayerLevel( layer.level ) !== req.level ){\n        continue;\n      }\n\n      update( layer, ele, req );\n    }\n  }\n};\n\nLTCp.haveLayers = function(){\n  var self = this;\n  var haveLayers = false;\n\n  for( var l = minLvl; l <= maxLvl; l++ ){\n    var layers = self.layersByLevel[l];\n\n    if( layers && layers.length > 0 ){\n      haveLayers = true;\n      break;\n    }\n  }\n\n  return haveLayers;\n};\n\nLTCp.invalidateElements = function( eles ){\n  var self = this;\n\n  self.lastInvalidationTime = util.performanceNow();\n\n  // log('update invalidate layer time from eles');\n\n  if( eles.length === 0 || !self.haveLayers() ){ return; }\n\n  self.updateElementsInLayers( eles, function invalAssocLayers( layer, ele, req ){\n    self.invalidateLayer( layer );\n  } );\n};\n\nLTCp.invalidateLayer = function( layer ){\n  // log('update invalidate layer time');\n\n  this.lastInvalidationTime = util.performanceNow();\n\n  if( layer.invalid ){ return; } // save cycles\n\n  var lvl = layer.level;\n  var eles = layer.eles;\n  var layers = this.layersByLevel[ lvl ];\n\n   // log('invalidate layer', layer.id );\n\n  util.removeFromArray( layers, layer );\n  // layer.eles = [];\n\n  layer.elesQueue = [];\n\n  layer.invalid = true;\n\n  if( layer.replacement ){\n    layer.replacement.invalid = true;\n  }\n\n  for( var i = 0; i < eles.length; i++ ){\n    var caches = eles[i]._private.rscratch.imgLayerCaches;\n\n    if( caches ){\n      caches[ lvl ] = null;\n    }\n  }\n};\n\nLTCp.refineElementTextures = function( eles ){\n  var self = this;\n\n  // log('refine', eles.length);\n\n  self.updateElementsInLayers( eles, function refineEachEle( layer, ele, req ){\n    var rLyr = layer.replacement;\n\n    if( !rLyr ){\n      rLyr = layer.replacement = self.makeLayer( layer.bb, layer.level );\n      rLyr.replaces = layer;\n      rLyr.eles = layer.eles;\n\n       // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n    }\n\n    if( !rLyr.reqs ){\n      for( var i = 0; i < rLyr.eles.length; i++ ){\n        self.queueLayer( rLyr, rLyr.eles[i] );\n      }\n\n       // log('queue replacement layer refinement', rLyr.id);\n    }\n  } );\n};\n\nLTCp.setupEleCacheInvalidation = function(){\n  var self = this;\n  var eleDeqs = [];\n\n  if( !useEleTxrCaching ){ return; }\n\n  var updatedElesInLayers = util.debounce( function(){\n    self.refineElementTextures( eleDeqs );\n\n    eleDeqs = [];\n  }, refineEleDebounceTime );\n\n  self.eleTxrCache.onDequeue(function( reqs ){\n    for( var i = 0; i < reqs.length; i++ ){\n      eleDeqs.push( reqs[i] );\n    }\n\n    updatedElesInLayers();\n  });\n};\n\nLTCp.queueLayer = function( layer, ele ){\n  var self = this;\n  var q = self.layersQueue;\n  var elesQ = layer.elesQueue;\n  var hasId = elesQ.hasId = elesQ.hasId || {};\n\n  // if a layer is going to be replaced, queuing is a waste of time\n  if( layer.replacement ){ return; }\n\n  if( ele ){\n    if( hasId[ ele.id() ] ){\n      return;\n    }\n\n    elesQ.push( ele );\n    hasId[ ele.id() ] = true;\n  }\n\n  if( layer.reqs ){\n    layer.reqs++;\n\n    q.updateItem( layer );\n  } else {\n    layer.reqs = 1;\n\n    q.push( layer );\n  }\n};\n\nLTCp.dequeue = function( pxRatio ){\n  var self = this;\n  var q = self.layersQueue;\n  var deqd = [];\n  var eleDeqs = 0;\n\n  while( eleDeqs < maxDeqSize ){\n    if( q.size() === 0 ){ break; }\n\n    var layer = q.peek();\n\n    // if a layer has been or will be replaced, then don't waste time with it\n    if( layer.replacement ){\n       // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n      q.pop();\n      continue;\n    }\n\n    // if this is a replacement layer that has been superceded, then forget it\n    if( layer.replaces && layer !== layer.replaces.replacement ){\n       // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n      q.pop();\n      continue;\n    }\n\n    if( layer.invalid ){\n       // log('replacement layer %s is invalid; dequeued', layer.id);\n      q.pop();\n      continue;\n    }\n\n    var ele = layer.elesQueue.shift();\n\n    if( ele ){\n       // log('dequeue layer %s', layer.id);\n\n      self.drawEleInLayer( layer, ele, layer.level, pxRatio );\n\n      eleDeqs++;\n    }\n\n    if( deqd.length === 0 ){\n      // we need only one entry in deqd to queue redrawing etc\n      deqd.push( true );\n    }\n\n    // if the layer has all its eles done, then remove from the queue\n    if( layer.elesQueue.length === 0 ){\n      q.pop();\n\n      layer.reqs = 0;\n\n       // log('dequeue of layer %s complete', layer.id);\n\n      // when a replacement layer is dequeued, it replaces the old layer in the level\n      if( layer.replaces ){\n        self.applyLayerReplacement( layer );\n      }\n\n      self.requestRedraw();\n    }\n  }\n\n  return deqd;\n};\n\nLTCp.applyLayerReplacement = function( layer ){\n  var self = this;\n  var layersInLevel = self.layersByLevel[ layer.level ];\n  var replaced = layer.replaces;\n  var index = layersInLevel.indexOf( replaced );\n\n  // if the replaced layer is not in the active list for the level, then replacing\n  // refs would be a mistake (i.e. overwriting the true active layer)\n  if( index < 0 || replaced.invalid ){\n     // log('replacement layer would have no effect', layer.id);\n    return;\n  }\n\n  layersInLevel[ index ] = layer; // replace level ref\n\n  // replace refs in eles\n  for( var i = 0; i < layer.eles.length; i++ ){\n    var _p = layer.eles[i]._private;\n    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n\n    if( cache ){\n      cache[ layer.level ] = layer;\n    }\n  }\n\n   // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\n  self.requestRedraw();\n};\n\nLTCp.requestRedraw = util.debounce( function(){\n  var r = this.renderer;\n\n  r.redrawHint( 'eles', true );\n  r.redrawHint( 'drag', true );\n  r.redraw();\n}, 100 );\n\nLTCp.setupDequeueing = defs.setupDequeueing({\n  deqRedrawThreshold: deqRedrawThreshold,\n  deqCost: deqCost,\n  deqAvgCost: deqAvgCost,\n  deqNoDrawCost: deqNoDrawCost,\n  deqFastCost: deqFastCost,\n  deq: function( self, pxRatio ){\n    return self.dequeue( pxRatio );\n  },\n  onDeqd: util.noop,\n  shouldRedraw: util.trueify,\n  priority: function( self ){\n    return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n  }\n});\n\nmodule.exports = LayeredTextureCache;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/layered-texture-cache.js\n ** module id = 122\n ** module chunks = 0\n **/","'use strict';\n\nvar CRp = {};\n\nvar impl;\n\nCRp.arrowShapeImpl = function( name ){\n  return ( impl || (impl = {\n    'polygon': function( context, points ){\n      for( var i = 0; i < points.length; i++ ){\n        var pt = points[ i ];\n\n        context.lineTo( pt.x, pt.y );\n      }\n    },\n\n    'triangle-backcurve': function( context, points, controlPoint ){\n      var firstPt;\n\n      for( var i = 0; i < points.length; i++ ){\n        var pt = points[ i ];\n\n        if( i === 0 ){\n          firstPt = pt;\n        }\n\n        context.lineTo( pt.x, pt.y );\n      }\n\n      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );\n    },\n\n    'triangle-tee': function( context, trianglePoints, teePoints ){\n      var triPts = trianglePoints;\n      for( var i = 0; i < triPts.length; i++ ){\n        var pt = triPts[ i ];\n\n        context.lineTo( pt.x, pt.y );\n      }\n\n      var teePts = teePoints;\n      var firstTeePt = teePoints[0];\n      context.moveTo( firstTeePt.x, firstTeePt.y );\n\n      for( var i = 0; i < teePts.length; i++ ){\n        var pt = teePts[ i ];\n\n        context.lineTo( pt.x, pt.y );\n      }\n    },\n\n    'circle': function( context, rx, ry, r ){\n      context.arc( rx, ry, r, 0, Math.PI * 2, false );\n    }\n  }) )[ name ];\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/arrow-shapes.js\n ** module id = 123\n ** module chunks = 0\n **/","'use strict';\n\nvar math = require( '../../../math' );\n\nvar CRp = {};\n\nCRp.drawElement = function( context, ele, shiftToOriginWithBb, showLabel ){\n  var r = this;\n\n  if( ele.isNode() ){\n    r.drawNode( context, ele, shiftToOriginWithBb, showLabel );\n  } else {\n    r.drawEdge( context, ele, shiftToOriginWithBb, showLabel );\n  }\n};\n\nCRp.drawCachedElement = function( context, ele, pxRatio, extent ){\n  var r = this;\n  var bb = ele.boundingBox();\n\n  if( !extent || math.boundingBoxesIntersect( bb, extent ) ){\n    var cache = r.data.eleTxrCache.getElement( ele, bb, pxRatio );\n\n    if( cache ){\n      context.drawImage( cache.texture.canvas, cache.x, 0, cache.width, cache.height, bb.x1, bb.y1, bb.w, bb.h );\n    } else { // if the element is not cacheable, then draw directly\n      r.drawElement( context, ele );\n    }\n  }\n};\n\nCRp.drawElements = function( context, eles ){\n  var r = this;\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[ i ];\n\n    r.drawElement( context, ele );\n  }\n};\n\nCRp.drawCachedElements = function( context, eles, pxRatio, extent ){\n  var r = this;\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[ i ];\n\n    r.drawCachedElement( context, ele, pxRatio, extent );\n  }\n};\n\nCRp.drawCachedNodes = function( context, eles, pxRatio, extent ){\n  var r = this;\n\n  for( var i = 0; i < eles.length; i++ ){\n    var ele = eles[ i ];\n\n    if( !ele.isNode() ){ continue; }\n\n    r.drawCachedElement( context, ele, pxRatio, extent );\n  }\n};\n\nCRp.drawLayeredElements = function( context, eles, pxRatio, extent ){\n  var r = this;\n\n  var layers = r.data.lyrTxrCache.getLayers( eles, pxRatio );\n\n  if( layers ){\n    for( var i = 0; i < layers.length; i++ ){\n      var layer = layers[i];\n      var bb = layer.bb;\n\n      context.drawImage( layer.canvas, bb.x1, bb.y1, bb.w, bb.h );\n    }\n  } else { // fall back on plain caching if no layers\n    r.drawCachedElements( context, eles, pxRatio, extent );\n  }\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/drawing-elements.js\n ** module id = 124\n ** module chunks = 0\n **/","'use strict';\n\nvar CRp = {};\n\nCRp.drawEdge = function( context, edge, shiftToOriginWithBb, drawLabel, drawOverlayInstead ){\n  var rs = edge._private.rscratch;\n  var usePaths = this.usePaths();\n\n  // if bezier ctrl pts can not be calculated, then die\n  if( rs.badLine || isNaN(rs.allpts[0]) ){ // isNaN in case edge is impossible and browser bugs (e.g. safari)\n    return;\n  }\n\n  // Edge line width\n  if( edge.pstyle( 'width' ).pfValue <= 0 ){\n    return;\n  }\n\n  var bb;\n  if( shiftToOriginWithBb ){\n    bb = shiftToOriginWithBb;\n\n    context.translate( -bb.x1, -bb.y1 );\n  }\n\n  var overlayPadding = edge.pstyle( 'overlay-padding' ).pfValue;\n  var overlayOpacity = edge.pstyle( 'overlay-opacity' ).value;\n  var overlayColor = edge.pstyle( 'overlay-color' ).value;\n\n  // Edge color & opacity\n  if( drawOverlayInstead ){\n\n    if( overlayOpacity === 0 ){ // exit early if no overlay\n      return;\n    }\n\n    this.strokeStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );\n    context.lineCap = 'round';\n\n    if( rs.edgeType == 'self' && !usePaths ){\n      context.lineCap = 'butt';\n    }\n\n  } else {\n    var lineColor = edge.pstyle( 'line-color' ).value;\n\n    this.strokeStyle( context, lineColor[0], lineColor[1], lineColor[2], edge.pstyle( 'opacity' ).value );\n\n    context.lineCap = 'butt';\n  }\n\n  context.lineJoin = 'round';\n\n  var edgeWidth = edge.pstyle( 'width' ).pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);\n  var lineStyle = drawOverlayInstead ? 'solid' : edge.pstyle( 'line-style' ).value;\n  context.lineWidth = edgeWidth;\n\n  var shadowBlur = edge.pstyle( 'shadow-blur' ).pfValue;\n  var shadowOpacity = edge.pstyle( 'shadow-opacity' ).value;\n  var shadowColor = edge.pstyle( 'shadow-color' ).value;\n  var shadowOffsetX = edge.pstyle( 'shadow-offset-x' ).pfValue;\n  var shadowOffsetY = edge.pstyle( 'shadow-offset-y' ).pfValue;\n\n  this.shadowStyle( context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );\n\n  this.drawEdgePath(\n    edge,\n    context,\n    rs.allpts,\n    lineStyle,\n    edgeWidth\n  );\n\n  this.drawArrowheads( context, edge, drawOverlayInstead );\n\n  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy\n\n  if( !drawOverlayInstead ){\n    this.drawEdge( context, edge, false, drawLabel, true );\n  }\n\n  this.drawElementText( context, edge, drawLabel );\n\n  if( shiftToOriginWithBb ){\n    context.translate( bb.x1, bb.y1 );\n  }\n};\n\n\nCRp.drawEdgePath = function( edge, context, pts, type, width ){\n  var rs = edge._private.rscratch;\n  var canvasCxt = context;\n  var path;\n  var pathCacheHit = false;\n  var usePaths = this.usePaths();\n\n  if( usePaths ){\n    var pathCacheKey = pts.join( '$' );\n    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n\n    if( keyMatches ){\n      path = context = rs.pathCache;\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D();\n      rs.pathCacheKey = pathCacheKey;\n      rs.pathCache = path;\n    }\n  }\n\n  if( canvasCxt.setLineDash ){ // for very outofdate browsers\n    switch( type ){\n      case 'dotted':\n        canvasCxt.setLineDash( [ 1, 1 ] );\n        break;\n\n      case 'dashed':\n        canvasCxt.setLineDash( [ 6, 3 ] );\n        break;\n\n      case 'solid':\n        canvasCxt.setLineDash( [ ] );\n        break;\n    }\n  }\n\n  if( !pathCacheHit && !rs.badLine ){\n    if( context.beginPath ){ context.beginPath(); }\n    context.moveTo( pts[0], pts[1] );\n\n    switch( rs.edgeType ){\n      case 'bezier':\n      case 'self':\n      case 'compound':\n      case 'multibezier':\n        for( var i = 2; i + 3 < pts.length; i += 4 ){\n          context.quadraticCurveTo( pts[ i ], pts[ i + 1], pts[ i + 2], pts[ i + 3] );\n        }\n        break;\n\n      case 'straight':\n      case 'segments':\n      case 'haystack':\n        for( var i = 2; i + 1 < pts.length; i += 2 ){\n          context.lineTo( pts[ i ], pts[ i + 1] );\n        }\n        break;\n    }\n  }\n\n  context = canvasCxt;\n  if( usePaths ){\n    context.stroke( path );\n  } else {\n    context.stroke();\n  }\n\n  // reset any line dashes\n  if( context.setLineDash ){ // for very outofdate browsers\n    context.setLineDash( [ ] );\n  }\n\n};\n\nCRp.drawArrowheads = function( context, edge, drawOverlayInstead ){\n  if( drawOverlayInstead ){ return; } // don't do anything for overlays\n\n  var rs = edge._private.rscratch;\n  var isHaystack = rs.edgeType === 'haystack';\n\n  if( !isHaystack ){\n    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );\n  }\n\n  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );\n\n  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );\n\n  if( !isHaystack ){\n    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );\n  }\n};\n\nCRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){\n  if( isNaN( x ) || x == null || isNaN( y ) || y == null || isNaN( angle ) || angle == null ){ return; }\n\n  var self = this;\n  var arrowShape = edge.pstyle( prefix + '-arrow-shape' ).value;\n\n  if( arrowShape === 'none' ){\n    return;\n  }\n\n  var gco = context.globalCompositeOperation;\n\n  var arrowClearFill = edge.pstyle( prefix + '-arrow-fill' ).value === 'hollow' ? 'both' : 'filled';\n  var arrowFill = edge.pstyle( prefix + '-arrow-fill' ).value;\n  var opacity = edge.pstyle( 'opacity' ).value;\n\n  if( arrowShape === 'half-triangle-overshot' ){\n    arrowFill = 'hollow';\n    arrowClearFill = 'hollow';\n  }\n\n  if( opacity !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed\n    context.globalCompositeOperation = 'destination-out';\n\n    self.fillStyle( context, 255, 255, 255, 1 );\n    self.strokeStyle( context, 255, 255, 255, 1 );\n\n    self.drawArrowShape( edge, prefix, context,\n      arrowClearFill, edge.pstyle( 'width' ).pfValue, edge.pstyle( prefix + '-arrow-shape' ).value,\n      x, y, angle\n    );\n\n    context.globalCompositeOperation = gco;\n  } // otherwise, the opaque arrow clears it for free :)\n\n  var color = edge.pstyle( prefix + '-arrow-color' ).value;\n  self.fillStyle( context, color[0], color[1], color[2], opacity );\n  self.strokeStyle( context, color[0], color[1], color[2], opacity );\n\n  self.drawArrowShape( edge, prefix, context,\n    arrowFill, edge.pstyle( 'width' ).pfValue, edge.pstyle( prefix + '-arrow-shape' ).value,\n    x, y, angle\n  );\n};\n\nCRp.drawArrowShape = function( edge, arrowType, context, fill, edgeWidth, shape, x, y, angle ){\n  var r = this;\n  var usePaths = this.usePaths();\n  var rs = edge._private.rscratch;\n  var pathCacheHit = false;\n  var path;\n  var canvasContext = context;\n  var translation = { x: x, y: y };\n  var size = this.getArrowWidth( edgeWidth );\n  var shapeImpl = r.arrowShapes[ shape ];\n\n  if( usePaths ){\n    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;\n    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};\n    rs.arrowPathCache = rs.arrowPathCache || {};\n\n    var alreadyCached = rs.arrowPathCacheKey[ arrowType ] === pathCacheKey;\n    if( alreadyCached ){\n      path = context = rs.arrowPathCache[ arrowType ];\n      pathCacheHit = true;\n    } else {\n      path = context = new Path2D();\n      rs.arrowPathCacheKey[ arrowType ] = pathCacheKey;\n      rs.arrowPathCache[ arrowType ] = path;\n    }\n  }\n\n  if( context.beginPath ){ context.beginPath(); }\n\n  if( !pathCacheHit ){\n    shapeImpl.draw( context, size, angle, translation );\n  }\n\n  if( !shapeImpl.leavePathOpen && context.closePath ){\n    context.closePath();\n  }\n\n  context = canvasContext;\n\n  if( fill === 'filled' || fill === 'both' ){\n    if( usePaths ){\n      context.fill( path );\n    } else {\n      context.fill();\n    }\n  }\n\n  if( fill === 'hollow' || fill === 'both' ){\n    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );\n    context.lineJoin = 'miter';\n\n    if( usePaths ){\n      context.stroke( path );\n    } else {\n      context.stroke();\n    }\n\n  }\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/drawing-edges.js\n ** module id = 125\n ** module chunks = 0\n **/","'use strict';\n\nvar CRp = {};\n\nCRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){\n  var r = this;\n\n  try {\n    context.drawImage( img, ix, iy, iw, ih, x, y, w, h );\n  } catch( e ){\n    r.redrawHint( 'eles', true );\n    r.redrawHint( 'drag', true );\n\n    r.drawingImage = true;\n\n    r.redraw();\n  }\n};\n\nCRp.drawInscribedImage = function( context, img, node ){\n  var r = this;\n  var nodeX = node._private.position.x;\n  var nodeY = node._private.position.y;\n  var fit = node.pstyle( 'background-fit' ).value;\n  var xPos = node.pstyle( 'background-position-x' );\n  var yPos = node.pstyle( 'background-position-y' );\n  var repeat = node.pstyle( 'background-repeat' ).value;\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var rs = node._private.rscratch;\n  var clip = node.pstyle( 'background-clip' ).value;\n  var shouldClip = clip === 'node';\n  var imgOpacity = node.pstyle( 'background-image-opacity' ).value;\n\n  var imgW = img.width || img.cachedW;\n  var imgH = img.height || img.cachedH;\n\n  // workaround for broken browsers like ie\n  if( null == imgW || null == imgH ){\n    document.body.appendChild( img );\n\n    imgW = img.cachedW = img.width || img.offsetWidth;\n    imgH = img.cachedH = img.height || img.offsetHeight;\n\n    document.body.removeChild( img );\n  }\n\n  var w = imgW;\n  var h = imgH;\n\n  var bgW = node.pstyle( 'background-width' );\n  if( bgW.value !== 'auto' ){\n    if( bgW.units === '%' ){\n      w = bgW.value / 100 * nodeW;\n    } else {\n      w = bgW.pfValue;\n    }\n  }\n\n  var bgH = node.pstyle( 'background-height' );\n  if( bgH.value !== 'auto' ){\n    if( bgH.units === '%' ){\n      h = bgH.value / 100 * nodeH;\n    } else {\n      h = bgH.pfValue;\n    }\n  }\n\n  if( w === 0 || h === 0 ){\n    return; // no point in drawing empty image (and chrome is broken in this case)\n  }\n\n  if( fit === 'contain' ){\n    var scale = Math.min( nodeW / w, nodeH / h );\n\n    w *= scale;\n    h *= scale;\n\n  } else if( fit === 'cover' ){\n    var scale = Math.max( nodeW / w, nodeH / h );\n\n    w *= scale;\n    h *= scale;\n  }\n\n  var x = (nodeX - nodeW / 2); // left\n  if( xPos.units === '%' ){\n    x += (nodeW - w) * xPos.value / 100;\n  } else {\n    x += xPos.pfValue;\n  }\n\n  var y = (nodeY - nodeH / 2); // top\n  if( yPos.units === '%' ){\n    y += (nodeH - h) * yPos.value / 100;\n  } else {\n    y += yPos.pfValue;\n  }\n\n  if( rs.pathCache ){\n    x -= nodeX;\n    y -= nodeY;\n\n    nodeX = 0;\n    nodeY = 0;\n  }\n\n  var gAlpha = context.globalAlpha;\n\n  context.globalAlpha = imgOpacity;\n\n  if( repeat === 'no-repeat' ){\n\n    if( shouldClip ){\n      context.save();\n\n      if( rs.pathCache ){\n        context.clip( rs.pathCache );\n      } else {\n        r.nodeShapes[ r.getNodeShape( node ) ].draw(\n          context,\n          nodeX, nodeY,\n          nodeW, nodeH );\n\n        context.clip();\n      }\n    }\n\n    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );\n\n    if( shouldClip ){\n      context.restore();\n    }\n  } else {\n    var pattern = context.createPattern( img, repeat );\n    context.fillStyle = pattern;\n\n    r.nodeShapes[ r.getNodeShape( node ) ].draw(\n        context,\n        nodeX, nodeY,\n        nodeW, nodeH );\n\n    context.translate( x, y );\n    context.fill();\n    context.translate( -x, -y );\n  }\n\n  context.globalAlpha = gAlpha;\n\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/drawing-images.js\n ** module id = 126\n ** module chunks = 0\n **/","'use strict';\n\nvar util = require( '../../../util' );\nvar math = require( '../../../math' );\n\nvar CRp = {};\n\nCRp.eleTextBiggerThanMin = function( ele, scale ){\n  if( !scale ){\n    var zoom = ele.cy().zoom();\n    var pxRatio = this.getPixelRatio();\n    var lvl = Math.ceil( math.log2( zoom * pxRatio ) ); // the effective texture level\n\n    scale = Math.pow( 2, lvl );\n  }\n\n  var computedSize = ele.pstyle( 'font-size' ).pfValue * scale;\n  var minSize = ele.pstyle( 'min-zoomed-font-size' ).pfValue;\n\n  if( computedSize < minSize ){\n    return false;\n  }\n\n  return true;\n};\n\nCRp.drawElementText = function( context, ele, force ){\n  var r = this;\n\n  if( force === undefined ){\n    if( !r.eleTextBiggerThanMin( ele ) ){ return; }\n  } else {\n    if( !force ){ return; }\n  }\n\n  if( ele.isNode() ){\n    var label = ele.pstyle( 'label' );\n\n    if( !label || !label.value ){ return; }\n\n    var textHalign = ele.pstyle( 'text-halign' ).strValue;\n    var textValign = ele.pstyle( 'text-valign' ).strValue;\n\n    switch( textHalign ){\n      case 'left':\n        context.textAlign = 'right';\n        break;\n\n      case 'right':\n        context.textAlign = 'left';\n        break;\n\n      default: // e.g. center\n        context.textAlign = 'center';\n    }\n\n    switch( textValign ){\n      case 'top':\n        context.textBaseline = 'bottom';\n        break;\n\n      case 'bottom':\n        context.textBaseline = 'top';\n        break;\n\n      default: // e.g. center\n        context.textBaseline = 'middle';\n    }\n  } else {\n    var label = ele.pstyle( 'label' );\n    var srcLabel = ele.pstyle( 'source-label' );\n    var tgtLabel = ele.pstyle( 'target-label' );\n\n    if(\n      ( !label || !label.value )\n      && ( !srcLabel || !srcLabel.value )\n      && ( !tgtLabel || !tgtLabel.value )\n    ){\n      return;\n    }\n\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n  }\n\n\n  r.drawText( context, ele );\n\n  if( ele.isEdge() ){\n    r.drawText( context, ele, 'source' );\n\n    r.drawText( context, ele, 'target' );\n  }\n};\n\nCRp.drawNodeText = CRp.drawEdgeText = CRp.drawElementText;\n\nCRp.getFontCache = function( context ){\n  var cache;\n\n  this.fontCaches = this.fontCaches || [];\n\n  for( var i = 0; i < this.fontCaches.length; i++ ){\n    cache = this.fontCaches[ i ];\n\n    if( cache.context === context ){\n      return cache;\n    }\n  }\n\n  cache = {\n    context: context\n  };\n  this.fontCaches.push( cache );\n\n  return cache;\n};\n\n// set up canvas context with font\n// returns transformed text string\nCRp.setupTextStyle = function( context, ele ){\n  // Font style\n  var parentOpacity = ele.effectiveOpacity();\n  var labelStyle = ele.pstyle( 'font-style' ).strValue;\n  var labelSize = ele.pstyle( 'font-size' ).pfValue + 'px';\n  var labelFamily = ele.pstyle( 'font-family' ).strValue;\n  var labelWeight = ele.pstyle( 'font-weight' ).strValue;\n  var opacity = ele.pstyle( 'text-opacity' ).value * ele.pstyle( 'opacity' ).value * parentOpacity;\n  var outlineOpacity = ele.pstyle( 'text-outline-opacity' ).value * opacity;\n  var color = ele.pstyle( 'color' ).value;\n  var outlineColor = ele.pstyle( 'text-outline-color' ).value;\n  var shadowBlur = ele.pstyle( 'text-shadow-blur' ).pfValue;\n  var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;\n  var shadowColor = ele.pstyle( 'text-shadow-color' ).value;\n  var shadowOffsetX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;\n  var shadowOffsetY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;\n\n  var fontCacheKey = ele._private.fontKey;\n  var cache = this.getFontCache( context );\n\n  if( cache.key !== fontCacheKey ){\n    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n\n    cache.key = fontCacheKey;\n  }\n\n  // Calculate text draw position based on text alignment\n\n  // so text outlines aren't jagged\n  context.lineJoin = 'round';\n\n  this.fillStyle( context, color[ 0 ], color[ 1 ], color[ 2 ], opacity );\n\n  this.strokeStyle( context, outlineColor[ 0 ], outlineColor[ 1 ], outlineColor[ 2 ], outlineOpacity );\n\n  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );\n};\n\nfunction roundRect( ctx, x, y, width, height, radius ){\n  var radius = radius || 5;\n  ctx.beginPath();\n  ctx.moveTo( x + radius, y );\n  ctx.lineTo( x + width - radius, y );\n  ctx.quadraticCurveTo( x + width, y, x + width, y + radius );\n  ctx.lineTo( x + width, y + height - radius );\n  ctx.quadraticCurveTo( x + width, y + height, x + width - radius, y + height );\n  ctx.lineTo( x + radius, y + height );\n  ctx.quadraticCurveTo( x, y + height, x, y + height - radius );\n  ctx.lineTo( x, y + radius );\n  ctx.quadraticCurveTo( x, y, x + radius, y );\n  ctx.closePath();\n  ctx.fill();\n}\n\n// Draw text\nCRp.drawText = function( context, ele, prefix ){\n  var _p = ele._private;\n  var rscratch = _p.rscratch;\n  var parentOpacity = ele.effectiveOpacity();\n  if( parentOpacity === 0 || ele.pstyle( 'text-opacity' ).value === 0 ){\n    return;\n  }\n\n  var textX = util.getPrefixedProperty( rscratch, 'labelX', prefix );\n  var textY = util.getPrefixedProperty( rscratch, 'labelY', prefix );\n  var text = this.getLabelText( ele, prefix );\n\n  if( text != null && text !== '' && !isNaN( textX ) && !isNaN( textY ) ){\n    this.setupTextStyle( context, ele );\n\n    var pdash = prefix ? prefix + '-' : '';\n    var textW = util.getPrefixedProperty( rscratch, 'labelWidth', prefix );\n    var textH = util.getPrefixedProperty( rscratch, 'labelHeight', prefix );\n    var textAngle = util.getPrefixedProperty( rscratch, 'labelAngle', prefix );\n    var marginX = ele.pstyle( pdash + 'text-margin-x' ).pfValue;\n    var marginY = ele.pstyle( pdash + 'text-margin-y' ).pfValue;\n\n    var isEdge = ele.isEdge();\n    var isNode = ele.isNode();\n\n    var halign = ele.pstyle( 'text-halign' ).value;\n    var valign = ele.pstyle( 'text-valign' ).value;\n\n    if( isEdge ){\n      halign = 'center';\n      valign = 'center';\n    }\n\n    textX += marginX;\n    textY += marginY;\n\n    var rotation = ele.pstyle( 'text-rotation' );\n    var theta;\n\n    if( rotation.strValue === 'autorotate' ){\n      theta = isEdge ? textAngle : 0;\n    } else if( rotation.strValue === 'none' ){\n      theta = 0;\n    } else {\n      theta = rotation.pfValue;\n    }\n\n    if( theta !== 0 ){\n      var orgTextX = textX;\n      var orgTextY = textY;\n\n      context.translate( orgTextX, orgTextY );\n      context.rotate( theta );\n\n      textX = 0;\n      textY = 0;\n    }\n\n    if( isNode ){\n      var pLeft = ele.pstyle( 'padding-left' ).pfValue;\n      var pRight = ele.pstyle( 'padding-right' ).pfValue;\n      var pTop = ele.pstyle( 'padding-top' ).pfValue;\n      var pBottom = ele.pstyle( 'padding-bottom' ).pfValue;\n\n      textX += pLeft / 2;\n      textX -= pRight / 2;\n\n      textY += pTop / 2;\n      textY -= pBottom / 2;\n    }\n\n    var backgroundOpacity = ele.pstyle( 'text-background-opacity' ).value;\n    var borderOpacity = ele.pstyle( 'text-border-opacity' ).value;\n    var textBorderWidth = ele.pstyle( 'text-border-width' ).pfValue;\n\n    if( backgroundOpacity > 0 || ( textBorderWidth > 0 && borderOpacity > 0 ) ){\n      var bgWidth = textW;\n      var bgHeight = textH;\n      var bgX = textX;\n\n      if( halign ){\n        if( halign == 'center' ){\n          bgX = bgX - bgWidth / 2;\n        } else if( halign == 'left' ){\n          bgX = bgX - bgWidth;\n        }\n      }\n\n      var bgY = textY;\n\n      if( isNode ){\n        if( valign == 'top' ){\n          bgY = bgY - bgHeight;\n        } else if( valign == 'center' ){\n          bgY = bgY - bgHeight / 2;\n        }\n      } else {\n        bgY = bgY - bgHeight / 2;\n      }\n\n      if( backgroundOpacity > 0 ){\n        var textFill = context.fillStyle;\n        var textBackgroundColor = ele.pstyle( 'text-background-color' ).value;\n\n        context.fillStyle = 'rgba(' + textBackgroundColor[ 0 ] + ',' + textBackgroundColor[ 1 ] + ',' + textBackgroundColor[ 2 ] + ',' + backgroundOpacity * parentOpacity + ')';\n        var styleShape = ele.pstyle( 'text-background-shape' ).strValue;\n        if( styleShape == 'roundrectangle' ){\n          roundRect( context, bgX, bgY, bgWidth, bgHeight, 2 );\n        } else {\n          context.fillRect( bgX, bgY, bgWidth, bgHeight );\n        }\n        context.fillStyle = textFill;\n      }\n\n      if( textBorderWidth > 0 && borderOpacity > 0 ){\n        var textStroke = context.strokeStyle;\n        var textLineWidth = context.lineWidth;\n        var textBorderColor = ele.pstyle( 'text-border-color' ).value;\n        var textBorderStyle = ele.pstyle( 'text-border-style' ).value;\n\n        context.strokeStyle = 'rgba(' + textBorderColor[ 0 ] + ',' + textBorderColor[ 1 ] + ',' + textBorderColor[ 2 ] + ',' + borderOpacity * parentOpacity + ')';\n        context.lineWidth = textBorderWidth;\n\n        if( context.setLineDash ){ // for very outofdate browsers\n          switch( textBorderStyle ){\n            case 'dotted':\n              context.setLineDash( [ 1, 1 ] );\n              break;\n            case 'dashed':\n              context.setLineDash( [ 4, 2 ] );\n              break;\n            case 'double':\n              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n              context.setLineDash( [] );\n              break;\n            case 'solid':\n              context.setLineDash( [] );\n              break;\n          }\n        }\n\n        context.strokeRect( bgX, bgY, bgWidth, bgHeight );\n\n        if( textBorderStyle === 'double' ){\n          var whiteWidth = textBorderWidth / 2;\n\n          context.strokeRect( bgX + whiteWidth, bgY + whiteWidth, bgWidth - whiteWidth * 2, bgHeight - whiteWidth * 2 );\n        }\n\n        if( context.setLineDash ){ // for very outofdate browsers\n          context.setLineDash( [] );\n        }\n        context.lineWidth = textLineWidth;\n        context.strokeStyle = textStroke;\n      }\n\n    }\n\n    var lineWidth = 2 * ele.pstyle( 'text-outline-width' ).pfValue; // *2 b/c the stroke is drawn centred on the middle\n\n    if( lineWidth > 0 ){\n      context.lineWidth = lineWidth;\n    }\n\n    if( ele.pstyle( 'text-wrap' ).value === 'wrap' ){\n      var lines = rscratch.labelWrapCachedLines;\n      var lineHeight = textH / lines.length;\n\n      switch( valign ){\n        case 'top':\n          textY -= ( lines.length - 1 ) * lineHeight;\n          break;\n\n        case 'bottom':\n          // nothing required\n          break;\n\n        default:\n        case 'center':\n          textY -= ( lines.length - 1 ) * lineHeight / 2;\n      }\n\n      for( var l = 0; l < lines.length; l++ ){\n        if( lineWidth > 0 ){\n          context.strokeText( lines[ l ], textX, textY );\n        }\n\n        context.fillText( lines[ l ], textX, textY );\n\n        textY += lineHeight;\n      }\n\n    } else {\n      if( lineWidth > 0 ){\n        context.strokeText( text, textX, textY );\n      }\n\n      context.fillText( text, textX, textY );\n    }\n\n    if( theta !== 0 ){\n      context.rotate( -theta );\n      context.translate( -orgTextX, -orgTextY );\n    }\n\n    this.shadowStyle( context, 'transparent', 0 ); // reset for next guy\n  }\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/drawing-label-text.js\n ** module id = 127\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../../is' );\n\nvar CRp = {};\n\nCRp.drawNode = function( context, node, shiftToOriginWithBb, drawLabel ){\n  var r = this;\n  var nodeWidth, nodeHeight;\n  var rs = node._private.rscratch;\n  var _p = node._private;\n  var pos = pos || _p.position;\n\n  if( !is.number( pos.x ) || !is.number( pos.y ) ){\n    return; // can't draw node with undefined position\n  }\n\n  var usePaths = this.usePaths();\n  var path;\n  var pathCacheHit = false;\n\n  var parentOpacity = node.effectiveOpacity();\n  if( parentOpacity === 0 ){ return; }\n\n  nodeWidth = node.width() + node.pstyle( 'padding-left' ).pfValue + node.pstyle( 'padding-right' ).pfValue;\n  nodeHeight = node.height() + node.pstyle( 'padding-top' ).pfValue + node.pstyle( 'padding-bottom' ).pfValue;\n\n  context.lineWidth = node.pstyle( 'border-width' ).pfValue;\n\n  //\n  // setup shift\n\n  var bb;\n  if( shiftToOriginWithBb ){\n    bb = shiftToOriginWithBb;\n\n    context.translate( -bb.x1, -bb.y1 );\n  }\n\n  //\n  // load bg image\n\n  var bgImgProp = node.pstyle( 'background-image' );\n  var url = bgImgProp.value[2] || bgImgProp.value[1];\n  var image;\n\n  if( url !== undefined ){\n\n    // get image, and if not loaded then ask to redraw when later loaded\n    image = this.getCachedImage( url, function(){\n      node.trigger('background');\n\n      r.redrawHint( 'eles', true );\n      r.redrawHint( 'drag', true );\n\n      r.drawingImage = true;\n\n      r.redraw();\n    } );\n\n    var prevBging = _p.backgrounding;\n    _p.backgrounding = !image.complete;\n\n    if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed\n      node.updateStyle( false );\n    }\n  }\n\n  //\n  // setup styles\n\n  var bgColor = node.pstyle( 'background-color' ).value;\n  var borderColor = node.pstyle( 'border-color' ).value;\n  var borderStyle = node.pstyle( 'border-style' ).value;\n\n  this.fillStyle( context, bgColor[0], bgColor[1], bgColor[2], node.pstyle( 'background-opacity' ).value * parentOpacity );\n\n  this.strokeStyle( context, borderColor[0], borderColor[1], borderColor[2], node.pstyle( 'border-opacity' ).value * parentOpacity );\n\n  var shadowBlur = node.pstyle( 'shadow-blur' ).pfValue;\n  var shadowOpacity = node.pstyle( 'shadow-opacity' ).value;\n  var shadowColor = node.pstyle( 'shadow-color' ).value;\n  var shadowOffsetX = node.pstyle( 'shadow-offset-x' ).pfValue;\n  var shadowOffsetY = node.pstyle( 'shadow-offset-y' ).pfValue;\n\n  this.shadowStyle( context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY );\n\n  context.lineJoin = 'miter'; // so borders are square with the node shape\n\n  if( context.setLineDash ){ // for very outofdate browsers\n    switch( borderStyle ){\n      case 'dotted':\n        context.setLineDash( [ 1, 1 ] );\n        break;\n\n      case 'dashed':\n        context.setLineDash( [ 4, 2 ] );\n        break;\n\n      case 'solid':\n      case 'double':\n        context.setLineDash( [ ] );\n        break;\n    }\n  }\n\n\n  //\n  // draw shape\n\n  var styleShape = node.pstyle( 'shape' ).strValue;\n\n  if( usePaths ){\n    var pathCacheKey = styleShape + '$' + nodeWidth + '$' + nodeHeight;\n\n    context.translate( pos.x, pos.y );\n\n    if( rs.pathCacheKey === pathCacheKey ){\n      path = rs.pathCache;\n      pathCacheHit = true;\n    } else {\n      path = new Path2D();\n      rs.pathCacheKey = pathCacheKey;\n      rs.pathCache = path;\n    }\n  }\n\n  if( !pathCacheHit ){\n\n    var npos = pos;\n\n    if( usePaths ){\n      npos = {\n        x: 0,\n        y: 0\n      };\n    }\n\n    r.nodeShapes[ this.getNodeShape( node ) ].draw(\n          ( path || context ),\n          npos.x,\n          npos.y,\n          nodeWidth,\n          nodeHeight );\n  }\n\n  if( usePaths ){\n    context.fill( path );\n  } else {\n    context.fill();\n  }\n\n  this.shadowStyle( context, 'transparent', 0 ); // reset for next guy\n\n  //\n  // bg image\n\n  if( url !== undefined ){\n    if( image.complete ){\n      this.drawInscribedImage( context, image, node );\n    }\n  }\n\n  //\n  // pie\n\n  var darkness = node.pstyle( 'background-blacken' ).value;\n  var borderWidth = node.pstyle( 'border-width' ).pfValue;\n\n  if( this.hasPie( node ) ){\n    this.drawPie( context, node, parentOpacity );\n\n    // redraw path for blacken and border\n    if( darkness !== 0 || borderWidth !== 0 ){\n\n      if( !usePaths ){\n        r.nodeShapes[ this.getNodeShape( node ) ].draw(\n            context,\n            pos.x,\n            pos.y,\n            nodeWidth,\n            nodeHeight );\n      }\n    }\n  }\n\n  //\n  // darken/lighten\n\n  if( darkness > 0 ){\n    this.fillStyle( context, 0, 0, 0, darkness );\n\n    if( usePaths ){\n      context.fill( path );\n    } else {\n      context.fill();\n    }\n\n  } else if( darkness < 0 ){\n    this.fillStyle( context, 255, 255, 255, -darkness );\n\n    if( usePaths ){\n      context.fill( path );\n    } else {\n      context.fill();\n    }\n  }\n\n  //\n  // border\n\n  if( borderWidth > 0 ){\n\n    if( usePaths ){\n      context.stroke( path );\n    } else {\n      context.stroke();\n    }\n\n    if( borderStyle === 'double' ){\n      context.lineWidth = node.pstyle( 'border-width' ).pfValue / 3;\n\n      var gco = context.globalCompositeOperation;\n      context.globalCompositeOperation = 'destination-out';\n\n      if( usePaths ){\n        context.stroke( path );\n      } else {\n        context.stroke();\n      }\n\n      context.globalCompositeOperation = gco;\n    }\n\n  }\n\n  if( usePaths ){\n    context.translate( -pos.x, -pos.y );\n  }\n\n  // reset in case we changed the border style\n  if( context.setLineDash ){ // for very outofdate browsers\n    context.setLineDash( [ ] );\n  }\n\n  //\n  // label\n\n  r.drawElementText( context, node, drawLabel );\n\n  //\n  // overlay\n\n  var overlayPadding = node.pstyle( 'overlay-padding' ).pfValue;\n  var overlayOpacity = node.pstyle( 'overlay-opacity' ).value;\n  var overlayColor = node.pstyle( 'overlay-color' ).value;\n\n  if( overlayOpacity > 0 ){\n    this.fillStyle( context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity );\n\n    r.nodeShapes[ 'roundrectangle' ].draw(\n      context,\n      node._private.position.x,\n      node._private.position.y,\n      nodeWidth + overlayPadding * 2,\n      nodeHeight + overlayPadding * 2\n    );\n\n    context.fill();\n  }\n\n  //\n  // clean up shift\n\n  if( shiftToOriginWithBb ){\n    context.translate( bb.x1, bb.y1 );\n  }\n\n};\n\n// does the node have at least one pie piece?\nCRp.hasPie = function( node ){\n  node = node[0]; // ensure ele ref\n\n  return node._private.hasPie;\n};\n\nCRp.drawPie = function( context, node, nodeOpacity, pos ){\n  node = node[0]; // ensure ele ref\n\n  var _p = node._private;\n  var cyStyle = node.cy().style();\n  var pieSize = node.pstyle( 'pie-size' );\n  var nodeW = node.width();\n  var nodeH = node.height();\n  var pos = pos || _p.position;\n  var x = pos.x;\n  var y = pos.y;\n  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node\n  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n  var usePaths = this.usePaths();\n\n  if( usePaths ){\n    x = 0;\n    y = 0;\n  }\n\n  if( pieSize.units === '%' ){\n    radius = radius * pieSize.value / 100;\n  } else if( pieSize.pfValue !== undefined ){\n    radius = pieSize.pfValue / 2;\n  }\n\n  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N\n    var size = node.pstyle( 'pie-' + i + '-background-size' ).value;\n    var color = node.pstyle( 'pie-' + i + '-background-color' ).value;\n    var opacity = node.pstyle( 'pie-' + i + '-background-opacity' ).value * nodeOpacity;\n    var percent = size / 100; // map integer range [0, 100] to [0, 1]\n\n    // percent can't push beyond 1\n    if( percent + lastPercent > 1 ){\n      percent = 1 - lastPercent;\n    }\n\n    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n    var angleDelta = 2 * Math.PI * percent;\n    var angleEnd = angleStart + angleDelta;\n\n    // ignore if\n    // - zero size\n    // - we're already beyond the full circle\n    // - adding the current slice would go beyond the full circle\n    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){\n      continue;\n    }\n\n    context.beginPath();\n    context.moveTo( x, y );\n    context.arc( x, y, radius, angleStart, angleEnd );\n    context.closePath();\n\n    this.fillStyle( context, color[0], color[1], color[2], opacity );\n\n    context.fill();\n\n    lastPercent += percent;\n  }\n\n};\n\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/drawing-nodes.js\n ** module id = 128\n ** module chunks = 0\n **/","'use strict';\n\nvar CRp = {};\n\nvar util = require( '../../../util' );\n\nvar motionBlurDelay = 100;\n\n// var isFirefox = typeof InstallTrigger !== 'undefined';\n\nCRp.getPixelRatio = function(){\n  var context = this.data.contexts[0];\n\n  if( this.forcedPixelRatio != null ){\n    return this.forcedPixelRatio;\n  }\n\n  var backingStore = context.backingStorePixelRatio ||\n    context.webkitBackingStorePixelRatio ||\n    context.mozBackingStorePixelRatio ||\n    context.msBackingStorePixelRatio ||\n    context.oBackingStorePixelRatio ||\n    context.backingStorePixelRatio || 1;\n\n  return (window.devicePixelRatio || 1) / backingStore;\n};\n\nCRp.paintCache = function( context ){\n  var caches = this.paintCaches = this.paintCaches || [];\n  var needToCreateCache = true;\n  var cache;\n\n  for( var i = 0; i < caches.length; i++ ){\n    cache = caches[ i ];\n\n    if( cache.context === context ){\n      needToCreateCache = false;\n      break;\n    }\n  }\n\n  if( needToCreateCache ){\n    cache = {\n      context: context\n    };\n    caches.push( cache );\n  }\n\n  return cache;\n};\n\nCRp.fillStyle = function( context, r, g, b, a ){\n  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // turn off for now, seems context does its own caching\n\n  // var cache = this.paintCache(context);\n\n  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // if( cache.fillStyle !== fillStyle ){\n  //   context.fillStyle = cache.fillStyle = fillStyle;\n  // }\n};\n\nCRp.strokeStyle = function( context, r, g, b, a ){\n  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // turn off for now, seems context does its own caching\n\n  // var cache = this.paintCache(context);\n\n  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n  // if( cache.strokeStyle !== strokeStyle ){\n  //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n  // }\n};\n\nCRp.shadowStyle = function( context, color, opacity, blur, offsetX, offsetY ){\n  var zoom = this.cy.zoom();\n\n  // var cache = this.paintCache( context );\n  //\n  // // don't make expensive changes to the shadow style if it's not used\n  // if( cache.shadowOpacity === 0 && opacity === 0 ){\n  //   return;\n  // }\n  //\n  // cache.shadowOpacity = opacity;\n\n  if( opacity > 0 ){\n    context.shadowBlur = blur * zoom;\n    context.shadowColor = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + opacity + ')';\n    context.shadowOffsetX = offsetX * zoom;\n    context.shadowOffsetY = offsetY * zoom;\n  } else {\n    context.shadowBlur = 0;\n    context.shadowColor = 'transparent';\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n  }\n};\n\n// Resize canvas\nCRp.matchCanvasSize = function( container ){\n  var r = this;\n  var data = r.data;\n  var width = container.clientWidth;\n  var height = container.clientHeight;\n  var pixelRatio = r.getPixelRatio();\n  var mbPxRatio = r.motionBlurPxRatio;\n\n  if(\n    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ] ||\n    container === r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ]\n  ){\n    pixelRatio = mbPxRatio;\n  }\n\n  var canvasWidth = width * pixelRatio;\n  var canvasHeight = height * pixelRatio;\n  var canvas;\n\n  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){\n    return; // save cycles if same\n  }\n\n  r.fontCaches = null; // resizing resets the style\n\n  var canvasContainer = data.canvasContainer;\n  canvasContainer.style.width = width + 'px';\n  canvasContainer.style.height = height + 'px';\n\n  for( var i = 0; i < r.CANVAS_LAYERS; i++ ){\n\n    canvas = data.canvases[ i ];\n\n    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){\n\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n    }\n  }\n\n  for( var i = 0; i < r.BUFFER_COUNT; i++ ){\n\n    canvas = data.bufferCanvases[ i ];\n\n    if( canvas.width !== canvasWidth || canvas.height !== canvasHeight ){\n\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n    }\n  }\n\n  r.textureMult = 1;\n  if( pixelRatio <= 1 ){\n    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];\n\n    r.textureMult = 2;\n    canvas.width = canvasWidth * r.textureMult;\n    canvas.height = canvasHeight * r.textureMult;\n  }\n\n  r.canvasWidth = canvasWidth;\n  r.canvasHeight = canvasHeight;\n\n};\n\nCRp.renderTo = function( cxt, zoom, pan, pxRatio ){\n  this.render( {\n    forcedContext: cxt,\n    forcedZoom: zoom,\n    forcedPan: pan,\n    drawAllLayers: true,\n    forcedPxRatio: pxRatio\n  } );\n};\n\nCRp.render = function( options ){\n  options = options || util.staticEmptyObject();\n\n  var forcedContext = options.forcedContext;\n  var drawAllLayers = options.drawAllLayers;\n  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n  var forcedZoom = options.forcedZoom;\n  var forcedPan = options.forcedPan;\n  var r = this;\n  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n  var cy = r.cy; var data = r.data;\n  var needDraw = data.canvasNeedsRedraw;\n  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n  var mbPxRatio = r.motionBlurPxRatio;\n  var hasCompoundNodes = cy.hasCompoundNodes();\n  var inNodeDragGesture = r.hoverData.draggingEles;\n  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n  var motionBlurFadeEffect = motionBlur;\n\n  if( !forcedContext ){\n    if( r.prevPxRatio !== pixelRatio ){\n      r.invalidateContainerClientCoordsCache();\n      r.matchCanvasSize( r.container );\n\n      r.redrawHint('eles', true);\n      r.redrawHint('drag', true);\n    }\n\n    r.prevPxRatio = pixelRatio;\n  }\n\n  if( !forcedContext && r.motionBlurTimeout ){\n    clearTimeout( r.motionBlurTimeout );\n  }\n\n  if( motionBlur ){\n    if( r.mbFrames == null ){\n      r.mbFrames = 0;\n    }\n\n    if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames\n      r.mbFrames++;\n    }\n\n    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur\n      motionBlurFadeEffect = false;\n    }\n\n    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n    if( r.mbFrames > r.minMbLowQualFrames ){\n      //r.fullQualityMb = false;\n      r.motionBlurPxRatio = r.mbPxRBlurry;\n    }\n  }\n\n  if( r.clearingMotionBlur ){\n    r.motionBlurPxRatio = 1;\n  }\n\n  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n  // because a rogue async texture frame would clear needDraw\n  if( r.textureDrawLastFrame && !textureDraw ){\n    needDraw[ r.NODE ] = true;\n    needDraw[ r.SELECT_BOX ] = true;\n  }\n\n  var coreStyle = cy.style()._private.coreStyle;\n\n  var zoom = cy.zoom();\n  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n  var pan = cy.pan();\n  var effectivePan = {\n    x: pan.x,\n    y: pan.y\n  };\n\n  var vp = {\n    zoom: zoom,\n    pan: {\n      x: pan.x,\n      y: pan.y\n    }\n  };\n  var prevVp = r.prevViewport;\n  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n\n  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){\n    r.motionBlurPxRatio = 1;\n  }\n\n  if( forcedPan ){\n    effectivePan = forcedPan;\n  }\n\n  // apply pixel ratio\n\n  effectiveZoom *= pixelRatio;\n  effectivePan.x *= pixelRatio;\n  effectivePan.y *= pixelRatio;\n\n  var eles = r.getCachedZSortedEles();\n\n  function mbclear( context, x, y, w, h ){\n    var gco = context.globalCompositeOperation;\n\n    context.globalCompositeOperation = 'destination-out';\n    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );\n    context.fillRect( x, y, w, h );\n\n    context.globalCompositeOperation = gco;\n  }\n\n  function setContextTransform( context, clear ){\n    var ePan, eZoom, w, h;\n\n    if( !r.clearingMotionBlur && (context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] || context === data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ]) ){\n      ePan = {\n        x: pan.x * mbPxRatio,\n        y: pan.y * mbPxRatio\n      };\n\n      eZoom = zoom * mbPxRatio;\n\n      w = r.canvasWidth * mbPxRatio;\n      h = r.canvasHeight * mbPxRatio;\n    } else {\n      ePan = effectivePan;\n      eZoom = effectiveZoom;\n\n      w = r.canvasWidth;\n      h = r.canvasHeight;\n    }\n\n    context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n    if( clear === 'motionBlur' ){\n      mbclear( context, 0, 0, w, h );\n    } else if( !forcedContext && (clear === undefined || clear) ){\n      context.clearRect( 0, 0, w, h );\n    }\n\n    if( !drawAllLayers ){\n      context.translate( ePan.x, ePan.y );\n      context.scale( eZoom, eZoom );\n    }\n    if( forcedPan ){\n      context.translate( forcedPan.x, forcedPan.y );\n    }\n    if( forcedZoom ){\n      context.scale( forcedZoom, forcedZoom );\n    }\n  }\n\n  if( !textureDraw ){\n    r.textureDrawLastFrame = false;\n  }\n\n  if( textureDraw ){\n    r.textureDrawLastFrame = true;\n\n    var bb;\n\n    if( !r.textureCache ){\n      r.textureCache = {};\n\n      bb = r.textureCache.bb = cy.mutableElements().boundingBox();\n\n      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];\n\n      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];\n\n      cxt.setTransform( 1, 0, 0, 1, 0, 0 );\n      cxt.clearRect( 0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult );\n\n      r.render( {\n        forcedContext: cxt,\n        drawOnlyNodeLayer: true,\n        forcedPxRatio: pixelRatio * r.textureMult\n      } );\n\n      var vp = r.textureCache.viewport = {\n        zoom: cy.zoom(),\n        pan: cy.pan(),\n        width: r.canvasWidth,\n        height: r.canvasHeight\n      };\n\n      vp.mpan = {\n        x: (0 - vp.pan.x) / vp.zoom,\n        y: (0 - vp.pan.y) / vp.zoom\n      };\n    }\n\n    needDraw[ r.DRAG ] = false;\n    needDraw[ r.NODE ] = false;\n\n    var context = data.contexts[ r.NODE ];\n\n    var texture = r.textureCache.texture;\n    var vp = r.textureCache.viewport;\n    bb = r.textureCache.bb;\n\n    context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n    if( motionBlur ){\n      mbclear( context, 0, 0, vp.width, vp.height );\n    } else {\n      context.clearRect( 0, 0, vp.width, vp.height );\n    }\n\n    var outsideBgColor = coreStyle[ 'outside-texture-bg-color' ].value;\n    var outsideBgOpacity = coreStyle[ 'outside-texture-bg-opacity' ].value;\n    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );\n    context.fillRect( 0, 0, vp.width, vp.height );\n\n    var zoom = cy.zoom();\n\n    setContextTransform( context, false );\n\n    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );\n    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio );\n\n  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it\n    r.textureCache = null;\n  }\n\n  var extent = cy.extent();\n  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);\n  var hideEdges = r.hideEdgesOnViewport && vpManip;\n\n  var needMbClear = [];\n\n  needMbClear[ r.NODE ] = !needDraw[ r.NODE ] && motionBlur && !r.clearedForMotionBlur[ r.NODE ] || r.clearingMotionBlur;\n  if( needMbClear[ r.NODE ] ){ r.clearedForMotionBlur[ r.NODE ] = true; }\n\n  needMbClear[ r.DRAG ] = !needDraw[ r.DRAG ] && motionBlur && !r.clearedForMotionBlur[ r.DRAG ] || r.clearingMotionBlur;\n  if( needMbClear[ r.DRAG ] ){ r.clearedForMotionBlur[ r.DRAG ] = true; }\n\n  if( needDraw[ r.NODE ] || drawAllLayers || drawOnlyNodeLayer || needMbClear[ r.NODE ] ){\n    var useBuffer = motionBlur && !needMbClear[ r.NODE ] && mbPxRatio !== 1;\n    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[ r.NODE ] );\n    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n\n    setContextTransform( context, clear );\n\n    if( hideEdges ){\n      r.drawCachedNodes( context, eles.nondrag, pixelRatio, extent );\n    } else {\n      r.drawLayeredElements( context, eles.nondrag, pixelRatio, extent );\n    }\n\n    if( !drawAllLayers && !motionBlur ){\n      needDraw[ r.NODE ] = false;\n    }\n  }\n\n  if( !drawOnlyNodeLayer && (needDraw[ r.DRAG ] || drawAllLayers || needMbClear[ r.DRAG ]) ){\n    var useBuffer = motionBlur && !needMbClear[ r.DRAG ] && mbPxRatio !== 1;\n    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[ r.DRAG ] );\n\n    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );\n\n    if( hideEdges ){\n      r.drawCachedNodes( context, eles.drag, pixelRatio, extent );\n    } else {\n      r.drawCachedElements( context, eles.drag, pixelRatio, extent );\n    }\n\n    if( !drawAllLayers && !motionBlur ){\n      needDraw[ r.DRAG ] = false;\n    }\n  }\n\n  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[ r.SELECT_BOX ] && !drawAllLayers)) ){\n    var context = forcedContext || data.contexts[ r.SELECT_BOX ];\n\n    setContextTransform( context );\n\n    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){\n      var zoom = r.cy.zoom();\n      var borderWidth = coreStyle[ 'selection-box-border-width' ].value / zoom;\n\n      context.lineWidth = borderWidth;\n      context.fillStyle = 'rgba('\n        + coreStyle[ 'selection-box-color' ].value[0] + ','\n        + coreStyle[ 'selection-box-color' ].value[1] + ','\n        + coreStyle[ 'selection-box-color' ].value[2] + ','\n        + coreStyle[ 'selection-box-opacity' ].value + ')';\n\n      context.fillRect(\n        r.selection[0],\n        r.selection[1],\n        r.selection[2] - r.selection[0],\n        r.selection[3] - r.selection[1] );\n\n      if( borderWidth > 0 ){\n        context.strokeStyle = 'rgba('\n          + coreStyle[ 'selection-box-border-color' ].value[0] + ','\n          + coreStyle[ 'selection-box-border-color' ].value[1] + ','\n          + coreStyle[ 'selection-box-border-color' ].value[2] + ','\n          + coreStyle[ 'selection-box-opacity' ].value + ')';\n\n        context.strokeRect(\n          r.selection[0],\n          r.selection[1],\n          r.selection[2] - r.selection[0],\n          r.selection[3] - r.selection[1] );\n      }\n    }\n\n    if( data.bgActivePosistion && !r.hoverData.selecting ){\n      var zoom = r.cy.zoom();\n      var pos = data.bgActivePosistion;\n\n      context.fillStyle = 'rgba('\n        + coreStyle[ 'active-bg-color' ].value[0] + ','\n        + coreStyle[ 'active-bg-color' ].value[1] + ','\n        + coreStyle[ 'active-bg-color' ].value[2] + ','\n        + coreStyle[ 'active-bg-opacity' ].value + ')';\n\n      context.beginPath();\n      context.arc( pos.x, pos.y, coreStyle[ 'active-bg-size' ].pfValue / zoom, 0, 2 * Math.PI );\n      context.fill();\n    }\n\n    var timeToRender = r.lastRedrawTime;\n    if( r.showFps && timeToRender ){\n      timeToRender = Math.round( timeToRender );\n      var fps = Math.round( 1000 / timeToRender );\n\n      context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n      context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n      context.lineWidth = 1;\n      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20 );\n\n      var maxFps = 60;\n      context.strokeRect( 0, 30, 250, 20 );\n      context.fillRect( 0, 30, 250 * Math.min( fps / maxFps, 1 ), 20 );\n    }\n\n    if( !drawAllLayers ){\n      needDraw[ r.SELECT_BOX ] = false;\n    }\n  }\n\n  // motionblur: blit rendered blurry frames\n  if( motionBlur && mbPxRatio !== 1 ){\n    var cxtNode = data.contexts[ r.NODE ];\n    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];\n\n    var cxtDrag = data.contexts[ r.DRAG ];\n    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];\n\n    var drawMotionBlur = function( cxt, txt, needClear ){\n      cxt.setTransform( 1, 0, 0, 1, 0, 0 );\n\n      if( needClear || !motionBlurFadeEffect ){\n        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );\n      } else {\n        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );\n      }\n\n      var pxr = mbPxRatio;\n\n      cxt.drawImage(\n        txt, // img\n        0, 0, // sx, sy\n        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n        0, 0, // x, y\n        r.canvasWidth, r.canvasHeight // w, h\n      );\n    };\n\n    if( needDraw[ r.NODE ] || needMbClear[ r.NODE ] ){\n      drawMotionBlur( cxtNode, txtNode, needMbClear[ r.NODE ] );\n      needDraw[ r.NODE ] = false;\n    }\n\n    if( needDraw[ r.DRAG ] || needMbClear[ r.DRAG ] ){\n      drawMotionBlur( cxtDrag, txtDrag, needMbClear[ r.DRAG ] );\n      needDraw[ r.DRAG ] = false;\n    }\n  }\n\n  r.prevViewport = vp;\n\n  if( r.clearingMotionBlur ){\n    r.clearingMotionBlur = false;\n    r.motionBlurCleared = true;\n    r.motionBlur = true;\n  }\n\n  if( motionBlur ){\n    r.motionBlurTimeout = setTimeout( function(){\n      r.motionBlurTimeout = null;\n\n      r.clearedForMotionBlur[ r.NODE ] = false;\n      r.clearedForMotionBlur[ r.DRAG ] = false;\n      r.motionBlur = false;\n      r.clearingMotionBlur = !textureDraw;\n      r.mbFrames = 0;\n\n      needDraw[ r.NODE ] = true;\n      needDraw[ r.DRAG ] = true;\n\n      r.redraw();\n    }, motionBlurDelay );\n  }\n\n  r.drawingImage = false;\n\n\n  if( !forcedContext && !r.initrender ){\n    r.initrender = true;\n    cy.trigger( 'initrender' );\n  }\n\n  if( !forcedContext ){\n    cy.trigger('render');\n  }\n\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/drawing-redraw.js\n ** module id = 129\n ** module chunks = 0\n **/","'use strict';\n\nvar math = require( '../../../math' );\n\nvar CRp = {};\n\n// @O Polygon drawing\nCRp.drawPolygonPath = function(\n  context, x, y, width, height, points ){\n\n  var halfW = width / 2;\n  var halfH = height / 2;\n\n  if( context.beginPath ){ context.beginPath(); }\n\n  context.moveTo( x + halfW * points[0], y + halfH * points[1] );\n\n  for( var i = 1; i < points.length / 2; i++ ){\n    context.lineTo( x + halfW * points[ i * 2], y + halfH * points[ i * 2 + 1] );\n  }\n\n  context.closePath();\n};\n\n// Round rectangle drawing\nCRp.drawRoundRectanglePath = function(\n  context, x, y, width, height, radius ){\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var cornerRadius = math.getRoundRectangleRadius( width, height );\n\n  if( context.beginPath ){ context.beginPath(); }\n\n  // Start at top middle\n  context.moveTo( x, y - halfHeight );\n  // Arc from middle top to right side\n  context.arcTo( x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius );\n  // Arc from right side to bottom\n  context.arcTo( x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius );\n  // Arc from bottom to left side\n  context.arcTo( x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius );\n  // Arc from left side to topBorder\n  context.arcTo( x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius );\n  // Join line\n  context.lineTo( x, y - halfHeight );\n\n\n  context.closePath();\n};\n\nvar sin0 = Math.sin( 0 );\nvar cos0 = Math.cos( 0 );\n\nvar sin = {};\nvar cos = {};\n\nvar ellipseStepSize = Math.PI / 40;\n\nfor( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){\n  sin[ i ] = Math.sin( i );\n  cos[ i ] = Math.cos( i );\n}\n\nCRp.drawEllipsePath = function( context, centerX, centerY, width, height ){\n    if( context.beginPath ){ context.beginPath(); }\n\n    if( context.ellipse ){\n      context.ellipse( centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI );\n    } else {\n      var xPos, yPos;\n      var rw = width / 2;\n      var rh = height / 2;\n      for( var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ){\n        xPos = centerX - (rw * sin[ i ]) * sin0 + (rw * cos[ i ]) * cos0;\n        yPos = centerY + (rh * cos[ i ]) * sin0 + (rh * sin[ i ]) * cos0;\n\n        if( i === 0 ){\n          context.moveTo( xPos, yPos );\n        } else {\n          context.lineTo( xPos, yPos );\n        }\n      }\n    }\n\n    context.closePath();\n  };\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/drawing-shapes.js\n ** module id = 130\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( '../../../is' );\n\nvar CRp = {};\n\nCRp.createBuffer = function( w, h ){\n  var buffer = document.createElement( 'canvas' );\n  buffer.width = w;\n  buffer.height = h;\n\n  return [ buffer, buffer.getContext( '2d' ) ];\n};\n\nCRp.bufferCanvasImage = function( options ){\n  var cy = this.cy;\n  var eles = cy.mutableElements();\n  var bb = eles.boundingBox();\n  var width = options.full ? Math.ceil( bb.w ) : this.container.clientWidth;\n  var height = options.full ? Math.ceil( bb.h ) : this.container.clientHeight;\n  var specdMaxDims = is.number( options.maxWidth ) || is.number( options.maxHeight );\n  var pxRatio = this.getPixelRatio();\n  var scale = 1;\n\n  if( options.scale !== undefined ){\n    width *= options.scale;\n    height *= options.scale;\n\n    scale = options.scale;\n  } else if( specdMaxDims ){\n    var maxScaleW = Infinity;\n    var maxScaleH = Infinity;\n\n    if( is.number( options.maxWidth ) ){\n      maxScaleW = scale * options.maxWidth / width;\n    }\n\n    if( is.number( options.maxHeight ) ){\n      maxScaleH = scale * options.maxHeight / height;\n    }\n\n    scale = Math.min( maxScaleW, maxScaleH );\n\n    width *= scale;\n    height *= scale;\n  }\n\n  if( !specdMaxDims ){\n    width *= pxRatio;\n    height *= pxRatio;\n    scale *= pxRatio;\n  }\n\n  var buffCanvas = document.createElement( 'canvas' );\n\n  buffCanvas.width = width;\n  buffCanvas.height = height;\n\n  buffCanvas.style.width = width + 'px';\n  buffCanvas.style.height = height + 'px';\n\n  var buffCxt = buffCanvas.getContext( '2d' );\n\n  // Rasterize the layers, but only if container has nonzero size\n  if( width > 0 && height > 0 ){\n\n    buffCxt.clearRect( 0, 0, width, height );\n\n    if( options.bg ){\n      buffCxt.fillStyle = options.bg;\n      buffCxt.rect( 0, 0, width, height );\n      buffCxt.fill();\n    }\n\n    buffCxt.globalCompositeOperation = 'source-over';\n\n    var zsortedEles = this.getCachedZSortedEles();\n\n    if( options.full ){ // draw the full bounds of the graph\n      buffCxt.translate( -bb.x1 * scale, -bb.y1 * scale );\n      buffCxt.scale( scale, scale );\n\n      this.drawElements( buffCxt, zsortedEles );\n    } else { // draw the current view\n      var pan = cy.pan();\n\n      var translation = {\n        x: pan.x * scale,\n        y: pan.y * scale\n      };\n\n      scale *= cy.zoom();\n\n      buffCxt.translate( translation.x, translation.y );\n      buffCxt.scale( scale, scale );\n\n      this.drawElements( buffCxt, zsortedEles );\n    }\n  }\n\n  return buffCanvas;\n};\n\nCRp.png = function( options ){\n  return this.bufferCanvasImage( options ).toDataURL( 'image/png' );\n};\n\nCRp.jpg = function( options ){\n  return this.bufferCanvasImage( options ).toDataURL( 'image/jpeg' );\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/export-image.js\n ** module id = 131\n ** module chunks = 0\n **/","'use strict';\n\nvar CRp = {};\n\nvar impl;\n\nCRp.nodeShapeImpl = function( name ){\n  var self = this;\n\n  return ( impl || (impl = {\n    'ellipse': function( context, centerX, centerY, width, height ){\n      self.drawEllipsePath( context, centerX, centerY, width, height );\n    },\n\n    'polygon': function( context, centerX, centerY, width, height, points ){\n      self.drawPolygonPath( context, centerX, centerY, width, height, points );\n    },\n\n    'roundrectangle': function( context, centerX, centerY, width, height ){\n      self.drawRoundRectanglePath( context, centerX, centerY, width, height, 10 );\n    }\n  }) )[ name ];\n};\n\nmodule.exports = CRp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/extensions/renderer/canvas/node-shapes.js\n ** module id = 132\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( './is' );\n\nvar cyReg = function( $ele ){\n  var d = $ele[0]._cyreg = $ele[0]._cyreg || {};\n\n  return d;\n};\n\nvar registerJquery = function( $, cytoscape ){\n  if( !$ ){ return; } // no jquery => don't need this\n\n  if( $.fn.cytoscape ){ return; } // already registered\n\n  // allow calls on a jQuery selector by proxying calls to $.cytoscape\n  // e.g. $(\"#foo\").cytoscape(options) => $.cytoscape(options) on #foo\n  $.fn.cytoscape = function( opts ){\n    var $this = $( this );\n\n    // get object\n    if( opts === 'get' ){\n      return cyReg( $this ).cy;\n    }\n\n    // bind to ready\n    else if( is.fn( opts ) ){\n\n      var ready = opts;\n      var cy = cyReg( $this ).cy;\n\n      if( cy && cy.isReady() ){ // already ready so just trigger now\n        cy.trigger( 'ready', [], ready );\n\n      } else { // not yet ready, so add to readies list\n        var data = cyReg( $this );\n        var readies = data.readies = data.readies || [];\n\n        readies.push( ready );\n      }\n\n    }\n\n    // proxy to create instance\n    else if( is.plainObject( opts ) ){\n      return $this.each( function(){\n        var options = $.extend( {}, opts, {\n          container: $( this )[0]\n        } );\n\n        cytoscape( options );\n      } );\n    }\n  };\n\n  // allow access to the global cytoscape object under jquery for legacy reasons\n  $.cytoscape = cytoscape;\n\n  // use short alias (cy) if not already defined\n  if( $.fn.cy == null && $.cy == null ){\n    $.fn.cy = $.fn.cytoscape;\n    $.cy = $.cytoscape;\n  }\n};\n\nmodule.exports = registerJquery;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/jquery-plugin.js\n ** module id = 133\n ** module chunks = 0\n **/","'use strict';\n\nvar is = require( './is' );\nvar util = require( './util' );\nvar Style = require( './style' );\n\n// a dummy stylesheet object that doesn't need a reference to the core\n// (useful for init)\nvar Stylesheet = function(){\n  if( !(this instanceof Stylesheet) ){\n    return new Stylesheet();\n  }\n\n  this.length = 0;\n};\n\nvar sheetfn = Stylesheet.prototype;\n\nsheetfn.instanceString = function(){\n  return 'stylesheet';\n};\n\n// just store the selector to be parsed later\nsheetfn.selector = function( selector ){\n  var i = this.length++;\n\n  this[ i ] = {\n    selector: selector,\n    properties: []\n  };\n\n  return this; // chaining\n};\n\n// just store the property to be parsed later\nsheetfn.css = function( name, value ){\n  var i = this.length - 1;\n\n  if( is.string( name ) ){\n    this[ i ].properties.push( {\n      name: name,\n      value: value\n    } );\n  } else if( is.plainObject( name ) ){\n    var map = name;\n\n    for( var j = 0; j < Style.properties.length; j++ ){\n      var prop = Style.properties[ j ];\n      var mapVal = map[ prop.name ];\n\n      if( mapVal === undefined ){ // also try camel case name\n        mapVal = map[ util.dash2camel( prop.name ) ];\n      }\n\n      if( mapVal !== undefined ){\n        var name = prop.name;\n        var value = mapVal;\n\n        this[ i ].properties.push( {\n          name: name,\n          value: value\n        } );\n      }\n    }\n  }\n\n  return this; // chaining\n};\n\nsheetfn.style = sheetfn.css;\n\n// generate a real style object from the dummy stylesheet\nsheetfn.generateStyle = function( cy ){\n  var style = new Style( cy );\n\n  for( var i = 0; i < this.length; i++ ){\n    var context = this[ i ];\n    var selector = context.selector;\n    var props = context.properties;\n\n    style.selector( selector ); // apply selector\n\n    for( var j = 0; j < props.length; j++ ){\n      var prop = props[ j ];\n\n      style.css( prop.name, prop.value ); // apply property\n    }\n  }\n\n  return style;\n};\n\nmodule.exports = Stylesheet;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/stylesheet.js\n ** module id = 134\n ** module chunks = 0\n **/","/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */\n\n'use strict';\n\nvar is = require('./is');\nvar util = require('./util');\nvar Thread = require('./thread');\nvar Promise = require('./promise');\nvar define = require('./define');\n\nvar Fabric = function( N ){\n  if( !(this instanceof Fabric) ){\n    return new Fabric( N );\n  }\n\n  this._private = {\n    pass: []\n  };\n\n  var defN = 4;\n\n  if( is.number(N) ){\n    // then use the specified number of threads\n  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){\n    N = navigator.hardwareConcurrency;\n  } else {\n    try{\n      N = require('os').cpus().length;\n    } catch( err ){\n      N = defN;\n    }\n  } // TODO could use an estimation here but would the additional expense be worth it?\n\n  for( var i = 0; i < N; i++ ){\n    this[i] = new Thread();\n  }\n\n  this.length = N;\n};\n\nvar fabfn = Fabric.prototype; // short alias\n\nutil.extend(fabfn, {\n\n  instanceString: function(){ return 'fabric'; },\n\n  // require fn in all threads\n  require: function( fn, as ){\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n\n      thread.require( fn, as );\n    }\n\n    return this;\n  },\n\n  // get a random thread\n  random: function(){\n    var i = Math.round( (this.length - 1) * Math.random() );\n    var thread = this[i];\n\n    return thread;\n  },\n\n  // run on random thread\n  run: function( fn ){\n    var pass = this._private.pass.shift();\n\n    return this.random().pass( pass ).run( fn );\n  },\n\n  // sends a random thread a message\n  message: function( m ){\n    return this.random().message( m );\n  },\n\n  // send all threads a message\n  broadcast: function( m ){\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n\n      thread.message( m );\n    }\n\n    return this; // chaining\n  },\n\n  // stop all threads\n  stop: function(){\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n\n      thread.stop();\n    }\n\n    return this; // chaining\n  },\n\n  // pass data to be used with .spread() etc.\n  pass: function( data ){\n    var pass = this._private.pass;\n\n    if( is.array(data) ){\n      pass.push( data );\n    } else {\n      throw 'Only arrays may be used with fabric.pass()';\n    }\n\n    return this; // chaining\n  },\n\n  spreadSize: function(){\n    var subsize =  Math.ceil( this._private.pass[0].length / this.length );\n\n    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread\n\n    return subsize;\n  },\n\n  // split the data into slices to spread the data equally among threads\n  spread: function( fn ){\n    var self = this;\n    var _p = self._private;\n    var subsize = self.spreadSize(); // number of pass eles to handle in each thread\n    var pass = _p.pass.shift().concat([]); // keep a copy\n    var runPs = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var thread = this[i];\n      var slice = pass.splice( 0, subsize );\n\n      var runP = thread.pass( slice ).run( fn );\n\n      runPs.push( runP );\n\n      var doneEarly = pass.length === 0;\n      if( doneEarly ){ break; }\n    }\n\n    return Promise.all( runPs ).then(function( thens ){\n      var postpass = [];\n      var p = 0;\n\n      // fill postpass with the total result joined from all threads\n      for( var i = 0; i < thens.length; i++ ){\n        var then = thens[i]; // array result from thread i\n\n        for( var j = 0; j < then.length; j++ ){\n          var t = then[j]; // array element\n\n          postpass[ p++ ] = t;\n        }\n      }\n\n      return postpass;\n    });\n  },\n\n  // parallel version of array.map()\n  map: function( fn ){\n    var self = this;\n\n    self.require( fn, '_$_$_fabmap' );\n\n    return self.spread(function( split ){\n      var mapped = [];\n      var origResolve = resolve; // jshint ignore:line\n\n      resolve = function( val ){ // jshint ignore:line\n        mapped.push( val );\n      };\n\n      for( var i = 0; i < split.length; i++ ){\n        var oldLen = mapped.length;\n        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line\n        var nothingInsdByResolve = oldLen === mapped.length;\n\n        if( nothingInsdByResolve ){\n          mapped.push( ret );\n        }\n      }\n\n      resolve = origResolve; // jshint ignore:line\n\n      return mapped;\n    });\n\n  },\n\n  // parallel version of array.filter()\n  filter: function( fn ){\n    var _p = this._private;\n    var pass = _p.pass[0];\n\n    return this.map( fn ).then(function( include ){\n      var ret = [];\n\n      for( var i = 0; i < pass.length; i++ ){\n        var datum = pass[i];\n        var incDatum = include[i];\n\n        if( incDatum ){\n          ret.push( datum );\n        }\n      }\n\n      return ret;\n    });\n  },\n\n  // sorts the passed array using a divide and conquer strategy\n  sort: function( cmp ){\n    var self = this;\n    var P = this._private.pass[0].length;\n    var subsize = this.spreadSize();\n\n    cmp = cmp || function( a, b ){ // default comparison function\n      if( a < b ){\n        return -1;\n      } else if( a > b ){\n        return 1;\n      }\n\n      return 0;\n    };\n\n    self.require( cmp, '_$_$_cmp' );\n\n    return self.spread(function( split ){ // sort each split normally\n      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line\n      resolve( sortedSplit ); // jshint ignore:line\n\n    }).then(function( joined ){\n      // do all the merging in the main thread to minimise data transfer\n\n      // TODO could do merging in separate threads but would incur add'l cost of data transfer\n      // for each level of the merge\n\n      var merge = function( i, j, max ){\n        // don't overflow array\n        j = Math.min( j, P );\n        max = Math.min( max, P );\n\n        // left and right sides of merge\n        var l = i;\n        var r = j;\n\n        var sorted = [];\n\n        for( var k = l; k < max; k++ ){\n\n          var eleI = joined[i];\n          var eleJ = joined[j];\n\n          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){\n            sorted.push( eleI );\n            i++;\n          } else {\n            sorted.push( eleJ );\n            j++;\n          }\n\n        }\n\n        // in the array proper, put the sorted values\n        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item\n          var index = l + k;\n\n          joined[ index ] = sorted[k];\n        }\n      };\n\n      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is \"split\" as 1\n\n        for( var i = 0; i < P; i += 2*splitL ){\n          merge( i, i + splitL, i + 2*splitL );\n        }\n\n      }\n\n      return joined;\n    });\n  }\n\n\n});\n\nvar defineRandomPasser = function( opts ){\n  opts = opts || {};\n\n  return function( fn, arg1 ){\n    var pass = this._private.pass.shift();\n\n    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );\n  };\n};\n\nutil.extend(fabfn, {\n  randomMap: defineRandomPasser({ threadFn: 'map' }),\n\n  reduce: defineRandomPasser({ threadFn: 'reduce' }),\n\n  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })\n});\n\n// aliases\nvar fn = fabfn;\nfn.promise = fn.run;\nfn.terminate = fn.halt = fn.stop;\nfn.include = fn.require;\n\n// pull in event apis\nutil.extend(fabfn, {\n  on: define.on(),\n  one: define.on({ unbindSelfOnTrigger: true }),\n  off: define.off(),\n  trigger: define.trigger()\n});\n\ndefine.eventAliasesOn( fabfn );\n\nmodule.exports = Fabric;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/fabric.js\n ** module id = 135\n ** module chunks = 0\n **/","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/os-browserify/browser.js\n ** module id = 136\n ** module chunks = 0\n **/","\"2.7.6\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/src/version.json\n ** module id = 137\n ** module chunks = 0\n **/","export const DEF_VISUAL_STYLE = [\n  {\n    selector: 'node',\n    style: {\n      'background-color': '#436EEE',\n      'background-opacity': 0.9,\n      'width': '40px',\n      'height': '40px',\n      'label': 'data(name)',\n      'font-family': 'Roboto, sans-serif'\n    }\n  },\n  {\n    selector: 'edge',\n    style: {\n      'line-color': '#aaaaaa',\n      'width': 1,\n      'label': 'data(interaction)',\n      'font-size': '0.15em',\n      'font-family': 'Roboto, sans-serif',\n      'text-opacity': 0.5\n    }\n  },\n  {\n    selector: 'node:selected',\n    style: {\n      'background-color': 'yellow'\n    }\n  },\n  {\n    selector: 'edge:selected',\n    style: {\n      'line-color': 'yellow',\n      'width': 6\n    }\n  }\n];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/component/VisualStyle.js\n **/","import {Map} from 'immutable'\n\nconst ADD_NETWORK = 'ADD_NETWORK'\nconst DELETE_NETWORK = 'DELETE_NETWORK'\n\nconst defaultState = Map({})\n\nexport default function networkStore(state = defaultState, action) {\n  switch (action.type) {\n    case ADD_NETWORK:\n      return state.set(action.networkId, Map(action.data))\n    case DELETE_NETWORK:\n      return state.delete(action.networkId)\n    default:\n      return state\n  }\n}\n\nexport function addNetwork(networkId, data) {\n  return {\n    type: ADD_NETWORK,\n    networkId,\n    data\n  }\n}\n\nexport function deleteNetwork(networkId) {\n  return {\n    type: DELETE_NETWORK,\n    networkId\n  }\n}\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/store/networks.js\n **/","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/immutable/dist/immutable.js\n ** module id = 140\n ** module chunks = 0\n **/","import {Map} from 'immutable'\nimport {addNetwork} from './networks'\n\nconst DOWNLOAD_BEGIN = 'DOWNLOAD_BEGIN'\nconst DOWNLOAD_SUCCESS = 'DOWNLOAD_SUCCESS'\nconst DOWNLOAD_ERROR = 'DOWNLOAD_ERROR'\n\nconst defaultState = Map({\n  downloading: false,\n  error: null\n})\n\nexport default function downloadState(state = defaultState, action) {\n  switch (action.type) {\n    case DOWNLOAD_BEGIN:\n      return state.merge({\n        downloading: true\n      })\n    case DOWNLOAD_SUCCESS:\n      return state.merge({\n        downloading: false\n      })\n    case DOWNLOAD_ERROR:\n      return state.merge({\n        downloading: false,\n        error: action.error\n      })\n    default:\n      return state\n  }\n}\n\n/*Set the downloading flag*/\nexport function downloadBegin() {\n  return {type: DOWNLOAD_BEGIN}\n}\n\n/*Send network to the networks store and remove the downloading flag*/\nexport function downloadSuccess(networkUrl, data) {\n  return dispatch => {\n    dispatch(addNetwork(networkUrl, data))\n    dispatch({type: DOWNLOAD_SUCCESS})\n  }\n}\n\n/*Set an error field if a download did not complete successfully*/\nexport function downloadError(error) {\n  return {type: DOWNLOAD_ERROR, error}\n}\n\n/*Download the network from the given url*/\nexport function download(networkUrl) {\n  var headers = {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json'\n  }\n  return dispatch =>\n    fetch(networkUrl, {\n      method: 'get',\n      headers: headers\n    }).then(response => {\n      if (response.status >= 200 && response.status < 300) {\n        response.json().then(data => dispatch(downloadSuccess(networkUrl, data)))\n      } else {\n        const error = new Error(response)\n        error.response = response\n        dispatch(downloadError(error))\n        throw error\n      }\n    }).catch(error => {\n      window.alert('Network ' + networkUrl + ' download failed, reason:', error)\n    })\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/store/networkDownload.js\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./component.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./component.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./component.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/style/component.scss\n ** module id = 142\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader!./src/style/component.scss\n ** module id = 143\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 144\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 145\n ** module chunks = 0\n **/"],"sourceRoot":""}